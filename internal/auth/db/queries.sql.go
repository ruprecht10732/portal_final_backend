// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

// Auth Domain SQL Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserToken = `-- name: CreateUserToken :exec
INSERT INTO user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateUserTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	Type      string             `json:"type"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateUserToken(ctx context.Context, arg CreateUserTokenParams) error {
	_, err := q.db.Exec(ctx, createUserToken,
		arg.UserID,
		arg.TokenHash,
		arg.Type,
		arg.ExpiresAt,
	)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM user_roles WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL
`

type GetRefreshTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, tokenHash string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, tokenHash)
	var i GetRefreshTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserToken = `-- name: GetUserToken :one
SELECT user_id, expires_at FROM user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type GetUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

type GetUserTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetUserToken(ctx context.Context, arg GetUserTokenParams) (GetUserTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserToken, arg.TokenHash, arg.Type)
	var i GetUserTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getValidRoles = `-- name: GetValidRoles :many
SELECT name FROM roles WHERE name = ANY($1::text[])
`

func (q *Queries) GetValidRoles(ctx context.Context, roleNames []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getValidRoles, roleNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserRoles = `-- name: InsertUserRoles :exec
INSERT INTO user_roles (user_id, role_id)
SELECT $1, id FROM roles WHERE name = ANY($2::text[])
`

type InsertUserRolesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 []string    `json:"column_2"`
}

func (q *Queries) InsertUserRoles(ctx context.Context, arg InsertUserRolesParams) error {
	_, err := q.db.Exec(ctx, insertUserRoles, arg.UserID, arg.Column2)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.email,
    COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles
FROM users u
LEFT JOIN user_roles ur ON ur.user_id = u.id
LEFT JOIN roles r ON r.id = ur.role_id
GROUP BY u.id
ORDER BY u.email
`

type ListUsersRow struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
	Roles interface{} `json:"roles"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(&i.ID, &i.Email, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailVerified = `-- name: MarkEmailVerified :exec
UPDATE users SET is_email_verified = true, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkEmailVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markEmailVerified, id)
	return err
}

const revokeAllRefreshTokens = `-- name: RevokeAllRefreshTokens :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllRefreshTokens(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, tokenHash)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users SET password_hash = $2, updated_at = now() WHERE id = $1
`

type UpdatePasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $2, is_email_verified = false, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
`

type UpdateUserEmailParams struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const useUserToken = `-- name: UseUserToken :exec
UPDATE user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type UseUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

func (q *Queries) UseUserToken(ctx context.Context, arg UseUserTokenParams) error {
	_, err := q.db.Exec(ctx, useUserToken, arg.TokenHash, arg.Type)
	return err
}
