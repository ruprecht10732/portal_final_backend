// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package catalogdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProductMaterials = `-- name: AddProductMaterials :exec

INSERT INTO RAC_catalog_product_materials (organization_id, product_id, material_id)
SELECT $1, $2, material_id
FROM RAC_catalog_products p
CROSS JOIN LATERAL unnest($3::uuid[]) AS material_id
WHERE p.id = $2 AND p.organization_id = $1
ON CONFLICT DO NOTHING
`

type AddProductMaterialsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	ProductID      pgtype.UUID   `json:"product_id"`
	Column3        []pgtype.UUID `json:"column_3"`
}

// Materials
func (q *Queries) AddProductMaterials(ctx context.Context, arg AddProductMaterialsParams) error {
	_, err := q.db.Exec(ctx, addProductMaterials, arg.OrganizationID, arg.ProductID, arg.Column3)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4)
`

type CountProductsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Column3        interface{} `json:"column_3"`
	Column4        pgtype.UUID `json:"column_4"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVatRates = `-- name: CountVatRates :one
SELECT COUNT(*) FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2)
`

type CountVatRatesParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
}

func (q *Queries) CountVatRates(ctx context.Context, arg CountVatRatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVatRates, arg.OrganizationID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO RAC_catalog_products (
  organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at
`

type CreateProductParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	Title          string      `json:"title"`
	Reference      string      `json:"reference"`
	Description    pgtype.Text `json:"description"`
	PriceCents     int32       `json:"price_cents"`
	Type           string      `json:"type"`
	PeriodCount    pgtype.Int4 `json:"period_count"`
	PeriodUnit     pgtype.Text `json:"period_unit"`
}

// Products
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.OrganizationID,
		arg.VatRateID,
		arg.Title,
		arg.Reference,
		arg.Description,
		arg.PriceCents,
		arg.Type,
		arg.PeriodCount,
		arg.PeriodUnit,
	)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVatRate = `-- name: CreateVatRate :one


INSERT INTO RAC_catalog_vat_rates (organization_id, name, rate_bps)
VALUES ($1, $2, $3)
RETURNING id, organization_id, name, rate_bps, created_at, updated_at
`

type CreateVatRateParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Name           string      `json:"name"`
	RateBps        int32       `json:"rate_bps"`
}

// Catalog Domain SQL Queries
// VAT Rates
func (q *Queries) CreateVatRate(ctx context.Context, arg CreateVatRateParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, createVatRate, arg.OrganizationID, arg.Name, arg.RateBps)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2
`

type DeleteProductParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.OrganizationID)
	return err
}

const deleteVatRate = `-- name: DeleteVatRate :exec
DELETE FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2
`

type DeleteVatRateParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) DeleteVatRate(ctx context.Context, arg DeleteVatRateParams) error {
	_, err := q.db.Exec(ctx, deleteVatRate, arg.ID, arg.OrganizationID)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2
`

type GetProductByIDParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.OrganizationID)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsByIDs = `-- name: GetProductsByIDs :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1 AND id = ANY($2::uuid[])
`

type GetProductsByIDsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	Column2        []pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetProductsByIDs(ctx context.Context, arg GetProductsByIDsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, arg.OrganizationID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVatRateByID = `-- name: GetVatRateByID :one
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2
`

type GetVatRateByIDParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) GetVatRateByID(ctx context.Context, arg GetVatRateByIDParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, getVatRateByID, arg.ID, arg.OrganizationID)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasProductMaterials = `-- name: HasProductMaterials :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_product_materials WHERE organization_id = $1 AND product_id = $2)
`

type HasProductMaterialsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	ProductID      pgtype.UUID `json:"product_id"`
}

func (q *Queries) HasProductMaterials(ctx context.Context, arg HasProductMaterialsParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasProductMaterials, arg.OrganizationID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasProductsWithVatRate = `-- name: HasProductsWithVatRate :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_products WHERE vat_rate_id = $1 AND organization_id = $2)
`

type HasProductsWithVatRateParams struct {
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) HasProductsWithVatRate(ctx context.Context, arg HasProductsWithVatRateParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasProductsWithVatRate, arg.VatRateID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listProductMaterials = `-- name: ListProductMaterials :many
SELECT p.id, p.organization_id, p.vat_rate_id, p.title, p.reference, p.description, p.price_cents, p.type, p.period_count, p.period_unit, p.created_at, p.updated_at FROM RAC_catalog_products p
JOIN RAC_catalog_product_materials pm
  ON pm.material_id = p.id AND pm.organization_id = p.organization_id
WHERE pm.organization_id = $1 AND pm.product_id = $2
ORDER BY p.title ASC
`

type ListProductMaterialsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	ProductID      pgtype.UUID `json:"product_id"`
}

func (q *Queries) ListProductMaterials(ctx context.Context, arg ListProductMaterialsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, listProductMaterials, arg.OrganizationID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListProductsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Column3        interface{} `json:"column_3"`
	Column4        pgtype.UUID `json:"column_4"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVatRates = `-- name: ListVatRates :many
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2)
ORDER BY name ASC
LIMIT $3 OFFSET $4
`

type ListVatRatesParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListVatRates(ctx context.Context, arg ListVatRatesParams) ([]RacCatalogVatRate, error) {
	rows, err := q.db.Query(ctx, listVatRates,
		arg.OrganizationID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogVatRate
	for rows.Next() {
		var i RacCatalogVatRate
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.RateBps,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProductMaterials = `-- name: RemoveProductMaterials :exec
DELETE FROM RAC_catalog_product_materials
WHERE organization_id = $1 AND product_id = $2 AND material_id = ANY($3::uuid[])
`

type RemoveProductMaterialsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	ProductID      pgtype.UUID   `json:"product_id"`
	Column3        []pgtype.UUID `json:"column_3"`
}

func (q *Queries) RemoveProductMaterials(ctx context.Context, arg RemoveProductMaterialsParams) error {
	_, err := q.db.Exec(ctx, removeProductMaterials, arg.OrganizationID, arg.ProductID, arg.Column3)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE RAC_catalog_products
SET
  vat_rate_id = COALESCE($3, vat_rate_id),
  title = COALESCE($4, title),
  reference = COALESCE($5, reference),
  description = COALESCE($6, description),
  price_cents = COALESCE($7, price_cents),
  type = COALESCE($8, type),
  period_count = COALESCE($9, period_count),
  period_unit = COALESCE($10, period_unit),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at
`

type UpdateProductParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	Title          string      `json:"title"`
	Reference      string      `json:"reference"`
	Description    pgtype.Text `json:"description"`
	PriceCents     int32       `json:"price_cents"`
	Type           string      `json:"type"`
	PeriodCount    pgtype.Int4 `json:"period_count"`
	PeriodUnit     pgtype.Text `json:"period_unit"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.OrganizationID,
		arg.VatRateID,
		arg.Title,
		arg.Reference,
		arg.Description,
		arg.PriceCents,
		arg.Type,
		arg.PeriodCount,
		arg.PeriodUnit,
	)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVatRate = `-- name: UpdateVatRate :one
UPDATE RAC_catalog_vat_rates
SET
  name = COALESCE($3, name),
  rate_bps = COALESCE($4, rate_bps),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, rate_bps, created_at, updated_at
`

type UpdateVatRateParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	Name           string      `json:"name"`
	RateBps        int32       `json:"rate_bps"`
}

func (q *Queries) UpdateVatRate(ctx context.Context, arg UpdateVatRateParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, updateVatRate,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.RateBps,
	)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
