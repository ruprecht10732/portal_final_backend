// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package leadsdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkSoftDeleteLeads = `-- name: BulkSoftDeleteLeads :execresult
UPDATE RAC_leads SET deleted_at = now(), updated_at = now() 
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
`

func (q *Queries) BulkSoftDeleteLeads(ctx context.Context, dollar_1 []pgtype.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, bulkSoftDeleteLeads, dollar_1)
}

const countLeads = `-- name: CountLeads :one
SELECT COUNT(*) FROM RAC_leads WHERE deleted_at IS NULL
`

func (q *Queries) CountLeads(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLeads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLead = `-- name: CreateLead :one

INSERT INTO RAC_leads (
    consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
    address_street, address_house_number, address_zip_code, address_city,
    service_type, status, assigned_agent_id,
    consumer_note, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'New', $11, $12, $13)
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type CreateLeadParams struct {
	ConsumerFirstName  string      `json:"consumer_first_name"`
	ConsumerLastName   string      `json:"consumer_last_name"`
	ConsumerPhone      string      `json:"consumer_phone"`
	ConsumerEmail      pgtype.Text `json:"consumer_email"`
	ConsumerRole       string      `json:"consumer_role"`
	AddressStreet      string      `json:"address_street"`
	AddressHouseNumber string      `json:"address_house_number"`
	AddressZipCode     string      `json:"address_zip_code"`
	AddressCity        string      `json:"address_city"`
	ServiceType        string      `json:"service_type"`
	AssignedAgentID    pgtype.UUID `json:"assigned_agent_id"`
	ConsumerNote       pgtype.Text `json:"consumer_note"`
	Source             pgtype.Text `json:"source"`
}

// Leads Domain SQL Queries
func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (RacLead, error) {
	row := q.db.QueryRow(ctx, createLead,
		arg.ConsumerFirstName,
		arg.ConsumerLastName,
		arg.ConsumerPhone,
		arg.ConsumerEmail,
		arg.ConsumerRole,
		arg.AddressStreet,
		arg.AddressHouseNumber,
		arg.AddressZipCode,
		arg.AddressCity,
		arg.ServiceType,
		arg.AssignedAgentID,
		arg.ConsumerNote,
		arg.Source,
	)
	var i RacLead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const createLeadAIAnalysis = `-- name: CreateLeadAIAnalysis :one

INSERT INTO RAC_lead_ai_analysis (lead_id, urgency_level, urgency_reason, talking_points, objection_handling, upsell_opportunities, summary)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, lead_id, urgency_level, urgency_reason, talking_points, objection_handling, upsell_opportunities, summary, created_at
`

type CreateLeadAIAnalysisParams struct {
	LeadID              pgtype.UUID `json:"lead_id"`
	UrgencyLevel        string      `json:"urgency_level"`
	UrgencyReason       pgtype.Text `json:"urgency_reason"`
	TalkingPoints       []byte      `json:"talking_points"`
	ObjectionHandling   []byte      `json:"objection_handling"`
	UpsellOpportunities []byte      `json:"upsell_opportunities"`
	Summary             string      `json:"summary"`
}

// Lead AI Analysis Queries
func (q *Queries) CreateLeadAIAnalysis(ctx context.Context, arg CreateLeadAIAnalysisParams) (RacLeadAiAnalysis, error) {
	row := q.db.QueryRow(ctx, createLeadAIAnalysis,
		arg.LeadID,
		arg.UrgencyLevel,
		arg.UrgencyReason,
		arg.TalkingPoints,
		arg.ObjectionHandling,
		arg.UpsellOpportunities,
		arg.Summary,
	)
	var i RacLeadAiAnalysis
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.UrgencyLevel,
		&i.UrgencyReason,
		&i.TalkingPoints,
		&i.ObjectionHandling,
		&i.UpsellOpportunities,
		&i.Summary,
		&i.CreatedAt,
	)
	return i, err
}

const createLeadActivity = `-- name: CreateLeadActivity :exec

INSERT INTO RAC_lead_activity (lead_id, user_id, action, meta)
VALUES ($1, $2, $3, $4)
`

type CreateLeadActivityParams struct {
	LeadID pgtype.UUID `json:"lead_id"`
	UserID pgtype.UUID `json:"user_id"`
	Action string      `json:"action"`
	Meta   []byte      `json:"meta"`
}

// Lead Activity Queries
func (q *Queries) CreateLeadActivity(ctx context.Context, arg CreateLeadActivityParams) error {
	_, err := q.db.Exec(ctx, createLeadActivity,
		arg.LeadID,
		arg.UserID,
		arg.Action,
		arg.Meta,
	)
	return err
}

const createLeadNote = `-- name: CreateLeadNote :one

INSERT INTO RAC_lead_notes (lead_id, author_id, body, type)
VALUES ($1, $2, $3, $4)
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type CreateLeadNoteParams struct {
	LeadID   pgtype.UUID `json:"lead_id"`
	AuthorID pgtype.UUID `json:"author_id"`
	Body     string      `json:"body"`
	Type     string      `json:"type"`
}

// Lead Notes Queries
func (q *Queries) CreateLeadNote(ctx context.Context, arg CreateLeadNoteParams) (RacLeadNote, error) {
	row := q.db.QueryRow(ctx, createLeadNote,
		arg.LeadID,
		arg.AuthorID,
		arg.Body,
		arg.Type,
	)
	var i RacLeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeadService = `-- name: CreateLeadService :one

WITH inserted AS (
    INSERT INTO RAC_lead_services (lead_id, service_type_id, status)
    VALUES (
        $1,
        (SELECT st.id FROM RAC_service_types st WHERE st.name = $2 OR st.slug = $2 LIMIT 1),
        'New'
    )
    RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at, service_type_id
)
SELECT i.id, i.lead_id, st.name AS service_type, i.status,
    i.created_at, i.updated_at
FROM inserted i
JOIN RAC_service_types st ON st.id = i.service_type_id
`

type CreateLeadServiceParams struct {
	LeadID pgtype.UUID `json:"lead_id"`
	Name   string      `json:"name"`
}

type CreateLeadServiceRow struct {
	ID          pgtype.UUID        `json:"id"`
	LeadID      pgtype.UUID        `json:"lead_id"`
	ServiceType string             `json:"service_type"`
	Status      string             `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Lead Services Queries
func (q *Queries) CreateLeadService(ctx context.Context, arg CreateLeadServiceParams) (CreateLeadServiceRow, error) {
	row := q.db.QueryRow(ctx, createLeadService, arg.LeadID, arg.Name)
	var i CreateLeadServiceRow
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeadNote = `-- name: DeleteLeadNote :exec
DELETE FROM RAC_lead_notes WHERE id = $1
`

func (q *Queries) DeleteLeadNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLeadNote, id)
	return err
}

const getLatestLeadAIAnalysis = `-- name: GetLatestLeadAIAnalysis :one
SELECT id, lead_id, urgency_level, urgency_reason, talking_points, objection_handling, upsell_opportunities, summary, created_at FROM RAC_lead_ai_analysis
WHERE lead_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestLeadAIAnalysis(ctx context.Context, leadID pgtype.UUID) (RacLeadAiAnalysis, error) {
	row := q.db.QueryRow(ctx, getLatestLeadAIAnalysis, leadID)
	var i RacLeadAiAnalysis
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.UrgencyLevel,
		&i.UrgencyReason,
		&i.TalkingPoints,
		&i.ObjectionHandling,
		&i.UpsellOpportunities,
		&i.Summary,
		&i.CreatedAt,
	)
	return i, err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source FROM RAC_leads WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLeadByID(ctx context.Context, id pgtype.UUID) (RacLead, error) {
	row := q.db.QueryRow(ctx, getLeadByID, id)
	var i RacLead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const getLeadByPhone = `-- name: GetLeadByPhone :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source FROM RAC_leads 
WHERE consumer_phone = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLeadByPhone(ctx context.Context, consumerPhone string) (RacLead, error) {
	row := q.db.QueryRow(ctx, getLeadByPhone, consumerPhone)
	var i RacLead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const getLeadNote = `-- name: GetLeadNote :one
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM RAC_lead_notes WHERE id = $1
`

func (q *Queries) GetLeadNote(ctx context.Context, id pgtype.UUID) (RacLeadNote, error) {
	row := q.db.QueryRow(ctx, getLeadNote, id)
	var i RacLeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadService = `-- name: GetLeadService :one
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at, service_type_id FROM RAC_lead_services WHERE id = $1
`

func (q *Queries) GetLeadService(ctx context.Context, id pgtype.UUID) (RacLeadService, error) {
	row := q.db.QueryRow(ctx, getLeadService, id)
	var i RacLeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServiceTypeID,
	)
	return i, err
}

const listLeadAIAnalysis = `-- name: ListLeadAIAnalysis :many
SELECT id, lead_id, urgency_level, urgency_reason, talking_points, objection_handling, upsell_opportunities, summary, created_at FROM RAC_lead_ai_analysis
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadAIAnalysis(ctx context.Context, leadID pgtype.UUID) ([]RacLeadAiAnalysis, error) {
	rows, err := q.db.Query(ctx, listLeadAIAnalysis, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacLeadAiAnalysis
	for rows.Next() {
		var i RacLeadAiAnalysis
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.UrgencyLevel,
			&i.UrgencyReason,
			&i.TalkingPoints,
			&i.ObjectionHandling,
			&i.UpsellOpportunities,
			&i.Summary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadActivities = `-- name: ListLeadActivities :many
SELECT id, lead_id, user_id, action, meta, created_at FROM RAC_lead_activity
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadActivities(ctx context.Context, leadID pgtype.UUID) ([]RacLeadActivity, error) {
	rows, err := q.db.Query(ctx, listLeadActivities, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacLeadActivity
	for rows.Next() {
		var i RacLeadActivity
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.UserID,
			&i.Action,
			&i.Meta,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadNotes = `-- name: ListLeadNotes :many
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM RAC_lead_notes
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadNotes(ctx context.Context, leadID pgtype.UUID) ([]RacLeadNote, error) {
	rows, err := q.db.Query(ctx, listLeadNotes, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacLeadNote
	for rows.Next() {
		var i RacLeadNote
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.AuthorID,
			&i.Body,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadServices = `-- name: ListLeadServices :many
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at, service_type_id FROM RAC_lead_services
WHERE lead_id = $1
ORDER BY created_at
`

func (q *Queries) ListLeadServices(ctx context.Context, leadID pgtype.UUID) ([]RacLeadService, error) {
	rows, err := q.db.Query(ctx, listLeadServices, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacLeadService
	for rows.Next() {
		var i RacLeadService
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.ServiceType,
			&i.Status,
			&i.VisitScheduledDate,
			&i.VisitScoutID,
			&i.VisitMeasurements,
			&i.VisitAccessDifficulty,
			&i.VisitNotes,
			&i.VisitCompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServiceTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLeadViewedBy = `-- name: SetLeadViewedBy :exec
UPDATE RAC_leads SET viewed_by_id = $2, viewed_at = now(), updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type SetLeadViewedByParams struct {
	ID         pgtype.UUID `json:"id"`
	ViewedByID pgtype.UUID `json:"viewed_by_id"`
}

func (q *Queries) SetLeadViewedBy(ctx context.Context, arg SetLeadViewedByParams) error {
	_, err := q.db.Exec(ctx, setLeadViewedBy, arg.ID, arg.ViewedByID)
	return err
}

const softDeleteLead = `-- name: SoftDeleteLead :exec
UPDATE RAC_leads SET deleted_at = now(), updated_at = now() 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteLead(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteLead, id)
	return err
}

const updateLeadNote = `-- name: UpdateLeadNote :one
UPDATE RAC_lead_notes SET body = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type UpdateLeadNoteParams struct {
	ID   pgtype.UUID `json:"id"`
	Body string      `json:"body"`
}

func (q *Queries) UpdateLeadNote(ctx context.Context, arg UpdateLeadNoteParams) (RacLeadNote, error) {
	row := q.db.QueryRow(ctx, updateLeadNote, arg.ID, arg.Body)
	var i RacLeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeadServiceStatus = `-- name: UpdateLeadServiceStatus :one
UPDATE RAC_lead_services SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at, service_type_id
`

type UpdateLeadServiceStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadServiceStatus(ctx context.Context, arg UpdateLeadServiceStatusParams) (RacLeadService, error) {
	row := q.db.QueryRow(ctx, updateLeadServiceStatus, arg.ID, arg.Status)
	var i RacLeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServiceTypeID,
	)
	return i, err
}

const updateLeadStatus = `-- name: UpdateLeadStatus :one
UPDATE RAC_leads SET status = $2, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type UpdateLeadStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadStatus(ctx context.Context, arg UpdateLeadStatusParams) (RacLead, error) {
	row := q.db.QueryRow(ctx, updateLeadStatus, arg.ID, arg.Status)
	var i RacLead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}
