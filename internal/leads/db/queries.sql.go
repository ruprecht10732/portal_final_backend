// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package leadsdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkSoftDeleteLeads = `-- name: BulkSoftDeleteLeads :execresult
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
`

func (q *Queries) BulkSoftDeleteLeads(ctx context.Context, ids []pgtype.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, bulkSoftDeleteLeads, ids)
}

const completeLeadServiceSurvey = `-- name: CompleteLeadServiceSurvey :one
UPDATE lead_services SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type CompleteLeadServiceSurveyParams struct {
	ID                    pgtype.UUID `json:"id"`
	VisitMeasurements     pgtype.Text `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text `json:"visit_notes"`
}

func (q *Queries) CompleteLeadServiceSurvey(ctx context.Context, arg CompleteLeadServiceSurveyParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, completeLeadServiceSurvey,
		arg.ID,
		arg.VisitMeasurements,
		arg.VisitAccessDifficulty,
		arg.VisitNotes,
	)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeLeadSurvey = `-- name: CompleteLeadSurvey :one
UPDATE leads SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type CompleteLeadSurveyParams struct {
	ID                    pgtype.UUID `json:"id"`
	VisitMeasurements     pgtype.Text `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text `json:"visit_notes"`
}

func (q *Queries) CompleteLeadSurvey(ctx context.Context, arg CompleteLeadSurveyParams) (Lead, error) {
	row := q.db.QueryRow(ctx, completeLeadSurvey,
		arg.ID,
		arg.VisitMeasurements,
		arg.VisitAccessDifficulty,
		arg.VisitNotes,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const countLeads = `-- name: CountLeads :one
SELECT COUNT(*) FROM leads WHERE deleted_at IS NULL
`

func (q *Queries) CountLeads(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLeads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLead = `-- name: CreateLead :one

INSERT INTO leads (
    consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
    address_street, address_house_number, address_zip_code, address_city,
    service_type, status, assigned_agent_id,
    consumer_note, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'New', $11, $12, $13)
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type CreateLeadParams struct {
	ConsumerFirstName  string      `json:"consumer_first_name"`
	ConsumerLastName   string      `json:"consumer_last_name"`
	ConsumerPhone      string      `json:"consumer_phone"`
	ConsumerEmail      pgtype.Text `json:"consumer_email"`
	ConsumerRole       string      `json:"consumer_role"`
	AddressStreet      string      `json:"address_street"`
	AddressHouseNumber string      `json:"address_house_number"`
	AddressZipCode     string      `json:"address_zip_code"`
	AddressCity        string      `json:"address_city"`
	ServiceType        string      `json:"service_type"`
	AssignedAgentID    pgtype.UUID `json:"assigned_agent_id"`
	ConsumerNote       pgtype.Text `json:"consumer_note"`
	Source             pgtype.Text `json:"source"`
}

// Leads Domain SQL Queries
func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, createLead,
		arg.ConsumerFirstName,
		arg.ConsumerLastName,
		arg.ConsumerPhone,
		arg.ConsumerEmail,
		arg.ConsumerRole,
		arg.AddressStreet,
		arg.AddressHouseNumber,
		arg.AddressZipCode,
		arg.AddressCity,
		arg.ServiceType,
		arg.AssignedAgentID,
		arg.ConsumerNote,
		arg.Source,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const createLeadActivity = `-- name: CreateLeadActivity :exec

INSERT INTO lead_activity (lead_id, user_id, action, meta)
VALUES ($1, $2, $3, $4)
`

type CreateLeadActivityParams struct {
	LeadID pgtype.UUID `json:"lead_id"`
	UserID pgtype.UUID `json:"user_id"`
	Action string      `json:"action"`
	Meta   []byte      `json:"meta"`
}

// Lead Activity Queries
func (q *Queries) CreateLeadActivity(ctx context.Context, arg CreateLeadActivityParams) error {
	_, err := q.db.Exec(ctx, createLeadActivity,
		arg.LeadID,
		arg.UserID,
		arg.Action,
		arg.Meta,
	)
	return err
}

const createLeadNote = `-- name: CreateLeadNote :one

INSERT INTO lead_notes (lead_id, author_id, body, type)
VALUES ($1, $2, $3, $4)
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type CreateLeadNoteParams struct {
	LeadID   pgtype.UUID `json:"lead_id"`
	AuthorID pgtype.UUID `json:"author_id"`
	Body     string      `json:"body"`
	Type     string      `json:"type"`
}

// Lead Notes Queries
func (q *Queries) CreateLeadNote(ctx context.Context, arg CreateLeadNoteParams) (LeadNote, error) {
	row := q.db.QueryRow(ctx, createLeadNote,
		arg.LeadID,
		arg.AuthorID,
		arg.Body,
		arg.Type,
	)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeadService = `-- name: CreateLeadService :one

INSERT INTO lead_services (lead_id, service_type, status)
VALUES ($1, $2, 'New')
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type CreateLeadServiceParams struct {
	LeadID      pgtype.UUID `json:"lead_id"`
	ServiceType string      `json:"service_type"`
}

// Lead Services Queries
func (q *Queries) CreateLeadService(ctx context.Context, arg CreateLeadServiceParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, createLeadService, arg.LeadID, arg.ServiceType)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVisitHistory = `-- name: CreateVisitHistory :one

INSERT INTO visit_history (lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at
`

type CreateVisitHistoryParams struct {
	LeadID           pgtype.UUID        `json:"lead_id"`
	ScheduledDate    pgtype.Timestamptz `json:"scheduled_date"`
	ScoutID          pgtype.UUID        `json:"scout_id"`
	Outcome          string             `json:"outcome"`
	Measurements     pgtype.Text        `json:"measurements"`
	AccessDifficulty pgtype.Text        `json:"access_difficulty"`
	Notes            pgtype.Text        `json:"notes"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
}

// Visit History Queries
func (q *Queries) CreateVisitHistory(ctx context.Context, arg CreateVisitHistoryParams) (VisitHistory, error) {
	row := q.db.QueryRow(ctx, createVisitHistory,
		arg.LeadID,
		arg.ScheduledDate,
		arg.ScoutID,
		arg.Outcome,
		arg.Measurements,
		arg.AccessDifficulty,
		arg.Notes,
		arg.CompletedAt,
	)
	var i VisitHistory
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ScheduledDate,
		&i.ScoutID,
		&i.Outcome,
		&i.Measurements,
		&i.AccessDifficulty,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLeadNote = `-- name: DeleteLeadNote :exec
DELETE FROM lead_notes WHERE id = $1
`

func (q *Queries) DeleteLeadNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLeadNote, id)
	return err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source FROM leads WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLeadByID(ctx context.Context, id pgtype.UUID) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByID, id)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const getLeadByPhone = `-- name: GetLeadByPhone :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source FROM leads 
WHERE consumer_phone = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLeadByPhone(ctx context.Context, consumerPhone string) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByPhone, consumerPhone)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const getLeadNote = `-- name: GetLeadNote :one
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM lead_notes WHERE id = $1
`

func (q *Queries) GetLeadNote(ctx context.Context, id pgtype.UUID) (LeadNote, error) {
	row := q.db.QueryRow(ctx, getLeadNote, id)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadService = `-- name: GetLeadService :one
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at FROM lead_services WHERE id = $1
`

func (q *Queries) GetLeadService(ctx context.Context, id pgtype.UUID) (LeadService, error) {
	row := q.db.QueryRow(ctx, getLeadService, id)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeadActivities = `-- name: ListLeadActivities :many
SELECT id, lead_id, user_id, action, meta, created_at FROM lead_activity
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadActivities(ctx context.Context, leadID pgtype.UUID) ([]LeadActivity, error) {
	rows, err := q.db.Query(ctx, listLeadActivities, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadActivity
	for rows.Next() {
		var i LeadActivity
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.UserID,
			&i.Action,
			&i.Meta,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadNotes = `-- name: ListLeadNotes :many
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM lead_notes
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadNotes(ctx context.Context, leadID pgtype.UUID) ([]LeadNote, error) {
	rows, err := q.db.Query(ctx, listLeadNotes, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadNote
	for rows.Next() {
		var i LeadNote
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.AuthorID,
			&i.Body,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadServices = `-- name: ListLeadServices :many
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at FROM lead_services
WHERE lead_id = $1
ORDER BY created_at
`

func (q *Queries) ListLeadServices(ctx context.Context, leadID pgtype.UUID) ([]LeadService, error) {
	rows, err := q.db.Query(ctx, listLeadServices, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadService
	for rows.Next() {
		var i LeadService
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.ServiceType,
			&i.Status,
			&i.VisitScheduledDate,
			&i.VisitScoutID,
			&i.VisitMeasurements,
			&i.VisitAccessDifficulty,
			&i.VisitNotes,
			&i.VisitCompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisitHistory = `-- name: ListVisitHistory :many
SELECT id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at FROM visit_history
WHERE lead_id = $1
ORDER BY scheduled_date DESC
`

func (q *Queries) ListVisitHistory(ctx context.Context, leadID pgtype.UUID) ([]VisitHistory, error) {
	rows, err := q.db.Query(ctx, listVisitHistory, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VisitHistory
	for rows.Next() {
		var i VisitHistory
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.ScheduledDate,
			&i.ScoutID,
			&i.Outcome,
			&i.Measurements,
			&i.AccessDifficulty,
			&i.Notes,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleLeadServiceVisit = `-- name: ScheduleLeadServiceVisit :one
UPDATE lead_services SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type ScheduleLeadServiceVisitParams struct {
	ID                 pgtype.UUID        `json:"id"`
	VisitScheduledDate pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID       pgtype.UUID        `json:"visit_scout_id"`
}

func (q *Queries) ScheduleLeadServiceVisit(ctx context.Context, arg ScheduleLeadServiceVisitParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, scheduleLeadServiceVisit, arg.ID, arg.VisitScheduledDate, arg.VisitScoutID)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const scheduleLeadVisit = `-- name: ScheduleLeadVisit :one
UPDATE leads SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type ScheduleLeadVisitParams struct {
	ID                 pgtype.UUID        `json:"id"`
	VisitScheduledDate pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID       pgtype.UUID        `json:"visit_scout_id"`
}

func (q *Queries) ScheduleLeadVisit(ctx context.Context, arg ScheduleLeadVisitParams) (Lead, error) {
	row := q.db.QueryRow(ctx, scheduleLeadVisit, arg.ID, arg.VisitScheduledDate, arg.VisitScoutID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}

const setLeadViewedBy = `-- name: SetLeadViewedBy :exec
UPDATE leads SET viewed_by_id = $2, viewed_at = now(), updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type SetLeadViewedByParams struct {
	ID         pgtype.UUID `json:"id"`
	ViewedByID pgtype.UUID `json:"viewed_by_id"`
}

func (q *Queries) SetLeadViewedBy(ctx context.Context, arg SetLeadViewedByParams) error {
	_, err := q.db.Exec(ctx, setLeadViewedBy, arg.ID, arg.ViewedByID)
	return err
}

const softDeleteLead = `-- name: SoftDeleteLead :exec
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteLead(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteLead, id)
	return err
}

const updateLeadNote = `-- name: UpdateLeadNote :one
UPDATE lead_notes SET body = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type UpdateLeadNoteParams struct {
	ID   pgtype.UUID `json:"id"`
	Body string      `json:"body"`
}

func (q *Queries) UpdateLeadNote(ctx context.Context, arg UpdateLeadNoteParams) (LeadNote, error) {
	row := q.db.QueryRow(ctx, updateLeadNote, arg.ID, arg.Body)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeadServiceStatus = `-- name: UpdateLeadServiceStatus :one
UPDATE lead_services SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type UpdateLeadServiceStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadServiceStatus(ctx context.Context, arg UpdateLeadServiceStatusParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, updateLeadServiceStatus, arg.ID, arg.Status)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeadStatus = `-- name: UpdateLeadStatus :one
UPDATE leads SET status = $2, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at, consumer_note, source
`

type UpdateLeadStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadStatus(ctx context.Context, arg UpdateLeadStatusParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLeadStatus, arg.ID, arg.Status)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConsumerNote,
		&i.Source,
	)
	return i, err
}
