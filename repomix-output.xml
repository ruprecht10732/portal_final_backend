This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.air.toml
.gitignore
cmd/api/main.go
go.mod
internal/adapters/auth_agent_provider.go
internal/auth/adapter/user_provider.go
internal/auth/auth.go
internal/auth/db/db.go
internal/auth/db/models.go
internal/auth/db/querier.go
internal/auth/db/queries.sql.go
internal/auth/handler/handler.go
internal/auth/migrations/001_init.sql
internal/auth/migrations/002_roles.sql
internal/auth/module.go
internal/auth/password/password.go
internal/auth/repository/interface.go
internal/auth/repository/repository.go
internal/auth/service/service.go
internal/auth/sql/queries.sql
internal/auth/token/token.go
internal/auth/transport/dto.go
internal/auth/validator/validator.go
internal/config/config.go
internal/db/db.go
internal/email/brevo.go
internal/events/bus.go
internal/events/event.go
internal/http/middleware/middleware.go
internal/http/module.go
internal/http/response/response.go
internal/http/router/portal_final.code-workspace
internal/http/router/router.go
internal/leads/db/db.go
internal/leads/db/models.go
internal/leads/db/querier.go
internal/leads/db/queries.sql.go
internal/leads/handler/handler.go
internal/leads/handler/notes.go
internal/leads/leads.go
internal/leads/management/mappers.go
internal/leads/management/service.go
internal/leads/migrations/001_leads.sql
internal/leads/migrations/002_lead_activity.sql
internal/leads/migrations/003_lead_notes.sql
internal/leads/migrations/004_lead_services.sql
internal/leads/migrations/005_visit_history.sql
internal/leads/module.go
internal/leads/notes/service.go
internal/leads/ports/agent_provider.go
internal/leads/ports/users.go
internal/leads/repository/interface.go
internal/leads/repository/lead_services.go
internal/leads/repository/notes.go
internal/leads/repository/repository.go
internal/leads/repository/visit_history.go
internal/leads/scheduling/service.go
internal/leads/service/notes.go
internal/leads/service/service.go
internal/leads/service/visit_history.go
internal/leads/sql/queries.sql
internal/leads/transport/dto.go
internal/leads/transport/notes.go
internal/leads/transport/optional.go
internal/logger/logger.go
internal/notification/module.go
internal/phone/normalize.go
internal/shared/validator/validator.go
migrations/001_init.sql
migrations/002_roles.sql
migrations/003_leads.sql
migrations/004_lead_activity.sql
migrations/005_leads_soft_delete.sql
migrations/006_lead_notes.sql
migrations/007_lead_services.sql
migrations/007_visit_history.sql
migrations/008_lead_notes_type.sql
platform/config/config.go
platform/db/db.go
platform/events/bus.go
platform/events/event.go
platform/httpkit/middleware.go
platform/httpkit/response.go
platform/logger/logger.go
platform/phone/normalize.go
platform/validator/validator.go
sql/auth.sql
sqlc.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".air.toml">
root = "."

tmp_dir = "tmp"

[build]
  cmd = "go build -o ./tmp/app.exe ./cmd/api"
  entrypoint = "./tmp/app.exe"
  delay = 200
  exclude_dir = ["tmp", "vendor", "migrations"]
  include_ext = ["go", "tpl", "tmpl", "html"]
  stop_on_error = true

[log]
  time = true

[color]
  main = "yellow"
  watcher = "cyan"
  build = "green"
  runner = "magenta"

[misc]
  clean_on_exit = true
</file>

<file path=".gitignore">
.env
.env.*

# Go build
/bin/
/build/
/dist/
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out

# Go workspace
/vendor/

# Logs
*.log

# OS
.DS_Store
Thumbs.db
</file>

<file path="internal/adapters/auth_agent_provider.go">
// Package adapters contains adapters that bridge different bounded contexts.
// These adapters implement interfaces defined by consuming domains while
// wrapping services from providing domains.
package adapters

import (
	"context"
	"strings"

	authservice "portal_final_backend/internal/auth/service"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// AuthAgentProvider adapts the auth service to satisfy the leads domain's
// AgentProvider interface. This is the Anti-Corruption Layer implementation
// that ensures the leads domain doesn't need to know about auth domain internals.
type AuthAgentProvider struct {
	authSvc *authservice.Service
}

// NewAuthAgentProvider creates a new adapter wrapping the auth service.
func NewAuthAgentProvider(authSvc *authservice.Service) *AuthAgentProvider {
	return &AuthAgentProvider{authSvc: authSvc}
}

// GetAgentByID returns agent information for the given user ID.
func (p *AuthAgentProvider) GetAgentByID(ctx context.Context, agentID uuid.UUID) (ports.Agent, error) {
	profile, err := p.authSvc.GetMe(ctx, agentID)
	if err != nil {
		return ports.Agent{}, err
	}

	return ports.Agent{
		ID:    profile.ID,
		Email: profile.Email,
		Name:  deriveNameFromEmail(profile.Email),
	}, nil
}

// GetAgentsByIDs returns agent information for multiple user IDs.
func (p *AuthAgentProvider) GetAgentsByIDs(ctx context.Context, agentIDs []uuid.UUID) (map[uuid.UUID]ports.Agent, error) {
	result := make(map[uuid.UUID]ports.Agent)

	for _, id := range agentIDs {
		agent, err := p.GetAgentByID(ctx, id)
		if err != nil {
			// Silently omit missing agents
			continue
		}
		result[id] = agent
	}

	return result, nil
}

// ListAgents returns all available agents.
func (p *AuthAgentProvider) ListAgents(ctx context.Context) ([]ports.Agent, error) {
	users, err := p.authSvc.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	agents := make([]ports.Agent, 0, len(users))
	for _, user := range users {
		id, err := uuid.Parse(user.ID)
		if err != nil {
			continue
		}
		agents = append(agents, ports.Agent{
			ID:    id,
			Email: user.Email,
			Name:  deriveNameFromEmail(user.Email),
		})
	}

	return agents, nil
}

// deriveNameFromEmail creates a display name from an email address.
func deriveNameFromEmail(email string) string {
	parts := strings.Split(email, "@")
	if len(parts) == 0 {
		return email
	}
	name := parts[0]
	name = strings.ReplaceAll(name, ".", " ")
	name = strings.ReplaceAll(name, "_", " ")
	name = strings.ReplaceAll(name, "-", " ")
	return strings.Title(name)
}

// Compile-time check that AuthAgentProvider implements ports.AgentProvider
var _ ports.AgentProvider = (*AuthAgentProvider)(nil)
</file>

<file path="internal/auth/adapter/user_provider.go">
// Package adapter provides implementations of external interfaces that other domains need.
// This follows the Anti-Corruption Layer pattern - auth domain provides adapters
// that satisfy consumer-driven interfaces defined by other domains.
package adapter

import (
	"context"

	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// UserProviderAdapter implements leads/ports.UserProvider using the auth repository.
// This allows the leads domain to get user information without depending on auth internals.
type UserProviderAdapter struct {
	repo repository.UserReader
}

// NewUserProviderAdapter creates a new adapter for providing user info to other domains.
func NewUserProviderAdapter(repo repository.UserReader) *UserProviderAdapter {
	return &UserProviderAdapter{repo: repo}
}

// GetUserByID implements ports.UserProvider.
func (a *UserProviderAdapter) GetUserByID(ctx context.Context, userID uuid.UUID) (ports.UserInfo, error) {
	user, err := a.repo.GetUserByID(ctx, userID)
	if err != nil {
		return ports.UserInfo{}, err
	}

	return ports.UserInfo{
		ID:    user.ID,
		Email: user.Email,
		// Roles would need to be fetched separately if needed
	}, nil
}

// Ensure UserProviderAdapter implements ports.UserProvider
var _ ports.UserProvider = (*UserProviderAdapter)(nil)

// UserExistenceAdapter implements leads/ports.UserExistenceChecker.
type UserExistenceAdapter struct {
	repo repository.UserReader
}

// NewUserExistenceAdapter creates a new adapter for checking user existence.
func NewUserExistenceAdapter(repo repository.UserReader) *UserExistenceAdapter {
	return &UserExistenceAdapter{repo: repo}
}

// UserExists implements ports.UserExistenceChecker.
func (a *UserExistenceAdapter) UserExists(ctx context.Context, userID uuid.UUID) (bool, error) {
	_, err := a.repo.GetUserByID(ctx, userID)
	if err != nil {
		if err == repository.ErrNotFound {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

// Ensure UserExistenceAdapter implements ports.UserExistenceChecker
var _ ports.UserExistenceChecker = (*UserExistenceAdapter)(nil)
</file>

<file path="internal/auth/auth.go">
// Package auth provides authentication and authorization functionality.
// This file defines the public API of the auth bounded context.
// Only types and interfaces defined here should be imported by other domains.
package auth

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// Profile represents user information that can be shared with other domains.
type Profile struct {
	ID            uuid.UUID
	Email         string
	EmailVerified bool
	Roles         []string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

// UserSummary represents minimal user information for listing purposes.
type UserSummary struct {
	ID    string   `json:"id"`
	Email string   `json:"email"`
	Roles []string `json:"roles"`
}

// Service defines the public interface for authentication operations.
// Other domains should depend on this interface, not on concrete implementations.
type Service interface {
	// GetMe returns the profile of the user with the given ID.
	GetMe(ctx context.Context, userID uuid.UUID) (Profile, error)
	// ListUsers returns a list of all users (for admin purposes).
	ListUsers(ctx context.Context) ([]UserSummary, error)
}

// UserProvider is an interface that other domains can use to get user information.
// This abstracts authentication details from other bounded contexts.
type UserProvider interface {
	// GetUserByID returns basic user information needed by other domains.
	GetUserByID(ctx context.Context, userID uuid.UUID) (Profile, error)
	// GetUsersByIDs returns user information for multiple users at once.
	GetUsersByIDs(ctx context.Context, userIDs []uuid.UUID) (map[uuid.UUID]Profile, error)
}
</file>

<file path="internal/auth/db/db.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
</file>

<file path="internal/auth/db/models.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"github.com/jackc/pgx/v5/pgtype"
)

type RefreshToken struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	RevokedAt pgtype.Timestamptz `json:"revoked_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Role struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

type User struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

type UserRole struct {
	UserID    pgtype.UUID        `json:"user_id"`
	RoleID    pgtype.UUID        `json:"role_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type UserToken struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	Type      string             `json:"type"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}
</file>

<file path="internal/auth/db/querier.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error
	// Auth Domain SQL Queries
	CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
	CreateUserToken(ctx context.Context, arg CreateUserTokenParams) error
	DeleteUserRoles(ctx context.Context, userID pgtype.UUID) error
	GetRefreshToken(ctx context.Context, tokenHash string) (GetRefreshTokenRow, error)
	GetUserByEmail(ctx context.Context, email string) (User, error)
	GetUserByID(ctx context.Context, id pgtype.UUID) (User, error)
	GetUserRoles(ctx context.Context, userID pgtype.UUID) ([]string, error)
	GetUserToken(ctx context.Context, arg GetUserTokenParams) (GetUserTokenRow, error)
	GetValidRoles(ctx context.Context, dollar_1 []string) ([]string, error)
	InsertUserRoles(ctx context.Context, arg InsertUserRolesParams) error
	ListUsers(ctx context.Context) ([]ListUsersRow, error)
	MarkEmailVerified(ctx context.Context, id pgtype.UUID) error
	RevokeAllRefreshTokens(ctx context.Context, userID pgtype.UUID) error
	RevokeRefreshToken(ctx context.Context, tokenHash string) error
	UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error
	UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error)
	UseUserToken(ctx context.Context, arg UseUserTokenParams) error
}

var _ Querier = (*Queries)(nil)
</file>

<file path="internal/auth/db/queries.sql.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

// Auth Domain SQL Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserToken = `-- name: CreateUserToken :exec
INSERT INTO user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateUserTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	Type      string             `json:"type"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateUserToken(ctx context.Context, arg CreateUserTokenParams) error {
	_, err := q.db.Exec(ctx, createUserToken,
		arg.UserID,
		arg.TokenHash,
		arg.Type,
		arg.ExpiresAt,
	)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM user_roles WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL
`

type GetRefreshTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, tokenHash string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, tokenHash)
	var i GetRefreshTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserToken = `-- name: GetUserToken :one
SELECT user_id, expires_at FROM user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type GetUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

type GetUserTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetUserToken(ctx context.Context, arg GetUserTokenParams) (GetUserTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserToken, arg.TokenHash, arg.Type)
	var i GetUserTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getValidRoles = `-- name: GetValidRoles :many
SELECT name FROM roles WHERE name = ANY($1::text[])
`

func (q *Queries) GetValidRoles(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getValidRoles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserRoles = `-- name: InsertUserRoles :exec
INSERT INTO user_roles (user_id, role_id)
SELECT $1, id FROM roles WHERE name = ANY($2::text[])
`

type InsertUserRolesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 []string    `json:"column_2"`
}

func (q *Queries) InsertUserRoles(ctx context.Context, arg InsertUserRolesParams) error {
	_, err := q.db.Exec(ctx, insertUserRoles, arg.UserID, arg.Column2)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.email,
    COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles
FROM users u
LEFT JOIN user_roles ur ON ur.user_id = u.id
LEFT JOIN roles r ON r.id = ur.role_id
GROUP BY u.id
ORDER BY u.email
`

type ListUsersRow struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
	Roles interface{} `json:"roles"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(&i.ID, &i.Email, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailVerified = `-- name: MarkEmailVerified :exec
UPDATE users SET is_email_verified = true, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkEmailVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markEmailVerified, id)
	return err
}

const revokeAllRefreshTokens = `-- name: RevokeAllRefreshTokens :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllRefreshTokens(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, tokenHash)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users SET password_hash = $2, updated_at = now() WHERE id = $1
`

type UpdatePasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $2, is_email_verified = false, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
`

type UpdateUserEmailParams struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const useUserToken = `-- name: UseUserToken :exec
UPDATE user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type UseUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

func (q *Queries) UseUserToken(ctx context.Context, arg UseUserTokenParams) error {
	_, err := q.db.Exec(ctx, useUserToken, arg.TokenHash, arg.Type)
	return err
}
</file>

<file path="internal/auth/migrations/001_init.sql">
-- Auth Domain: Core user tables
-- This migration is isolated to the auth domain

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  is_email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  revoked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON refresh_tokens(expires_at);

CREATE TABLE IF NOT EXISTS user_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  type TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_user_tokens_user_id ON user_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tokens_type ON user_tokens(type);
CREATE INDEX IF NOT EXISTS idx_user_tokens_expires ON user_tokens(expires_at);
</file>

<file path="internal/auth/migrations/002_roles.sql">
-- Auth Domain: Roles and user-role assignments

CREATE TABLE IF NOT EXISTS roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, role_id)
);

-- Seed default roles
INSERT INTO roles (name)
VALUES ('admin'), ('user'), ('agent'), ('scout')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="internal/auth/password/password.go">
package password

import "golang.org/x/crypto/bcrypt"

func Hash(plain string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(plain), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

func Compare(hash, plain string) error {
	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(plain))
}
</file>

<file path="internal/auth/sql/queries.sql">
-- Auth Domain SQL Queries

-- name: CreateUser :one
INSERT INTO users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at;

-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE email = $1;

-- name: GetUserByID :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE id = $1;

-- name: MarkEmailVerified :exec
UPDATE users SET is_email_verified = true, updated_at = now() WHERE id = $1;

-- name: UpdatePassword :exec
UPDATE users SET password_hash = $2, updated_at = now() WHERE id = $1;

-- name: UpdateUserEmail :one
UPDATE users
SET email = $2, is_email_verified = false, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at;

-- name: CreateUserToken :exec
INSERT INTO user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4);

-- name: GetUserToken :one
SELECT user_id, expires_at FROM user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: UseUserToken :exec
UPDATE user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3);

-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeAllRefreshTokens :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL;

-- name: GetUserRoles :many
SELECT r.name
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY r.name;

-- name: ListUsers :many
SELECT u.id, u.email,
    COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles
FROM users u
LEFT JOIN user_roles ur ON ur.user_id = u.id
LEFT JOIN roles r ON r.id = ur.role_id
GROUP BY u.id
ORDER BY u.email;

-- name: DeleteUserRoles :exec
DELETE FROM user_roles WHERE user_id = $1;

-- name: InsertUserRoles :exec
INSERT INTO user_roles (user_id, role_id)
SELECT $1, id FROM roles WHERE name = ANY($2::text[]);

-- name: GetValidRoles :many
SELECT name FROM roles WHERE name = ANY($1::text[]);
</file>

<file path="internal/auth/token/token.go">
package token

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
)

func GenerateRandomToken(size int) (string, error) {
	b := make([]byte, size)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}

func HashSHA256(token string) string {
	h := sha256.Sum256([]byte(token))
	return hex.EncodeToString(h[:])
}
</file>

<file path="internal/http/response/response.go">
package response

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type ErrorResponse struct {
	Error   string      `json:"error"`
	Details interface{} `json:"details,omitempty"`
}

func JSON(c *gin.Context, status int, payload interface{}) {
	c.JSON(status, payload)
}

func Error(c *gin.Context, status int, message string, details interface{}) {
	c.JSON(status, ErrorResponse{Error: message, Details: details})
}

func OK(c *gin.Context, payload interface{}) {
	c.JSON(http.StatusOK, payload)
}
</file>

<file path="internal/http/router/portal_final.code-workspace">
{
	"folders": [
		{
			"path": "../../../../portal_final"
		},
		{
			"path": "../../.."
		}
	],
	"settings": {}
}
</file>

<file path="internal/leads/db/db.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package leadsdb

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
</file>

<file path="internal/leads/db/models.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package leadsdb

import (
	"github.com/jackc/pgx/v5/pgtype"
)

type Lead struct {
	ID                    pgtype.UUID        `json:"id"`
	ConsumerFirstName     string             `json:"consumer_first_name"`
	ConsumerLastName      string             `json:"consumer_last_name"`
	ConsumerPhone         string             `json:"consumer_phone"`
	ConsumerEmail         pgtype.Text        `json:"consumer_email"`
	ConsumerRole          string             `json:"consumer_role"`
	AddressStreet         string             `json:"address_street"`
	AddressHouseNumber    string             `json:"address_house_number"`
	AddressZipCode        string             `json:"address_zip_code"`
	AddressCity           string             `json:"address_city"`
	ServiceType           string             `json:"service_type"`
	Status                string             `json:"status"`
	AssignedAgentID       pgtype.UUID        `json:"assigned_agent_id"`
	ViewedByID            pgtype.UUID        `json:"viewed_by_id"`
	ViewedAt              pgtype.Timestamptz `json:"viewed_at"`
	VisitScheduledDate    pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID          pgtype.UUID        `json:"visit_scout_id"`
	VisitMeasurements     pgtype.Text        `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text        `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text        `json:"visit_notes"`
	VisitCompletedAt      pgtype.Timestamptz `json:"visit_completed_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

type LeadActivity struct {
	ID        pgtype.UUID        `json:"id"`
	LeadID    pgtype.UUID        `json:"lead_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Action    string             `json:"action"`
	Meta      []byte             `json:"meta"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type LeadNote struct {
	ID        pgtype.UUID        `json:"id"`
	LeadID    pgtype.UUID        `json:"lead_id"`
	AuthorID  pgtype.UUID        `json:"author_id"`
	Body      string             `json:"body"`
	Type      string             `json:"type"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type LeadService struct {
	ID                    pgtype.UUID        `json:"id"`
	LeadID                pgtype.UUID        `json:"lead_id"`
	ServiceType           string             `json:"service_type"`
	Status                string             `json:"status"`
	VisitScheduledDate    pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID          pgtype.UUID        `json:"visit_scout_id"`
	VisitMeasurements     pgtype.Text        `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text        `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text        `json:"visit_notes"`
	VisitCompletedAt      pgtype.Timestamptz `json:"visit_completed_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

type VisitHistory struct {
	ID               pgtype.UUID        `json:"id"`
	LeadID           pgtype.UUID        `json:"lead_id"`
	ScheduledDate    pgtype.Timestamptz `json:"scheduled_date"`
	ScoutID          pgtype.UUID        `json:"scout_id"`
	Outcome          string             `json:"outcome"`
	Measurements     pgtype.Text        `json:"measurements"`
	AccessDifficulty pgtype.Text        `json:"access_difficulty"`
	Notes            pgtype.Text        `json:"notes"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}
</file>

<file path="internal/leads/db/querier.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package leadsdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	BulkSoftDeleteLeads(ctx context.Context, dollar_1 []pgtype.UUID) (pgconn.CommandTag, error)
	CompleteLeadServiceSurvey(ctx context.Context, arg CompleteLeadServiceSurveyParams) (LeadService, error)
	CompleteLeadSurvey(ctx context.Context, arg CompleteLeadSurveyParams) (Lead, error)
	CountLeads(ctx context.Context) (int64, error)
	// Leads Domain SQL Queries
	CreateLead(ctx context.Context, arg CreateLeadParams) (Lead, error)
	// Lead Activity Queries
	CreateLeadActivity(ctx context.Context, arg CreateLeadActivityParams) error
	// Lead Notes Queries
	CreateLeadNote(ctx context.Context, arg CreateLeadNoteParams) (LeadNote, error)
	// Lead Services Queries
	CreateLeadService(ctx context.Context, arg CreateLeadServiceParams) (LeadService, error)
	// Visit History Queries
	CreateVisitHistory(ctx context.Context, arg CreateVisitHistoryParams) (VisitHistory, error)
	DeleteLeadNote(ctx context.Context, id pgtype.UUID) error
	GetLeadByID(ctx context.Context, id pgtype.UUID) (Lead, error)
	GetLeadByPhone(ctx context.Context, consumerPhone string) (Lead, error)
	GetLeadNote(ctx context.Context, id pgtype.UUID) (LeadNote, error)
	GetLeadService(ctx context.Context, id pgtype.UUID) (LeadService, error)
	ListLeadActivities(ctx context.Context, leadID pgtype.UUID) ([]LeadActivity, error)
	ListLeadNotes(ctx context.Context, leadID pgtype.UUID) ([]LeadNote, error)
	ListLeadServices(ctx context.Context, leadID pgtype.UUID) ([]LeadService, error)
	ListVisitHistory(ctx context.Context, leadID pgtype.UUID) ([]VisitHistory, error)
	ScheduleLeadServiceVisit(ctx context.Context, arg ScheduleLeadServiceVisitParams) (LeadService, error)
	ScheduleLeadVisit(ctx context.Context, arg ScheduleLeadVisitParams) (Lead, error)
	SetLeadViewedBy(ctx context.Context, arg SetLeadViewedByParams) error
	SoftDeleteLead(ctx context.Context, id pgtype.UUID) error
	UpdateLeadNote(ctx context.Context, arg UpdateLeadNoteParams) (LeadNote, error)
	UpdateLeadServiceStatus(ctx context.Context, arg UpdateLeadServiceStatusParams) (LeadService, error)
	UpdateLeadStatus(ctx context.Context, arg UpdateLeadStatusParams) (Lead, error)
}

var _ Querier = (*Queries)(nil)
</file>

<file path="internal/leads/db/queries.sql.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package leadsdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkSoftDeleteLeads = `-- name: BulkSoftDeleteLeads :execresult
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
`

func (q *Queries) BulkSoftDeleteLeads(ctx context.Context, dollar_1 []pgtype.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, bulkSoftDeleteLeads, dollar_1)
}

const completeLeadServiceSurvey = `-- name: CompleteLeadServiceSurvey :one
UPDATE lead_services SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type CompleteLeadServiceSurveyParams struct {
	ID                    pgtype.UUID `json:"id"`
	VisitMeasurements     pgtype.Text `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text `json:"visit_notes"`
}

func (q *Queries) CompleteLeadServiceSurvey(ctx context.Context, arg CompleteLeadServiceSurveyParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, completeLeadServiceSurvey,
		arg.ID,
		arg.VisitMeasurements,
		arg.VisitAccessDifficulty,
		arg.VisitNotes,
	)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeLeadSurvey = `-- name: CompleteLeadSurvey :one
UPDATE leads SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at
`

type CompleteLeadSurveyParams struct {
	ID                    pgtype.UUID `json:"id"`
	VisitMeasurements     pgtype.Text `json:"visit_measurements"`
	VisitAccessDifficulty pgtype.Text `json:"visit_access_difficulty"`
	VisitNotes            pgtype.Text `json:"visit_notes"`
}

func (q *Queries) CompleteLeadSurvey(ctx context.Context, arg CompleteLeadSurveyParams) (Lead, error) {
	row := q.db.QueryRow(ctx, completeLeadSurvey,
		arg.ID,
		arg.VisitMeasurements,
		arg.VisitAccessDifficulty,
		arg.VisitNotes,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countLeads = `-- name: CountLeads :one
SELECT COUNT(*) FROM leads WHERE deleted_at IS NULL
`

func (q *Queries) CountLeads(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLeads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLead = `-- name: CreateLead :one

INSERT INTO leads (
    consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
    address_street, address_house_number, address_zip_code, address_city,
    service_type, status, assigned_agent_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'New', $11)
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at
`

type CreateLeadParams struct {
	ConsumerFirstName  string      `json:"consumer_first_name"`
	ConsumerLastName   string      `json:"consumer_last_name"`
	ConsumerPhone      string      `json:"consumer_phone"`
	ConsumerEmail      pgtype.Text `json:"consumer_email"`
	ConsumerRole       string      `json:"consumer_role"`
	AddressStreet      string      `json:"address_street"`
	AddressHouseNumber string      `json:"address_house_number"`
	AddressZipCode     string      `json:"address_zip_code"`
	AddressCity        string      `json:"address_city"`
	ServiceType        string      `json:"service_type"`
	AssignedAgentID    pgtype.UUID `json:"assigned_agent_id"`
}

// Leads Domain SQL Queries
func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, createLead,
		arg.ConsumerFirstName,
		arg.ConsumerLastName,
		arg.ConsumerPhone,
		arg.ConsumerEmail,
		arg.ConsumerRole,
		arg.AddressStreet,
		arg.AddressHouseNumber,
		arg.AddressZipCode,
		arg.AddressCity,
		arg.ServiceType,
		arg.AssignedAgentID,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeadActivity = `-- name: CreateLeadActivity :exec

INSERT INTO lead_activity (lead_id, user_id, action, meta)
VALUES ($1, $2, $3, $4)
`

type CreateLeadActivityParams struct {
	LeadID pgtype.UUID `json:"lead_id"`
	UserID pgtype.UUID `json:"user_id"`
	Action string      `json:"action"`
	Meta   []byte      `json:"meta"`
}

// Lead Activity Queries
func (q *Queries) CreateLeadActivity(ctx context.Context, arg CreateLeadActivityParams) error {
	_, err := q.db.Exec(ctx, createLeadActivity,
		arg.LeadID,
		arg.UserID,
		arg.Action,
		arg.Meta,
	)
	return err
}

const createLeadNote = `-- name: CreateLeadNote :one

INSERT INTO lead_notes (lead_id, author_id, body, type)
VALUES ($1, $2, $3, $4)
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type CreateLeadNoteParams struct {
	LeadID   pgtype.UUID `json:"lead_id"`
	AuthorID pgtype.UUID `json:"author_id"`
	Body     string      `json:"body"`
	Type     string      `json:"type"`
}

// Lead Notes Queries
func (q *Queries) CreateLeadNote(ctx context.Context, arg CreateLeadNoteParams) (LeadNote, error) {
	row := q.db.QueryRow(ctx, createLeadNote,
		arg.LeadID,
		arg.AuthorID,
		arg.Body,
		arg.Type,
	)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeadService = `-- name: CreateLeadService :one

INSERT INTO lead_services (lead_id, service_type, status)
VALUES ($1, $2, 'New')
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type CreateLeadServiceParams struct {
	LeadID      pgtype.UUID `json:"lead_id"`
	ServiceType string      `json:"service_type"`
}

// Lead Services Queries
func (q *Queries) CreateLeadService(ctx context.Context, arg CreateLeadServiceParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, createLeadService, arg.LeadID, arg.ServiceType)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVisitHistory = `-- name: CreateVisitHistory :one

INSERT INTO visit_history (lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at
`

type CreateVisitHistoryParams struct {
	LeadID           pgtype.UUID        `json:"lead_id"`
	ScheduledDate    pgtype.Timestamptz `json:"scheduled_date"`
	ScoutID          pgtype.UUID        `json:"scout_id"`
	Outcome          string             `json:"outcome"`
	Measurements     pgtype.Text        `json:"measurements"`
	AccessDifficulty pgtype.Text        `json:"access_difficulty"`
	Notes            pgtype.Text        `json:"notes"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
}

// Visit History Queries
func (q *Queries) CreateVisitHistory(ctx context.Context, arg CreateVisitHistoryParams) (VisitHistory, error) {
	row := q.db.QueryRow(ctx, createVisitHistory,
		arg.LeadID,
		arg.ScheduledDate,
		arg.ScoutID,
		arg.Outcome,
		arg.Measurements,
		arg.AccessDifficulty,
		arg.Notes,
		arg.CompletedAt,
	)
	var i VisitHistory
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ScheduledDate,
		&i.ScoutID,
		&i.Outcome,
		&i.Measurements,
		&i.AccessDifficulty,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLeadNote = `-- name: DeleteLeadNote :exec
DELETE FROM lead_notes WHERE id = $1
`

func (q *Queries) DeleteLeadNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLeadNote, id)
	return err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at FROM leads WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLeadByID(ctx context.Context, id pgtype.UUID) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByID, id)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadByPhone = `-- name: GetLeadByPhone :one
SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at FROM leads 
WHERE consumer_phone = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLeadByPhone(ctx context.Context, consumerPhone string) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByPhone, consumerPhone)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadNote = `-- name: GetLeadNote :one
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM lead_notes WHERE id = $1
`

func (q *Queries) GetLeadNote(ctx context.Context, id pgtype.UUID) (LeadNote, error) {
	row := q.db.QueryRow(ctx, getLeadNote, id)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadService = `-- name: GetLeadService :one
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at FROM lead_services WHERE id = $1
`

func (q *Queries) GetLeadService(ctx context.Context, id pgtype.UUID) (LeadService, error) {
	row := q.db.QueryRow(ctx, getLeadService, id)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeadActivities = `-- name: ListLeadActivities :many
SELECT id, lead_id, user_id, action, meta, created_at FROM lead_activity
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadActivities(ctx context.Context, leadID pgtype.UUID) ([]LeadActivity, error) {
	rows, err := q.db.Query(ctx, listLeadActivities, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadActivity
	for rows.Next() {
		var i LeadActivity
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.UserID,
			&i.Action,
			&i.Meta,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadNotes = `-- name: ListLeadNotes :many
SELECT id, lead_id, author_id, body, type, created_at, updated_at FROM lead_notes
WHERE lead_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLeadNotes(ctx context.Context, leadID pgtype.UUID) ([]LeadNote, error) {
	rows, err := q.db.Query(ctx, listLeadNotes, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadNote
	for rows.Next() {
		var i LeadNote
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.AuthorID,
			&i.Body,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadServices = `-- name: ListLeadServices :many
SELECT id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at FROM lead_services
WHERE lead_id = $1
ORDER BY created_at
`

func (q *Queries) ListLeadServices(ctx context.Context, leadID pgtype.UUID) ([]LeadService, error) {
	rows, err := q.db.Query(ctx, listLeadServices, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadService
	for rows.Next() {
		var i LeadService
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.ServiceType,
			&i.Status,
			&i.VisitScheduledDate,
			&i.VisitScoutID,
			&i.VisitMeasurements,
			&i.VisitAccessDifficulty,
			&i.VisitNotes,
			&i.VisitCompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisitHistory = `-- name: ListVisitHistory :many
SELECT id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at FROM visit_history
WHERE lead_id = $1
ORDER BY scheduled_date DESC
`

func (q *Queries) ListVisitHistory(ctx context.Context, leadID pgtype.UUID) ([]VisitHistory, error) {
	rows, err := q.db.Query(ctx, listVisitHistory, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VisitHistory
	for rows.Next() {
		var i VisitHistory
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.ScheduledDate,
			&i.ScoutID,
			&i.Outcome,
			&i.Measurements,
			&i.AccessDifficulty,
			&i.Notes,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleLeadServiceVisit = `-- name: ScheduleLeadServiceVisit :one
UPDATE lead_services SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type ScheduleLeadServiceVisitParams struct {
	ID                 pgtype.UUID        `json:"id"`
	VisitScheduledDate pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID       pgtype.UUID        `json:"visit_scout_id"`
}

func (q *Queries) ScheduleLeadServiceVisit(ctx context.Context, arg ScheduleLeadServiceVisitParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, scheduleLeadServiceVisit, arg.ID, arg.VisitScheduledDate, arg.VisitScoutID)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const scheduleLeadVisit = `-- name: ScheduleLeadVisit :one
UPDATE leads SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at
`

type ScheduleLeadVisitParams struct {
	ID                 pgtype.UUID        `json:"id"`
	VisitScheduledDate pgtype.Timestamptz `json:"visit_scheduled_date"`
	VisitScoutID       pgtype.UUID        `json:"visit_scout_id"`
}

func (q *Queries) ScheduleLeadVisit(ctx context.Context, arg ScheduleLeadVisitParams) (Lead, error) {
	row := q.db.QueryRow(ctx, scheduleLeadVisit, arg.ID, arg.VisitScheduledDate, arg.VisitScoutID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setLeadViewedBy = `-- name: SetLeadViewedBy :exec
UPDATE leads SET viewed_by_id = $2, viewed_at = now(), updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

type SetLeadViewedByParams struct {
	ID         pgtype.UUID `json:"id"`
	ViewedByID pgtype.UUID `json:"viewed_by_id"`
}

func (q *Queries) SetLeadViewedBy(ctx context.Context, arg SetLeadViewedByParams) error {
	_, err := q.db.Exec(ctx, setLeadViewedBy, arg.ID, arg.ViewedByID)
	return err
}

const softDeleteLead = `-- name: SoftDeleteLead :exec
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteLead(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteLead, id)
	return err
}

const updateLeadNote = `-- name: UpdateLeadNote :one
UPDATE lead_notes SET body = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, author_id, body, type, created_at, updated_at
`

type UpdateLeadNoteParams struct {
	ID   pgtype.UUID `json:"id"`
	Body string      `json:"body"`
}

func (q *Queries) UpdateLeadNote(ctx context.Context, arg UpdateLeadNoteParams) (LeadNote, error) {
	row := q.db.QueryRow(ctx, updateLeadNote, arg.ID, arg.Body)
	var i LeadNote
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.AuthorID,
		&i.Body,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeadServiceStatus = `-- name: UpdateLeadServiceStatus :one
UPDATE lead_services SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, lead_id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
`

type UpdateLeadServiceStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadServiceStatus(ctx context.Context, arg UpdateLeadServiceStatusParams) (LeadService, error) {
	row := q.db.QueryRow(ctx, updateLeadServiceStatus, arg.ID, arg.Status)
	var i LeadService
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.ServiceType,
		&i.Status,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeadStatus = `-- name: UpdateLeadStatus :one
UPDATE leads SET status = $2, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role, address_street, address_house_number, address_zip_code, address_city, service_type, status, assigned_agent_id, viewed_by_id, viewed_at, visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at, deleted_at, created_at, updated_at
`

type UpdateLeadStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateLeadStatus(ctx context.Context, arg UpdateLeadStatusParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLeadStatus, arg.ID, arg.Status)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.ConsumerFirstName,
		&i.ConsumerLastName,
		&i.ConsumerPhone,
		&i.ConsumerEmail,
		&i.ConsumerRole,
		&i.AddressStreet,
		&i.AddressHouseNumber,
		&i.AddressZipCode,
		&i.AddressCity,
		&i.ServiceType,
		&i.Status,
		&i.AssignedAgentID,
		&i.ViewedByID,
		&i.ViewedAt,
		&i.VisitScheduledDate,
		&i.VisitScoutID,
		&i.VisitMeasurements,
		&i.VisitAccessDifficulty,
		&i.VisitNotes,
		&i.VisitCompletedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
</file>

<file path="internal/leads/leads.go">
// Package leads provides lead management functionality.
// This file defines the public API of the leads bounded context.
// Only types and interfaces defined here should be imported by other domains.
package leads

import (
	"context"

	"github.com/google/uuid"
)

// Lead represents the minimal lead information that can be shared with other domains.
type Lead struct {
	ID              uuid.UUID
	ConsumerName    string
	AssignedAgentID *uuid.UUID
}

// Service defines the public interface for lead operations.
// Other domains should depend on this interface, not on concrete implementations.
type Service interface {
	// GetLeadByID returns minimal lead information for a given ID.
	GetLeadByID(ctx context.Context, id uuid.UUID) (Lead, error)
	// GetLeadsForAgent returns leads assigned to a specific agent.
	GetLeadsForAgent(ctx context.Context, agentID uuid.UUID) ([]Lead, error)
}

// Note: The full leads service with all CRUD operations is intended for use
// within the HTTP handler layer only. Other domains should use the minimal
// Service interface above or define their own interfaces for the specific
// data they need (see AgentProvider pattern below).
</file>

<file path="internal/leads/management/mappers.go">
package management

import (
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
)

// ToLeadResponse converts a repository Lead to a transport LeadResponse.
func ToLeadResponse(lead repository.Lead) transport.LeadResponse {
	return transport.LeadResponse{
		ID:              lead.ID,
		AssignedAgentID: lead.AssignedAgentID,
		ViewedByID:      lead.ViewedByID,
		ViewedAt:        lead.ViewedAt,
		CreatedAt:       lead.CreatedAt,
		UpdatedAt:       lead.UpdatedAt,
		Services:        []transport.LeadServiceResponse{},
		Consumer: transport.ConsumerResponse{
			FirstName: lead.ConsumerFirstName,
			LastName:  lead.ConsumerLastName,
			Phone:     lead.ConsumerPhone,
			Email:     lead.ConsumerEmail,
			Role:      transport.ConsumerRole(lead.ConsumerRole),
		},
		Address: transport.AddressResponse{
			Street:      lead.AddressStreet,
			HouseNumber: lead.AddressHouseNumber,
			ZipCode:     lead.AddressZipCode,
			City:        lead.AddressCity,
		},
	}
}

// ToLeadResponseWithServices converts a repository Lead with services to a transport LeadResponse.
func ToLeadResponseWithServices(lead repository.Lead, services []repository.LeadService) transport.LeadResponse {
	resp := ToLeadResponse(lead)

	resp.Services = make([]transport.LeadServiceResponse, len(services))
	for i, svc := range services {
		resp.Services[i] = ToLeadServiceResponse(svc)
	}

	// Set current service (first non-terminal or first if all terminal)
	if len(services) > 0 {
		for _, svc := range services {
			if svc.Status != "Closed" && svc.Status != "Bad_Lead" && svc.Status != "Surveyed" {
				svcResp := ToLeadServiceResponse(svc)
				resp.CurrentService = &svcResp
				break
			}
		}
		if resp.CurrentService == nil {
			svcResp := ToLeadServiceResponse(services[0])
			resp.CurrentService = &svcResp
		}
	}

	return resp
}

// ToLeadServiceResponse converts a repository LeadService to a transport LeadServiceResponse.
func ToLeadServiceResponse(svc repository.LeadService) transport.LeadServiceResponse {
	resp := transport.LeadServiceResponse{
		ID:          svc.ID,
		ServiceType: transport.ServiceType(svc.ServiceType),
		Status:      transport.LeadStatus(svc.Status),
		CreatedAt:   svc.CreatedAt,
		UpdatedAt:   svc.UpdatedAt,
		Visit: transport.VisitResponse{
			ScheduledDate: svc.VisitScheduledDate,
			ScoutID:       svc.VisitScoutID,
			Measurements:  svc.VisitMeasurements,
			Notes:         svc.VisitNotes,
			CompletedAt:   svc.VisitCompletedAt,
		},
	}

	if svc.VisitAccessDifficulty != nil {
		difficulty := transport.AccessDifficulty(*svc.VisitAccessDifficulty)
		resp.Visit.AccessDifficulty = &difficulty
	}

	return resp
}
</file>

<file path="internal/leads/management/service.go">
// Package management handles lead CRUD operations.
// This is a vertically sliced feature package containing service logic
// for creating, reading, updating, and deleting leads.
package management

import (
	"context"
	"errors"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/phone"

	"github.com/google/uuid"
)

// Errors specific to lead management operations.
var (
	ErrLeadNotFound   = errors.New("lead not found")
	ErrDuplicatePhone = errors.New("a lead with this phone number already exists")
	ErrForbidden      = errors.New("forbidden")
)

// Repository defines the data access interface needed by the management service.
// This is a consumer-driven interface - only what management needs.
type Repository interface {
	repository.LeadReader
	repository.LeadWriter
	repository.LeadViewTracker
	repository.ActivityLogger
	repository.LeadServiceReader
	repository.LeadServiceWriter
}

// Service handles lead management operations (CRUD).
type Service struct {
	repo Repository
}

// New creates a new lead management service.
func New(repo Repository) *Service {
	return &Service{repo: repo}
}

// Create creates a new lead.
func (s *Service) Create(ctx context.Context, req transport.CreateLeadRequest) (transport.LeadResponse, error) {
	req.Phone = phone.NormalizeE164(req.Phone)

	params := repository.CreateLeadParams{
		ConsumerFirstName:  req.FirstName,
		ConsumerLastName:   req.LastName,
		ConsumerPhone:      req.Phone,
		ConsumerRole:       string(req.ConsumerRole),
		AddressStreet:      req.Street,
		AddressHouseNumber: req.HouseNumber,
		AddressZipCode:     req.ZipCode,
		AddressCity:        req.City,
		ServiceType:        string(req.ServiceType),
	}

	if req.AssigneeID.Set {
		params.AssignedAgentID = req.AssigneeID.Value
	}

	if req.Email != "" {
		params.ConsumerEmail = &req.Email
	}

	lead, err := s.repo.Create(ctx, params)
	if err != nil {
		return transport.LeadResponse{}, err
	}

	services, _ := s.repo.ListLeadServices(ctx, lead.ID)
	return ToLeadResponseWithServices(lead, services), nil
}

// GetByID retrieves a lead by ID.
func (s *Service) GetByID(ctx context.Context, id uuid.UUID) (transport.LeadResponse, error) {
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return ToLeadResponseWithServices(lead, services), nil
}

// Update updates a lead's information.
func (s *Service) Update(ctx context.Context, id uuid.UUID, req transport.UpdateLeadRequest, actorID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	params := repository.UpdateLeadParams{}
	var current repository.Lead
	loadedCurrent := false

	if req.AssigneeID.Set {
		lead, err := s.repo.GetByID(ctx, id)
		if err != nil {
			if errors.Is(err, repository.ErrNotFound) {
				return transport.LeadResponse{}, ErrLeadNotFound
			}
			return transport.LeadResponse{}, err
		}
		current = lead
		loadedCurrent = true

		if !hasRole(actorRoles, "admin") {
			if current.AssignedAgentID == nil || *current.AssignedAgentID != actorID {
				return transport.LeadResponse{}, ErrForbidden
			}
		}

		params.AssignedAgentID = req.AssigneeID.Value
		params.AssignedAgentIDSet = true
	}

	if req.FirstName != nil {
		params.ConsumerFirstName = req.FirstName
	}
	if req.LastName != nil {
		params.ConsumerLastName = req.LastName
	}
	if req.Phone != nil {
		normalized := phone.NormalizeE164(*req.Phone)
		params.ConsumerPhone = &normalized
	}
	if req.Email != nil {
		params.ConsumerEmail = req.Email
	}
	if req.ConsumerRole != nil {
		role := string(*req.ConsumerRole)
		params.ConsumerRole = &role
	}
	if req.Street != nil {
		params.AddressStreet = req.Street
	}
	if req.HouseNumber != nil {
		params.AddressHouseNumber = req.HouseNumber
	}
	if req.ZipCode != nil {
		params.AddressZipCode = req.ZipCode
	}
	if req.City != nil {
		params.AddressCity = req.City
	}

	lead, err := s.repo.Update(ctx, id, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	if req.AssigneeID.Set && loadedCurrent {
		if !equalUUIDPtrs(current.AssignedAgentID, req.AssigneeID.Value) {
			_ = s.repo.AddActivity(ctx, id, actorID, "assigned", map[string]interface{}{
				"from": current.AssignedAgentID,
				"to":   req.AssigneeID.Value,
			})
		}
	}

	services, _ := s.repo.ListLeadServices(ctx, lead.ID)
	return ToLeadResponseWithServices(lead, services), nil
}

// Delete soft-deletes a lead.
func (s *Service) Delete(ctx context.Context, id uuid.UUID) error {
	err := s.repo.Delete(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return ErrLeadNotFound
		}
		return err
	}
	return nil
}

// BulkDelete deletes multiple leads.
func (s *Service) BulkDelete(ctx context.Context, ids []uuid.UUID) (int, error) {
	deletedCount, err := s.repo.BulkDelete(ctx, ids)
	if err != nil {
		return 0, err
	}
	if deletedCount == 0 {
		return 0, ErrLeadNotFound
	}
	return deletedCount, nil
}

// List retrieves a paginated list of leads.
func (s *Service) List(ctx context.Context, req transport.ListLeadsRequest) (transport.LeadListResponse, error) {
	if req.Page < 1 {
		req.Page = 1
	}
	if req.PageSize < 1 {
		req.PageSize = 20
	}
	if req.PageSize > 100 {
		req.PageSize = 100
	}

	params := repository.ListParams{
		Search:    req.Search,
		Offset:    (req.Page - 1) * req.PageSize,
		Limit:     req.PageSize,
		SortBy:    req.SortBy,
		SortOrder: req.SortOrder,
	}

	if req.Status != nil {
		status := string(*req.Status)
		params.Status = &status
	}
	if req.ServiceType != nil {
		serviceType := string(*req.ServiceType)
		params.ServiceType = &serviceType
	}

	leads, total, err := s.repo.List(ctx, params)
	if err != nil {
		return transport.LeadListResponse{}, err
	}

	items := make([]transport.LeadResponse, len(leads))
	for i, lead := range leads {
		services, _ := s.repo.ListLeadServices(ctx, lead.ID)
		items[i] = ToLeadResponseWithServices(lead, services)
	}

	totalPages := (total + req.PageSize - 1) / req.PageSize

	return transport.LeadListResponse{
		Items:      items,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// CheckDuplicate checks if a lead with the given phone already exists.
func (s *Service) CheckDuplicate(ctx context.Context, phoneNumber string) (transport.DuplicateCheckResponse, error) {
	lead, err := s.repo.GetByPhone(ctx, phoneNumber)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.DuplicateCheckResponse{IsDuplicate: false}, nil
		}
		return transport.DuplicateCheckResponse{}, err
	}

	resp := ToLeadResponse(lead)
	return transport.DuplicateCheckResponse{
		IsDuplicate:  true,
		ExistingLead: &resp,
	}, nil
}

// Assign assigns or unassigns a lead to an agent.
func (s *Service) Assign(ctx context.Context, id uuid.UUID, assigneeID *uuid.UUID, actorID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	current, err := s.repo.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	if !hasRole(actorRoles, "admin") {
		if current.AssignedAgentID == nil || *current.AssignedAgentID != actorID {
			return transport.LeadResponse{}, ErrForbidden
		}
	}

	params := repository.UpdateLeadParams{
		AssignedAgentID:    assigneeID,
		AssignedAgentIDSet: true,
	}
	updated, err := s.repo.Update(ctx, id, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	_ = s.repo.AddActivity(ctx, id, actorID, "assigned", map[string]interface{}{
		"from": current.AssignedAgentID,
		"to":   assigneeID,
	})

	return ToLeadResponse(updated), nil
}

// SetViewedBy marks a lead as viewed by a user.
func (s *Service) SetViewedBy(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	return s.repo.SetViewedBy(ctx, id, userID)
}

// AddService adds a new service to an existing lead.
func (s *Service) AddService(ctx context.Context, leadID uuid.UUID, req transport.AddServiceRequest) (transport.LeadResponse, error) {
	lead, err := s.repo.GetByID(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	if req.CloseCurrentStatus {
		if err := s.repo.CloseAllActiveServices(ctx, leadID); err != nil {
			return transport.LeadResponse{}, err
		}
	}

	_, err = s.repo.CreateLeadService(ctx, repository.CreateLeadServiceParams{
		LeadID:      leadID,
		ServiceType: string(req.ServiceType),
	})
	if err != nil {
		return transport.LeadResponse{}, err
	}

	services, _ := s.repo.ListLeadServices(ctx, leadID)
	return ToLeadResponseWithServices(lead, services), nil
}

// UpdateServiceStatus updates the status of a specific service.
func (s *Service) UpdateServiceStatus(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, req transport.UpdateServiceStatusRequest) (transport.LeadResponse, error) {
	svc, err := s.repo.GetLeadServiceByID(ctx, serviceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, errors.New("lead service not found")
		}
		return transport.LeadResponse{}, err
	}
	if svc.LeadID != leadID {
		return transport.LeadResponse{}, errors.New("lead service not found")
	}

	_, err = s.repo.UpdateServiceStatus(ctx, serviceID, string(req.Status))
	if err != nil {
		return transport.LeadResponse{}, err
	}

	return s.GetByID(ctx, leadID)
}

// UpdateStatus updates the status of the lead's current service.
func (s *Service) UpdateStatus(ctx context.Context, id uuid.UUID, req transport.UpdateLeadStatusRequest) (transport.LeadResponse, error) {
	lead, err := s.repo.UpdateStatus(ctx, id, string(req.Status))
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return ToLeadResponse(lead), nil
}

func hasRole(roles []string, target string) bool {
	for _, role := range roles {
		if role == target {
			return true
		}
	}
	return false
}

func equalUUIDPtrs(a *uuid.UUID, b *uuid.UUID) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}
</file>

<file path="internal/leads/migrations/001_leads.sql">
-- Leads Domain: Core leads table
-- IMPORTANT: This migration uses SOFT REFERENCES to the auth domain.
-- The user_id fields (assigned_agent_id, viewed_by_id, visit_scout_id) are
-- stored as UUIDs WITHOUT foreign key constraints to the users table.
-- This allows the auth and leads domains to be independently deployed and
-- potentially split into separate databases in the future.

-- Lead statuses: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling, Closed
-- Consumer roles: Owner, Tenant, Landlord
-- Service types: Windows, Insulation, Solar
-- Access difficulty: Low, Medium, High

CREATE TABLE IF NOT EXISTS leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Consumer information
    consumer_first_name TEXT NOT NULL,
    consumer_last_name TEXT NOT NULL,
    consumer_phone TEXT NOT NULL,
    consumer_email TEXT,
    consumer_role TEXT NOT NULL DEFAULT 'Owner' CHECK (consumer_role IN ('Owner', 'Tenant', 'Landlord')),
    
    -- Address information
    address_street TEXT NOT NULL,
    address_house_number TEXT NOT NULL,
    address_zip_code TEXT NOT NULL,
    address_city TEXT NOT NULL,
    
    -- Lead details
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Assignment - SOFT REFERENCES to users (no FK constraint)
    assigned_agent_id UUID,        -- References users.id (soft reference)
    viewed_by_id UUID,             -- References users.id (soft reference)
    viewed_at TIMESTAMPTZ,
    
    -- Visit / Survey information
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID,           -- References users.id (soft reference)
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Soft delete
    deleted_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent ON leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_scout ON leads(visit_scout_id);
CREATE INDEX IF NOT EXISTS idx_leads_phone ON leads(consumer_phone);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON leads(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_leads_scheduled_date ON leads(visit_scheduled_date) WHERE visit_scheduled_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_leads_deleted_at ON leads(deleted_at);
</file>

<file path="internal/leads/migrations/002_lead_activity.sql">
-- Leads Domain: Activity tracking for leads
-- SOFT REFERENCES: user_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS lead_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,         -- References users.id (soft reference)
    action TEXT NOT NULL,
    meta JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_activity_lead_id ON lead_activity(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_activity_user_id ON lead_activity(user_id);
</file>

<file path="internal/leads/migrations/003_lead_notes.sql">
-- Leads Domain: Internal notes for leads
-- SOFT REFERENCES: author_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS lead_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    author_id UUID NOT NULL,       -- References users.id (soft reference)
    body TEXT NOT NULL CHECK (char_length(body) >= 1 AND char_length(body) <= 2000),
    type TEXT NOT NULL DEFAULT 'note' CHECK (type IN ('note', 'call', 'text', 'email', 'system')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_notes_lead_id ON lead_notes(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_notes_created_at ON lead_notes(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_notes_author_id ON lead_notes(author_id);
</file>

<file path="internal/leads/migrations/004_lead_services.sql">
-- Leads Domain: Multiple services per lead
-- SOFT REFERENCES: visit_scout_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS lead_services (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    
    -- Service info
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Visit / Survey information (per service)
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID,           -- References users.id (soft reference)
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_lead_services_lead_id ON lead_services(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_services_status ON lead_services(status);
CREATE INDEX IF NOT EXISTS idx_lead_services_service_type ON lead_services(service_type);
CREATE INDEX IF NOT EXISTS idx_lead_services_created_at ON lead_services(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_services_scout_id ON lead_services(visit_scout_id);
</file>

<file path="internal/leads/migrations/005_visit_history.sql">
-- Leads Domain: Visit history for audit trail
-- SOFT REFERENCES: scout_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS visit_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    scheduled_date TIMESTAMPTZ NOT NULL,
    scout_id UUID,                 -- References users.id (soft reference)
    outcome TEXT NOT NULL CHECK (outcome IN ('completed', 'no_show', 'rescheduled', 'cancelled')),
    measurements TEXT,
    access_difficulty TEXT CHECK (access_difficulty IN ('Low', 'Medium', 'High')),
    notes TEXT,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_visit_history_lead_id ON visit_history(lead_id);
CREATE INDEX IF NOT EXISTS idx_visit_history_scheduled_date ON visit_history(scheduled_date);
CREATE INDEX IF NOT EXISTS idx_visit_history_scout_id ON visit_history(scout_id);
</file>

<file path="internal/leads/notes/service.go">
// Package notes handles lead note operations.
// This is a vertically sliced feature package containing service logic
// for creating and listing notes on leads.
package notes

import (
	"context"
	"errors"
	"strings"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"

	"github.com/google/uuid"
)

// Errors specific to note operations.
var (
	ErrLeadNotFound = errors.New("lead not found")
	ErrInvalidNote  = errors.New("invalid note")
)

// ValidNoteTypes defines the allowed note types.
var ValidNoteTypes = map[string]bool{
	"note":   true,
	"call":   true,
	"text":   true,
	"email":  true,
	"system": true,
}

// Repository defines the data access interface needed by the notes service.
// This is a consumer-driven interface - only what notes needs.
type Repository interface {
	// LeadExistenceChecker
	GetByID(ctx context.Context, id uuid.UUID) (repository.Lead, error)
	// NoteStore
	repository.NoteStore
}

// Service handles lead note operations.
type Service struct {
	repo Repository
}

// New creates a new notes service.
func New(repo Repository) *Service {
	return &Service{repo: repo}
}

// Add adds a new note to a lead.
func (s *Service) Add(ctx context.Context, leadID uuid.UUID, authorID uuid.UUID, req transport.CreateLeadNoteRequest) (transport.LeadNoteResponse, error) {
	body := strings.TrimSpace(req.Body)
	if body == "" || len(body) > 2000 {
		return transport.LeadNoteResponse{}, ErrInvalidNote
	}

	noteType := strings.TrimSpace(req.Type)
	if noteType == "" {
		noteType = "note"
	}
	if !ValidNoteTypes[noteType] {
		return transport.LeadNoteResponse{}, ErrInvalidNote
	}

	// Verify lead exists
	if _, err := s.repo.GetByID(ctx, leadID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadNoteResponse{}, ErrLeadNotFound
		}
		return transport.LeadNoteResponse{}, err
	}

	note, err := s.repo.CreateLeadNote(ctx, repository.CreateLeadNoteParams{
		LeadID:   leadID,
		AuthorID: authorID,
		Type:     noteType,
		Body:     body,
	})
	if err != nil {
		return transport.LeadNoteResponse{}, err
	}

	return toLeadNoteResponse(note), nil
}

// List retrieves all notes for a lead.
func (s *Service) List(ctx context.Context, leadID uuid.UUID) (transport.LeadNotesResponse, error) {
	// Verify lead exists
	if _, err := s.repo.GetByID(ctx, leadID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadNotesResponse{}, ErrLeadNotFound
		}
		return transport.LeadNotesResponse{}, err
	}

	notesList, err := s.repo.ListLeadNotes(ctx, leadID)
	if err != nil {
		return transport.LeadNotesResponse{}, err
	}

	items := make([]transport.LeadNoteResponse, len(notesList))
	for i, note := range notesList {
		items[i] = toLeadNoteResponse(note)
	}

	return transport.LeadNotesResponse{Items: items}, nil
}

func toLeadNoteResponse(note repository.LeadNote) transport.LeadNoteResponse {
	return transport.LeadNoteResponse{
		ID:          note.ID,
		LeadID:      note.LeadID,
		AuthorID:    note.AuthorID,
		AuthorEmail: note.AuthorEmail,
		Type:        note.Type,
		Body:        note.Body,
		CreatedAt:   note.CreatedAt,
		UpdatedAt:   note.UpdatedAt,
	}
}
</file>

<file path="internal/leads/ports/agent_provider.go">
// Package ports defines the interfaces that the leads domain requires from
// external systems. These interfaces form the Anti-Corruption Layer (ACL),
// ensuring the leads domain only knows about the data it needs, formatted
// the way it wants.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// Agent represents the agent information that the leads domain needs.
// This is defined by the leads domain, not by the auth domain.
type Agent struct {
	ID    uuid.UUID
	Email string
	Name  string // Display name, can be derived from email if needed
}

// AgentProvider is the interface that the leads domain uses to get agent information.
// The implementation is provided by the composition root (main/router) and wraps
// the auth service. This ensures leads never directly imports the auth domain.
type AgentProvider interface {
	// GetAgentByID returns agent information for the given user ID.
	// Returns an error if the agent is not found.
	GetAgentByID(ctx context.Context, agentID uuid.UUID) (Agent, error)

	// GetAgentsByIDs returns agent information for multiple user IDs.
	// Missing agents are silently omitted from the result map.
	GetAgentsByIDs(ctx context.Context, agentIDs []uuid.UUID) (map[uuid.UUID]Agent, error)

	// ListAgents returns all available agents that can be assigned to leads.
	ListAgents(ctx context.Context) ([]Agent, error)
}
</file>

<file path="internal/leads/ports/users.go">
// Package ports defines consumer-driven interfaces for external dependencies.
// These interfaces are defined in the Leads domain based on what it needs,
// rather than what other domains choose to offer.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// UserInfo represents the minimal user data the leads domain needs.
type UserInfo struct {
	ID    uuid.UUID
	Email string
	Roles []string
}

// UserProvider provides user information needed by the leads domain.
// This interface is defined here (consumer-driven) rather than in the auth domain.
// The auth domain's repository or service can implement this interface.
type UserProvider interface {
	// GetUserByID returns basic user info. Returns error if user not found.
	GetUserByID(ctx context.Context, userID uuid.UUID) (UserInfo, error)
}

// UserExistenceChecker verifies if users exist without exposing full user data.
// Useful for validating assignee IDs without tight coupling to auth internals.
type UserExistenceChecker interface {
	// UserExists returns true if a user with the given ID exists.
	UserExists(ctx context.Context, userID uuid.UUID) (bool, error)
}

// UserLister provides a list of users for assignment dropdowns.
type UserLister interface {
	// ListAssignableUsers returns users that can be assigned to leads.
	// Implementation may filter by role (e.g., agents, scouts).
	ListAssignableUsers(ctx context.Context) ([]UserInfo, error)
}
</file>

<file path="internal/leads/repository/visit_history.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type VisitHistory struct {
	ID               uuid.UUID
	LeadID           uuid.UUID
	ScheduledDate    time.Time
	ScoutID          *uuid.UUID
	Outcome          string
	Measurements     *string
	AccessDifficulty *string
	Notes            *string
	CompletedAt      *time.Time
	CreatedAt        time.Time
}

type CreateVisitHistoryParams struct {
	LeadID           uuid.UUID
	ScheduledDate    time.Time
	ScoutID          *uuid.UUID
	Outcome          string
	Measurements     *string
	AccessDifficulty *string
	Notes            *string
	CompletedAt      *time.Time
}

func (r *Repository) CreateVisitHistory(ctx context.Context, params CreateVisitHistoryParams) (VisitHistory, error) {
	var vh VisitHistory
	err := r.pool.QueryRow(ctx, `
		INSERT INTO visit_history (lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
		RETURNING id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at
	`,
		params.LeadID, params.ScheduledDate, params.ScoutID, params.Outcome,
		params.Measurements, params.AccessDifficulty, params.Notes, params.CompletedAt,
	).Scan(
		&vh.ID, &vh.LeadID, &vh.ScheduledDate, &vh.ScoutID, &vh.Outcome,
		&vh.Measurements, &vh.AccessDifficulty, &vh.Notes, &vh.CompletedAt, &vh.CreatedAt,
	)
	return vh, err
}

func (r *Repository) ListVisitHistory(ctx context.Context, leadID uuid.UUID) ([]VisitHistory, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at
		FROM visit_history
		WHERE lead_id = $1
		ORDER BY scheduled_date DESC
	`, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var history []VisitHistory
	for rows.Next() {
		var vh VisitHistory
		if err := rows.Scan(
			&vh.ID, &vh.LeadID, &vh.ScheduledDate, &vh.ScoutID, &vh.Outcome,
			&vh.Measurements, &vh.AccessDifficulty, &vh.Notes, &vh.CompletedAt, &vh.CreatedAt,
		); err != nil {
			return nil, err
		}
		history = append(history, vh)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return history, nil
}

func (r *Repository) GetVisitHistoryByID(ctx context.Context, id uuid.UUID) (VisitHistory, error) {
	var vh VisitHistory
	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at, created_at
		FROM visit_history
		WHERE id = $1
	`, id).Scan(
		&vh.ID, &vh.LeadID, &vh.ScheduledDate, &vh.ScoutID, &vh.Outcome,
		&vh.Measurements, &vh.AccessDifficulty, &vh.Notes, &vh.CompletedAt, &vh.CreatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return VisitHistory{}, ErrNotFound
	}
	return vh, err
}
</file>

<file path="internal/leads/scheduling/service.go">
// Package scheduling handles visit scheduling operations for leads.
// This is a vertically sliced feature package containing service logic
// for scheduling, rescheduling, completing, and managing lead visits.
package scheduling

import (
	"context"
	"errors"
	"time"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/management"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"

	"github.com/google/uuid"
)

// Errors specific to scheduling operations.
var (
	ErrLeadNotFound      = errors.New("lead not found")
	ErrServiceNotFound   = errors.New("lead service not found")
	ErrVisitNotScheduled = errors.New("visit is not scheduled")
	ErrVisitInFuture     = errors.New("cannot complete a visit scheduled in the future")
	ErrScheduledInPast   = errors.New("cannot schedule a visit in the past")
)

// Repository defines the data access interface needed by the scheduling service.
// This is a consumer-driven interface - only what scheduling needs.
type Repository interface {
	repository.LeadReader
	repository.LeadServiceReader
	repository.VisitManager
	repository.ActivityLogger
	repository.VisitHistoryStore
}

// Service handles visit scheduling operations.
type Service struct {
	repo     Repository
	eventBus events.Bus
}

// New creates a new visit scheduling service.
func New(repo Repository, eventBus events.Bus) *Service {
	return &Service{repo: repo, eventBus: eventBus}
}

// ScheduleVisit schedules a new visit for a lead service.
func (s *Service) ScheduleVisit(ctx context.Context, leadID uuid.UUID, req transport.ScheduleVisitRequest) (transport.LeadResponse, error) {
	// Validate scheduled date is not in the past
	today := time.Now().Truncate(24 * time.Hour)
	scheduledDay := req.ScheduledDate.Truncate(24 * time.Hour)
	if scheduledDay.Before(today) {
		return transport.LeadResponse{}, ErrScheduledInPast
	}

	// Schedule visit on the service
	_, err := s.repo.ScheduleServiceVisit(ctx, req.ServiceID, req.ScheduledDate, req.ScoutID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.VisitScheduled{
		BaseEvent:          events.NewBaseEvent(),
		LeadID:             leadID,
		ServiceID:          req.ServiceID,
		ScheduledDate:      req.ScheduledDate,
		ScoutID:            req.ScoutID,
		ConsumerEmail:      lead.ConsumerEmail,
		ConsumerFirstName:  lead.ConsumerFirstName,
		ConsumerLastName:   lead.ConsumerLastName,
		AddressStreet:      lead.AddressStreet,
		AddressHouseNumber: lead.AddressHouseNumber,
		AddressZipCode:     lead.AddressZipCode,
		AddressCity:        lead.AddressCity,
		SendInvite:         req.SendInvite,
	})

	return management.ToLeadResponseWithServices(lead, services), nil
}

// RescheduleVisit reschedules an existing visit.
func (s *Service) RescheduleVisit(ctx context.Context, leadID uuid.UUID, req transport.RescheduleVisitRequest, actorID uuid.UUID) (transport.LeadResponse, error) {
	// Validate scheduled date is not in the past
	today := time.Now().Truncate(24 * time.Hour)
	scheduledDay := req.ScheduledDate.Truncate(24 * time.Hour)
	if scheduledDay.Before(today) {
		return transport.LeadResponse{}, ErrScheduledInPast
	}

	// Get current service to capture old visit data for history
	currentService, err := s.repo.GetLeadServiceByID(ctx, req.ServiceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Store the old visit in history if there was a scheduled date
	if currentService.VisitScheduledDate != nil {
		outcome := "rescheduled"
		if req.MarkAsNoShow {
			outcome = "no_show"
		}

		_, _ = s.repo.CreateVisitHistory(ctx, repository.CreateVisitHistoryParams{
			LeadID:           leadID,
			ScheduledDate:    *currentService.VisitScheduledDate,
			ScoutID:          currentService.VisitScoutID,
			Outcome:          outcome,
			Measurements:     currentService.VisitMeasurements,
			AccessDifficulty: currentService.VisitAccessDifficulty,
			Notes:            &req.NoShowNotes,
			CompletedAt:      currentService.VisitCompletedAt,
		})
	}

	// Perform the reschedule on the service
	_, err = s.repo.RescheduleServiceVisit(ctx, req.ServiceID, req.ScheduledDate, req.ScoutID, req.NoShowNotes, req.MarkAsNoShow)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Log the no-show to activity only if marked as no-show
	if req.MarkAsNoShow {
		_ = s.repo.AddActivity(ctx, leadID, actorID, "no_show", map[string]interface{}{
			"serviceId":             req.ServiceID,
			"previousScheduledDate": currentService.VisitScheduledDate,
			"notes":                 req.NoShowNotes,
		})
	}

	// Log the reschedule to activity
	_ = s.repo.AddActivity(ctx, leadID, actorID, "rescheduled", map[string]interface{}{
		"serviceId":             req.ServiceID,
		"previousScheduledDate": currentService.VisitScheduledDate,
		"newScheduledDate":      req.ScheduledDate,
		"scoutId":               req.ScoutID,
	})

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.VisitRescheduled{
		BaseEvent:          events.NewBaseEvent(),
		LeadID:             leadID,
		ServiceID:          req.ServiceID,
		PreviousDate:       currentService.VisitScheduledDate,
		NewScheduledDate:   req.ScheduledDate,
		ScoutID:            req.ScoutID,
		MarkedAsNoShow:     req.MarkAsNoShow,
		ConsumerEmail:      lead.ConsumerEmail,
		ConsumerFirstName:  lead.ConsumerFirstName,
		ConsumerLastName:   lead.ConsumerLastName,
		AddressStreet:      lead.AddressStreet,
		AddressHouseNumber: lead.AddressHouseNumber,
		AddressZipCode:     lead.AddressZipCode,
		AddressCity:        lead.AddressCity,
		SendInvite:         req.SendInvite,
	})

	return management.ToLeadResponseWithServices(lead, services), nil
}

// CompleteSurvey marks a visit as completed with survey data.
func (s *Service) CompleteSurvey(ctx context.Context, leadID uuid.UUID, req transport.CompleteSurveyRequest) (transport.LeadResponse, error) {
	// Get current service to check scheduled date
	currentService, err := s.repo.GetLeadServiceByID(ctx, req.ServiceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Check if visit is scheduled
	if currentService.VisitScheduledDate == nil {
		return transport.LeadResponse{}, ErrVisitNotScheduled
	}

	// Check if scheduled date is in the future
	if currentService.VisitScheduledDate.After(time.Now()) {
		return transport.LeadResponse{}, ErrVisitInFuture
	}

	// Complete survey on the service
	_, err = s.repo.CompleteServiceSurvey(ctx, req.ServiceID, req.Measurements, string(req.AccessDifficulty), req.Notes)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return management.ToLeadResponseWithServices(lead, services), nil
}

// MarkNoShow marks a visit as a no-show.
func (s *Service) MarkNoShow(ctx context.Context, leadID uuid.UUID, req transport.MarkNoShowRequest) (transport.LeadResponse, error) {
	// Mark no-show on the service
	_, err := s.repo.MarkServiceNoShow(ctx, req.ServiceID, req.Notes)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return management.ToLeadResponseWithServices(lead, services), nil
}

// ListVisitHistory returns the visit history for a lead.
func (s *Service) ListVisitHistory(ctx context.Context, leadID uuid.UUID) (transport.VisitHistoryListResponse, error) {
	// Verify lead exists
	if _, err := s.repo.GetByID(ctx, leadID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.VisitHistoryListResponse{}, ErrLeadNotFound
		}
		return transport.VisitHistoryListResponse{}, err
	}

	history, err := s.repo.ListVisitHistory(ctx, leadID)
	if err != nil {
		return transport.VisitHistoryListResponse{}, err
	}

	items := make([]transport.VisitHistoryResponse, len(history))
	for i, h := range history {
		items[i] = toVisitHistoryResponse(h)
	}

	return transport.VisitHistoryListResponse{Items: items}, nil
}

// toVisitHistoryResponse converts a repository visit history to a transport response.
func toVisitHistoryResponse(vh repository.VisitHistory) transport.VisitHistoryResponse {
	resp := transport.VisitHistoryResponse{
		ID:            vh.ID,
		LeadID:        vh.LeadID,
		ScheduledDate: vh.ScheduledDate,
		ScoutID:       vh.ScoutID,
		Outcome:       transport.VisitOutcome(vh.Outcome),
		Measurements:  vh.Measurements,
		Notes:         vh.Notes,
		CompletedAt:   vh.CompletedAt,
		CreatedAt:     vh.CreatedAt,
	}

	if vh.AccessDifficulty != nil {
		difficulty := transport.AccessDifficulty(*vh.AccessDifficulty)
		resp.AccessDifficulty = &difficulty
	}

	return resp
}
</file>

<file path="internal/leads/service/visit_history.go">
package service

import (
	"context"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"

	"github.com/google/uuid"
)

func (s *Service) ListVisitHistory(ctx context.Context, leadID uuid.UUID) (transport.VisitHistoryListResponse, error) {
	// Verify lead exists
	_, err := s.repo.GetByID(ctx, leadID)
	if err != nil {
		return transport.VisitHistoryListResponse{}, ErrLeadNotFound
	}

	history, err := s.repo.ListVisitHistory(ctx, leadID)
	if err != nil {
		return transport.VisitHistoryListResponse{}, err
	}

	items := make([]transport.VisitHistoryResponse, len(history))
	for i, vh := range history {
		items[i] = toVisitHistoryResponse(vh)
	}

	return transport.VisitHistoryListResponse{Items: items}, nil
}

func (s *Service) CreateVisitHistoryEntry(ctx context.Context, params repository.CreateVisitHistoryParams) (transport.VisitHistoryResponse, error) {
	vh, err := s.repo.CreateVisitHistory(ctx, params)
	if err != nil {
		return transport.VisitHistoryResponse{}, err
	}
	return toVisitHistoryResponse(vh), nil
}

func toVisitHistoryResponse(vh repository.VisitHistory) transport.VisitHistoryResponse {
	resp := transport.VisitHistoryResponse{
		ID:            vh.ID,
		LeadID:        vh.LeadID,
		ScheduledDate: vh.ScheduledDate,
		ScoutID:       vh.ScoutID,
		Outcome:       transport.VisitOutcome(vh.Outcome),
		Measurements:  vh.Measurements,
		Notes:         vh.Notes,
		CompletedAt:   vh.CompletedAt,
		CreatedAt:     vh.CreatedAt,
	}

	if vh.AccessDifficulty != nil {
		difficulty := transport.AccessDifficulty(*vh.AccessDifficulty)
		resp.AccessDifficulty = &difficulty
	}

	return resp
}
</file>

<file path="internal/leads/sql/queries.sql">
-- Leads Domain SQL Queries

-- name: CreateLead :one
INSERT INTO leads (
    consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
    address_street, address_house_number, address_zip_code, address_city,
    service_type, status, assigned_agent_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'New', $11)
RETURNING *;

-- name: GetLeadByID :one
SELECT * FROM leads WHERE id = $1 AND deleted_at IS NULL;

-- name: GetLeadByPhone :one
SELECT * FROM leads 
WHERE consumer_phone = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1;

-- name: UpdateLeadStatus :one
UPDATE leads SET status = $2, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING *;

-- name: SetLeadViewedBy :exec
UPDATE leads SET viewed_by_id = $2, viewed_at = now(), updated_at = now()
WHERE id = $1 AND deleted_at IS NULL;

-- name: ScheduleLeadVisit :one
UPDATE leads SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING *;

-- name: CompleteLeadSurvey :one
UPDATE leads SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING *;

-- name: SoftDeleteLead :exec
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = $1 AND deleted_at IS NULL;

-- name: BulkSoftDeleteLeads :execresult
UPDATE leads SET deleted_at = now(), updated_at = now() 
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL;

-- name: CountLeads :one
SELECT COUNT(*) FROM leads WHERE deleted_at IS NULL;

-- Lead Activity Queries

-- name: CreateLeadActivity :exec
INSERT INTO lead_activity (lead_id, user_id, action, meta)
VALUES ($1, $2, $3, $4);

-- name: ListLeadActivities :many
SELECT * FROM lead_activity
WHERE lead_id = $1
ORDER BY created_at DESC;

-- Lead Notes Queries

-- name: CreateLeadNote :one
INSERT INTO lead_notes (lead_id, author_id, body, type)
VALUES ($1, $2, $3, $4)
RETURNING *;

-- name: GetLeadNote :one
SELECT * FROM lead_notes WHERE id = $1;

-- name: UpdateLeadNote :one
UPDATE lead_notes SET body = $2, updated_at = now()
WHERE id = $1
RETURNING *;

-- name: DeleteLeadNote :exec
DELETE FROM lead_notes WHERE id = $1;

-- name: ListLeadNotes :many
SELECT * FROM lead_notes
WHERE lead_id = $1
ORDER BY created_at DESC;

-- Lead Services Queries

-- name: CreateLeadService :one
INSERT INTO lead_services (lead_id, service_type, status)
VALUES ($1, $2, 'New')
RETURNING *;

-- name: GetLeadService :one
SELECT * FROM lead_services WHERE id = $1;

-- name: UpdateLeadServiceStatus :one
UPDATE lead_services SET status = $2, updated_at = now()
WHERE id = $1
RETURNING *;

-- name: ListLeadServices :many
SELECT * FROM lead_services
WHERE lead_id = $1
ORDER BY created_at;

-- name: ScheduleLeadServiceVisit :one
UPDATE lead_services SET 
    visit_scheduled_date = $2, 
    visit_scout_id = $3,
    status = 'Scheduled',
    updated_at = now()
WHERE id = $1
RETURNING *;

-- name: CompleteLeadServiceSurvey :one
UPDATE lead_services SET 
    visit_measurements = $2,
    visit_access_difficulty = $3,
    visit_notes = $4,
    visit_completed_at = now(),
    status = 'Surveyed',
    updated_at = now()
WHERE id = $1
RETURNING *;

-- Visit History Queries

-- name: CreateVisitHistory :one
INSERT INTO visit_history (lead_id, scheduled_date, scout_id, outcome, measurements, access_difficulty, notes, completed_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING *;

-- name: ListVisitHistory :many
SELECT * FROM visit_history
WHERE lead_id = $1
ORDER BY scheduled_date DESC;
</file>

<file path="internal/leads/transport/optional.go">
package transport

import (
	"encoding/json"

	"github.com/google/uuid"
)

type OptionalUUID struct {
	Value *uuid.UUID
	Set   bool
}

func (o OptionalUUID) IsZero() bool {
	return !o.Set
}

func (o *OptionalUUID) UnmarshalJSON(data []byte) error {
	o.Set = true
	if string(data) == "null" {
		o.Value = nil
		return nil
	}

	var raw string
	if err := json.Unmarshal(data, &raw); err == nil {
		if raw == "" {
			o.Value = nil
			return nil
		}

		parsed, err := uuid.Parse(raw)
		if err != nil {
			return err
		}

		o.Value = &parsed
		return nil
	}

	var parsed uuid.UUID
	if err := json.Unmarshal(data, &parsed); err != nil {
		return err
	}

	o.Value = &parsed
	return nil
}
</file>

<file path="internal/logger/logger.go">
package logger

import (
	"context"
	"log/slog"
	"os"
	"strings"
)

// Logger wraps slog.Logger for structured logging
type Logger struct {
	*slog.Logger
}

// New creates a new logger based on environment
func New(env string) *Logger {
	var handler slog.Handler

	opts := &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}

	if strings.EqualFold(env, "development") {
		opts.Level = slog.LevelDebug
		handler = slog.NewTextHandler(os.Stdout, opts)
	} else {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	}

	return &Logger{
		Logger: slog.New(handler),
	}
}

// WithContext returns a logger with context values
func (l *Logger) WithContext(ctx context.Context) *Logger {
	return l
}

// WithRequestID returns a logger with request ID
func (l *Logger) WithRequestID(requestID string) *Logger {
	return &Logger{
		Logger: l.Logger.With(slog.String("request_id", requestID)),
	}
}

// WithUserID returns a logger with user ID
func (l *Logger) WithUserID(userID string) *Logger {
	return &Logger{
		Logger: l.Logger.With(slog.String("user_id", userID)),
	}
}

// HTTPRequest logs an HTTP request
func (l *Logger) HTTPRequest(method, path string, status int, latencyMs float64, clientIP string) {
	l.Info("http_request",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.Float64("latency_ms", latencyMs),
		slog.String("client_ip", clientIP),
	)
}

// HTTPError logs an HTTP error
func (l *Logger) HTTPError(method, path string, status int, err error, clientIP string) {
	l.Error("http_error",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.String("error", err.Error()),
		slog.String("client_ip", clientIP),
	)
}

// AuthEvent logs authentication events
func (l *Logger) AuthEvent(event, email string, success bool, reason string) {
	if success {
		l.Info("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
		)
	} else {
		l.Warn("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
			slog.String("reason", reason),
		)
	}
}

// DatabaseError logs database errors
func (l *Logger) DatabaseError(operation string, err error) {
	l.Error("database_error",
		slog.String("operation", operation),
		slog.String("error", err.Error()),
	)
}

// RateLimitExceeded logs rate limit events
func (l *Logger) RateLimitExceeded(clientIP, path string) {
	l.Warn("rate_limit_exceeded",
		slog.String("client_ip", clientIP),
		slog.String("path", path),
	)
}
</file>

<file path="internal/phone/normalize.go">
package phone

import (
	"strings"

	"github.com/nyaruka/phonenumbers"
)

const defaultRegion = "NL"

// NormalizeE164 formats a phone number to E.164. If parsing fails, it returns the trimmed input.
func NormalizeE164(input string) string {
	trimmed := strings.TrimSpace(input)
	if trimmed == "" {
		return trimmed
	}

	number, err := phonenumbers.Parse(trimmed, defaultRegion)
	if err != nil {
		return trimmed
	}

	if !phonenumbers.IsValidNumber(number) {
		return trimmed
	}

	return phonenumbers.Format(number, phonenumbers.E164)
}
</file>

<file path="internal/shared/validator/validator.go">
// Package validator provides a shared validation instance for use across all
// bounded contexts. Domain-specific validation rules should be registered in
// their respective domains.
package validator

import "github.com/go-playground/validator/v10"

// Validate is the shared validator instance used across all modules.
// Domain-specific validation rules can be registered in their respective
// domain packages using RegisterValidation.
var Validate = validator.New()
</file>

<file path="migrations/001_init.sql">
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  is_email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  revoked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON refresh_tokens(expires_at);

CREATE TABLE IF NOT EXISTS user_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  type TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_user_tokens_user_id ON user_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tokens_type ON user_tokens(type);
CREATE INDEX IF NOT EXISTS idx_user_tokens_expires ON user_tokens(expires_at);
</file>

<file path="migrations/002_roles.sql">
CREATE TABLE IF NOT EXISTS roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, role_id)
);

INSERT INTO roles (name)
VALUES ('admin'), ('user')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="migrations/003_leads.sql">
-- Lead statuses: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling
-- Consumer roles: Owner, Tenant, Landlord
-- Service types: Windows, Insulation, Solar
-- Access difficulty: Low, Medium, High

CREATE TABLE IF NOT EXISTS leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Consumer information
    consumer_first_name TEXT NOT NULL,
    consumer_last_name TEXT NOT NULL,
    consumer_phone TEXT NOT NULL,
    consumer_email TEXT,
    consumer_role TEXT NOT NULL DEFAULT 'Owner' CHECK (consumer_role IN ('Owner', 'Tenant', 'Landlord')),
    
    -- Address information
    address_street TEXT NOT NULL,
    address_house_number TEXT NOT NULL,
    address_zip_code TEXT NOT NULL,
    address_city TEXT NOT NULL,
    
    -- Lead details
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling')),
    
    -- Assignment
    assigned_agent_id UUID REFERENCES users(id) ON DELETE SET NULL,
    viewed_by_id UUID REFERENCES users(id) ON DELETE SET NULL,
    viewed_at TIMESTAMPTZ,
    
    -- Visit / Survey information
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID REFERENCES users(id) ON DELETE SET NULL,
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent ON leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_scout ON leads(visit_scout_id);
CREATE INDEX IF NOT EXISTS idx_leads_phone ON leads(consumer_phone);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON leads(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_leads_scheduled_date ON leads(visit_scheduled_date) WHERE visit_scheduled_date IS NOT NULL;

-- Add agent and scout roles
INSERT INTO roles (name)
VALUES ('agent'), ('scout')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="migrations/004_lead_activity.sql">
-- Track actions performed on leads for auditing purposes

CREATE TABLE IF NOT EXISTS lead_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    action TEXT NOT NULL,
    meta JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_activity_lead_id ON lead_activity(lead_id);
</file>

<file path="migrations/005_leads_soft_delete.sql">
ALTER TABLE leads
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_leads_deleted_at ON leads(deleted_at);
</file>

<file path="migrations/006_lead_notes.sql">
-- Lead notes for internal comments

CREATE TABLE IF NOT EXISTS lead_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    body TEXT NOT NULL CHECK (char_length(body) >= 1 AND char_length(body) <= 2000),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_notes_lead_id ON lead_notes(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_notes_created_at ON lead_notes(created_at DESC);
</file>

<file path="migrations/007_lead_services.sql">
-- Lead services table: allows multiple services per lead with per-service status and visit info

CREATE TABLE IF NOT EXISTS lead_services (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    
    -- Service info
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Visit / Survey information (per service)
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID REFERENCES users(id) ON DELETE SET NULL,
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_lead_services_lead_id ON lead_services(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_services_status ON lead_services(status);
CREATE INDEX IF NOT EXISTS idx_lead_services_service_type ON lead_services(service_type);
CREATE INDEX IF NOT EXISTS idx_lead_services_created_at ON lead_services(created_at DESC);

-- Migrate existing leads into lead_services
INSERT INTO lead_services (
    lead_id,
    service_type,
    status,
    visit_scheduled_date,
    visit_scout_id,
    visit_measurements,
    visit_access_difficulty,
    visit_notes,
    visit_completed_at,
    created_at,
    updated_at
)
SELECT 
    id,
    service_type,
    status,
    visit_scheduled_date,
    visit_scout_id,
    visit_measurements,
    visit_access_difficulty,
    visit_notes,
    visit_completed_at,
    created_at,
    updated_at
FROM leads
WHERE deleted_at IS NULL;

-- Add 'Closed' to leads status constraint (for backward compatibility during transition)
ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_status_check;
ALTER TABLE leads ADD CONSTRAINT leads_status_check CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed'));
</file>

<file path="migrations/007_visit_history.sql">
-- Track visit history for audit trail
-- Each row represents a scheduled visit attempt

CREATE TABLE IF NOT EXISTS visit_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
    scheduled_date TIMESTAMPTZ NOT NULL,
    scout_id UUID REFERENCES users(id) ON DELETE SET NULL,
    outcome TEXT NOT NULL CHECK (outcome IN ('completed', 'no_show', 'rescheduled', 'cancelled')),
    measurements TEXT,
    access_difficulty TEXT CHECK (access_difficulty IN ('Low', 'Medium', 'High')),
    notes TEXT,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_visit_history_lead_id ON visit_history(lead_id);
CREATE INDEX IF NOT EXISTS idx_visit_history_scheduled_date ON visit_history(scheduled_date);
</file>

<file path="migrations/008_lead_notes_type.sql">
-- Add note type to lead notes

ALTER TABLE lead_notes
  ADD COLUMN IF NOT EXISTS type TEXT NOT NULL DEFAULT 'note';

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'lead_notes_type_check'
  ) THEN
    ALTER TABLE lead_notes
      ADD CONSTRAINT lead_notes_type_check
      CHECK (type IN ('note', 'call', 'text', 'email', 'system'));
  END IF;
END $$;
</file>

<file path="platform/config/config.go">
// Package config provides application configuration loading.
// This is part of the platform layer and contains no business logic.
package config

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/joho/godotenv"
)

// Config holds all application configuration values.
type Config struct {
	Env                   string
	HTTPAddr              string
	DatabaseURL           string
	JWTAccessSecret       string
	JWTRefreshSecret      string
	AccessTokenTTL        time.Duration
	RefreshTokenTTL       time.Duration
	VerifyTokenTTL        time.Duration
	ResetTokenTTL         time.Duration
	CORSAllowAll          bool
	CORSOrigins           []string
	CORSAllowCreds        bool
	AppBaseURL            string
	EmailEnabled          bool
	BrevoAPIKey           string
	EmailFromName         string
	EmailFromAddress      string
	RefreshCookieName     string
	RefreshCookieDomain   string
	RefreshCookiePath     string
	RefreshCookieSecure   bool
	RefreshCookieSameSite http.SameSite
}

// Load reads configuration from environment variables.
func Load() (*Config, error) {
	_ = godotenv.Load()

	corsOrigins := splitCSV(getEnv("CORS_ORIGINS", "http://localhost:4200"))
	corsAllowAll := strings.EqualFold(getEnv("CORS_ALLOW_ALL", "false"), "true")
	if containsWildcard(corsOrigins) {
		corsAllowAll = true
	}

	brevoAPIKey := getEnv("BREVO_API_KEY", "")
	emailEnabled := strings.EqualFold(getEnv("EMAIL_ENABLED", "true"), "true")

	refreshCookieSecure := strings.EqualFold(getEnv("REFRESH_COOKIE_SECURE", ""), "true")
	if getEnv("REFRESH_COOKIE_SECURE", "") == "" {
		refreshCookieSecure = strings.EqualFold(getEnv("APP_ENV", "development"), "production")
	}

	cfg := &Config{
		Env:                   getEnv("APP_ENV", "development"),
		HTTPAddr:              getEnv("HTTP_ADDR", ":8080"),
		DatabaseURL:           getEnv("DATABASE_URL", ""),
		JWTAccessSecret:       getEnv("JWT_ACCESS_SECRET", ""),
		JWTRefreshSecret:      getEnv("JWT_REFRESH_SECRET", ""),
		AccessTokenTTL:        mustDuration(getEnv("JWT_ACCESS_TTL", "15m")),
		RefreshTokenTTL:       mustDuration(getEnv("JWT_REFRESH_TTL", "720h")),
		VerifyTokenTTL:        mustDuration(getEnv("VERIFY_TOKEN_TTL", "30m")),
		ResetTokenTTL:         mustDuration(getEnv("RESET_TOKEN_TTL", "30m")),
		CORSAllowAll:          corsAllowAll,
		CORSOrigins:           corsOrigins,
		CORSAllowCreds:        strings.EqualFold(getEnv("CORS_ALLOW_CREDENTIALS", "true"), "true"),
		AppBaseURL:            getEnv("APP_BASE_URL", "http://localhost:4200"),
		EmailEnabled:          emailEnabled && brevoAPIKey != "",
		BrevoAPIKey:           brevoAPIKey,
		EmailFromName:         getEnv("EMAIL_FROM_NAME", "Portal"),
		EmailFromAddress:      getEnv("EMAIL_FROM_ADDRESS", ""),
		RefreshCookieName:     getEnv("REFRESH_COOKIE_NAME", "portal_refresh"),
		RefreshCookieDomain:   getEnv("REFRESH_COOKIE_DOMAIN", ""),
		RefreshCookiePath:     getEnv("REFRESH_COOKIE_PATH", "/api/v1/auth"),
		RefreshCookieSecure:   refreshCookieSecure,
		RefreshCookieSameSite: parseSameSite(getEnv("REFRESH_COOKIE_SAMESITE", "Lax")),
	}

	if cfg.DatabaseURL == "" {
		return nil, fmt.Errorf("DATABASE_URL is required")
	}
	if cfg.JWTAccessSecret == "" || cfg.JWTRefreshSecret == "" {
		return nil, fmt.Errorf("JWT_ACCESS_SECRET and JWT_REFRESH_SECRET are required")
	}
	if emailEnabled && cfg.BrevoAPIKey == "" {
		return nil, fmt.Errorf("BREVO_API_KEY is required when EMAIL_ENABLED is true")
	}
	if cfg.EmailEnabled && cfg.EmailFromAddress == "" {
		return nil, fmt.Errorf("EMAIL_FROM_ADDRESS is required when email is enabled")
	}
	if cfg.CORSAllowAll && cfg.CORSAllowCreds {
		return nil, fmt.Errorf("CORS_ALLOW_CREDENTIALS cannot be true when CORS_ALLOW_ALL is true")
	}

	return cfg, nil
}

func getEnv(key, fallback string) string {
	if val, ok := os.LookupEnv(key); ok {
		return val
	}
	return fallback
}

func mustDuration(value string) time.Duration {
	d, err := time.ParseDuration(value)
	if err != nil {
		return 0
	}
	return d
}

func splitCSV(value string) []string {
	parts := strings.Split(value, ",")
	results := make([]string, 0, len(parts))
	for _, part := range parts {
		trimmed := strings.TrimSpace(part)
		if trimmed != "" {
			results = append(results, trimmed)
		}
	}
	return results
}

func containsWildcard(values []string) bool {
	for _, value := range values {
		if value == "*" {
			return true
		}
	}
	return false
}

func parseSameSite(value string) http.SameSite {
	switch strings.ToLower(strings.TrimSpace(value)) {
	case "none":
		return http.SameSiteNoneMode
	case "strict":
		return http.SameSiteStrictMode
	default:
		return http.SameSiteLaxMode
	}
}
</file>

<file path="platform/db/db.go">
// Package db provides database connection infrastructure.
// This is part of the platform layer and contains no business logic.
package db

import (
	"context"
	"time"

	"portal_final_backend/platform/config"

	"github.com/jackc/pgx/v5/pgxpool"
)

// NewPool creates a new database connection pool with production-ready settings.
func NewPool(ctx context.Context, cfg *config.Config) (*pgxpool.Pool, error) {
	poolConfig, err := pgxpool.ParseConfig(cfg.DatabaseURL)
	if err != nil {
		return nil, err
	}

	// Production-ready pool configuration
	poolConfig.MaxConns = 25                       // Maximum number of connections
	poolConfig.MinConns = 5                        // Minimum number of idle connections
	poolConfig.MaxConnLifetime = 1 * time.Hour     // Maximum connection lifetime
	poolConfig.MaxConnIdleTime = 30 * time.Minute  // Maximum idle time before closing
	poolConfig.HealthCheckPeriod = 1 * time.Minute // Health check interval

	pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(ctx); err != nil {
		pool.Close()
		return nil, err
	}

	return pool, nil
}
</file>

<file path="platform/events/bus.go">
// Package events provides event bus infrastructure for decoupled,
// event-driven communication between modules.
// This is part of the platform layer and contains no business logic.
package events

import (
	"context"
	"sync"

	"portal_final_backend/platform/logger"
)

// InMemoryBus is an in-memory implementation of the event Bus interface.
// It executes handlers asynchronously by default for non-blocking event publishing.
type InMemoryBus struct {
	mu       sync.RWMutex
	handlers map[string][]Handler
	log      *logger.Logger
}

// NewInMemoryBus creates a new in-memory event bus.
func NewInMemoryBus(log *logger.Logger) *InMemoryBus {
	return &InMemoryBus{
		handlers: make(map[string][]Handler),
		log:      log,
	}
}

// Publish sends an event to all registered handlers asynchronously.
// Errors are logged but do not propagate back to the publisher.
func (b *InMemoryBus) Publish(ctx context.Context, event Event) {
	b.mu.RLock()
	handlers := b.handlers[event.EventName()]
	b.mu.RUnlock()

	if len(handlers) == 0 {
		return
	}

	// Execute all handlers asynchronously
	for _, h := range handlers {
		go func(handler Handler) {
			if err := handler.Handle(ctx, event); err != nil {
				b.log.Error("event handler failed",
					"event", event.EventName(),
					"error", err,
				)
			}
		}(h)
	}
}

// PublishSync sends an event and waits for all handlers to complete.
// Returns the first error encountered, but all handlers are still executed.
func (b *InMemoryBus) PublishSync(ctx context.Context, event Event) error {
	b.mu.RLock()
	handlers := b.handlers[event.EventName()]
	b.mu.RUnlock()

	if len(handlers) == 0 {
		return nil
	}

	var wg sync.WaitGroup
	errChan := make(chan error, len(handlers))

	for _, h := range handlers {
		wg.Add(1)
		go func(handler Handler) {
			defer wg.Done()
			if err := handler.Handle(ctx, event); err != nil {
				errChan <- err
				b.log.Error("event handler failed",
					"event", event.EventName(),
					"error", err,
				)
			}
		}(h)
	}

	wg.Wait()
	close(errChan)

	// Return first error if any
	for err := range errChan {
		return err
	}

	return nil
}

// Subscribe registers a handler for a specific event type.
func (b *InMemoryBus) Subscribe(eventName string, handler Handler) {
	b.mu.Lock()
	defer b.mu.Unlock()

	b.handlers[eventName] = append(b.handlers[eventName], handler)
	b.log.Debug("event handler subscribed", "event", eventName)
}

// SubscribeFunc is a convenience method to subscribe a function as a handler.
func (b *InMemoryBus) SubscribeFunc(eventName string, fn func(ctx context.Context, event Event) error) {
	b.Subscribe(eventName, HandlerFunc(fn))
}

// Ensure InMemoryBus implements Bus
var _ Bus = (*InMemoryBus)(nil)
</file>

<file path="platform/events/event.go">
// Package events provides event bus infrastructure for decoupled,
// event-driven communication between modules.
// This is part of the platform layer and contains no business logic.
package events

import (
	"context"
	"time"
)

// Event is the base interface all domain events must implement.
type Event interface {
	// EventName returns a unique identifier for the event type.
	EventName() string
	// OccurredAt returns when the event occurred.
	OccurredAt() time.Time
}

// BaseEvent provides common fields for all events.
type BaseEvent struct {
	Timestamp time.Time `json:"timestamp"`
}

// OccurredAt returns when the event occurred.
func (e BaseEvent) OccurredAt() time.Time {
	return e.Timestamp
}

// NewBaseEvent creates a new base event with the current timestamp.
func NewBaseEvent() BaseEvent {
	return BaseEvent{Timestamp: time.Now()}
}

// Handler processes events of a specific type.
type Handler interface {
	Handle(ctx context.Context, event Event) error
}

// HandlerFunc is an adapter to allow ordinary functions to be used as handlers.
type HandlerFunc func(ctx context.Context, event Event) error

// Handle calls the underlying function.
func (f HandlerFunc) Handle(ctx context.Context, event Event) error {
	return f(ctx, event)
}

// Bus is the interface for publishing and subscribing to domain events.
type Bus interface {
	// Publish sends an event to all registered handlers for that event type.
	// Handlers are executed asynchronously by default.
	Publish(ctx context.Context, event Event)

	// PublishSync sends an event and waits for all handlers to complete.
	PublishSync(ctx context.Context, event Event) error

	// Subscribe registers a handler for a specific event type.
	// The eventName should match the value returned by Event.EventName().
	Subscribe(eventName string, handler Handler)
}
</file>

<file path="platform/httpkit/middleware.go">
// Package httpkit provides HTTP middleware infrastructure.
// This is part of the platform layer and contains no business logic.
package httpkit

import (
	"errors"
	"net/http"
	"strings"
	"sync"
	"time"

	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/time/rate"
)

const (
	// ContextUserIDKey is the gin context key for the authenticated user ID.
	ContextUserIDKey = "userID"
	// ContextRolesKey is the gin context key for the user's roles.
	ContextRolesKey = "roles"

	errMissingToken = "missing token"
	errInvalidToken = "invalid token"
)

// RequestLogger logs HTTP requests with timing.
func RequestLogger(log *logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		clientIP := c.ClientIP()

		log.HTTPRequest(c.Request.Method, path, status, float64(latency.Milliseconds()), clientIP)
	}
}

// SecurityHeaders adds security headers to responses.
func SecurityHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		c.Header("Content-Security-Policy", "default-src 'self'")
		c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()")

		// Only add HSTS in production
		if c.Request.TLS != nil {
			c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}

		c.Next()
	}
}

// IPRateLimiter manages per-IP rate limiters.
type IPRateLimiter struct {
	limiters sync.Map
	rate     rate.Limit
	burst    int
	log      *logger.Logger
}

// NewIPRateLimiter creates a new IP-based rate limiter.
func NewIPRateLimiter(r rate.Limit, burst int, log *logger.Logger) *IPRateLimiter {
	return &IPRateLimiter{
		rate:  r,
		burst: burst,
		log:   log,
	}
}

func (i *IPRateLimiter) getLimiter(ip string) *rate.Limiter {
	limiter, exists := i.limiters.Load(ip)
	if !exists {
		newLimiter := rate.NewLimiter(i.rate, i.burst)
		i.limiters.Store(ip, newLimiter)
		return newLimiter
	}
	return limiter.(*rate.Limiter)
}

// RateLimit returns a middleware that rate limits by IP.
func (i *IPRateLimiter) RateLimit() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()
		limiter := i.getLimiter(ip)

		if !limiter.Allow() {
			if i.log != nil {
				i.log.RateLimitExceeded(ip, c.Request.URL.Path)
			}
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"error": "rate limit exceeded",
			})
			return
		}

		c.Next()
	}
}

// AuthRateLimiter is a stricter rate limiter for auth endpoints.
type AuthRateLimiter struct {
	*IPRateLimiter
}

// NewAuthRateLimiter creates a rate limiter for authentication endpoints
// with stricter limits (e.g., 5 requests per minute).
func NewAuthRateLimiter(log *logger.Logger) *AuthRateLimiter {
	return &AuthRateLimiter{
		IPRateLimiter: NewIPRateLimiter(rate.Limit(5.0/60.0), 5, log), // 5 requests per minute, burst of 5
	}
}

// AuthRequired returns middleware that validates JWT access tokens.
func AuthRequired(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		rawToken, ok := extractBearerToken(c.GetHeader("Authorization"))
		if !ok {
			abortUnauthorized(c, errMissingToken)
			return
		}

		claims, err := parseAccessClaims(rawToken, cfg)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		userID, err := parseUserID(claims)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		roles := extractRoles(claims["roles"])
		c.Set(ContextUserIDKey, userID)
		c.Set(ContextRolesKey, roles)
		c.Next()
	}
}

// RequireRole returns middleware that checks if the user has the specified role.
func RequireRole(role string) gin.HandlerFunc {
	return func(c *gin.Context) {
		roles, ok := c.Get(ContextRolesKey)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		roleList, ok := roles.([]string)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		for _, item := range roleList {
			if item == role {
				c.Next()
				return
			}
		}

		c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
	}
}

func extractRoles(value interface{}) []string {
	roles := make([]string, 0)
	if value == nil {
		return roles
	}

	switch typed := value.(type) {
	case []string:
		return append(roles, typed...)
	case []interface{}:
		for _, item := range typed {
			if text, ok := item.(string); ok {
				roles = append(roles, text)
			}
		}
	}

	return roles
}

func extractBearerToken(authHeader string) (string, bool) {
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return "", false
	}

	rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
	if rawToken == "" {
		return "", false
	}

	return rawToken, true
}

func parseAccessClaims(rawToken string, cfg *config.Config) (jwt.MapClaims, error) {
	parsed, err := jwt.Parse(rawToken, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("invalid signing method")
		}
		return []byte(cfg.JWTAccessSecret), nil
	})
	if err != nil || !parsed.Valid {
		return nil, errors.New(errInvalidToken)
	}

	claims, ok := parsed.Claims.(jwt.MapClaims)
	if !ok {
		return nil, errors.New(errInvalidToken)
	}

	if tokenType, _ := claims["type"].(string); tokenType != "access" {
		return nil, errors.New(errInvalidToken)
	}

	return claims, nil
}

func parseUserID(claims jwt.MapClaims) (uuid.UUID, error) {
	userIDRaw, _ := claims["sub"].(string)
	return uuid.Parse(userIDRaw)
}

func abortUnauthorized(c *gin.Context, message string) {
	c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": message})
}
</file>

<file path="platform/httpkit/response.go">
// Package httpkit provides HTTP response utilities.
// This is part of the platform layer and contains no business logic.
package httpkit

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// ErrorResponse is the standard error response format.
type ErrorResponse struct {
	Error   string      `json:"error"`
	Details interface{} `json:"details,omitempty"`
}

// JSON sends a JSON response with the given status code.
func JSON(c *gin.Context, status int, payload interface{}) {
	c.JSON(status, payload)
}

// Error sends an error response with the given status code and message.
func Error(c *gin.Context, status int, message string, details interface{}) {
	c.JSON(status, ErrorResponse{Error: message, Details: details})
}

// OK sends a 200 OK response with the given payload.
func OK(c *gin.Context, payload interface{}) {
	c.JSON(http.StatusOK, payload)
}
</file>

<file path="platform/logger/logger.go">
// Package logger provides structured logging infrastructure for the application.
// This is part of the platform layer and contains no business logic.
package logger

import (
	"context"
	"log/slog"
	"os"
	"strings"
)

// Logger wraps slog.Logger for structured logging
type Logger struct {
	*slog.Logger
}

// New creates a new logger based on environment
func New(env string) *Logger {
	var handler slog.Handler

	opts := &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}

	if strings.EqualFold(env, "development") {
		opts.Level = slog.LevelDebug
		handler = slog.NewTextHandler(os.Stdout, opts)
	} else {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	}

	return &Logger{
		Logger: slog.New(handler),
	}
}

// WithContext returns a logger with context values
func (l *Logger) WithContext(ctx context.Context) *Logger {
	return l
}

// WithRequestID returns a logger with request ID
func (l *Logger) WithRequestID(requestID string) *Logger {
	return &Logger{
		Logger: l.Logger.With(slog.String("request_id", requestID)),
	}
}

// WithUserID returns a logger with user ID
func (l *Logger) WithUserID(userID string) *Logger {
	return &Logger{
		Logger: l.Logger.With(slog.String("user_id", userID)),
	}
}

// HTTPRequest logs an HTTP request
func (l *Logger) HTTPRequest(method, path string, status int, latencyMs float64, clientIP string) {
	l.Info("http_request",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.Float64("latency_ms", latencyMs),
		slog.String("client_ip", clientIP),
	)
}

// HTTPError logs an HTTP error
func (l *Logger) HTTPError(method, path string, status int, err error, clientIP string) {
	l.Error("http_error",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.String("error", err.Error()),
		slog.String("client_ip", clientIP),
	)
}

// AuthEvent logs authentication events
func (l *Logger) AuthEvent(event, email string, success bool, reason string) {
	if success {
		l.Info("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
		)
	} else {
		l.Warn("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
			slog.String("reason", reason),
		)
	}
}

// DatabaseError logs database errors
func (l *Logger) DatabaseError(operation string, err error) {
	l.Error("database_error",
		slog.String("operation", operation),
		slog.String("error", err.Error()),
	)
}

// RateLimitExceeded logs rate limit events
func (l *Logger) RateLimitExceeded(clientIP, path string) {
	l.Warn("rate_limit_exceeded",
		slog.String("client_ip", clientIP),
		slog.String("path", path),
	)
}
</file>

<file path="platform/phone/normalize.go">
// Package phone provides phone number utilities.
// This is part of the platform layer and contains no business logic.
package phone

import (
	"strings"

	"github.com/nyaruka/phonenumbers"
)

const defaultRegion = "NL"

// NormalizeE164 formats a phone number to E.164. If parsing fails, it returns the trimmed input.
func NormalizeE164(input string) string {
	trimmed := strings.TrimSpace(input)
	if trimmed == "" {
		return trimmed
	}

	number, err := phonenumbers.Parse(trimmed, defaultRegion)
	if err != nil {
		return trimmed
	}

	if !phonenumbers.IsValidNumber(number) {
		return trimmed
	}

	return phonenumbers.Format(number, phonenumbers.E164)
}
</file>

<file path="platform/validator/validator.go">
// Package validator provides a shared validation instance for use across all
// bounded contexts. Domain-specific validation rules should be registered in
// their respective domains.
// This is part of the platform layer and contains no business logic.
package validator

import "github.com/go-playground/validator/v10"

// Validate is the shared validator instance used across all modules.
// Domain-specific validation rules can be registered in their respective
// domain packages using RegisterValidation.
var Validate = validator.New()
</file>

<file path="sql/auth.sql">
-- name: CreateUser :one
INSERT INTO users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, created_at, updated_at;

-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at
FROM users WHERE email = $1;

-- name: MarkEmailVerified :exec
UPDATE users SET is_email_verified = true, updated_at = now() WHERE id = $1;

-- name: UpdatePassword :exec
UPDATE users SET password_hash = $2, updated_at = now() WHERE id = $1;

-- name: CreateUserToken :exec
INSERT INTO user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4);

-- name: GetUserToken :one
SELECT user_id, expires_at FROM user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: UseUserToken :exec
UPDATE user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3);

-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeAllRefreshTokens :exec
UPDATE refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL;
</file>

<file path="internal/auth/module.go">
// Package auth provides the authentication bounded context module.
// This file defines the module that encapsulates all auth setup and route registration.
package auth

import (
	"portal_final_backend/internal/auth/handler"
	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/auth/service"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the auth bounded context module implementing http.Module.
type Module struct {
	handler *handler.Handler
	service *service.Service
	cfg     *config.Config
}

// NewModule creates and initializes the auth module with all its dependencies.
func NewModule(pool *pgxpool.Pool, cfg *config.Config, eventBus events.Bus, log *logger.Logger) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, cfg, eventBus, log)
	h := handler.New(svc, cfg)

	return &Module{
		handler: h,
		service: svc,
		cfg:     cfg,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "auth"
}

// Service returns the auth service for use by adapters (e.g., AgentProvider).
func (m *Module) Service() *service.Service {
	return m.service
}

// RegisterRoutes mounts auth routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// Public auth routes with stricter rate limiting
	authGroup := ctx.V1.Group("/auth")
	authGroup.Use(ctx.AuthRateLimiter.RateLimit())
	m.handler.RegisterRoutes(authGroup)

	// Protected user routes
	ctx.Protected.GET("/users/me", m.handler.GetMe)
	ctx.Protected.GET("/users", m.handler.ListUsers)
	ctx.Protected.PATCH("/users/me", m.handler.UpdateMe)
	ctx.Protected.POST("/users/me/password", m.handler.ChangePassword)

	// Admin routes
	ctx.Admin.PUT("/users/:id/roles", m.handler.SetUserRoles)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/auth/repository/interface.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// =====================================
// Segregated Interfaces (Interface Segregation Principle)
// =====================================

// UserReader provides read-only access to user data.
type UserReader interface {
	GetUserByEmail(ctx context.Context, email string) (User, error)
	GetUserByID(ctx context.Context, userID uuid.UUID) (User, error)
}

// UserWriter provides write operations for user management.
type UserWriter interface {
	CreateUser(ctx context.Context, email, passwordHash string) (User, error)
	MarkEmailVerified(ctx context.Context, userID uuid.UUID) error
	UpdatePassword(ctx context.Context, userID uuid.UUID, passwordHash string) error
	UpdateUserEmail(ctx context.Context, userID uuid.UUID, email string) (User, error)
	ListUsers(ctx context.Context) ([]UserWithRoles, error)
}

// TokenStore manages one-time tokens (email verification, password reset).
type TokenStore interface {
	CreateUserToken(ctx context.Context, userID uuid.UUID, tokenHash string, tokenType string, expiresAt time.Time) error
	GetUserToken(ctx context.Context, tokenHash string, tokenType string) (uuid.UUID, time.Time, error)
	UseUserToken(ctx context.Context, tokenHash string, tokenType string) error
}

// RefreshTokenStore manages refresh tokens for session management.
type RefreshTokenStore interface {
	CreateRefreshToken(ctx context.Context, userID uuid.UUID, tokenHash string, expiresAt time.Time) error
	GetRefreshToken(ctx context.Context, tokenHash string) (uuid.UUID, time.Time, error)
	RevokeRefreshToken(ctx context.Context, tokenHash string) error
	RevokeAllRefreshTokens(ctx context.Context, userID uuid.UUID) error
}

// RoleManager provides role-based access control operations.
type RoleManager interface {
	GetUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error)
	SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error
}

// =====================================
// Composite Interface (for backward compatibility)
// =====================================

// AuthRepository defines the complete interface for authentication data operations.
// Composed of smaller, focused interfaces for better testability and flexibility.
type AuthRepository interface {
	UserReader
	UserWriter
	TokenStore
	RefreshTokenStore
	RoleManager
}

// Ensure Repository implements AuthRepository
var _ AuthRepository = (*Repository)(nil)
</file>

<file path="internal/events/bus.go">
// Package events re-exports the platform event bus for convenience.
// This allows internal modules to import events from internal/events
// while the implementation lives in platform/events.
package events

import (
	platformevents "portal_final_backend/platform/events"
	"portal_final_backend/platform/logger"
)

// InMemoryBus is a type alias to the platform InMemoryBus
type InMemoryBus = platformevents.InMemoryBus

// NewInMemoryBus creates a new in-memory event bus.
// This is a convenience re-export from platform/events.
func NewInMemoryBus(log *logger.Logger) *InMemoryBus {
	return platformevents.NewInMemoryBus(log)
}
</file>

<file path="internal/events/event.go">
// Package events provides domain event definitions for decoupled,
// event-driven communication between modules.
// Infrastructure (Bus, Handler) is in platform/events.
package events

import (
	"time"

	"portal_final_backend/platform/events"

	"github.com/google/uuid"
)

// Re-export platform types for convenience
type (
	Event       = events.Event
	Bus         = events.Bus
	Handler     = events.Handler
	HandlerFunc = events.HandlerFunc
	BaseEvent   = events.BaseEvent
)

// Re-export platform functions
var NewBaseEvent = events.NewBaseEvent

// =============================================================================
// Auth Domain Events
// =============================================================================

// UserSignedUp is published when a new user successfully registers.
type UserSignedUp struct {
	BaseEvent
	UserID      uuid.UUID `json:"userId"`
	Email       string    `json:"email"`
	VerifyToken string    `json:"verifyToken"`
}

func (e UserSignedUp) EventName() string { return "auth.user.signed_up" }

// EmailVerificationRequested is published when a user needs to verify their email.
type EmailVerificationRequested struct {
	BaseEvent
	UserID      uuid.UUID `json:"userId"`
	Email       string    `json:"email"`
	VerifyToken string    `json:"verifyToken"`
}

func (e EmailVerificationRequested) EventName() string { return "auth.email.verification_requested" }

// PasswordResetRequested is published when a user requests a password reset.
type PasswordResetRequested struct {
	BaseEvent
	UserID     uuid.UUID `json:"userId"`
	Email      string    `json:"email"`
	ResetToken string    `json:"resetToken"`
}

func (e PasswordResetRequested) EventName() string { return "auth.password.reset_requested" }

// =============================================================================
// Leads Domain Events
// =============================================================================

// LeadCreated is published when a new lead is created.
type LeadCreated struct {
	BaseEvent
	LeadID          uuid.UUID  `json:"leadId"`
	AssignedAgentID *uuid.UUID `json:"assignedAgentId,omitempty"`
	ServiceType     string     `json:"serviceType"`
}

func (e LeadCreated) EventName() string { return "leads.lead.created" }

// LeadAssigned is published when a lead is assigned to an agent.
type LeadAssigned struct {
	BaseEvent
	LeadID        uuid.UUID  `json:"leadId"`
	PreviousAgent *uuid.UUID `json:"previousAgent,omitempty"`
	NewAgent      *uuid.UUID `json:"newAgent,omitempty"`
	AssignedByID  uuid.UUID  `json:"assignedById"`
}

func (e LeadAssigned) EventName() string { return "leads.lead.assigned" }

// VisitScheduled is published when a visit is scheduled for a lead.
type VisitScheduled struct {
	BaseEvent
	LeadID        uuid.UUID  `json:"leadId"`
	ServiceID     uuid.UUID  `json:"serviceId"`
	ScheduledDate time.Time  `json:"scheduledDate"`
	ScoutID       *uuid.UUID `json:"scoutId,omitempty"`
	// Consumer details for notification
	ConsumerEmail     *string `json:"consumerEmail,omitempty"`
	ConsumerFirstName string  `json:"consumerFirstName"`
	ConsumerLastName  string  `json:"consumerLastName"`
	// Address for notification
	AddressStreet      string `json:"addressStreet"`
	AddressHouseNumber string `json:"addressHouseNumber"`
	AddressZipCode     string `json:"addressZipCode"`
	AddressCity        string `json:"addressCity"`
	// Whether to send invite
	SendInvite bool `json:"sendInvite"`
}

func (e VisitScheduled) EventName() string { return "leads.visit.scheduled" }

// VisitRescheduled is published when a visit is rescheduled.
type VisitRescheduled struct {
	BaseEvent
	LeadID           uuid.UUID  `json:"leadId"`
	ServiceID        uuid.UUID  `json:"serviceId"`
	PreviousDate     *time.Time `json:"previousDate,omitempty"`
	NewScheduledDate time.Time  `json:"newScheduledDate"`
	ScoutID          *uuid.UUID `json:"scoutId,omitempty"`
	MarkedAsNoShow   bool       `json:"markedAsNoShow"`
	// Consumer details for notification
	ConsumerEmail     *string `json:"consumerEmail,omitempty"`
	ConsumerFirstName string  `json:"consumerFirstName"`
	ConsumerLastName  string  `json:"consumerLastName"`
	// Address for notification
	AddressStreet      string `json:"addressStreet"`
	AddressHouseNumber string `json:"addressHouseNumber"`
	AddressZipCode     string `json:"addressZipCode"`
	AddressCity        string `json:"addressCity"`
	// Whether to send invite
	SendInvite bool `json:"sendInvite"`
}

func (e VisitRescheduled) EventName() string { return "leads.visit.rescheduled" }

// SurveyCompleted is published when a survey/visit is completed.
type SurveyCompleted struct {
	BaseEvent
	LeadID           uuid.UUID `json:"leadId"`
	ServiceID        uuid.UUID `json:"serviceId"`
	Measurements     string    `json:"measurements"`
	AccessDifficulty string    `json:"accessDifficulty"`
}

func (e SurveyCompleted) EventName() string { return "leads.survey.completed" }

// LeadMarkedNoShow is published when a lead is marked as no-show.
type LeadMarkedNoShow struct {
	BaseEvent
	LeadID    uuid.UUID `json:"leadId"`
	ServiceID uuid.UUID `json:"serviceId"`
	Notes     string    `json:"notes"`
}

func (e LeadMarkedNoShow) EventName() string { return "leads.visit.no_show" }
</file>

<file path="internal/http/module.go">
// Package http provides HTTP server infrastructure including the Module interface
// that all domain modules must implement for route registration.
package http

import (
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"

	"github.com/gin-gonic/gin"
)

// Module represents a bounded context that can register its HTTP routes.
// Each domain module implements this interface to encapsulate its own
// route setup, keeping the main router decoupled from specific endpoints.
type Module interface {
	// Name returns the module's identifier for logging purposes.
	Name() string
	// RegisterRoutes mounts the module's routes on the provided router group.
	// The RouterContext provides access to shared middleware and configuration.
	RegisterRoutes(ctx *RouterContext)
}

// RouterContext provides shared dependencies for module route registration.
// This avoids passing many parameters to each module's RegisterRoutes method.
type RouterContext struct {
	// Engine is the root Gin engine for modules that need engine-level access.
	Engine *gin.Engine
	// V1 is the /api/v1 route group.
	V1 *gin.RouterGroup
	// Protected is the authenticated route group under /api/v1.
	Protected *gin.RouterGroup
	// Admin is the admin-only route group under /api/v1/admin.
	Admin *gin.RouterGroup
	// Config is the application configuration.
	Config *config.Config
	// AuthMiddleware provides the authentication middleware.
	AuthMiddleware gin.HandlerFunc
	// AuthRateLimiter is the stricter rate limiter for auth routes.
	AuthRateLimiter *httpkit.AuthRateLimiter
}
</file>

<file path="internal/leads/module.go">
// Package leads provides the lead management bounded context module.
// This file defines the module that encapsulates all leads setup and route registration.
package leads

import (
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/leads/handler"
	"portal_final_backend/internal/leads/management"
	"portal_final_backend/internal/leads/notes"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/scheduling"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the leads bounded context module implementing http.Module.
type Module struct {
	handler    *handler.Handler
	management *management.Service
	scheduling *scheduling.Service
	notes      *notes.Service
}

// NewModule creates and initializes the leads module with all its dependencies.
func NewModule(pool *pgxpool.Pool, eventBus events.Bus) *Module {
	// Create shared repository
	repo := repository.New(pool)

	// Create focused services (vertical slices)
	mgmtSvc := management.New(repo)
	schedulingSvc := scheduling.New(repo, eventBus)
	notesSvc := notes.New(repo)

	// Create handlers
	notesHandler := handler.NewNotesHandler(notesSvc)
	h := handler.New(mgmtSvc, schedulingSvc, notesHandler)

	return &Module{
		handler:    h,
		management: mgmtSvc,
		scheduling: schedulingSvc,
		notes:      notesSvc,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "leads"
}

// ManagementService returns the lead management service for external use.
func (m *Module) ManagementService() *management.Service {
	return m.management
}

// SchedulingService returns the lead scheduling service for external use.
func (m *Module) SchedulingService() *scheduling.Service {
	return m.scheduling
}

// NotesService returns the lead notes service for external use.
func (m *Module) NotesService() *notes.Service {
	return m.notes
}

// RegisterRoutes mounts leads routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// All leads routes require authentication
	leadsGroup := ctx.Protected.Group("/leads")
	m.handler.RegisterRoutes(leadsGroup)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/leads/repository/interface.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// =====================================
// Segregated Interfaces (Interface Segregation Principle)
// =====================================

// LeadReader provides read-only access to lead data.
type LeadReader interface {
	GetByID(ctx context.Context, id uuid.UUID) (Lead, error)
	GetByIDWithServices(ctx context.Context, id uuid.UUID) (Lead, []LeadService, error)
	GetByPhone(ctx context.Context, phone string) (Lead, error)
	List(ctx context.Context, params ListParams) ([]Lead, int, error)
}

// LeadWriter provides write operations for lead management.
type LeadWriter interface {
	Create(ctx context.Context, params CreateLeadParams) (Lead, error)
	Update(ctx context.Context, id uuid.UUID, params UpdateLeadParams) (Lead, error)
	UpdateStatus(ctx context.Context, id uuid.UUID, status string) (Lead, error)
	Delete(ctx context.Context, id uuid.UUID) error
	BulkDelete(ctx context.Context, ids []uuid.UUID) (int, error)
}

// LeadViewTracker tracks which users have viewed leads.
type LeadViewTracker interface {
	SetViewedBy(ctx context.Context, id uuid.UUID, userID uuid.UUID) error
}

// ActivityLogger records activity/audit trail on leads.
type ActivityLogger interface {
	AddActivity(ctx context.Context, leadID uuid.UUID, userID uuid.UUID, action string, meta map[string]interface{}) error
}

// LeadServiceReader provides read access to lead services.
type LeadServiceReader interface {
	GetLeadServiceByID(ctx context.Context, id uuid.UUID) (LeadService, error)
	ListLeadServices(ctx context.Context, leadID uuid.UUID) ([]LeadService, error)
	GetCurrentLeadService(ctx context.Context, leadID uuid.UUID) (LeadService, error)
}

// LeadServiceWriter provides write operations for lead services.
type LeadServiceWriter interface {
	CreateLeadService(ctx context.Context, params CreateLeadServiceParams) (LeadService, error)
	UpdateLeadService(ctx context.Context, id uuid.UUID, params UpdateLeadServiceParams) (LeadService, error)
	UpdateServiceStatus(ctx context.Context, id uuid.UUID, status string) (LeadService, error)
	CloseAllActiveServices(ctx context.Context, leadID uuid.UUID) error
}

// VisitManager handles visit scheduling and completion on services.
type VisitManager interface {
	ScheduleServiceVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID) (LeadService, error)
	CompleteServiceSurvey(ctx context.Context, id uuid.UUID, measurements string, accessDifficulty string, notes string) (LeadService, error)
	MarkServiceNoShow(ctx context.Context, id uuid.UUID, notes string) (LeadService, error)
	RescheduleServiceVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID, noShowNotes string, markAsNoShow bool) (LeadService, error)
}

// LegacyVisitManager handles legacy visit operations directly on leads (deprecated).
// Prefer using VisitManager with lead services instead.
type LegacyVisitManager interface {
	ScheduleVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID) (Lead, error)
	CompleteSurvey(ctx context.Context, id uuid.UUID, measurements string, accessDifficulty string, notes string) (Lead, error)
	MarkNoShow(ctx context.Context, id uuid.UUID, notes string) (Lead, error)
	RescheduleVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID, noShowNotes string, markAsNoShow bool) (Lead, error)
}

// NoteStore manages lead notes.
type NoteStore interface {
	CreateLeadNote(ctx context.Context, params CreateLeadNoteParams) (LeadNote, error)
	ListLeadNotes(ctx context.Context, leadID uuid.UUID) ([]LeadNote, error)
}

// VisitHistoryStore manages visit history records.
type VisitHistoryStore interface {
	CreateVisitHistory(ctx context.Context, params CreateVisitHistoryParams) (VisitHistory, error)
	ListVisitHistory(ctx context.Context, leadID uuid.UUID) ([]VisitHistory, error)
	GetVisitHistoryByID(ctx context.Context, id uuid.UUID) (VisitHistory, error)
}

// =====================================
// Composite Interface (for backward compatibility)
// =====================================

// LeadsRepository defines the complete interface for leads data operations.
// Composed of smaller, focused interfaces for better testability and flexibility.
type LeadsRepository interface {
	LeadReader
	LeadWriter
	LeadViewTracker
	ActivityLogger
	LeadServiceReader
	LeadServiceWriter
	VisitManager
	LegacyVisitManager
	NoteStore
	VisitHistoryStore
}

// Ensure Repository implements LeadsRepository
var _ LeadsRepository = (*Repository)(nil)
</file>

<file path="internal/leads/repository/lead_services.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var ErrServiceNotFound = errors.New("lead service not found")

type LeadService struct {
	ID                    uuid.UUID
	LeadID                uuid.UUID
	ServiceType           string
	Status                string
	VisitScheduledDate    *time.Time
	VisitScoutID          *uuid.UUID
	VisitMeasurements     *string
	VisitAccessDifficulty *string
	VisitNotes            *string
	VisitCompletedAt      *time.Time
	CreatedAt             time.Time
	UpdatedAt             time.Time
}

type CreateLeadServiceParams struct {
	LeadID      uuid.UUID
	ServiceType string
}

func (r *Repository) CreateLeadService(ctx context.Context, params CreateLeadServiceParams) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		INSERT INTO lead_services (lead_id, service_type, status)
		VALUES ($1, $2, 'New')
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, params.LeadID, params.ServiceType).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	return svc, err
}

func (r *Repository) GetLeadServiceByID(ctx context.Context, id uuid.UUID) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM lead_services WHERE id = $1
	`, id).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) ListLeadServices(ctx context.Context, leadID uuid.UUID) ([]LeadService, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM lead_services WHERE lead_id = $1
		ORDER BY created_at DESC
	`, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	services := make([]LeadService, 0)
	for rows.Next() {
		var svc LeadService
		if err := rows.Scan(
			&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
			&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
			&svc.CreatedAt, &svc.UpdatedAt,
		); err != nil {
			return nil, err
		}
		services = append(services, svc)
	}
	return services, rows.Err()
}

// GetCurrentLeadService returns the most recent non-terminal (not Closed, not Bad_Lead, not Surveyed) service,
// or falls back to the most recent service if all are terminal.
func (r *Repository) GetCurrentLeadService(ctx context.Context, leadID uuid.UUID) (LeadService, error) {
	var svc LeadService
	// Try to find an active (non-terminal) service first
	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM lead_services 
		WHERE lead_id = $1 AND status NOT IN ('Closed', 'Bad_Lead', 'Surveyed')
		ORDER BY created_at DESC
		LIMIT 1
	`, leadID).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		// Fallback to most recent service of any status
		err = r.pool.QueryRow(ctx, `
			SELECT id, lead_id, service_type, status,
				visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
				created_at, updated_at
			FROM lead_services 
			WHERE lead_id = $1
			ORDER BY created_at DESC
			LIMIT 1
		`, leadID).Scan(
			&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
			&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
			&svc.CreatedAt, &svc.UpdatedAt,
		)
	}
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

type UpdateLeadServiceParams struct {
	Status *string
}

func (r *Repository) UpdateLeadService(ctx context.Context, id uuid.UUID, params UpdateLeadServiceParams) (LeadService, error) {
	setClauses := []string{}
	args := []interface{}{}
	argIdx := 1

	if params.Status != nil {
		setClauses = append(setClauses, fmt.Sprintf("status = $%d", argIdx))
		args = append(args, *params.Status)
		argIdx++
	}

	if len(setClauses) == 0 {
		return r.GetLeadServiceByID(ctx, id)
	}

	setClauses = append(setClauses, "updated_at = now()")
	args = append(args, id)

	query := fmt.Sprintf(`
		UPDATE lead_services SET %s
		WHERE id = $%d
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, strings.Join(setClauses, ", "), argIdx)

	var svc LeadService
	err := r.pool.QueryRow(ctx, query, args...).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) UpdateServiceStatus(ctx context.Context, id uuid.UUID, status string) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		UPDATE lead_services SET status = $2, updated_at = now()
		WHERE id = $1
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, status).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) ScheduleServiceVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		UPDATE lead_services SET 
			visit_scheduled_date = $2, 
			visit_scout_id = $3,
			status = 'Scheduled',
			updated_at = now()
		WHERE id = $1
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, scheduledDate, scoutID).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) CompleteServiceSurvey(ctx context.Context, id uuid.UUID, measurements string, accessDifficulty string, notes string) (LeadService, error) {
	var svc LeadService
	var notesPtr *string
	if notes != "" {
		notesPtr = &notes
	}
	err := r.pool.QueryRow(ctx, `
		UPDATE lead_services SET 
			visit_measurements = $2,
			visit_access_difficulty = $3,
			visit_notes = $4,
			visit_completed_at = now(),
			status = 'Surveyed',
			updated_at = now()
		WHERE id = $1
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, measurements, accessDifficulty, notesPtr).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) MarkServiceNoShow(ctx context.Context, id uuid.UUID, notes string) (LeadService, error) {
	var svc LeadService
	var notesPtr *string
	if notes != "" {
		notesPtr = &notes
	}
	err := r.pool.QueryRow(ctx, `
		UPDATE lead_services SET 
			visit_notes = COALESCE(visit_notes || E'\n', '') || COALESCE($2, 'No show'),
			status = 'Needs_Rescheduling',
			updated_at = now()
		WHERE id = $1
		RETURNING id, lead_id, service_type, status,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, notesPtr).Scan(
		&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
		&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
		&svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) RescheduleServiceVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID, noShowNotes string, markAsNoShow bool) (LeadService, error) {
	var svc LeadService
	var err error

	if markAsNoShow {
		// Build no-show note
		noShowNote := "No show"
		if noShowNotes != "" {
			noShowNote = "No show: " + noShowNotes
		}

		err = r.pool.QueryRow(ctx, `
			UPDATE lead_services SET 
				visit_notes = COALESCE(visit_notes || E'\n', '') || $4,
				visit_scheduled_date = $2,
				visit_scout_id = $3,
				visit_measurements = NULL,
				visit_access_difficulty = NULL,
				visit_completed_at = NULL,
				status = 'Scheduled',
				updated_at = now()
			WHERE id = $1
			RETURNING id, lead_id, service_type, status,
				visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
				created_at, updated_at
		`, id, scheduledDate, scoutID, noShowNote).Scan(
			&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
			&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
			&svc.CreatedAt, &svc.UpdatedAt,
		)
	} else {
		// Simple reschedule without no-show
		err = r.pool.QueryRow(ctx, `
			UPDATE lead_services SET 
				visit_scheduled_date = $2,
				visit_scout_id = $3,
				visit_measurements = NULL,
				visit_access_difficulty = NULL,
				visit_completed_at = NULL,
				status = 'Scheduled',
				updated_at = now()
			WHERE id = $1
			RETURNING id, lead_id, service_type, status,
				visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
				created_at, updated_at
		`, id, scheduledDate, scoutID).Scan(
			&svc.ID, &svc.LeadID, &svc.ServiceType, &svc.Status,
			&svc.VisitScheduledDate, &svc.VisitScoutID, &svc.VisitMeasurements, &svc.VisitAccessDifficulty, &svc.VisitNotes, &svc.VisitCompletedAt,
			&svc.CreatedAt, &svc.UpdatedAt,
		)
	}

	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

// CloseAllActiveServices marks all non-terminal services for a lead as Closed
func (r *Repository) CloseAllActiveServices(ctx context.Context, leadID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE lead_services 
		SET status = 'Closed', updated_at = now()
		WHERE lead_id = $1 AND status NOT IN ('Closed', 'Bad_Lead', 'Surveyed')
	`, leadID)
	return err
}
</file>

<file path="internal/leads/repository/notes.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

type LeadNote struct {
	ID          uuid.UUID
	LeadID      uuid.UUID
	AuthorID    uuid.UUID
	AuthorEmail string
	Type        string
	Body        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type CreateLeadNoteParams struct {
	LeadID   uuid.UUID
	AuthorID uuid.UUID
	Type     string
	Body     string
}

func (r *Repository) CreateLeadNote(ctx context.Context, params CreateLeadNoteParams) (LeadNote, error) {
	var note LeadNote
	query := `
		WITH inserted AS (
			INSERT INTO lead_notes (lead_id, author_id, type, body)
			VALUES ($1, $2, $3, $4)
			RETURNING id, lead_id, author_id, type, body, created_at, updated_at
		)
		SELECT inserted.id, inserted.lead_id, inserted.author_id, u.email, inserted.type, inserted.body, inserted.created_at, inserted.updated_at
		FROM inserted
		JOIN users u ON u.id = inserted.author_id
	`

	err := r.pool.QueryRow(ctx, query, params.LeadID, params.AuthorID, params.Type, params.Body).Scan(
		&note.ID,
		&note.LeadID,
		&note.AuthorID,
		&note.AuthorEmail,
		&note.Type,
		&note.Body,
		&note.CreatedAt,
		&note.UpdatedAt,
	)
	return note, err
}

func (r *Repository) ListLeadNotes(ctx context.Context, leadID uuid.UUID) ([]LeadNote, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT ln.id, ln.lead_id, ln.author_id, u.email, ln.type, ln.body, ln.created_at, ln.updated_at
		FROM lead_notes ln
		JOIN users u ON u.id = ln.author_id
		WHERE ln.lead_id = $1
		ORDER BY ln.created_at DESC
	`, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	notes := make([]LeadNote, 0)
	for rows.Next() {
		var note LeadNote
		if err := rows.Scan(
			&note.ID,
			&note.LeadID,
			&note.AuthorID,
			&note.AuthorEmail,
			&note.Type,
			&note.Body,
			&note.CreatedAt,
			&note.UpdatedAt,
		); err != nil {
			return nil, err
		}
		notes = append(notes, note)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return notes, nil
}
</file>

<file path="internal/leads/service/notes.go">
package service

import (
	"context"
	"strings"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"

	"github.com/google/uuid"
)

func (s *Service) AddNote(ctx context.Context, leadID uuid.UUID, authorID uuid.UUID, req transport.CreateLeadNoteRequest) (transport.LeadNoteResponse, error) {
	body := strings.TrimSpace(req.Body)
	if body == "" || len(body) > 2000 {
		return transport.LeadNoteResponse{}, ErrInvalidNote
	}

	noteType := strings.TrimSpace(req.Type)
	if noteType == "" {
		noteType = "note"
	}
	if noteType != "note" && noteType != "call" && noteType != "text" && noteType != "email" && noteType != "system" {
		return transport.LeadNoteResponse{}, ErrInvalidNote
	}

	if _, err := s.repo.GetByID(ctx, leadID); err != nil {
		if err == repository.ErrNotFound {
			return transport.LeadNoteResponse{}, ErrLeadNotFound
		}
		return transport.LeadNoteResponse{}, err
	}

	note, err := s.repo.CreateLeadNote(ctx, repository.CreateLeadNoteParams{
		LeadID:   leadID,
		AuthorID: authorID,
		Type:     noteType,
		Body:     body,
	})
	if err != nil {
		return transport.LeadNoteResponse{}, err
	}

	return toLeadNoteResponse(note), nil
}

func (s *Service) ListNotes(ctx context.Context, leadID uuid.UUID) (transport.LeadNotesResponse, error) {
	if _, err := s.repo.GetByID(ctx, leadID); err != nil {
		if err == repository.ErrNotFound {
			return transport.LeadNotesResponse{}, ErrLeadNotFound
		}
		return transport.LeadNotesResponse{}, err
	}

	notes, err := s.repo.ListLeadNotes(ctx, leadID)
	if err != nil {
		return transport.LeadNotesResponse{}, err
	}

	items := make([]transport.LeadNoteResponse, len(notes))
	for i, note := range notes {
		items[i] = toLeadNoteResponse(note)
	}

	return transport.LeadNotesResponse{Items: items}, nil
}

func toLeadNoteResponse(note repository.LeadNote) transport.LeadNoteResponse {
	return transport.LeadNoteResponse{
		ID:          note.ID,
		LeadID:      note.LeadID,
		AuthorID:    note.AuthorID,
		AuthorEmail: note.AuthorEmail,
		Type:        note.Type,
		Body:        note.Body,
		CreatedAt:   note.CreatedAt,
		UpdatedAt:   note.UpdatedAt,
	}
}
</file>

<file path="internal/leads/transport/notes.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

type CreateLeadNoteRequest struct {
	Body string `json:"body" validate:"required,min=1,max=2000"`
	Type string `json:"type" validate:"omitempty,oneof=note call text email system"`
}

type LeadNoteResponse struct {
	ID          uuid.UUID `json:"id"`
	LeadID      uuid.UUID `json:"leadId"`
	AuthorID    uuid.UUID `json:"authorId"`
	AuthorEmail string    `json:"authorEmail"`
	Type        string    `json:"type"`
	Body        string    `json:"body"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

type LeadNotesResponse struct {
	Items []LeadNoteResponse `json:"items"`
}
</file>

<file path="internal/notification/module.go">
// Package notification provides event handlers for sending notifications
// (emails, SMS, push, etc.) in response to domain events.
// This module subscribes to events and inverts the dependency: domain modules
// no longer need to know about email providers or templates.
package notification

import (
	"context"
	"fmt"
	"strings"

	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
)

// Module handles all notification-related event subscriptions.
type Module struct {
	sender email.Sender
	cfg    *config.Config
	log    *logger.Logger
}

// New creates a new notification module.
func New(sender email.Sender, cfg *config.Config, log *logger.Logger) *Module {
	return &Module{
		sender: sender,
		cfg:    cfg,
		log:    log,
	}
}

// RegisterHandlers subscribes to all relevant domain events on the event bus.
func (m *Module) RegisterHandlers(bus *events.InMemoryBus) {
	// Auth domain events
	bus.Subscribe(events.UserSignedUp{}.EventName(), m)
	bus.Subscribe(events.EmailVerificationRequested{}.EventName(), m)
	bus.Subscribe(events.PasswordResetRequested{}.EventName(), m)

	// Leads domain events
	bus.Subscribe(events.VisitScheduled{}.EventName(), m)
	bus.Subscribe(events.VisitRescheduled{}.EventName(), m)

	m.log.Info("notification module registered event handlers")
}

// Handle routes events to the appropriate handler method.
func (m *Module) Handle(ctx context.Context, event events.Event) error {
	switch e := event.(type) {
	case events.UserSignedUp:
		return m.handleUserSignedUp(ctx, e)
	case events.EmailVerificationRequested:
		return m.handleEmailVerificationRequested(ctx, e)
	case events.PasswordResetRequested:
		return m.handlePasswordResetRequested(ctx, e)
	case events.VisitScheduled:
		return m.handleVisitScheduled(ctx, e)
	case events.VisitRescheduled:
		return m.handleVisitRescheduled(ctx, e)
	default:
		m.log.Warn("unhandled event type", "event", event.EventName())
		return nil
	}
}

func (m *Module) handleUserSignedUp(ctx context.Context, e events.UserSignedUp) error {
	verifyURL := m.buildURL("/verify-email", e.VerifyToken)
	if err := m.sender.SendVerificationEmail(ctx, e.Email, verifyURL); err != nil {
		m.log.Error("failed to send verification email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("verification email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handleEmailVerificationRequested(ctx context.Context, e events.EmailVerificationRequested) error {
	verifyURL := m.buildURL("/verify-email", e.VerifyToken)
	if err := m.sender.SendVerificationEmail(ctx, e.Email, verifyURL); err != nil {
		m.log.Error("failed to send verification email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("verification email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handlePasswordResetRequested(ctx context.Context, e events.PasswordResetRequested) error {
	resetURL := m.buildURL("/reset-password", e.ResetToken)
	if err := m.sender.SendPasswordResetEmail(ctx, e.Email, resetURL); err != nil {
		m.log.Error("failed to send password reset email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("password reset email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handleVisitScheduled(ctx context.Context, e events.VisitScheduled) error {
	if !e.SendInvite {
		return nil
	}

	if e.ConsumerEmail == nil || *e.ConsumerEmail == "" {
		m.log.Debug("skipping visit invite email - no consumer email", "leadId", e.LeadID)
		return nil
	}

	consumerName := e.ConsumerFirstName + " " + e.ConsumerLastName
	scheduledDateStr := e.ScheduledDate.Format("Monday, January 2, 2006 at 15:04")
	address := fmt.Sprintf("%s %s, %s %s",
		e.AddressStreet, e.AddressHouseNumber, e.AddressZipCode, e.AddressCity)

	if err := m.sender.SendVisitInviteEmail(ctx, *e.ConsumerEmail, consumerName, scheduledDateStr, address); err != nil {
		m.log.Error("failed to send visit invite email",
			"leadId", e.LeadID,
			"email", *e.ConsumerEmail,
			"error", err,
		)
		return err
	}
	m.log.Info("visit invite email sent", "leadId", e.LeadID, "email", *e.ConsumerEmail)
	return nil
}

func (m *Module) handleVisitRescheduled(ctx context.Context, e events.VisitRescheduled) error {
	if !e.SendInvite {
		return nil
	}

	if e.ConsumerEmail == nil || *e.ConsumerEmail == "" {
		m.log.Debug("skipping visit invite email - no consumer email", "leadId", e.LeadID)
		return nil
	}

	consumerName := e.ConsumerFirstName + " " + e.ConsumerLastName
	scheduledDateStr := e.NewScheduledDate.Format("Monday, January 2, 2006 at 15:04")
	address := fmt.Sprintf("%s %s, %s %s",
		e.AddressStreet, e.AddressHouseNumber, e.AddressZipCode, e.AddressCity)

	if err := m.sender.SendVisitInviteEmail(ctx, *e.ConsumerEmail, consumerName, scheduledDateStr, address); err != nil {
		m.log.Error("failed to send visit invite email",
			"leadId", e.LeadID,
			"email", *e.ConsumerEmail,
			"error", err,
		)
		return err
	}
	m.log.Info("visit reschedule invite email sent", "leadId", e.LeadID, "email", *e.ConsumerEmail)
	return nil
}

func (m *Module) buildURL(path string, tokenValue string) string {
	base := strings.TrimRight(m.cfg.AppBaseURL, "/")
	return base + path + "?token=" + tokenValue
}
</file>

<file path="sqlc.yaml">
version: "2"
sql:
  # Auth Domain - isolated user/authentication queries
  - schema: "internal/auth/migrations"
    queries: "internal/auth/sql"
    engine: "postgresql"
    gen:
      go:
        package: "authdb"
        out: "internal/auth/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false

  # Leads Domain - isolated leads/activity queries
  - schema: "internal/leads/migrations"
    queries: "internal/leads/sql"
    engine: "postgresql"
    gen:
      go:
        package: "leadsdb"
        out: "internal/leads/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false
</file>

<file path="cmd/api/main.go">
package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"portal_final_backend/internal/http/router"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}

	// Initialize structured logger
	log := logger.New(cfg.Env)
	log.Info("starting server", "env", cfg.Env, "addr", cfg.HTTPAddr)

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	pool, err := db.NewPool(ctx, cfg)
	if err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	defer pool.Close()
	log.Info("database connection established")

	engine := router.New(cfg, pool, log)

	srvErr := make(chan error, 1)
	go func() {
		log.Info("server listening", "addr", cfg.HTTPAddr)
		srvErr <- engine.Run(cfg.HTTPAddr)
	}()

	select {
	case <-ctx.Done():
		log.Info("shutdown signal received, gracefully shutting down")
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		_ = shutdownCtx
	case err := <-srvErr:
		if err != nil {
			log.Error("server error", "error", err)
			panic("server error: " + err.Error())
		}
	}
}
</file>

<file path="internal/config/config.go">
package config

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/joho/godotenv"
)

type Config struct {
	Env                   string
	HTTPAddr              string
	DatabaseURL           string
	JWTAccessSecret       string
	JWTRefreshSecret      string
	AccessTokenTTL        time.Duration
	RefreshTokenTTL       time.Duration
	VerifyTokenTTL        time.Duration
	ResetTokenTTL         time.Duration
	CORSAllowAll          bool
	CORSOrigins           []string
	CORSAllowCreds        bool
	AppBaseURL            string
	EmailEnabled          bool
	BrevoAPIKey           string
	EmailFromName         string
	EmailFromAddress      string
	RefreshCookieName     string
	RefreshCookieDomain   string
	RefreshCookiePath     string
	RefreshCookieSecure   bool
	RefreshCookieSameSite http.SameSite
}

func Load() (*Config, error) {
	_ = godotenv.Load()

	corsOrigins := splitCSV(getEnv("CORS_ORIGINS", "http://localhost:4200"))
	corsAllowAll := strings.EqualFold(getEnv("CORS_ALLOW_ALL", "false"), "true")
	if containsWildcard(corsOrigins) {
		corsAllowAll = true
	}

	brevoAPIKey := getEnv("BREVO_API_KEY", "")
	emailEnabled := strings.EqualFold(getEnv("EMAIL_ENABLED", "true"), "true")

	refreshCookieSecure := strings.EqualFold(getEnv("REFRESH_COOKIE_SECURE", ""), "true")
	if getEnv("REFRESH_COOKIE_SECURE", "") == "" {
		refreshCookieSecure = strings.EqualFold(getEnv("APP_ENV", "development"), "production")
	}

	cfg := &Config{
		Env:                   getEnv("APP_ENV", "development"),
		HTTPAddr:              getEnv("HTTP_ADDR", ":8080"),
		DatabaseURL:           getEnv("DATABASE_URL", ""),
		JWTAccessSecret:       getEnv("JWT_ACCESS_SECRET", ""),
		JWTRefreshSecret:      getEnv("JWT_REFRESH_SECRET", ""),
		AccessTokenTTL:        mustDuration(getEnv("JWT_ACCESS_TTL", "15m")),
		RefreshTokenTTL:       mustDuration(getEnv("JWT_REFRESH_TTL", "720h")),
		VerifyTokenTTL:        mustDuration(getEnv("VERIFY_TOKEN_TTL", "30m")),
		ResetTokenTTL:         mustDuration(getEnv("RESET_TOKEN_TTL", "30m")),
		CORSAllowAll:          corsAllowAll,
		CORSOrigins:           corsOrigins,
		CORSAllowCreds:        strings.EqualFold(getEnv("CORS_ALLOW_CREDENTIALS", "true"), "true"),
		AppBaseURL:            getEnv("APP_BASE_URL", "http://localhost:4200"),
		EmailEnabled:          emailEnabled && brevoAPIKey != "",
		BrevoAPIKey:           brevoAPIKey,
		EmailFromName:         getEnv("EMAIL_FROM_NAME", "Portal"),
		EmailFromAddress:      getEnv("EMAIL_FROM_ADDRESS", ""),
		RefreshCookieName:     getEnv("REFRESH_COOKIE_NAME", "portal_refresh"),
		RefreshCookieDomain:   getEnv("REFRESH_COOKIE_DOMAIN", ""),
		RefreshCookiePath:     getEnv("REFRESH_COOKIE_PATH", "/api/v1/auth"),
		RefreshCookieSecure:   refreshCookieSecure,
		RefreshCookieSameSite: parseSameSite(getEnv("REFRESH_COOKIE_SAMESITE", "Lax")),
	}

	if cfg.DatabaseURL == "" {
		return nil, fmt.Errorf("DATABASE_URL is required")
	}
	if cfg.JWTAccessSecret == "" || cfg.JWTRefreshSecret == "" {
		return nil, fmt.Errorf("JWT_ACCESS_SECRET and JWT_REFRESH_SECRET are required")
	}
	if emailEnabled && cfg.BrevoAPIKey == "" {
		return nil, fmt.Errorf("BREVO_API_KEY is required when EMAIL_ENABLED is true")
	}
	if cfg.EmailEnabled && cfg.EmailFromAddress == "" {
		return nil, fmt.Errorf("EMAIL_FROM_ADDRESS is required when email is enabled")
	}
	if cfg.CORSAllowAll && cfg.CORSAllowCreds {
		return nil, fmt.Errorf("CORS_ALLOW_CREDENTIALS cannot be true when CORS_ALLOW_ALL is true")
	}

	return cfg, nil
}

func getEnv(key, fallback string) string {
	if val, ok := os.LookupEnv(key); ok {
		return val
	}
	return fallback
}

func mustDuration(value string) time.Duration {
	d, err := time.ParseDuration(value)
	if err != nil {
		return 0
	}
	return d
}

func splitCSV(value string) []string {
	parts := strings.Split(value, ",")
	results := make([]string, 0, len(parts))
	for _, part := range parts {
		trimmed := strings.TrimSpace(part)
		if trimmed != "" {
			results = append(results, trimmed)
		}
	}
	return results
}

func containsWildcard(values []string) bool {
	for _, value := range values {
		if value == "*" {
			return true
		}
	}
	return false
}

func parseSameSite(value string) http.SameSite {
	switch strings.ToLower(strings.TrimSpace(value)) {
	case "none":
		return http.SameSiteNoneMode
	case "strict":
		return http.SameSiteStrictMode
	default:
		return http.SameSiteLaxMode
	}
}
</file>

<file path="internal/db/db.go">
package db

import (
	"context"
	"time"

	"portal_final_backend/platform/config"

	"github.com/jackc/pgx/v5/pgxpool"
)

func NewPool(ctx context.Context, cfg *config.Config) (*pgxpool.Pool, error) {
	poolConfig, err := pgxpool.ParseConfig(cfg.DatabaseURL)
	if err != nil {
		return nil, err
	}

	// Production-ready pool configuration
	poolConfig.MaxConns = 25                       // Maximum number of connections
	poolConfig.MinConns = 5                        // Minimum number of idle connections
	poolConfig.MaxConnLifetime = 1 * time.Hour     // Maximum connection lifetime
	poolConfig.MaxConnIdleTime = 30 * time.Minute  // Maximum idle time before closing
	poolConfig.HealthCheckPeriod = 1 * time.Minute // Health check interval

	pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(ctx); err != nil {
		pool.Close()
		return nil, err
	}

	return pool, nil
}
</file>

<file path="internal/email/brevo.go">
package email

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"portal_final_backend/platform/config"
)

type Sender interface {
	SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error
	SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error
	SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error
}

type NoopSender struct{}

func (NoopSender) SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error {
	return nil
}

func (NoopSender) SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error {
	return nil
}

func (NoopSender) SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error {
	return nil
}

type BrevoSender struct {
	apiKey    string
	fromName  string
	fromEmail string
	client    *http.Client
}

type brevoEmailRequest struct {
	Sender struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	} `json:"sender"`
	To []struct {
		Email string `json:"email"`
	} `json:"to"`
	Subject     string `json:"subject"`
	HTMLContent string `json:"htmlContent"`
}

func NewSender(cfg *config.Config) (Sender, error) {
	if !cfg.EmailEnabled {
		return NoopSender{}, nil
	}

	client := &http.Client{Timeout: 10 * time.Second}
	return &BrevoSender{
		apiKey:    cfg.BrevoAPIKey,
		fromName:  cfg.EmailFromName,
		fromEmail: cfg.EmailFromAddress,
		client:    client,
	}, nil
}

func (b *BrevoSender) SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error {
	subject := "Verify your email"
	content := buildEmailTemplate(
		"Confirm your email",
		"Thanks for signing up. Please verify your email to activate your account.",
		"Verify email",
		verifyURL,
	)
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error {
	subject := "Reset your password"
	content := buildEmailTemplate(
		"Reset your password",
		"We received a request to reset your password. Use the link below to set a new one.",
		"Reset password",
		resetURL,
	)
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error {
	subject := "Your visit has been scheduled"
	content := buildVisitInviteTemplate(consumerName, scheduledDate, address)
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) send(ctx context.Context, toEmail, subject, htmlContent string) error {
	payload := brevoEmailRequest{
		Subject:     subject,
		HTMLContent: htmlContent,
	}
	payload.Sender.Name = b.fromName
	payload.Sender.Email = b.fromEmail
	payload.To = []struct {
		Email string `json:"email"`
	}{{Email: toEmail}}

	body, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, "https://api.brevo.com/v3/smtp/email", bytes.NewReader(body))
	if err != nil {
		return err
	}
	req.Header.Set("api-key", b.apiKey)
	req.Header.Set("content-type", "application/json")
	req.Header.Set("accept", "application/json")

	resp, err := b.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("brevo send failed: status %d: %s", resp.StatusCode, string(data))
	}

	return nil
}

func buildEmailTemplate(title, message, ctaLabel, ctaURL string) string {
	return fmt.Sprintf(`<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>%s</title>
</head>
<body style="margin:0;padding:0;background:#f4f4f5;font-family:Arial,sans-serif;color:#111827;">
  <table role="presentation" width="100%%" cellpadding="0" cellspacing="0" style="background:#f4f4f5;padding:24px 0;">
    <tr>
      <td align="center">
        <table role="presentation" width="520" cellpadding="0" cellspacing="0" style="background:#ffffff;border:1px solid #e4e4e7;padding:24px;">
          <tr>
            <td style="font-size:20px;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;">
              %s
            </td>
          </tr>
          <tr>
            <td style="padding-top:12px;font-size:14px;line-height:1.5;color:#52525b;">
              %s
            </td>
          </tr>
          <tr>
            <td style="padding-top:24px;">
              <a href="%s" style="display:inline-block;padding:12px 18px;background:#111827;color:#ffffff;text-decoration:none;text-transform:uppercase;font-size:12px;letter-spacing:0.18em;font-weight:600;">
                %s
              </a>
            </td>
          </tr>
          <tr>
            <td style="padding-top:20px;font-size:12px;color:#a1a1aa;">
              If the button does not work, copy and paste this link into your browser:<br />
              <a href="%s" style="color:#71717a;">%s</a>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`, title, title, message, ctaURL, ctaLabel, ctaURL, ctaURL)
}

func buildVisitInviteTemplate(consumerName, scheduledDate, address string) string {
	return fmt.Sprintf(`<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visit Scheduled</title>
</head>
<body style="margin:0;padding:0;background:#f4f4f5;font-family:Arial,sans-serif;color:#111827;">
  <table role="presentation" width="100%%" cellpadding="0" cellspacing="0" style="background:#f4f4f5;padding:24px 0;">
    <tr>
      <td align="center">
        <table role="presentation" width="520" cellpadding="0" cellspacing="0" style="background:#ffffff;border:1px solid #e4e4e7;padding:24px;">
          <tr>
            <td style="font-size:20px;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;">
              Visit Scheduled
            </td>
          </tr>
          <tr>
            <td style="padding-top:12px;font-size:14px;line-height:1.5;color:#52525b;">
              Dear %s,<br /><br />
              Your visit has been scheduled for:
            </td>
          </tr>
          <tr>
            <td style="padding-top:16px;font-size:16px;font-weight:600;color:#111827;">
              %s
            </td>
          </tr>
          <tr>
            <td style="padding-top:8px;font-size:14px;line-height:1.5;color:#52525b;">
              at<br />
              %s
            </td>
          </tr>
          <tr>
            <td style="padding-top:20px;font-size:12px;color:#a1a1aa;">
              If you need to reschedule or have any questions, please contact us.
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`, consumerName, scheduledDate, address)
}
</file>

<file path="go.mod">
module portal_final_backend

go 1.24.0

require (
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-gonic/gin v1.11.0
	github.com/go-playground/validator/v10 v10.30.1
	github.com/golang-jwt/jwt/v5 v5.3.1
	github.com/google/uuid v1.6.0
	github.com/jackc/pgx/v5 v5.8.0
	github.com/joho/godotenv v1.5.1
	github.com/nyaruka/phonenumbers v1.6.8
	golang.org/x/crypto v0.47.0
	golang.org/x/time v0.14.0
)

require (
	github.com/bytedance/sonic v1.14.0 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cloudwego/base64x v0.1.6 // indirect
	github.com/gabriel-vasile/mimetype v1.4.12 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/goccy/go-yaml v1.18.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.54.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	go.uber.org/mock v0.5.0 // indirect
	golang.org/x/arch v0.20.0 // indirect
	golang.org/x/exp v0.0.0-20250305212735-054e65f0b394 // indirect
	golang.org/x/mod v0.31.0 // indirect
	golang.org/x/net v0.48.0 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/sys v0.40.0 // indirect
	golang.org/x/text v0.33.0 // indirect
	golang.org/x/tools v0.40.0 // indirect
	google.golang.org/protobuf v1.36.11 // indirect
)
</file>

<file path="internal/auth/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrNotFound = errors.New("not found")
var ErrInvalidRole = errors.New("invalid role")

const (
	TokenTypeEmailVerify   = "EMAIL_VERIFY"
	TokenTypePasswordReset = "PASSWORD_RESET"
)

type Repository struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

type User struct {
	ID            uuid.UUID
	Email         string
	PasswordHash  string
	EmailVerified bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type UserWithRoles struct {
	ID    uuid.UUID
	Email string
	Roles []string
}

func (r *Repository) CreateUser(ctx context.Context, email, passwordHash string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		INSERT INTO users (email, password_hash, is_email_verified)
		VALUES ($1, $2, false)
		RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
	`, email, passwordHash).Scan(&user.ID, &user.Email, &user.PasswordHash, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)
	return user, err
}

func (r *Repository) GetUserByEmail(ctx context.Context, email string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		SELECT id, email, password_hash, is_email_verified, created_at, updated_at
		FROM users WHERE email = $1
	`, email).Scan(&user.ID, &user.Email, &user.PasswordHash, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return User{}, ErrNotFound
	}
	return user, err
}

func (r *Repository) GetUserByID(ctx context.Context, userID uuid.UUID) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		SELECT id, email, password_hash, is_email_verified, created_at, updated_at
		FROM users WHERE id = $1
	`, userID).Scan(&user.ID, &user.Email, &user.PasswordHash, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return User{}, ErrNotFound
	}
	return user, err
}

func (r *Repository) MarkEmailVerified(ctx context.Context, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE users SET is_email_verified = true, updated_at = now()
		WHERE id = $1
	`, userID)
	return err
}

func (r *Repository) UpdatePassword(ctx context.Context, userID uuid.UUID, passwordHash string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE users SET password_hash = $2, updated_at = now()
		WHERE id = $1
	`, userID, passwordHash)
	return err
}

func (r *Repository) UpdateUserEmail(ctx context.Context, userID uuid.UUID, email string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		UPDATE users
		SET email = $2, is_email_verified = false, updated_at = now()
		WHERE id = $1
		RETURNING id, email, password_hash, is_email_verified, created_at, updated_at
	`, userID, email).Scan(&user.ID, &user.Email, &user.PasswordHash, &user.EmailVerified, &user.CreatedAt, &user.UpdatedAt)
	return user, err
}

func (r *Repository) CreateUserToken(ctx context.Context, userID uuid.UUID, tokenHash string, tokenType string, expiresAt time.Time) error {
	_, err := r.pool.Exec(ctx, `
		INSERT INTO user_tokens (user_id, token_hash, type, expires_at)
		VALUES ($1, $2, $3, $4)
	`, userID, tokenHash, tokenType, expiresAt)
	return err
}

func (r *Repository) GetUserToken(ctx context.Context, tokenHash string, tokenType string) (uuid.UUID, time.Time, error) {
	var userID uuid.UUID
	var expiresAt time.Time
	err := r.pool.QueryRow(ctx, `
		SELECT user_id, expires_at FROM user_tokens
		WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
	`, tokenHash, tokenType).Scan(&userID, &expiresAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return uuid.UUID{}, time.Time{}, ErrNotFound
	}
	return userID, expiresAt, err
}

func (r *Repository) UseUserToken(ctx context.Context, tokenHash string, tokenType string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE user_tokens SET used_at = now()
		WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
	`, tokenHash, tokenType)
	return err
}

func (r *Repository) CreateRefreshToken(ctx context.Context, userID uuid.UUID, tokenHash string, expiresAt time.Time) error {
	_, err := r.pool.Exec(ctx, `
		INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
		VALUES ($1, $2, $3)
	`, userID, tokenHash, expiresAt)
	return err
}

func (r *Repository) GetRefreshToken(ctx context.Context, tokenHash string) (uuid.UUID, time.Time, error) {
	var userID uuid.UUID
	var expiresAt time.Time
	err := r.pool.QueryRow(ctx, `
		SELECT user_id, expires_at FROM refresh_tokens
		WHERE token_hash = $1 AND revoked_at IS NULL
	`, tokenHash).Scan(&userID, &expiresAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return uuid.UUID{}, time.Time{}, ErrNotFound
	}
	return userID, expiresAt, err
}

func (r *Repository) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE refresh_tokens SET revoked_at = now()
		WHERE token_hash = $1 AND revoked_at IS NULL
	`, tokenHash)
	return err
}

func (r *Repository) RevokeAllRefreshTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE refresh_tokens SET revoked_at = now()
		WHERE user_id = $1 AND revoked_at IS NULL
	`, userID)
	return err
}

func (r *Repository) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT r.name
		FROM roles r
		JOIN user_roles ur ON ur.role_id = r.id
		WHERE ur.user_id = $1
		ORDER BY r.name
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	roles := make([]string, 0)
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		roles = append(roles, name)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return roles, nil
}

func (r *Repository) SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error {
	if len(roles) == 0 {
		return ErrInvalidRole
	}

	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback(ctx)
		}
	}()

	rows, err := tx.Query(ctx, `SELECT name FROM roles WHERE name = ANY($1)`, roles)
	if err != nil {
		return err
	}
	defer rows.Close()

	valid := make(map[string]struct{})
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return err
		}
		valid[name] = struct{}{}
	}
	if rows.Err() != nil {
		return rows.Err()
	}
	if len(valid) != len(uniqueStrings(roles)) {
		return ErrInvalidRole
	}

	if _, err := tx.Exec(ctx, `DELETE FROM user_roles WHERE user_id = $1`, userID); err != nil {
		return err
	}

	if _, err := tx.Exec(ctx, `
		INSERT INTO user_roles (user_id, role_id)
		SELECT $1, id FROM roles WHERE name = ANY($2)
	`, userID, roles); err != nil {
		return err
	}

	if err := tx.Commit(ctx); err != nil {
		return err
	}

	return nil
}

func (r *Repository) ListUsers(ctx context.Context) ([]UserWithRoles, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT u.id, u.email,
			COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles
		FROM users u
		LEFT JOIN user_roles ur ON ur.user_id = u.id
		LEFT JOIN roles r ON r.id = ur.role_id
		GROUP BY u.id
		ORDER BY u.email
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	users := make([]UserWithRoles, 0)
	for rows.Next() {
		var user UserWithRoles
		if err := rows.Scan(&user.ID, &user.Email, &user.Roles); err != nil {
			return nil, err
		}
		users = append(users, user)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return users, nil
}

func uniqueStrings(values []string) []string {
	seen := make(map[string]struct{}, len(values))
	result := make([]string, 0, len(values))
	for _, value := range values {
		if _, ok := seen[value]; ok {
			continue
		}
		seen[value] = struct{}{}
		result = append(result, value)
	}
	return result
}
</file>

<file path="internal/auth/validator/validator.go">
package validator

import (
	"regexp"
	"unicode"

	platformvalidator "portal_final_backend/platform/validator"

	"github.com/go-playground/validator/v10"
)

// Validate is an alias to the platform validator for convenience within the auth domain.
// Auth-specific validations are registered in init().
var Validate = platformvalidator.Validate

func init() {
	// Register auth-specific password validation on the shared validator
	_ = Validate.RegisterValidation("strongpassword", validateStrongPassword)
}

// validateStrongPassword checks for password complexity:
// - At least 8 characters
// - At least one uppercase letter
// - At least one lowercase letter
// - At least one digit
// - At least one special character
func validateStrongPassword(fl validator.FieldLevel) bool {
	password := fl.Field().String()

	if len(password) < 8 {
		return false
	}

	var (
		hasUpper   bool
		hasLower   bool
		hasDigit   bool
		hasSpecial bool
	)

	for _, char := range password {
		switch {
		case unicode.IsUpper(char):
			hasUpper = true
		case unicode.IsLower(char):
			hasLower = true
		case unicode.IsDigit(char):
			hasDigit = true
		case unicode.IsPunct(char) || unicode.IsSymbol(char):
			hasSpecial = true
		}
	}

	return hasUpper && hasLower && hasDigit && hasSpecial
}

// PasswordPolicy describes the password requirements for API error messages
const PasswordPolicy = "Password must be at least 8 characters and include: uppercase letter, lowercase letter, number, and special character"

// IsValidEmail validates email format
func IsValidEmail(email string) bool {
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return emailRegex.MatchString(email)
}
</file>

<file path="internal/http/middleware/middleware.go">
package middleware

import (
	"errors"
	"net/http"
	"strings"
	"sync"
	"time"

	"portal_final_backend/internal/config"
	"portal_final_backend/internal/logger"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/time/rate"
)

const (
	ContextUserIDKey = "userID"
	ContextRolesKey  = "roles"
	errMissingToken  = "missing token"
	errInvalidToken  = "invalid token"
)

// RequestLogger logs HTTP requests with timing
func RequestLogger(log *logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		clientIP := c.ClientIP()

		log.HTTPRequest(c.Request.Method, path, status, float64(latency.Milliseconds()), clientIP)
	}
}

// SecurityHeaders adds security headers to responses
func SecurityHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		c.Header("Content-Security-Policy", "default-src 'self'")
		c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()")

		// Only add HSTS in production
		if c.Request.TLS != nil {
			c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}

		c.Next()
	}
}

// IPRateLimiter manages per-IP rate limiters
type IPRateLimiter struct {
	limiters sync.Map
	rate     rate.Limit
	burst    int
	log      *logger.Logger
}

// NewIPRateLimiter creates a new IP-based rate limiter
func NewIPRateLimiter(r rate.Limit, burst int, log *logger.Logger) *IPRateLimiter {
	return &IPRateLimiter{
		rate:  r,
		burst: burst,
		log:   log,
	}
}

func (i *IPRateLimiter) getLimiter(ip string) *rate.Limiter {
	limiter, exists := i.limiters.Load(ip)
	if !exists {
		newLimiter := rate.NewLimiter(i.rate, i.burst)
		i.limiters.Store(ip, newLimiter)
		return newLimiter
	}
	return limiter.(*rate.Limiter)
}

// RateLimit returns a middleware that rate limits by IP
func (i *IPRateLimiter) RateLimit() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()
		limiter := i.getLimiter(ip)

		if !limiter.Allow() {
			if i.log != nil {
				i.log.RateLimitExceeded(ip, c.Request.URL.Path)
			}
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"error": "rate limit exceeded",
			})
			return
		}

		c.Next()
	}
}

// AuthRateLimiter is a stricter rate limiter for auth endpoints
type AuthRateLimiter struct {
	*IPRateLimiter
}

// NewAuthRateLimiter creates a rate limiter for authentication endpoints
// with stricter limits (e.g., 5 requests per minute)
func NewAuthRateLimiter(log *logger.Logger) *AuthRateLimiter {
	return &AuthRateLimiter{
		IPRateLimiter: NewIPRateLimiter(rate.Limit(5.0/60.0), 5, log), // 5 requests per minute, burst of 5
	}
}

func AuthRequired(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		rawToken, ok := extractBearerToken(c.GetHeader("Authorization"))
		if !ok {
			abortUnauthorized(c, errMissingToken)
			return
		}

		claims, err := parseAccessClaims(rawToken, cfg)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		userID, err := parseUserID(claims)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		roles := extractRoles(claims["roles"])
		c.Set(ContextUserIDKey, userID)
		c.Set(ContextRolesKey, roles)
		c.Next()
	}
}

func RequireRole(role string) gin.HandlerFunc {
	return func(c *gin.Context) {
		roles, ok := c.Get(ContextRolesKey)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		roleList, ok := roles.([]string)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		for _, item := range roleList {
			if item == role {
				c.Next()
				return
			}
		}

		c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
	}
}

func extractRoles(value interface{}) []string {
	roles := make([]string, 0)
	if value == nil {
		return roles
	}

	switch typed := value.(type) {
	case []string:
		return append(roles, typed...)
	case []interface{}:
		for _, item := range typed {
			if text, ok := item.(string); ok {
				roles = append(roles, text)
			}
		}
	}

	return roles
}

func extractBearerToken(authHeader string) (string, bool) {
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return "", false
	}

	rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
	if rawToken == "" {
		return "", false
	}

	return rawToken, true
}

func parseAccessClaims(rawToken string, cfg *config.Config) (jwt.MapClaims, error) {
	parsed, err := jwt.Parse(rawToken, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("invalid signing method")
		}
		return []byte(cfg.JWTAccessSecret), nil
	})
	if err != nil || !parsed.Valid {
		return nil, errors.New(errInvalidToken)
	}

	claims, ok := parsed.Claims.(jwt.MapClaims)
	if !ok {
		return nil, errors.New(errInvalidToken)
	}

	if tokenType, _ := claims["type"].(string); tokenType != "access" {
		return nil, errors.New(errInvalidToken)
	}

	return claims, nil
}

func parseUserID(claims jwt.MapClaims) (uuid.UUID, error) {
	userIDRaw, _ := claims["sub"].(string)
	return uuid.Parse(userIDRaw)
}

func abortUnauthorized(c *gin.Context, message string) {
	c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": message})
}
</file>

<file path="internal/leads/handler/notes.go">
package handler

import (
	"errors"
	"net/http"

	"portal_final_backend/internal/leads/notes"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// NotesHandler handles HTTP requests for lead notes.
// This is separate from the main Handler to allow independent wiring.
type NotesHandler struct {
	svc *notes.Service
}

// NewNotesHandler creates a new notes handler.
func NewNotesHandler(svc *notes.Service) *NotesHandler {
	return &NotesHandler{svc: svc}
}

func (h *NotesHandler) ListNotes(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	notesList, err := h.svc.List(c.Request.Context(), id)
	if err != nil {
		if errors.Is(err, notes.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, notesList)
}

func (h *NotesHandler) AddNote(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CreateLeadNoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	actorIDValue, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	authorID := actorIDValue.(uuid.UUID)
	created, err := h.svc.Add(c.Request.Context(), id, authorID, req)
	if err != nil {
		switch {
		case errors.Is(err, notes.ErrLeadNotFound):
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
		case errors.Is(err, notes.ErrInvalidNote):
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		default:
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		}
		return
	}

	httpkit.JSON(c, http.StatusCreated, created)
}
</file>

<file path="internal/auth/handler/handler.go">
package handler

import (
	"errors"
	"net/http"
	"time"

	"portal_final_backend/internal/auth/service"
	"portal_final_backend/internal/auth/transport"
	"portal_final_backend/internal/auth/validator"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Handler struct {
	svc *service.Service
	cfg *config.Config
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

func New(svc *service.Service, cfg *config.Config) *Handler {
	return &Handler{svc: svc, cfg: cfg}
}

func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.POST("/sign-up", h.SignUp)
	rg.POST("/sign-in", h.SignIn)
	rg.POST("/refresh", h.Refresh)
	rg.POST("/sign-out", h.SignOut)
	rg.POST("/forgot-password", h.ForgotPassword)
	rg.POST("/reset-password", h.ResetPassword)
	rg.POST("/verify-email", h.VerifyEmail)
}

func (h *Handler) ListUsers(c *gin.Context) {
	users, err := h.svc.ListUsers(c.Request.Context())
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	httpkit.OK(c, users)
}

func (h *Handler) GetMe(c *gin.Context) {
	userID, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	profile, err := h.svc.GetMe(c.Request.Context(), userID.(uuid.UUID))
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
		return
	}

	httpkit.OK(c, transport.ProfileResponse{
		ID:            profile.ID.String(),
		Email:         profile.Email,
		EmailVerified: profile.EmailVerified,
		Roles:         profile.Roles,
		CreatedAt:     profile.CreatedAt,
		UpdatedAt:     profile.UpdatedAt,
	})
}

func (h *Handler) UpdateMe(c *gin.Context) {
	userID, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	var req transport.UpdateProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	profile, err := h.svc.UpdateMe(c.Request.Context(), userID.(uuid.UUID), req.Email)
	if err != nil {
		switch {
		case errors.Is(err, service.ErrEmailTaken):
			httpkit.Error(c, http.StatusConflict, err.Error(), nil)
		case errors.Is(err, service.ErrInvalidCredentials):
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		default:
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		}
		return
	}

	httpkit.OK(c, transport.ProfileResponse{
		ID:            profile.ID.String(),
		Email:         profile.Email,
		EmailVerified: profile.EmailVerified,
		Roles:         profile.Roles,
		CreatedAt:     profile.CreatedAt,
		UpdatedAt:     profile.UpdatedAt,
	})
}

func (h *Handler) ChangePassword(c *gin.Context) {
	userID, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	var req transport.ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.ChangePassword(c.Request.Context(), userID.(uuid.UUID), req.CurrentPassword, req.NewPassword); err != nil {
		if errors.Is(err, service.ErrInvalidCurrentPassword) {
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "password updated"})
}

func (h *Handler) SignUp(c *gin.Context) {
	var req transport.SignUpRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.SignUp(c.Request.Context(), req.Email, req.Password); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}
	httpkit.JSON(c, http.StatusCreated, gin.H{"message": "account created"})
}

func (h *Handler) SignIn(c *gin.Context) {
	var req transport.SignInRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	accessToken, refreshToken, err := h.svc.SignIn(c.Request.Context(), req.Email, req.Password)
	if err != nil {
		httpkit.Error(c, http.StatusUnauthorized, err.Error(), nil)
		return
	}

	h.setRefreshCookie(c, refreshToken)
	httpkit.OK(c, transport.AuthResponse{AccessToken: accessToken})
}

func (h *Handler) Refresh(c *gin.Context) {
	refreshToken, err := c.Cookie(h.cfg.RefreshCookieName)
	if err != nil || refreshToken == "" {
		httpkit.Error(c, http.StatusUnauthorized, service.ErrTokenInvalid.Error(), nil)
		return
	}

	accessToken, newRefreshToken, err := h.svc.Refresh(c.Request.Context(), refreshToken)
	if err != nil {
		h.clearRefreshCookie(c)
		httpkit.Error(c, http.StatusUnauthorized, err.Error(), nil)
		return
	}

	h.setRefreshCookie(c, newRefreshToken)
	httpkit.OK(c, transport.AuthResponse{AccessToken: accessToken})
}

func (h *Handler) SignOut(c *gin.Context) {
	if refreshToken, err := c.Cookie(h.cfg.RefreshCookieName); err == nil && refreshToken != "" {
		if err := h.svc.SignOut(c.Request.Context(), refreshToken); err != nil {
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
			return
		}
	}

	h.clearRefreshCookie(c)

	httpkit.OK(c, gin.H{"message": "signed out"})
}

func (h *Handler) ForgotPassword(c *gin.Context) {
	var req transport.ForgotPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.ForgotPassword(c.Request.Context(), req.Email); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}
	httpkit.OK(c, gin.H{"message": "if the account exists, a reset link will be sent"})
}

func (h *Handler) ResetPassword(c *gin.Context) {
	var req transport.ResetPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.ResetPassword(c.Request.Context(), req.Token, req.NewPassword); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "password reset"})
}

func (h *Handler) VerifyEmail(c *gin.Context) {
	var req transport.VerifyEmailRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.VerifyEmail(c.Request.Context(), req.Token); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "email verified"})
}

func (h *Handler) SetUserRoles(c *gin.Context) {
	userID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.RoleUpdateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.SetUserRoles(c.Request.Context(), userID, req.Roles); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, transport.RoleUpdateResponse{UserID: userID.String(), Roles: req.Roles})
}

func (h *Handler) setRefreshCookie(c *gin.Context, value string) {
	maxAge := int(h.cfg.RefreshTokenTTL / time.Second)
	c.SetSameSite(h.cfg.RefreshCookieSameSite)
	c.SetCookie(
		h.cfg.RefreshCookieName,
		value,
		maxAge,
		h.cfg.RefreshCookiePath,
		h.cfg.RefreshCookieDomain,
		h.cfg.RefreshCookieSecure,
		true,
	)
}

func (h *Handler) clearRefreshCookie(c *gin.Context) {
	c.SetSameSite(h.cfg.RefreshCookieSameSite)
	c.SetCookie(
		h.cfg.RefreshCookieName,
		"",
		-1,
		h.cfg.RefreshCookiePath,
		h.cfg.RefreshCookieDomain,
		h.cfg.RefreshCookieSecure,
		true,
	)
}
</file>

<file path="internal/auth/transport/dto.go">
package transport

import "time"

type SignUpRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,strongpassword"`
}

type SignInRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

type ForgotPasswordRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type ResetPasswordRequest struct {
	Token       string `json:"token" validate:"required"`
	NewPassword string `json:"newPassword" validate:"required,strongpassword"`
}

type VerifyEmailRequest struct {
	Token string `json:"token" validate:"required"`
}

type RoleUpdateRequest struct {
	Roles []string `json:"roles" validate:"required,min=1,dive,required"`
}

type RoleUpdateResponse struct {
	UserID string   `json:"userId"`
	Roles  []string `json:"roles"`
}

type AuthResponse struct {
	AccessToken string `json:"accessToken"`
}

type ProfileResponse struct {
	ID            string    `json:"id"`
	Email         string    `json:"email"`
	EmailVerified bool      `json:"emailVerified"`
	Roles         []string  `json:"roles"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

type UpdateProfileRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type ChangePasswordRequest struct {
	CurrentPassword string `json:"currentPassword" validate:"required"`
	NewPassword     string `json:"newPassword" validate:"required,strongpassword"`
}

type UserSummary struct {
	ID    string   `json:"id"`
	Email string   `json:"email"`
	Roles []string `json:"roles"`
}
</file>

<file path="internal/auth/service/service.go">
package service

import (
	"context"
	"errors"
	"strings"
	"time"

	"portal_final_backend/internal/auth/password"
	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/auth/transport"
	"portal_final_backend/internal/events"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

var ErrInvalidCredentials = errors.New("invalid credentials")
var ErrTokenExpired = errors.New("token expired")
var ErrTokenInvalid = errors.New("token invalid")
var ErrEmailNotVerified = errors.New("email not verified")
var ErrEmailTaken = errors.New("email already in use")
var ErrInvalidCurrentPassword = errors.New("current password is incorrect")

const (
	accessTokenType  = "access"
	refreshTokenType = "refresh"
	defaultUserRole  = "user" // Default role for new users (not admin)
)

type Service struct {
	repo     *repository.Repository
	cfg      *config.Config
	eventBus events.Bus
	log      *logger.Logger
}

type Profile struct {
	ID            uuid.UUID
	Email         string
	EmailVerified bool
	Roles         []string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func New(repo *repository.Repository, cfg *config.Config, eventBus events.Bus, log *logger.Logger) *Service {
	return &Service{repo: repo, cfg: cfg, eventBus: eventBus, log: log}
}

func (s *Service) SignUp(ctx context.Context, email, plainPassword string) error {
	hash, err := password.Hash(plainPassword)
	if err != nil {
		s.log.Error("failed to hash password", "error", err)
		return err
	}

	user, err := s.repo.CreateUser(ctx, email, hash)
	if err != nil {
		s.log.Error("failed to create user", "email", email, "error", err)
		return err
	}

	// Assign default 'user' role - not admin
	if err := s.repo.SetUserRoles(ctx, user.ID, []string{defaultUserRole}); err != nil {
		s.log.Error("failed to set user roles", "user_id", user.ID, "error", err)
		return err
	}

	s.log.AuthEvent("signup", email, true, "")

	verifyToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return err
	}

	verifyHash := token.HashSHA256(verifyToken)
	expiresAt := time.Now().Add(s.cfg.VerifyTokenTTL)
	if err := s.repo.CreateUserToken(ctx, user.ID, verifyHash, repository.TokenTypeEmailVerify, expiresAt); err != nil {
		return err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.UserSignedUp{
		BaseEvent:   events.NewBaseEvent(),
		UserID:      user.ID,
		Email:       user.Email,
		VerifyToken: verifyToken,
	})

	return nil
}

func (s *Service) SignIn(ctx context.Context, email, plainPassword string) (string, string, error) {
	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		return "", "", ErrInvalidCredentials
	}

	if err := password.Compare(user.PasswordHash, plainPassword); err != nil {
		return "", "", ErrInvalidCredentials
	}

	if !user.EmailVerified {
		return "", "", ErrEmailNotVerified
	}

	return s.issueTokens(ctx, user.ID)
}

func (s *Service) Refresh(ctx context.Context, refreshToken string) (string, string, error) {
	hash := token.HashSHA256(refreshToken)
	userID, expiresAt, err := s.repo.GetRefreshToken(ctx, hash)
	if err != nil {
		return "", "", ErrTokenInvalid
	}

	if time.Now().After(expiresAt) {
		_ = s.repo.RevokeRefreshToken(ctx, hash)
		return "", "", ErrTokenExpired
	}

	_ = s.repo.RevokeRefreshToken(ctx, hash)
	return s.issueTokens(ctx, userID)
}

func (s *Service) SignOut(ctx context.Context, refreshToken string) error {
	hash := token.HashSHA256(refreshToken)
	return s.repo.RevokeRefreshToken(ctx, hash)
}

func (s *Service) ForgotPassword(ctx context.Context, email string) error {
	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		return nil
	}

	resetToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return err
	}

	resetHash := token.HashSHA256(resetToken)
	expiresAt := time.Now().Add(s.cfg.ResetTokenTTL)
	if err := s.repo.CreateUserToken(ctx, user.ID, resetHash, repository.TokenTypePasswordReset, expiresAt); err != nil {
		return err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.PasswordResetRequested{
		BaseEvent:  events.NewBaseEvent(),
		UserID:     user.ID,
		Email:      user.Email,
		ResetToken: resetToken,
	})

	return nil
}

func (s *Service) ResetPassword(ctx context.Context, rawToken, newPassword string) error {
	hash := token.HashSHA256(rawToken)
	userID, expiresAt, err := s.repo.GetUserToken(ctx, hash, repository.TokenTypePasswordReset)
	if err != nil {
		return ErrTokenInvalid
	}

	if time.Now().After(expiresAt) {
		return ErrTokenExpired
	}

	passwordHash, err := password.Hash(newPassword)
	if err != nil {
		return err
	}

	if err := s.repo.UpdatePassword(ctx, userID, passwordHash); err != nil {
		return err
	}

	_ = s.repo.UseUserToken(ctx, hash, repository.TokenTypePasswordReset)
	_ = s.repo.RevokeAllRefreshTokens(ctx, userID)

	return nil
}

func (s *Service) VerifyEmail(ctx context.Context, rawToken string) error {
	hash := token.HashSHA256(rawToken)
	userID, expiresAt, err := s.repo.GetUserToken(ctx, hash, repository.TokenTypeEmailVerify)
	if err != nil {
		return ErrTokenInvalid
	}

	if time.Now().After(expiresAt) {
		return ErrTokenExpired
	}

	if err := s.repo.MarkEmailVerified(ctx, userID); err != nil {
		return err
	}

	_ = s.repo.UseUserToken(ctx, hash, repository.TokenTypeEmailVerify)
	return nil
}

func (s *Service) issueTokens(ctx context.Context, userID uuid.UUID) (string, string, error) {
	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return "", "", err
	}

	accessToken, err := s.signJWT(userID, roles, s.cfg.AccessTokenTTL, accessTokenType, s.cfg.JWTAccessSecret)
	if err != nil {
		return "", "", err
	}

	refreshToken, err := token.GenerateRandomToken(48)
	if err != nil {
		return "", "", err
	}

	hash := token.HashSHA256(refreshToken)
	expiresAt := time.Now().Add(s.cfg.RefreshTokenTTL)
	if err := s.repo.CreateRefreshToken(ctx, userID, hash, expiresAt); err != nil {
		return "", "", err
	}

	return accessToken, refreshToken, nil
}

func (s *Service) signJWT(userID uuid.UUID, roles []string, ttl time.Duration, tokenType, secret string) (string, error) {
	claims := jwt.MapClaims{
		"sub":   userID.String(),
		"type":  tokenType,
		"roles": roles,
		"exp":   time.Now().Add(ttl).Unix(),
		"iat":   time.Now().Unix(),
	}

	tokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return tokenObj.SignedString([]byte(secret))
}

func (s *Service) SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error {
	return s.repo.SetUserRoles(ctx, userID, roles)
}

func (s *Service) ListUsers(ctx context.Context) ([]transport.UserSummary, error) {
	users, err := s.repo.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]transport.UserSummary, 0, len(users))
	for _, user := range users {
		result = append(result, transport.UserSummary{
			ID:    user.ID.String(),
			Email: user.Email,
			Roles: user.Roles,
		})
	}

	return result, nil
}

func (s *Service) GetMe(ctx context.Context, userID uuid.UUID) (Profile, error) {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	return Profile{
		ID:            user.ID,
		Email:         user.Email,
		EmailVerified: user.EmailVerified,
		Roles:         roles,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
	}, nil
}

func (s *Service) UpdateMe(ctx context.Context, userID uuid.UUID, email string) (Profile, error) {
	current, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	if strings.EqualFold(strings.TrimSpace(email), current.Email) {
		return Profile{
			ID:            current.ID,
			Email:         current.Email,
			EmailVerified: current.EmailVerified,
			Roles:         roles,
			CreatedAt:     current.CreatedAt,
			UpdatedAt:     current.UpdatedAt,
		}, nil
	}

	if existing, err := s.repo.GetUserByEmail(ctx, email); err == nil && existing.ID != userID {
		return Profile{}, ErrEmailTaken
	} else if err != nil && err != repository.ErrNotFound {
		return Profile{}, err
	}

	updated, err := s.repo.UpdateUserEmail(ctx, userID, email)
	if err != nil {
		return Profile{}, err
	}

	verifyToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return Profile{}, err
	}

	verifyHash := token.HashSHA256(verifyToken)
	expiresAt := time.Now().Add(s.cfg.VerifyTokenTTL)
	if err := s.repo.CreateUserToken(ctx, userID, verifyHash, repository.TokenTypeEmailVerify, expiresAt); err != nil {
		return Profile{}, err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.EmailVerificationRequested{
		BaseEvent:   events.NewBaseEvent(),
		UserID:      userID,
		Email:       updated.Email,
		VerifyToken: verifyToken,
	})

	return Profile{
		ID:            updated.ID,
		Email:         updated.Email,
		EmailVerified: updated.EmailVerified,
		Roles:         roles,
		CreatedAt:     updated.CreatedAt,
		UpdatedAt:     updated.UpdatedAt,
	}, nil
}

func (s *Service) ChangePassword(ctx context.Context, userID uuid.UUID, currentPassword, newPassword string) error {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return err
	}

	if err := password.Compare(user.PasswordHash, currentPassword); err != nil {
		return ErrInvalidCurrentPassword
	}

	passwordHash, err := password.Hash(newPassword)
	if err != nil {
		return err
	}

	if err := s.repo.UpdatePassword(ctx, userID, passwordHash); err != nil {
		return err
	}

	_ = s.repo.RevokeAllRefreshTokens(ctx, userID)
	return nil
}

// buildURL is no longer used - URL building moved to notification module
// Kept for potential future use within auth domain
func (s *Service) buildURL(path string, tokenValue string) string {
	base := strings.TrimRight(s.cfg.AppBaseURL, "/")
	return base + path + "?token=" + tokenValue
}
</file>

<file path="internal/leads/repository/repository.go">
package repository

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrNotFound = errors.New("lead not found")

type Repository struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

type Lead struct {
	ID                    uuid.UUID
	ConsumerFirstName     string
	ConsumerLastName      string
	ConsumerPhone         string
	ConsumerEmail         *string
	ConsumerRole          string
	AddressStreet         string
	AddressHouseNumber    string
	AddressZipCode        string
	AddressCity           string
	ServiceType           string
	Status                string
	AssignedAgentID       *uuid.UUID
	ViewedByID            *uuid.UUID
	ViewedAt              *time.Time
	VisitScheduledDate    *time.Time
	VisitScoutID          *uuid.UUID
	VisitMeasurements     *string
	VisitAccessDifficulty *string
	VisitNotes            *string
	VisitCompletedAt      *time.Time
	CreatedAt             time.Time
	UpdatedAt             time.Time
}

type CreateLeadParams struct {
	ConsumerFirstName  string
	ConsumerLastName   string
	ConsumerPhone      string
	ConsumerEmail      *string
	ConsumerRole       string
	AddressStreet      string
	AddressHouseNumber string
	AddressZipCode     string
	AddressCity        string
	ServiceType        string
	AssignedAgentID    *uuid.UUID
}

func (r *Repository) Create(ctx context.Context, params CreateLeadParams) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		INSERT INTO leads (
			consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'New', $11)
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`,
		params.ConsumerFirstName, params.ConsumerLastName, params.ConsumerPhone, params.ConsumerEmail, params.ConsumerRole,
		params.AddressStreet, params.AddressHouseNumber, params.AddressZipCode, params.AddressCity,
		params.ServiceType, params.AssignedAgentID,
	).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if err != nil {
		return Lead{}, err
	}

	// Also create a corresponding lead_service entry
	_, err = r.CreateLeadService(ctx, CreateLeadServiceParams{
		LeadID:      lead.ID,
		ServiceType: params.ServiceType,
	})
	if err != nil {
		return Lead{}, err
	}

	return lead, nil
}

func (r *Repository) GetByID(ctx context.Context, id uuid.UUID) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM leads WHERE id = $1 AND deleted_at IS NULL
	`, id).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

// GetByIDWithServices returns a lead with all its services populated
func (r *Repository) GetByIDWithServices(ctx context.Context, id uuid.UUID) (Lead, []LeadService, error) {
	lead, err := r.GetByID(ctx, id)
	if err != nil {
		return Lead{}, nil, err
	}

	services, err := r.ListLeadServices(ctx, id)
	if err != nil {
		return Lead{}, nil, err
	}

	return lead, services, nil
}

func (r *Repository) GetByPhone(ctx context.Context, phone string) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM leads WHERE consumer_phone = $1 AND deleted_at IS NULL
		ORDER BY created_at DESC
		LIMIT 1
	`, phone).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

type UpdateLeadParams struct {
	ConsumerFirstName  *string
	ConsumerLastName   *string
	ConsumerPhone      *string
	ConsumerEmail      *string
	ConsumerRole       *string
	AddressStreet      *string
	AddressHouseNumber *string
	AddressZipCode     *string
	AddressCity        *string
	ServiceType        *string
	Status             *string
	AssignedAgentID    *uuid.UUID
	AssignedAgentIDSet bool
}

func (r *Repository) Update(ctx context.Context, id uuid.UUID, params UpdateLeadParams) (Lead, error) {
	setClauses := []string{}
	args := []interface{}{}
	argIdx := 1

	if params.ConsumerFirstName != nil {
		setClauses = append(setClauses, fmt.Sprintf("consumer_first_name = $%d", argIdx))
		args = append(args, *params.ConsumerFirstName)
		argIdx++
	}
	if params.ConsumerLastName != nil {
		setClauses = append(setClauses, fmt.Sprintf("consumer_last_name = $%d", argIdx))
		args = append(args, *params.ConsumerLastName)
		argIdx++
	}
	if params.ConsumerPhone != nil {
		setClauses = append(setClauses, fmt.Sprintf("consumer_phone = $%d", argIdx))
		args = append(args, *params.ConsumerPhone)
		argIdx++
	}
	if params.ConsumerEmail != nil {
		setClauses = append(setClauses, fmt.Sprintf("consumer_email = $%d", argIdx))
		args = append(args, *params.ConsumerEmail)
		argIdx++
	}
	if params.ConsumerRole != nil {
		setClauses = append(setClauses, fmt.Sprintf("consumer_role = $%d", argIdx))
		args = append(args, *params.ConsumerRole)
		argIdx++
	}
	if params.AddressStreet != nil {
		setClauses = append(setClauses, fmt.Sprintf("address_street = $%d", argIdx))
		args = append(args, *params.AddressStreet)
		argIdx++
	}
	if params.AddressHouseNumber != nil {
		setClauses = append(setClauses, fmt.Sprintf("address_house_number = $%d", argIdx))
		args = append(args, *params.AddressHouseNumber)
		argIdx++
	}
	if params.AddressZipCode != nil {
		setClauses = append(setClauses, fmt.Sprintf("address_zip_code = $%d", argIdx))
		args = append(args, *params.AddressZipCode)
		argIdx++
	}
	if params.AddressCity != nil {
		setClauses = append(setClauses, fmt.Sprintf("address_city = $%d", argIdx))
		args = append(args, *params.AddressCity)
		argIdx++
	}
	if params.ServiceType != nil {
		setClauses = append(setClauses, fmt.Sprintf("service_type = $%d", argIdx))
		args = append(args, *params.ServiceType)
		argIdx++
	}
	if params.AssignedAgentIDSet {
		setClauses = append(setClauses, fmt.Sprintf("assigned_agent_id = $%d", argIdx))
		args = append(args, params.AssignedAgentID)
		argIdx++
	}
	if params.Status != nil {
		setClauses = append(setClauses, fmt.Sprintf("status = $%d", argIdx))
		args = append(args, *params.Status)
		argIdx++
	}

	if len(setClauses) == 0 {
		return r.GetByID(ctx, id)
	}

	setClauses = append(setClauses, "updated_at = now()")
	args = append(args, id)

	query := fmt.Sprintf(`
		UPDATE leads SET %s
		WHERE id = $%d AND deleted_at IS NULL
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, strings.Join(setClauses, ", "), argIdx)

	var lead Lead
	err := r.pool.QueryRow(ctx, query, args...).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) UpdateStatus(ctx context.Context, id uuid.UUID, status string) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		UPDATE leads SET status = $2, updated_at = now()
		WHERE id = $1 AND deleted_at IS NULL
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, status).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) SetViewedBy(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE leads SET viewed_by_id = $2, viewed_at = now(), updated_at = now()
		WHERE id = $1 AND deleted_at IS NULL
	`, id, userID)
	return err
}

func (r *Repository) AddActivity(ctx context.Context, leadID uuid.UUID, userID uuid.UUID, action string, meta map[string]interface{}) error {
	var metaJSON []byte
	if meta != nil {
		encoded, err := json.Marshal(meta)
		if err != nil {
			return err
		}
		metaJSON = encoded
	}

	_, err := r.pool.Exec(ctx, `
		INSERT INTO lead_activity (lead_id, user_id, action, meta)
		VALUES ($1, $2, $3, $4)
	`, leadID, userID, action, metaJSON)
	return err
}

func (r *Repository) ScheduleVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		UPDATE leads SET 
			visit_scheduled_date = $2, 
			visit_scout_id = $3,
			status = 'Scheduled',
			updated_at = now()
		WHERE id = $1 AND deleted_at IS NULL
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, scheduledDate, scoutID).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) CompleteSurvey(ctx context.Context, id uuid.UUID, measurements string, accessDifficulty string, notes string) (Lead, error) {
	var lead Lead
	var notesPtr *string
	if notes != "" {
		notesPtr = &notes
	}
	err := r.pool.QueryRow(ctx, `
		UPDATE leads SET 
			visit_measurements = $2,
			visit_access_difficulty = $3,
			visit_notes = $4,
			visit_completed_at = now(),
			status = 'Surveyed',
			updated_at = now()
		WHERE id = $1 AND deleted_at IS NULL
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, measurements, accessDifficulty, notesPtr).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) MarkNoShow(ctx context.Context, id uuid.UUID, notes string) (Lead, error) {
	var lead Lead
	var notesPtr *string
	if notes != "" {
		notesPtr = &notes
	}
	err := r.pool.QueryRow(ctx, `
		UPDATE leads SET 
			visit_notes = COALESCE(visit_notes || E'\n', '') || COALESCE($2, 'No show'),
			status = 'Needs_Rescheduling',
			updated_at = now()
		WHERE id = $1 AND deleted_at IS NULL
		RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
	`, id, notesPtr).Scan(
		&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
		&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
		&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) RescheduleVisit(ctx context.Context, id uuid.UUID, scheduledDate time.Time, scoutID *uuid.UUID, noShowNotes string, markAsNoShow bool) (Lead, error) {
	var lead Lead
	var err error

	if markAsNoShow {
		// Build no-show note
		noShowNote := "No show"
		if noShowNotes != "" {
			noShowNote = "No show: " + noShowNotes
		}

		err = r.pool.QueryRow(ctx, `
			UPDATE leads SET 
				visit_notes = COALESCE(visit_notes || E'\n', '') || $4,
				visit_scheduled_date = $2,
				visit_scout_id = $3,
				visit_measurements = NULL,
				visit_access_difficulty = NULL,
				visit_completed_at = NULL,
				status = 'Scheduled',
				updated_at = now()
			WHERE id = $1 AND deleted_at IS NULL
			RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
				address_street, address_house_number, address_zip_code, address_city,
				service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
				visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
				created_at, updated_at
		`, id, scheduledDate, scoutID, noShowNote).Scan(
			&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
			&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
			&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
			&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
			&lead.CreatedAt, &lead.UpdatedAt,
		)
	} else {
		// Simple reschedule without no-show
		err = r.pool.QueryRow(ctx, `
			UPDATE leads SET 
				visit_scheduled_date = $2,
				visit_scout_id = $3,
				visit_measurements = NULL,
				visit_access_difficulty = NULL,
				visit_completed_at = NULL,
				status = 'Scheduled',
				updated_at = now()
			WHERE id = $1 AND deleted_at IS NULL
			RETURNING id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
				address_street, address_house_number, address_zip_code, address_city,
				service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
				visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
				created_at, updated_at
		`, id, scheduledDate, scoutID).Scan(
			&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
			&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
			&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
			&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
			&lead.CreatedAt, &lead.UpdatedAt,
		)
	}

	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

type ListParams struct {
	Status      *string
	ServiceType *string
	Search      string
	Offset      int
	Limit       int
	SortBy      string
	SortOrder   string
}

func (r *Repository) List(ctx context.Context, params ListParams) ([]Lead, int, error) {
	whereClauses := []string{"deleted_at IS NULL"}
	args := []interface{}{}
	argIdx := 1

	if params.Status != nil {
		whereClauses = append(whereClauses, fmt.Sprintf("status = $%d", argIdx))
		args = append(args, *params.Status)
		argIdx++
	}
	if params.ServiceType != nil {
		whereClauses = append(whereClauses, fmt.Sprintf("service_type = $%d", argIdx))
		args = append(args, *params.ServiceType)
		argIdx++
	}
	if params.Search != "" {
		searchPattern := "%" + params.Search + "%"
		whereClauses = append(whereClauses, fmt.Sprintf(
			"(consumer_first_name ILIKE $%d OR consumer_last_name ILIKE $%d OR consumer_phone ILIKE $%d OR consumer_email ILIKE $%d OR address_city ILIKE $%d)",
			argIdx, argIdx, argIdx, argIdx, argIdx,
		))
		args = append(args, searchPattern)
		argIdx++
	}

	whereClause := strings.Join(whereClauses, " AND ")

	var total int
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM leads WHERE %s", whereClause)
	if err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, err
	}

	sortColumn := "created_at"
	switch params.SortBy {
	case "scheduledDate":
		sortColumn = "visit_scheduled_date"
	case "status":
		sortColumn = "status"
	case "firstName":
		sortColumn = "consumer_first_name"
	case "lastName":
		sortColumn = "consumer_last_name"
	}
	sortOrder := "DESC"
	if params.SortOrder == "asc" {
		sortOrder = "ASC"
	}

	args = append(args, params.Limit, params.Offset)

	query := fmt.Sprintf(`
		SELECT id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city,
			service_type, status, assigned_agent_id, viewed_by_id, viewed_at,
			visit_scheduled_date, visit_scout_id, visit_measurements, visit_access_difficulty, visit_notes, visit_completed_at,
			created_at, updated_at
		FROM leads
		WHERE %s
		ORDER BY %s %s
		LIMIT $%d OFFSET $%d
	`, whereClause, sortColumn, sortOrder, argIdx, argIdx+1)

	rows, err := r.pool.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	leads := make([]Lead, 0)
	for rows.Next() {
		var lead Lead
		if err := rows.Scan(
			&lead.ID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
			&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity,
			&lead.ServiceType, &lead.Status, &lead.AssignedAgentID, &lead.ViewedByID, &lead.ViewedAt,
			&lead.VisitScheduledDate, &lead.VisitScoutID, &lead.VisitMeasurements, &lead.VisitAccessDifficulty, &lead.VisitNotes, &lead.VisitCompletedAt,
			&lead.CreatedAt, &lead.UpdatedAt,
		); err != nil {
			return nil, 0, err
		}
		leads = append(leads, lead)
	}

	if rows.Err() != nil {
		return nil, 0, rows.Err()
	}

	return leads, total, nil
}

func (r *Repository) Delete(ctx context.Context, id uuid.UUID) error {
	result, err := r.pool.Exec(ctx, "UPDATE leads SET deleted_at = now(), updated_at = now() WHERE id = $1 AND deleted_at IS NULL", id)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (r *Repository) BulkDelete(ctx context.Context, ids []uuid.UUID) (int, error) {
	result, err := r.pool.Exec(ctx, "UPDATE leads SET deleted_at = now(), updated_at = now() WHERE id = ANY($1) AND deleted_at IS NULL", ids)
	if err != nil {
		return 0, err
	}
	return int(result.RowsAffected()), nil
}
</file>

<file path="internal/leads/handler/handler.go">
package handler

import (
	"errors"
	"net/http"

	"portal_final_backend/internal/leads/management"
	"portal_final_backend/internal/leads/scheduling"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// Handler handles HTTP requests for leads.
// Uses focused services following vertical slicing pattern.
type Handler struct {
	mgmt         *management.Service
	scheduling   *scheduling.Service
	notesHandler *NotesHandler
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

// New creates a new leads handler with focused services.
func New(mgmt *management.Service, scheduling *scheduling.Service, notesHandler *NotesHandler) *Handler {
	return &Handler{mgmt: mgmt, scheduling: scheduling, notesHandler: notesHandler}
}

func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("", h.List)
	rg.POST("", h.Create)
	rg.GET("/check-duplicate", h.CheckDuplicate)
	rg.GET("/:id", h.GetByID)
	rg.PUT("/:id", h.Update)
	rg.DELETE("/:id", h.Delete)
	rg.POST("/bulk-delete", h.BulkDelete)
	rg.PATCH("/:id/status", h.UpdateStatus)
	rg.PUT(":id/assign", h.Assign)
	rg.POST("/:id/schedule", h.ScheduleVisit)
	rg.POST("/:id/reschedule", h.RescheduleVisit)
	rg.POST("/:id/survey", h.CompleteSurvey)
	rg.POST("/:id/no-show", h.MarkNoShow)
	rg.POST("/:id/view", h.MarkViewed)
	rg.GET("/:id/notes", h.notesHandler.ListNotes)
	rg.POST("/:id/notes", h.notesHandler.AddNote)
	rg.GET("/:id/visit-history", h.ListVisitHistory)
	// Service-specific routes
	rg.POST("/:id/services", h.AddService)
	rg.PATCH("/:id/services/:serviceId/status", h.UpdateServiceStatus)
}

func (h *Handler) Create(c *gin.Context) {
	var req transport.CreateLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.Create(c.Request.Context(), req)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.JSON(c, http.StatusCreated, lead)
}

func (h *Handler) GetByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	lead, err := h.mgmt.GetByID(c.Request.Context(), id)
	if err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	actorIDValue, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}
	rolesValue, ok := c.Get(httpkit.ContextRolesKey)
	if !ok {
		httpkit.Error(c, http.StatusForbidden, "forbidden", nil)
		return
	}

	actorID := actorIDValue.(uuid.UUID)
	roles := rolesValue.([]string)

	lead, err := h.mgmt.Update(c.Request.Context(), id, req, actorID, roles)
	if err != nil {
		switch {
		case errors.Is(err, management.ErrLeadNotFound):
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		case errors.Is(err, management.ErrForbidden):
			httpkit.Error(c, http.StatusForbidden, err.Error(), nil)
			return
		default:
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
			return
		}
	}

	httpkit.OK(c, lead)
}

func (h *Handler) Assign(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.AssignLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	actorIDValue, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}
	rolesValue, ok := c.Get(httpkit.ContextRolesKey)
	if !ok {
		httpkit.Error(c, http.StatusForbidden, "forbidden", nil)
		return
	}

	actorID := actorIDValue.(uuid.UUID)
	roles := rolesValue.([]string)

	lead, err := h.mgmt.Assign(c.Request.Context(), id, req.AssigneeID, actorID, roles)
	if err != nil {
		switch {
		case errors.Is(err, management.ErrLeadNotFound):
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		case errors.Is(err, management.ErrForbidden):
			httpkit.Error(c, http.StatusForbidden, err.Error(), nil)
			return
		default:
			httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
			return
		}
	}

	httpkit.OK(c, lead)
}

func (h *Handler) Delete(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	if err := h.mgmt.Delete(c.Request.Context(), id); err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "lead deleted"})
}

func (h *Handler) BulkDelete(c *gin.Context) {
	var req transport.BulkDeleteLeadsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	deletedCount, err := h.mgmt.BulkDelete(c.Request.Context(), req.IDs)
	if err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, transport.BulkDeleteLeadsResponse{DeletedCount: deletedCount})
}

func (h *Handler) UpdateStatus(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateLeadStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.UpdateStatus(c.Request.Context(), id, req)
	if err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) ScheduleVisit(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.ScheduleVisitRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.scheduling.ScheduleVisit(c.Request.Context(), id, req)
	if err != nil {
		if errors.Is(err, scheduling.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) RescheduleVisit(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.RescheduleVisitRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	actorID, ok := c.Get(httpkit.ContextUserIDKey)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	lead, err := h.scheduling.RescheduleVisit(c.Request.Context(), id, req, actorID.(uuid.UUID))
	if err != nil {
		if errors.Is(err, scheduling.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) CompleteSurvey(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CompleteSurveyRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.scheduling.CompleteSurvey(c.Request.Context(), id, req)
	if err != nil {
		if errors.Is(err, scheduling.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) MarkNoShow(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.MarkNoShowRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	lead, err := h.scheduling.MarkNoShow(c.Request.Context(), id, req)
	if err != nil {
		if errors.Is(err, scheduling.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) MarkViewed(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	userID, exists := c.Get(httpkit.ContextUserIDKey)
	if !exists {
		httpkit.Error(c, http.StatusUnauthorized, "unauthorized", nil)
		return
	}

	if err := h.mgmt.SetViewedBy(c.Request.Context(), id, userID.(uuid.UUID)); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "lead marked as viewed"})
}

func (h *Handler) CheckDuplicate(c *gin.Context) {
	phone := c.Query("phone")
	if phone == "" {
		httpkit.Error(c, http.StatusBadRequest, "phone parameter required", nil)
		return
	}

	result, err := h.mgmt.CheckDuplicate(c.Request.Context(), phone)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) List(c *gin.Context) {
	var req transport.ListLeadsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.mgmt.List(c.Request.Context(), req)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) ListVisitHistory(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.scheduling.ListVisitHistory(c.Request.Context(), id)
	if err != nil {
		if errors.Is(err, scheduling.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) AddService(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.AddServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.AddService(c.Request.Context(), id, req)
	if err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.JSON(c, http.StatusCreated, lead)
}

func (h *Handler) UpdateServiceStatus(c *gin.Context) {
	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateServiceStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := validator.Validate.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.UpdateServiceStatus(c.Request.Context(), leadID, serviceID, req)
	if err != nil {
		if errors.Is(err, management.ErrLeadNotFound) {
			httpkit.Error(c, http.StatusNotFound, err.Error(), nil)
			return
		}
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	httpkit.OK(c, lead)
}
</file>

<file path="internal/leads/transport/dto.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

// Enum values
type ConsumerRole string

const (
	ConsumerRoleOwner    ConsumerRole = "Owner"
	ConsumerRoleTenant   ConsumerRole = "Tenant"
	ConsumerRoleLandlord ConsumerRole = "Landlord"
)

type ServiceType string

const (
	ServiceTypeWindows    ServiceType = "Windows"
	ServiceTypeInsulation ServiceType = "Insulation"
	ServiceTypeSolar      ServiceType = "Solar"
)

type LeadStatus string

const (
	LeadStatusNew               LeadStatus = "New"
	LeadStatusAttemptedContact  LeadStatus = "Attempted_Contact"
	LeadStatusScheduled         LeadStatus = "Scheduled"
	LeadStatusSurveyed          LeadStatus = "Surveyed"
	LeadStatusBadLead           LeadStatus = "Bad_Lead"
	LeadStatusNeedsRescheduling LeadStatus = "Needs_Rescheduling"
	LeadStatusClosed            LeadStatus = "Closed"
)

type AccessDifficulty string

const (
	AccessDifficultyLow    AccessDifficulty = "Low"
	AccessDifficultyMedium AccessDifficulty = "Medium"
	AccessDifficultyHigh   AccessDifficulty = "High"
)

// Request DTOs
type CreateLeadRequest struct {
	FirstName    string       `json:"firstName" validate:"required,min=1,max=100"`
	LastName     string       `json:"lastName" validate:"required,min=1,max=100"`
	Phone        string       `json:"phone" validate:"required,min=5,max=20"`
	Email        string       `json:"email,omitempty" validate:"omitempty,email"`
	ConsumerRole ConsumerRole `json:"consumerRole" validate:"required,oneof=Owner Tenant Landlord"`
	Street       string       `json:"street" validate:"required,min=1,max=200"`
	HouseNumber  string       `json:"houseNumber" validate:"required,min=1,max=20"`
	ZipCode      string       `json:"zipCode" validate:"required,min=1,max=20"`
	City         string       `json:"city" validate:"required,min=1,max=100"`
	ServiceType  ServiceType  `json:"serviceType" validate:"required,oneof=Windows Insulation Solar"`
	AssigneeID   OptionalUUID `json:"assigneeId,omitempty" validate:"-"`
}

type UpdateLeadRequest struct {
	FirstName    *string       `json:"firstName,omitempty" validate:"omitempty,min=1,max=100"`
	LastName     *string       `json:"lastName,omitempty" validate:"omitempty,min=1,max=100"`
	Phone        *string       `json:"phone,omitempty" validate:"omitempty,min=5,max=20"`
	Email        *string       `json:"email,omitempty" validate:"omitempty,email"`
	ConsumerRole *ConsumerRole `json:"consumerRole,omitempty" validate:"omitempty,oneof=Owner Tenant Landlord"`
	Street       *string       `json:"street,omitempty" validate:"omitempty,min=1,max=200"`
	HouseNumber  *string       `json:"houseNumber,omitempty" validate:"omitempty,min=1,max=20"`
	ZipCode      *string       `json:"zipCode,omitempty" validate:"omitempty,min=1,max=20"`
	City         *string       `json:"city,omitempty" validate:"omitempty,min=1,max=100"`
	AssigneeID   OptionalUUID  `json:"assigneeId,omitempty" validate:"-"`
}

type UpdateServiceStatusRequest struct {
	Status LeadStatus `json:"status" validate:"required,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
}

type AddServiceRequest struct {
	ServiceType        ServiceType `json:"serviceType" validate:"required,oneof=Windows Insulation Solar"`
	CloseCurrentStatus bool        `json:"closeCurrentStatus"` // If true, auto-close current active service
}

type UpdateLeadStatusRequest struct {
	Status LeadStatus `json:"status" validate:"required,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
}

type AssignLeadRequest struct {
	AssigneeID *uuid.UUID `json:"assigneeId" validate:"omitempty"`
}

type ScheduleVisitRequest struct {
	ServiceID     uuid.UUID  `json:"serviceId" validate:"required"`
	ScheduledDate time.Time  `json:"scheduledDate" validate:"required"`
	ScoutID       *uuid.UUID `json:"scoutId,omitempty"`
	SendInvite    bool       `json:"sendInvite,omitempty"`
}

type CompleteSurveyRequest struct {
	ServiceID        uuid.UUID        `json:"serviceId" validate:"required"`
	Measurements     string           `json:"measurements" validate:"required,min=1,max=500"`
	AccessDifficulty AccessDifficulty `json:"accessDifficulty" validate:"required,oneof=Low Medium High"`
	Notes            string           `json:"notes,omitempty" validate:"max=2000"`
}

type MarkNoShowRequest struct {
	ServiceID uuid.UUID `json:"serviceId" validate:"required"`
	Notes     string    `json:"notes,omitempty" validate:"max=500"`
}

type RescheduleVisitRequest struct {
	ServiceID     uuid.UUID  `json:"serviceId" validate:"required"`
	NoShowNotes   string     `json:"noShowNotes,omitempty" validate:"max=500"`
	MarkAsNoShow  bool       `json:"markAsNoShow"`
	ScheduledDate time.Time  `json:"scheduledDate" validate:"required"`
	ScoutID       *uuid.UUID `json:"scoutId,omitempty"`
	SendInvite    bool       `json:"sendInvite,omitempty"`
}

type BulkDeleteLeadsRequest struct {
	IDs []uuid.UUID `json:"ids" validate:"required,min=1,dive,required"`
}

type ListLeadsRequest struct {
	Status      *LeadStatus  `form:"status" validate:"omitempty,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
	ServiceType *ServiceType `form:"serviceType" validate:"omitempty,oneof=Windows Insulation Solar"`
	Search      string       `form:"search" validate:"max=100"`
	Page        int          `form:"page" validate:"min=1"`
	PageSize    int          `form:"pageSize" validate:"min=1,max=100"`
	SortBy      string       `form:"sortBy" validate:"omitempty,oneof=createdAt scheduledDate status firstName lastName"`
	SortOrder   string       `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
}

// Response DTOs
type ConsumerResponse struct {
	FirstName string       `json:"firstName"`
	LastName  string       `json:"lastName"`
	Phone     string       `json:"phone"`
	Email     *string      `json:"email,omitempty"`
	Role      ConsumerRole `json:"role"`
}

type AddressResponse struct {
	Street      string `json:"street"`
	HouseNumber string `json:"houseNumber"`
	ZipCode     string `json:"zipCode"`
	City        string `json:"city"`
}

type VisitResponse struct {
	ScheduledDate    *time.Time        `json:"scheduledDate,omitempty"`
	ScoutID          *uuid.UUID        `json:"scoutId,omitempty"`
	Measurements     *string           `json:"measurements,omitempty"`
	AccessDifficulty *AccessDifficulty `json:"accessDifficulty,omitempty"`
	Notes            *string           `json:"notes,omitempty"`
	CompletedAt      *time.Time        `json:"completedAt,omitempty"`
}

type LeadServiceResponse struct {
	ID          uuid.UUID     `json:"id"`
	ServiceType ServiceType   `json:"serviceType"`
	Status      LeadStatus    `json:"status"`
	Visit       VisitResponse `json:"visit"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
}

type LeadResponse struct {
	ID              uuid.UUID             `json:"id"`
	Consumer        ConsumerResponse      `json:"consumer"`
	Address         AddressResponse       `json:"address"`
	Services        []LeadServiceResponse `json:"services"`
	CurrentService  *LeadServiceResponse  `json:"currentService,omitempty"`
	AssignedAgentID *uuid.UUID            `json:"assignedAgentId,omitempty"`
	ViewedByID      *uuid.UUID            `json:"viewedById,omitempty"`
	ViewedAt        *time.Time            `json:"viewedAt,omitempty"`
	CreatedAt       time.Time             `json:"createdAt"`
	UpdatedAt       time.Time             `json:"updatedAt"`
}

type LeadListResponse struct {
	Items      []LeadResponse `json:"items"`
	Total      int            `json:"total"`
	Page       int            `json:"page"`
	PageSize   int            `json:"pageSize"`
	TotalPages int            `json:"totalPages"`
}

type DuplicateCheckResponse struct {
	IsDuplicate  bool          `json:"isDuplicate"`
	ExistingLead *LeadResponse `json:"existingLead,omitempty"`
}

type BulkDeleteLeadsResponse struct {
	DeletedCount int `json:"deletedCount"`
}

// Visit history types
type VisitOutcome string

const (
	VisitOutcomeCompleted   VisitOutcome = "completed"
	VisitOutcomeNoShow      VisitOutcome = "no_show"
	VisitOutcomeRescheduled VisitOutcome = "rescheduled"
	VisitOutcomeCancelled   VisitOutcome = "cancelled"
)

type VisitHistoryResponse struct {
	ID               uuid.UUID         `json:"id"`
	LeadID           uuid.UUID         `json:"leadId"`
	ScheduledDate    time.Time         `json:"scheduledDate"`
	ScoutID          *uuid.UUID        `json:"scoutId,omitempty"`
	Outcome          VisitOutcome      `json:"outcome"`
	Measurements     *string           `json:"measurements,omitempty"`
	AccessDifficulty *AccessDifficulty `json:"accessDifficulty,omitempty"`
	Notes            *string           `json:"notes,omitempty"`
	CompletedAt      *time.Time        `json:"completedAt,omitempty"`
	CreatedAt        time.Time         `json:"createdAt"`
}

type VisitHistoryListResponse struct {
	Items []VisitHistoryResponse `json:"items"`
}
</file>

<file path="internal/http/router/router.go">
package router

import (
	"net/http"
	"time"

	"portal_final_backend/internal/adapters"
	"portal_final_backend/internal/auth"
	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/leads"
	"portal_final_backend/internal/notification"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/logger"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"golang.org/x/time/rate"
)

func New(cfg *config.Config, pool *pgxpool.Pool, log *logger.Logger) *gin.Engine {
	engine := gin.New()
	engine.Use(gin.Recovery())

	// Security headers
	engine.Use(httpkit.SecurityHeaders())

	// Request logging
	engine.Use(httpkit.RequestLogger(log))

	// Global rate limiter (100 requests per second, burst of 200)
	globalLimiter := httpkit.NewIPRateLimiter(rate.Limit(100), 200, log)
	engine.Use(globalLimiter.RateLimit())

	corsConfig := cors.Config{
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: cfg.CORSAllowCreds,
		MaxAge:           12 * time.Hour,
	}
	if cfg.CORSAllowAll {
		corsConfig.AllowAllOrigins = true
	} else {
		corsConfig.AllowOrigins = cfg.CORSOrigins
	}
	engine.Use(cors.New(corsConfig))

	sender, err := email.NewSender(cfg)
	if err != nil {
		log.Error("failed to initialize email sender", "error", err)
		panic(err)
	}

	// Event bus for decoupled communication between modules
	eventBus := events.NewInMemoryBus(log)

	// Notification module subscribes to domain events (not HTTP-facing)
	notificationModule := notification.New(sender, cfg, log)
	notificationModule.RegisterHandlers(eventBus)

	// Health check endpoint (outside versioned API)
	engine.GET("/api/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	// Set up route groups
	v1 := engine.Group("/api/v1")
	protected := v1.Group("")
	protected.Use(httpkit.AuthRequired(cfg))
	admin := v1.Group("/admin")
	admin.Use(httpkit.AuthRequired(cfg), httpkit.RequireRole("admin"))

	// Router context provides shared dependencies to modules
	routerCtx := &apphttp.RouterContext{
		Engine:          engine,
		V1:              v1,
		Protected:       protected,
		Admin:           admin,
		Config:          cfg,
		AuthMiddleware:  httpkit.AuthRequired(cfg),
		AuthRateLimiter: httpkit.NewAuthRateLimiter(log),
	}

	// Initialize domain modules
	authModule := auth.NewModule(pool, cfg, eventBus, log)
	leadsModule := leads.NewModule(pool, eventBus)

	// Anti-Corruption Layer: Create adapter for cross-domain communication
	// This ensures leads module only depends on its own AgentProvider interface
	_ = adapters.NewAuthAgentProvider(authModule.Service())

	// Register all HTTP modules
	modules := []apphttp.Module{
		authModule,
		leadsModule,
	}

	for _, mod := range modules {
		log.Info("registering module routes", "module", mod.Name())
		mod.RegisterRoutes(routerCtx)
	}

	return engine
}
</file>

<file path="internal/leads/service/service.go">
package service

import (
	"context"
	"errors"
	"time"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/phone"

	"github.com/google/uuid"
)

var (
	ErrLeadNotFound      = errors.New("lead not found")
	ErrServiceNotFound   = errors.New("lead service not found")
	ErrDuplicatePhone    = errors.New("a lead with this phone number already exists")
	ErrInvalidTransition = errors.New("invalid status transition")
	ErrForbidden         = errors.New("forbidden")
	ErrInvalidNote       = errors.New("invalid note")
	ErrVisitNotScheduled = errors.New("visit is not scheduled")
	ErrVisitInFuture     = errors.New("cannot complete a visit scheduled in the future")
	ErrScheduledInPast   = errors.New("cannot schedule a visit in the past")
)

type Service struct {
	repo     *repository.Repository
	eventBus events.Bus
}

func New(repo *repository.Repository, eventBus events.Bus) *Service {
	return &Service{repo: repo, eventBus: eventBus}
}

func (s *Service) Create(ctx context.Context, req transport.CreateLeadRequest) (transport.LeadResponse, error) {
	req.Phone = phone.NormalizeE164(req.Phone)

	params := repository.CreateLeadParams{
		ConsumerFirstName:  req.FirstName,
		ConsumerLastName:   req.LastName,
		ConsumerPhone:      req.Phone,
		ConsumerRole:       string(req.ConsumerRole),
		AddressStreet:      req.Street,
		AddressHouseNumber: req.HouseNumber,
		AddressZipCode:     req.ZipCode,
		AddressCity:        req.City,
		ServiceType:        string(req.ServiceType),
	}

	if req.AssigneeID.Set {
		params.AssignedAgentID = req.AssigneeID.Value
	}

	if req.Email != "" {
		params.ConsumerEmail = &req.Email
	}

	lead, err := s.repo.Create(ctx, params)
	if err != nil {
		return transport.LeadResponse{}, err
	}

	// Fetch services for the response
	services, _ := s.repo.ListLeadServices(ctx, lead.ID)
	return toLeadResponseWithServices(lead, services), nil
}

// AddService adds a new service to an existing lead
func (s *Service) AddService(ctx context.Context, leadID uuid.UUID, req transport.AddServiceRequest) (transport.LeadResponse, error) {
	// Verify lead exists
	lead, err := s.repo.GetByID(ctx, leadID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Optionally close all active services
	if req.CloseCurrentStatus {
		if err := s.repo.CloseAllActiveServices(ctx, leadID); err != nil {
			return transport.LeadResponse{}, err
		}
	}

	// Create the new service
	_, err = s.repo.CreateLeadService(ctx, repository.CreateLeadServiceParams{
		LeadID:      leadID,
		ServiceType: string(req.ServiceType),
	})
	if err != nil {
		return transport.LeadResponse{}, err
	}

	// Fetch updated lead with services
	services, _ := s.repo.ListLeadServices(ctx, leadID)
	return toLeadResponseWithServices(lead, services), nil
}

// UpdateServiceStatus updates the status of a specific service
func (s *Service) UpdateServiceStatus(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, req transport.UpdateServiceStatusRequest) (transport.LeadResponse, error) {
	// Verify service belongs to lead
	svc, err := s.repo.GetLeadServiceByID(ctx, serviceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}
	if svc.LeadID != leadID {
		return transport.LeadResponse{}, ErrServiceNotFound
	}

	// Update service status
	_, err = s.repo.UpdateServiceStatus(ctx, serviceID, string(req.Status))
	if err != nil {
		return transport.LeadResponse{}, err
	}

	// Return updated lead
	return s.GetByID(ctx, leadID)
}

func (s *Service) GetByID(ctx context.Context, id uuid.UUID) (transport.LeadResponse, error) {
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) Update(ctx context.Context, id uuid.UUID, req transport.UpdateLeadRequest, actorID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	params := repository.UpdateLeadParams{}
	var current repository.Lead
	loadedCurrent := false

	if req.AssigneeID.Set {
		lead, err := s.repo.GetByID(ctx, id)
		if err != nil {
			if errors.Is(err, repository.ErrNotFound) {
				return transport.LeadResponse{}, ErrLeadNotFound
			}
			return transport.LeadResponse{}, err
		}
		current = lead
		loadedCurrent = true

		if !hasRole(actorRoles, "admin") {
			if current.AssignedAgentID == nil || *current.AssignedAgentID != actorID {
				return transport.LeadResponse{}, ErrForbidden
			}
		}

		params.AssignedAgentID = req.AssigneeID.Value
		params.AssignedAgentIDSet = true
	}

	if req.FirstName != nil {
		params.ConsumerFirstName = req.FirstName
	}
	if req.LastName != nil {
		params.ConsumerLastName = req.LastName
	}
	if req.Phone != nil {
		normalized := phone.NormalizeE164(*req.Phone)
		params.ConsumerPhone = &normalized
	}
	if req.Email != nil {
		params.ConsumerEmail = req.Email
	}
	if req.ConsumerRole != nil {
		role := string(*req.ConsumerRole)
		params.ConsumerRole = &role
	}
	if req.Street != nil {
		params.AddressStreet = req.Street
	}
	if req.HouseNumber != nil {
		params.AddressHouseNumber = req.HouseNumber
	}
	if req.ZipCode != nil {
		params.AddressZipCode = req.ZipCode
	}
	if req.City != nil {
		params.AddressCity = req.City
	}

	lead, err := s.repo.Update(ctx, id, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	if req.AssigneeID.Set && loadedCurrent {
		if !equalUUIDPtrs(current.AssignedAgentID, req.AssigneeID.Value) {
			_ = s.repo.AddActivity(ctx, id, actorID, "assigned", map[string]interface{}{
				"from": current.AssignedAgentID,
				"to":   req.AssigneeID.Value,
			})
		}
	}

	// Fetch services for the response
	services, _ := s.repo.ListLeadServices(ctx, lead.ID)
	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) Assign(ctx context.Context, id uuid.UUID, assigneeID *uuid.UUID, actorID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	current, err := s.repo.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	if !hasRole(actorRoles, "admin") {
		if current.AssignedAgentID == nil || *current.AssignedAgentID != actorID {
			return transport.LeadResponse{}, ErrForbidden
		}
	}

	params := repository.UpdateLeadParams{
		AssignedAgentID:    assigneeID,
		AssignedAgentIDSet: true,
	}
	updated, err := s.repo.Update(ctx, id, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	_ = s.repo.AddActivity(ctx, id, actorID, "assigned", map[string]interface{}{
		"from": current.AssignedAgentID,
		"to":   assigneeID,
	})

	return toLeadResponse(updated), nil
}

func (s *Service) UpdateStatus(ctx context.Context, id uuid.UUID, req transport.UpdateLeadStatusRequest) (transport.LeadResponse, error) {
	lead, err := s.repo.UpdateStatus(ctx, id, string(req.Status))
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return toLeadResponse(lead), nil
}

func (s *Service) ScheduleVisit(ctx context.Context, id uuid.UUID, req transport.ScheduleVisitRequest) (transport.LeadResponse, error) {
	// Validate scheduled date is not in the past
	today := time.Now().Truncate(24 * time.Hour)
	scheduledDay := req.ScheduledDate.Truncate(24 * time.Hour)
	if scheduledDay.Before(today) {
		return transport.LeadResponse{}, ErrScheduledInPast
	}

	// Schedule visit on the service
	_, err := s.repo.ScheduleServiceVisit(ctx, req.ServiceID, req.ScheduledDate, req.ScoutID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.VisitScheduled{
		BaseEvent:          events.NewBaseEvent(),
		LeadID:             id,
		ServiceID:          req.ServiceID,
		ScheduledDate:      req.ScheduledDate,
		ScoutID:            req.ScoutID,
		ConsumerEmail:      lead.ConsumerEmail,
		ConsumerFirstName:  lead.ConsumerFirstName,
		ConsumerLastName:   lead.ConsumerLastName,
		AddressStreet:      lead.AddressStreet,
		AddressHouseNumber: lead.AddressHouseNumber,
		AddressZipCode:     lead.AddressZipCode,
		AddressCity:        lead.AddressCity,
		SendInvite:         req.SendInvite,
	})

	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) CompleteSurvey(ctx context.Context, id uuid.UUID, req transport.CompleteSurveyRequest) (transport.LeadResponse, error) {
	// Get current service to check scheduled date
	currentService, err := s.repo.GetLeadServiceByID(ctx, req.ServiceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Check if visit is scheduled
	if currentService.VisitScheduledDate == nil {
		return transport.LeadResponse{}, ErrVisitNotScheduled
	}

	// Check if scheduled date is in the future
	if currentService.VisitScheduledDate.After(time.Now()) {
		return transport.LeadResponse{}, ErrVisitInFuture
	}

	// Complete survey on the service
	_, err = s.repo.CompleteServiceSurvey(ctx, req.ServiceID, req.Measurements, string(req.AccessDifficulty), req.Notes)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) MarkNoShow(ctx context.Context, id uuid.UUID, req transport.MarkNoShowRequest) (transport.LeadResponse, error) {
	// Mark no-show on the service
	_, err := s.repo.MarkServiceNoShow(ctx, req.ServiceID, req.Notes)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) RescheduleVisit(ctx context.Context, id uuid.UUID, req transport.RescheduleVisitRequest, actorID uuid.UUID) (transport.LeadResponse, error) {
	// Validate scheduled date is not in the past
	today := time.Now().Truncate(24 * time.Hour)
	scheduledDay := req.ScheduledDate.Truncate(24 * time.Hour)
	if scheduledDay.Before(today) {
		return transport.LeadResponse{}, ErrScheduledInPast
	}

	// Get current service to capture old visit data for history
	currentService, err := s.repo.GetLeadServiceByID(ctx, req.ServiceID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Store the old visit in history if there was a scheduled date
	if currentService.VisitScheduledDate != nil {
		outcome := "rescheduled"
		if req.MarkAsNoShow {
			outcome = "no_show"
		}

		_, _ = s.repo.CreateVisitHistory(ctx, repository.CreateVisitHistoryParams{
			LeadID:           id,
			ScheduledDate:    *currentService.VisitScheduledDate,
			ScoutID:          currentService.VisitScoutID,
			Outcome:          outcome,
			Measurements:     currentService.VisitMeasurements,
			AccessDifficulty: currentService.VisitAccessDifficulty,
			Notes:            &req.NoShowNotes,
			CompletedAt:      currentService.VisitCompletedAt,
		})
	}

	// Perform the reschedule on the service
	_, err = s.repo.RescheduleServiceVisit(ctx, req.ServiceID, req.ScheduledDate, req.ScoutID, req.NoShowNotes, req.MarkAsNoShow)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, ErrServiceNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Log the no-show to activity only if marked as no-show
	if req.MarkAsNoShow {
		_ = s.repo.AddActivity(ctx, id, actorID, "no_show", map[string]interface{}{
			"serviceId":             req.ServiceID,
			"previousScheduledDate": currentService.VisitScheduledDate,
			"notes":                 req.NoShowNotes,
		})
	}

	// Log the reschedule to activity
	_ = s.repo.AddActivity(ctx, id, actorID, "rescheduled", map[string]interface{}{
		"serviceId":             req.ServiceID,
		"previousScheduledDate": currentService.VisitScheduledDate,
		"newScheduledDate":      req.ScheduledDate,
		"scoutId":               req.ScoutID,
	})

	// Return the lead with all services
	lead, services, err := s.repo.GetByIDWithServices(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, ErrLeadNotFound
		}
		return transport.LeadResponse{}, err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.VisitRescheduled{
		BaseEvent:          events.NewBaseEvent(),
		LeadID:             id,
		ServiceID:          req.ServiceID,
		PreviousDate:       currentService.VisitScheduledDate,
		NewScheduledDate:   req.ScheduledDate,
		ScoutID:            req.ScoutID,
		MarkedAsNoShow:     req.MarkAsNoShow,
		ConsumerEmail:      lead.ConsumerEmail,
		ConsumerFirstName:  lead.ConsumerFirstName,
		ConsumerLastName:   lead.ConsumerLastName,
		AddressStreet:      lead.AddressStreet,
		AddressHouseNumber: lead.AddressHouseNumber,
		AddressZipCode:     lead.AddressZipCode,
		AddressCity:        lead.AddressCity,
		SendInvite:         req.SendInvite,
	})

	return toLeadResponseWithServices(lead, services), nil
}

func (s *Service) SetViewedBy(ctx context.Context, id uuid.UUID, userID uuid.UUID) error {
	return s.repo.SetViewedBy(ctx, id, userID)
}

func (s *Service) CheckDuplicate(ctx context.Context, phone string) (transport.DuplicateCheckResponse, error) {
	lead, err := s.repo.GetByPhone(ctx, phone)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.DuplicateCheckResponse{IsDuplicate: false}, nil
		}
		return transport.DuplicateCheckResponse{}, err
	}

	resp := toLeadResponse(lead)
	return transport.DuplicateCheckResponse{
		IsDuplicate:  true,
		ExistingLead: &resp,
	}, nil
}

func (s *Service) List(ctx context.Context, req transport.ListLeadsRequest) (transport.LeadListResponse, error) {
	if req.Page < 1 {
		req.Page = 1
	}
	if req.PageSize < 1 {
		req.PageSize = 20
	}
	if req.PageSize > 100 {
		req.PageSize = 100
	}

	params := repository.ListParams{
		Search:    req.Search,
		Offset:    (req.Page - 1) * req.PageSize,
		Limit:     req.PageSize,
		SortBy:    req.SortBy,
		SortOrder: req.SortOrder,
	}

	if req.Status != nil {
		status := string(*req.Status)
		params.Status = &status
	}
	if req.ServiceType != nil {
		serviceType := string(*req.ServiceType)
		params.ServiceType = &serviceType
	}

	leads, total, err := s.repo.List(ctx, params)
	if err != nil {
		return transport.LeadListResponse{}, err
	}

	items := make([]transport.LeadResponse, len(leads))
	for i, lead := range leads {
		// Fetch services for each lead
		services, _ := s.repo.ListLeadServices(ctx, lead.ID)
		items[i] = toLeadResponseWithServices(lead, services)
	}

	totalPages := (total + req.PageSize - 1) / req.PageSize

	return transport.LeadListResponse{
		Items:      items,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

func (s *Service) Delete(ctx context.Context, id uuid.UUID) error {
	err := s.repo.Delete(ctx, id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return ErrLeadNotFound
		}
		return err
	}
	return nil
}

func (s *Service) BulkDelete(ctx context.Context, ids []uuid.UUID) (int, error) {
	deletedCount, err := s.repo.BulkDelete(ctx, ids)
	if err != nil {
		return 0, err
	}
	if deletedCount == 0 {
		return 0, ErrLeadNotFound
	}
	return deletedCount, nil
}

func toLeadResponse(lead repository.Lead) transport.LeadResponse {
	return transport.LeadResponse{
		ID:              lead.ID,
		AssignedAgentID: lead.AssignedAgentID,
		ViewedByID:      lead.ViewedByID,
		ViewedAt:        lead.ViewedAt,
		CreatedAt:       lead.CreatedAt,
		UpdatedAt:       lead.UpdatedAt,
		Services:        []transport.LeadServiceResponse{},
		Consumer: transport.ConsumerResponse{
			FirstName: lead.ConsumerFirstName,
			LastName:  lead.ConsumerLastName,
			Phone:     lead.ConsumerPhone,
			Email:     lead.ConsumerEmail,
			Role:      transport.ConsumerRole(lead.ConsumerRole),
		},
		Address: transport.AddressResponse{
			Street:      lead.AddressStreet,
			HouseNumber: lead.AddressHouseNumber,
			ZipCode:     lead.AddressZipCode,
			City:        lead.AddressCity,
		},
	}
}

func toLeadResponseWithServices(lead repository.Lead, services []repository.LeadService) transport.LeadResponse {
	resp := toLeadResponse(lead)

	// Convert services
	resp.Services = make([]transport.LeadServiceResponse, len(services))
	for i, svc := range services {
		resp.Services[i] = toLeadServiceResponse(svc)
	}

	// Set current service (first non-terminal or first if all terminal)
	if len(services) > 0 {
		for _, svc := range services {
			if svc.Status != "Closed" && svc.Status != "Bad_Lead" && svc.Status != "Surveyed" {
				svcResp := toLeadServiceResponse(svc)
				resp.CurrentService = &svcResp
				break
			}
		}
		// If no active service found, use the most recent one
		if resp.CurrentService == nil {
			svcResp := toLeadServiceResponse(services[0])
			resp.CurrentService = &svcResp
		}
	}

	return resp
}

func toLeadServiceResponse(svc repository.LeadService) transport.LeadServiceResponse {
	resp := transport.LeadServiceResponse{
		ID:          svc.ID,
		ServiceType: transport.ServiceType(svc.ServiceType),
		Status:      transport.LeadStatus(svc.Status),
		CreatedAt:   svc.CreatedAt,
		UpdatedAt:   svc.UpdatedAt,
		Visit: transport.VisitResponse{
			ScheduledDate: svc.VisitScheduledDate,
			ScoutID:       svc.VisitScoutID,
			Measurements:  svc.VisitMeasurements,
			Notes:         svc.VisitNotes,
			CompletedAt:   svc.VisitCompletedAt,
		},
	}

	if svc.VisitAccessDifficulty != nil {
		difficulty := transport.AccessDifficulty(*svc.VisitAccessDifficulty)
		resp.Visit.AccessDifficulty = &difficulty
	}

	return resp
}

func hasRole(roles []string, target string) bool {
	for _, role := range roles {
		if role == target {
			return true
		}
	}
	return false
}

func equalUUIDPtrs(a *uuid.UUID, b *uuid.UUID) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}
</file>

</files>
