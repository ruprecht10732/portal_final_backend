This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.air.toml
.dockerignore
.gitignore
.golangci.yml
cmd/api/main.go
cmd/lead-energylabel-backfill/main.go
cmd/lead-energylabel-backfill/README.md
cmd/lead-enrichment-backfill/main.go
cmd/lead-geocode/main.go
cmd/scheduler/main.go
Dockerfile
go.mod
healthcheck.sh
internal/adapters/appointment_public_slots_adapter.go
internal/adapters/appointments_adapter.go
internal/adapters/appointments_lead_assigner.go
internal/adapters/auth_agent_provider.go
internal/adapters/catalog_product_reader.go
internal/adapters/energylabel_adapter.go
internal/adapters/lead_enrichment_adapter.go
internal/adapters/lead_timeline_writer.go
internal/adapters/offer_summary_generator_adapter.go
internal/adapters/org_settings_adapter.go
internal/adapters/organization_public_viewer.go
internal/adapters/partner_offer_adapter.go
internal/adapters/partner_offers_timeline_writer.go
internal/adapters/public_viewers.go
internal/adapters/quote_acceptance_processor.go
internal/adapters/quote_activity_writer.go
internal/adapters/quote_generator.go
internal/adapters/quotes_contact_reader.go
internal/adapters/quotes_draft_writer.go
internal/adapters/quotes_timeline_writer.go
internal/adapters/storage/client.go
internal/adapters/storage/service.go
internal/adapters/storage/validation.go
internal/appointments/handler/handler.go
internal/appointments/module.go
internal/appointments/repository/availability.go
internal/appointments/repository/repository.go
internal/appointments/repository/visit_reports.go
internal/appointments/service/service.go
internal/appointments/transport/dto.go
internal/auth/adapter/user_provider.go
internal/auth/auth.go
internal/auth/db/db.go
internal/auth/db/models.go
internal/auth/db/querier.go
internal/auth/db/queries.sql.go
internal/auth/handler/handler.go
internal/auth/migrations/001_init.sql
internal/auth/migrations/002_roles.sql
internal/auth/migrations/003_user_profile_settings.sql
internal/auth/module.go
internal/auth/password/password.go
internal/auth/repository/interface.go
internal/auth/repository/repository.go
internal/auth/service/service.go
internal/auth/sql/queries.sql
internal/auth/token/token.go
internal/auth/transport/dto.go
internal/auth/validator/validator.go
internal/catalog/db/db.go
internal/catalog/db/models.go
internal/catalog/db/querier.go
internal/catalog/db/queries.sql.go
internal/catalog/handler/handler.go
internal/catalog/migrations/001_catalog.sql
internal/catalog/module.go
internal/catalog/repository/assets.go
internal/catalog/repository/interface.go
internal/catalog/repository/repository.go
internal/catalog/service/service.go
internal/catalog/sql/queries.sql
internal/catalog/transport/dto.go
internal/email/brevo.go
internal/email/subjects.go
internal/email/templates.go
internal/email/templates/base.html
internal/email/templates/organization_invite.html
internal/email/templates/partner_invite.html
internal/email/templates/partner_offer_accepted.html
internal/email/templates/partner_offer_confirmation.html
internal/email/templates/partner_offer_rejected.html
internal/email/templates/password_reset.html
internal/email/templates/quote_accepted.html
internal/email/templates/quote_proposal.html
internal/email/templates/quote_thank_you.html
internal/email/templates/verification.html
internal/email/templates/visit_invite.html
internal/energylabel/client/client.go
internal/energylabel/energylabel.go
internal/energylabel/module.go
internal/energylabel/service/service.go
internal/energylabel/transport/dto.go
internal/events/bus.go
internal/events/event.go
internal/exports/handler.go
internal/exports/middleware.go
internal/exports/module.go
internal/exports/repository.go
internal/http/app.go
internal/http/middleware/middleware.go
internal/http/module.go
internal/http/response/response.go
internal/http/router/portal_final.code-workspace
internal/http/router/router.go
internal/identity/handler/handler.go
internal/identity/identity.go
internal/identity/module.go
internal/identity/repository/repository.go
internal/identity/service/service.go
internal/identity/transport/dto.go
internal/leadenrichment/client/client.go
internal/leadenrichment/module.go
internal/leadenrichment/service/service.go
internal/leads/agent/call_logger.go
internal/leads/agent/dispatcher.go
internal/leads/agent/estimator.go
internal/leads/agent/gatekeeper.go
internal/leads/agent/helpers.go
internal/leads/agent/offer_summary_generator.go
internal/leads/agent/photo_analyzer.go
internal/leads/agent/pipeline_prompts.go
internal/leads/agent/quote_generator.go
internal/leads/agent/tools.go
internal/leads/agent/types.go
internal/leads/domain/service_state.go
internal/leads/handler/attachments.go
internal/leads/handler/handler.go
internal/leads/handler/notes.go
internal/leads/handler/photo_analysis.go
internal/leads/handler/public_handler.go
internal/leads/leads.go
internal/leads/management/feed_enrichment.go
internal/leads/management/feed_social.go
internal/leads/management/mappers.go
internal/leads/management/service.go
internal/leads/migrations/001_leads.sql
internal/leads/migrations/002_lead_activity.sql
internal/leads/migrations/003_lead_notes.sql
internal/leads/migrations/004_lead_services.sql
internal/leads/migrations/005_visit_history.sql
internal/leads/migrations/006_lead_details.sql
internal/leads/migrations/007_lead_ai_analysis.sql
internal/leads/migrations/008_leads_filters_indexes.sql
internal/leads/migrations/009_service_types.sql
internal/leads/migrations/010_pipeline_and_timeline.sql
internal/leads/module.go
internal/leads/notes/service.go
internal/leads/orchestrator.go
internal/leads/photo_analysis_batcher.go
internal/leads/ports/agent_provider.go
internal/leads/ports/appointments.go
internal/leads/ports/catalog.go
internal/leads/ports/energylabel.go
internal/leads/ports/leadenrichment.go
internal/leads/ports/offer_summary.go
internal/leads/ports/partners.go
internal/leads/ports/public_interfaces.go
internal/leads/ports/quotes.go
internal/leads/ports/users.go
internal/leads/repository/ai_analysis.go
internal/leads/repository/appointments.go
internal/leads/repository/attachments.go
internal/leads/repository/feed_social.go
internal/leads/repository/interface.go
internal/leads/repository/lead_services.go
internal/leads/repository/metrics.go
internal/leads/repository/notes.go
internal/leads/repository/partners.go
internal/leads/repository/photo_analysis.go
internal/leads/repository/public_token.go
internal/leads/repository/repository.go
internal/leads/repository/timeline.go
internal/leads/scoring/service.go
internal/leads/transport/attachments.go
internal/leads/transport/dto.go
internal/leads/transport/notes.go
internal/leads/transport/optional.go
internal/maps/handler.go
internal/maps/module.go
internal/maps/service.go
internal/maps/types.go
internal/notification/module.go
internal/notification/sse/service.go
internal/partners/handler/handler.go
internal/partners/handler/public_handler.go
internal/partners/module.go
internal/partners/repository/offer_repository.go
internal/partners/repository/repository.go
internal/partners/service/offer_service.go
internal/partners/service/service.go
internal/partners/transport/dto.go
internal/partners/transport/logo.go
internal/partners/transport/offer_dto.go
internal/pdf/generator.go
internal/pdf/gotenberg.go
internal/pdf/templates/cover.html
internal/pdf/templates/footer.html
internal/pdf/templates/quote.html
internal/pdf/templates/signature.html
internal/quotes/handler/handler.go
internal/quotes/handler/public_handler.go
internal/quotes/module.go
internal/quotes/repository/repository.go
internal/quotes/service/calculator.go
internal/quotes/service/service.go
internal/quotes/transport/dto.go
internal/scheduler/client.go
internal/scheduler/tasks.go
internal/scheduler/worker.go
internal/services/handler/handler.go
internal/services/module.go
internal/services/repository/interface.go
internal/services/repository/repository.go
internal/services/service/service.go
internal/services/transport/dto.go
internal/webhook/extractor.go
internal/webhook/handler.go
internal/webhook/middleware.go
internal/webhook/module.go
internal/webhook/repository.go
internal/webhook/sdk_handler.go
internal/webhook/sdk.js
internal/webhook/service.go
internal/whatsapp/client.go
migrations/001_init.sql
migrations/002_roles.sql
migrations/003_leads.sql
migrations/004_lead_activity.sql
migrations/005_leads_soft_delete.sql
migrations/006_lead_notes.sql
migrations/007_lead_services.sql
migrations/007_visit_history.sql
migrations/008_lead_notes_type.sql
migrations/009_lead_details.sql
migrations/010_lead_ai_analysis.sql
migrations/011_service_types.sql
migrations/012_lead_projected_value.sql
migrations/013_lead_coordinates.sql
migrations/014_user_profile_settings.sql
migrations/015_leads_filters_indexes.sql
migrations/016_multi_service_cleanup.sql
migrations/017_ai_analysis_per_service.sql
migrations/018_lead_service_source.sql
migrations/019_appointments.sql
migrations/020_identity.sql
migrations/020_remove_lead_visit_fields.sql
migrations/021_appointment_visit_reports.sql
migrations/021_organization_profile.sql
migrations/022_appointment_availability.sql
migrations/023_tenancy_isolation.sql
migrations/024_service_types_tenancy.sql
migrations/025_add_whatsapp_to_analysis.sql
migrations/026_catalog_core.sql
migrations/026_gatekeeper_refactor.sql
migrations/027_price_bigint.sql
migrations/028_lead_service_attachments.sql
migrations/029_photo_analysis.sql
migrations/030_lead_energy_label.sql
migrations/031_lead_enrichment.sql
migrations/032_remove_legacy_enrichment_fields.sql
migrations/033_lead_enrichment_pc4.sql
migrations/034_lead_enrichment_mediaan_vermogen.sql
migrations/035_appointments_meeting_link.sql
migrations/036_catalog_product_assets.sql
migrations/037_rename_to_rac.sql
migrations/038_partners.sql
migrations/039_partner_logos_service_types.sql
migrations/040_partner_coordinates.sql
migrations/041_partner_house_number.sql
migrations/042_pipeline_and_timeline.sql
migrations/043_partner_invites.sql
migrations/044_catalog_unit_pricing.sql
migrations/045_catalog_unit_pricing_check.sql
migrations/046_catalog_labor_time.sql
migrations/047_organization_logo.sql
migrations/048_quotes.sql
migrations/049_interactive_quotes.sql
migrations/050_quote_activity.sql
migrations/051_quote_preview_tokens.sql
migrations/052_quotes_created_by.sql
migrations/053_organization_settings.sql
migrations/054_quote_attachments.sql
migrations/055_fix_attachment_unique_index.sql
migrations/056_quote_items_catalog_product.sql
migrations/057_fix_english_timeline_titles.sql
migrations/058_quote_financing_disclaimer.sql
migrations/059_partner_offers.sql
migrations/060_partner_offers_summary.sql
migrations/061_pipeline_quote_sent.sql
migrations/062_photo_analysis_v2.sql
migrations/063_lead_public_token.sql
migrations/064_lead_customer_preferences.sql
migrations/065_appointment_requested_status.sql
migrations/066_partner_offers_builder_summary.sql
migrations/067_organization_whatsapp_device.sql
migrations/068_remove_service_type_order.sql
migrations/069_smart_feed_prep.sql
migrations/070_feed_reactions_comments.sql
migrations/071_lead_notes_service_scope.sql
migrations/072_webhook_api_keys.sql
migrations/073_general_service_type.sql
migrations/074_google_ads_exports.sql
platform/ai/embeddingapi/client.go
platform/ai/embeddings/client.go
platform/ai/moonshot/model.go
platform/apperr/apperr.go
platform/config/config.go
platform/db/db.go
platform/db/migrate.go
platform/events/bus.go
platform/events/event.go
platform/httpkit/identity.go
platform/httpkit/middleware.go
platform/httpkit/response.go
platform/logger/logger.go
platform/phone/normalize.go
platform/qdrant/client.go
platform/sanitize/sanitize.go
platform/validator/validator.go
sql/auth.sql
sqlc.yaml
start.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".air.toml">
root = "."

tmp_dir = "tmp"

[build]
  cmd = "go build -o ./tmp/app.exe ./cmd/api"
  entrypoint = "./tmp/app.exe"
  delay = 200
  exclude_dir = ["tmp", "vendor", "migrations"]
  include_ext = ["go", "tpl", "tmpl", "html"]
  stop_on_error = true

[log]
  time = true

[color]
  main = "yellow"
  watcher = "cyan"
  build = "green"
  runner = "magenta"

[misc]
  clean_on_exit = true
</file>

<file path=".dockerignore">
.env
.git
.tmp
.tmp/
*.exe
*.log
repomix-output.xml

# Local tooling
.air.toml
</file>

<file path=".gitignore">
.env
.env.*

# Go build
/bin/
/build/
/dist/
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out

# Go workspace
/vendor/

# Logs
*.log

# OS
.DS_Store
Thumbs.db
nul
</file>

<file path=".golangci.yml">
version: "2"

linters:
  enable:
    - gocyclo

linters-settings:
  gocyclo:
    min-complexity: 8
</file>

<file path="cmd/lead-energylabel-backfill/main.go">
package main

import (
	"context"
	"errors"
	"time"

	"portal_final_backend/internal/adapters"
	"portal_final_backend/internal/energylabel"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

type leadEnergyAddress struct {
	id       uuid.UUID
	tenantID uuid.UUID
	street   string
	house    string
	zip      string
	city     string
}

type energyLabelUpdater interface {
	UpdateEnergyLabel(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params repository.UpdateEnergyLabelParams) error
}

func main() {
	cfg := mustLoadConfig()
	log := logger.New(cfg.Env)
	log.Info("starting energy label backfill")

	if !cfg.IsEnergyLabelEnabled() {
		log.Warn("energy label module disabled, skipping backfill")
		return
	}

	ctx := context.Background()
	pool := mustOpenPool(ctx, cfg, log)
	defer pool.Close()

	enricher := setupEnricher(cfg, log)
	if enricher == nil {
		return
	}

	repo := repository.New(pool)
	runBackfill(ctx, pool, repo, enricher, log)
}

func mustLoadConfig() *config.Config {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}
	return cfg
}

func mustOpenPool(ctx context.Context, cfg *config.Config, log *logger.Logger) *pgxpool.Pool {
	pool, err := db.NewPool(ctx, cfg)
	if err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	return pool
}

func setupEnricher(cfg *config.Config, log *logger.Logger) ports.EnergyLabelEnricher {
	energyModule := energylabel.NewModule(cfg, log)
	if !energyModule.IsEnabled() {
		log.Warn("energy label service not available, skipping backfill")
		return nil
	}

	enricher := adapters.NewEnergyLabelAdapter(energyModule.Service())
	if enricher == nil {
		log.Warn("energy label enricher unavailable, skipping backfill")
		return nil
	}

	return enricher
}

func runBackfill(ctx context.Context, pool *pgxpool.Pool, repo energyLabelUpdater, enricher ports.EnergyLabelEnricher, log *logger.Logger) {
	const batchSize = 25
	const delayBetweenCalls = 500 * time.Millisecond

	var processed int
	var succeeded int

	for {
		leads, err := listLeadsMissingEnergyLabel(ctx, pool, batchSize)
		if err != nil {
			log.Error("failed to list leads", "error", err)
			break
		}
		if len(leads) == 0 {
			log.Info("no leads left to backfill", "processed", processed, "updated", succeeded)
			break
		}

		for _, lead := range leads {
			processed++

			if !isAddressValid(lead) {
				log.Info("skipping lead with invalid address", "leadId", lead.id, "tenantId", lead.tenantID)
				continue
			}

			if err := backfillLeadEnergyLabel(ctx, repo, enricher, lead, log); err != nil {
				log.Error("failed to backfill energy label", "leadId", lead.id, "tenantId", lead.tenantID, "error", err)
				// Back off slightly on failure to avoid hammering the API
				time.Sleep(time.Second)
				continue
			}

			succeeded++
			time.Sleep(delayBetweenCalls)
		}
	}

	log.Info("energy label backfill completed", "processed", processed, "updated", succeeded)
}

func listLeadsMissingEnergyLabel(ctx context.Context, pool *pgxpool.Pool, limit int) ([]leadEnergyAddress, error) {
	rows, err := pool.Query(ctx, `
        SELECT id, organization_id, address_street, address_house_number, address_zip_code, address_city
        FROM leads
        WHERE deleted_at IS NULL
          AND energy_label_fetched_at IS NULL
          AND address_zip_code <> ''
          AND address_house_number <> ''
        ORDER BY created_at ASC
        LIMIT $1
    `, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	leads := make([]leadEnergyAddress, 0)
	for rows.Next() {
		var lead leadEnergyAddress
		if err := rows.Scan(&lead.id, &lead.tenantID, &lead.street, &lead.house, &lead.zip, &lead.city); err != nil {
			return nil, err
		}
		leads = append(leads, lead)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return leads, nil
}

func isAddressValid(lead leadEnergyAddress) bool {
	if lead.zip == "" || lead.house == "" {
		return false
	}
	if lead.zip == "0000XX" || lead.street == "Unknown" || lead.city == "Unknown" {
		return false
	}
	return true
}

func backfillLeadEnergyLabel(parentCtx context.Context, repo energyLabelUpdater, enricher ports.EnergyLabelEnricher, lead leadEnergyAddress, log *logger.Logger) error {
	if enricher == nil {
		return errors.New("energy label enricher not configured")
	}

	// Use a timeout per lead to avoid hanging on slow API calls
	ctx, cancel := context.WithTimeout(parentCtx, 15*time.Second)
	defer cancel()

	data, err := enricher.EnrichLead(ctx, ports.EnrichLeadParams{
		Postcode:   lead.zip,
		Huisnummer: lead.house,
	})
	if err != nil {
		return err
	}

	fetchedAt := time.Now().UTC()

	var classPtr *string
	var indexPtr *float64
	var bouwjaarPtr *int
	var gebouwtypePtr *string
	var validUntilPtr *time.Time
	var registeredPtr *time.Time
	var primairPtr *float64
	var bagPtr *string

	if data != nil {
		if data.Energieklasse != "" {
			val := data.Energieklasse
			classPtr = &val
		}
		if data.EnergieIndex != nil {
			val := *data.EnergieIndex
			indexPtr = &val
		}
		if data.Bouwjaar != 0 {
			val := data.Bouwjaar
			bouwjaarPtr = &val
		}
		if data.Gebouwtype != "" {
			val := data.Gebouwtype
			gebouwtypePtr = &val
		}
		if data.GeldigTot != nil {
			val := *data.GeldigTot
			validUntilPtr = &val
		}
		if data.Registratiedatum != nil {
			val := *data.Registratiedatum
			registeredPtr = &val
		}
		if data.PrimaireFossieleEnergie != nil {
			val := *data.PrimaireFossieleEnergie
			primairPtr = &val
		}
		if data.BAGVerblijfsobjectID != "" {
			val := data.BAGVerblijfsobjectID
			bagPtr = &val
		}
	}

	params := repository.UpdateEnergyLabelParams{
		Class:          classPtr,
		Index:          indexPtr,
		Bouwjaar:       bouwjaarPtr,
		Gebouwtype:     gebouwtypePtr,
		ValidUntil:     validUntilPtr,
		RegisteredAt:   registeredPtr,
		PrimairFossiel: primairPtr,
		BAGObjectID:    bagPtr,
		FetchedAt:      fetchedAt,
	}

	if err := repo.UpdateEnergyLabel(ctx, lead.id, lead.tenantID, params); err != nil {
		return err
	}

	if data == nil {
		log.Info("no energy label found", "leadId", lead.id, "tenantId", lead.tenantID)
	} else {
		log.Info("energy label updated", "leadId", lead.id, "tenantId", lead.tenantID, "class", data.Energieklasse)
	}

	return nil
}
</file>

<file path="cmd/lead-energylabel-backfill/README.md">
# Lead Energy Label Backfill

Run the backfill to fetch EP-Online energy labels for legacy leads that were created before enrichment was introduced.

```
go run ./cmd/lead-energylabel-backfill
```

Environment requirements:

- `DATABASE_URL`, `JWT_ACCESS_SECRET`, and `JWT_REFRESH_SECRET` must be set (config loader validation).
- `EP_ONLINE_API_KEY` must be present; otherwise the command exits immediately.

The command processes batches of 25 leads missing `energy_label_fetched_at`, throttles requests to protect the EP-Online API, and logs progress for each lead.
</file>

<file path="cmd/lead-enrichment-backfill/main.go">
package main

import (
	"context"
	"errors"
	"time"

	"portal_final_backend/internal/adapters"
	"portal_final_backend/internal/leadenrichment"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/scoring"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

type leadAddress struct {
	id        uuid.UUID
	tenantID  uuid.UUID
	zip       string
	house     string
	createdAt time.Time
}

type leadEnrichmentUpdater interface {
	UpdateLeadEnrichment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params repository.UpdateLeadEnrichmentParams) error
	UpdateLeadScore(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params repository.UpdateLeadScoreParams) error
}

func main() {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}

	log := logger.New(cfg.Env)
	log.Info("starting lead enrichment backfill")

	ctx := context.Background()
	pool, err := db.NewPool(ctx, cfg)
	if err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	defer pool.Close()

	enrichmentModule := leadenrichment.NewModule(log)
	enricher := adapters.NewLeadEnrichmentAdapter(enrichmentModule.Service())
	if enricher == nil {
		log.Warn("lead enrichment adapter unavailable, skipping backfill")
		return
	}

	repo := repository.New(pool)
	scorer := scoring.New(repo, log)

	runBackfill(ctx, pool, repo, scorer, enricher, log)
}

func runBackfill(ctx context.Context, pool *pgxpool.Pool, repo leadEnrichmentUpdater, scorer *scoring.Service, enricher ports.LeadEnricher, log *logger.Logger) {

	const batchSize = 50
	const delayBetweenCalls = 300 * time.Millisecond

	var processed int
	var succeeded int

	cursorTime := time.Time{}
	cursorID := uuid.Nil

	for {
		leads, err := listLeads(ctx, pool, batchSize, cursorTime, cursorID)
		if err != nil {
			log.Error("failed to list leads", "error", err)
			break
		}
		if len(leads) == 0 {
			log.Info("no leads left to backfill", "processed", processed, "updated", succeeded)
			break
		}

		for _, lead := range leads {
			processed++
			cursorTime = lead.createdAt
			cursorID = lead.id

			if !isAddressValid(lead) {
				log.Info("skipping lead with invalid address", "leadId", lead.id, "tenantId", lead.tenantID)
				continue
			}

			if err := backfillLead(ctx, repo, scorer, enricher, lead, log); err != nil {
				log.Error("failed to backfill lead enrichment", "leadId", lead.id, "tenantId", lead.tenantID, "error", err)
				time.Sleep(time.Second)
				continue
			}

			succeeded++
			time.Sleep(delayBetweenCalls)
		}
	}

	log.Info("lead enrichment backfill completed", "processed", processed, "updated", succeeded)
}

func listLeads(ctx context.Context, pool *pgxpool.Pool, limit int, cursorTime time.Time, cursorID uuid.UUID) ([]leadAddress, error) {
	rows, err := pool.Query(ctx, `
    SELECT id, organization_id, address_zip_code, address_house_number, created_at
    FROM leads
    WHERE deleted_at IS NULL
      AND address_zip_code <> ''
      AND address_house_number <> ''
      AND (created_at > $1 OR (created_at = $1 AND id > $2))
    ORDER BY created_at ASC, id ASC
    LIMIT $3
  `, cursorTime, cursorID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	leads := make([]leadAddress, 0)
	for rows.Next() {
		var lead leadAddress
		if err := rows.Scan(&lead.id, &lead.tenantID, &lead.zip, &lead.house, &lead.createdAt); err != nil {
			return nil, err
		}
		leads = append(leads, lead)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return leads, nil
}

func isAddressValid(lead leadAddress) bool {
	if lead.zip == "" || lead.house == "" {
		return false
	}
	if lead.zip == "0000XX" {
		return false
	}
	return true
}

func backfillLead(parentCtx context.Context, repo leadEnrichmentUpdater, scorer *scoring.Service, enricher ports.LeadEnricher, lead leadAddress, log *logger.Logger) error {
	if scorer == nil {
		return errors.New("lead scorer not configured")
	}

	ctx, cancel := context.WithTimeout(parentCtx, 20*time.Second)
	defer cancel()

	data, err := enricher.EnrichLead(ctx, lead.zip)
	if err != nil {
		return err
	}

	scoreResult, err := scorer.Recalculate(ctx, lead.id, nil, lead.tenantID, true)
	if err != nil {
		return err
	}

	if data != nil {
		fetchedAt := time.Now().UTC()
		updateParams := repository.UpdateLeadEnrichmentParams{
			Source:                    toPtr(data.Source),
			Postcode6:                 toPtr(data.Postcode6),
			Postcode4:                 toPtr(data.Postcode4),
			Buurtcode:                 toPtr(data.Buurtcode),
			DataYear:                  data.DataYear,
			GemAardgasverbruik:        data.GemAardgasverbruik,
			GemElektriciteitsverbruik: data.GemElektriciteitsverbruik,
			HuishoudenGrootte:         data.HuishoudenGrootte,
			KoopwoningenPct:           data.KoopwoningenPct,
			BouwjaarVanaf2000Pct:      data.BouwjaarVanaf2000Pct,
			WOZWaarde:                 data.WOZWaarde,
			MediaanVermogenX1000:      data.MediaanVermogenX1000,
			GemInkomen:                data.GemInkomenHuishouden,
			PctHoogInkomen:            data.PctHoogInkomen,
			PctLaagInkomen:            data.PctLaagInkomen,
			HuishoudensMetKinderenPct: data.HuishoudensMetKinderenPct,
			Stedelijkheid:             data.Stedelijkheid,
			Confidence:                data.Confidence,
			FetchedAt:                 fetchedAt,
			Score:                     &scoreResult.Score,
			ScorePreAI:                &scoreResult.ScorePreAI,
			ScoreFactors:              scoreResult.FactorsJSON,
			ScoreVersion:              toPtr(scoreResult.Version),
			ScoreUpdatedAt:            &scoreResult.UpdatedAt,
		}

		if err := repo.UpdateLeadEnrichment(ctx, lead.id, lead.tenantID, updateParams); err != nil {
			return err
		}

		log.Info("lead enrichment updated", "leadId", lead.id, "tenantId", lead.tenantID, "score", scoreResult.Score)
		return nil
	}

	if err := repo.UpdateLeadScore(ctx, lead.id, lead.tenantID, repository.UpdateLeadScoreParams{
		Score:          &scoreResult.Score,
		ScorePreAI:     &scoreResult.ScorePreAI,
		ScoreFactors:   scoreResult.FactorsJSON,
		ScoreVersion:   toPtr(scoreResult.Version),
		ScoreUpdatedAt: scoreResult.UpdatedAt,
	}); err != nil {
		return err
	}

	log.Info("lead score updated without enrichment", "leadId", lead.id, "tenantId", lead.tenantID, "score", scoreResult.Score)
	return nil
}

func toPtr(value string) *string {
	if value == "" {
		return nil
	}
	return &value
}
</file>

<file path="cmd/lead-geocode/main.go">
package main

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"portal_final_backend/internal/maps"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

type leadAddress struct {
	id          uuid.UUID
	street      string
	houseNumber string
	zipCode     string
	city        string
}

func main() {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}

	log := logger.New(cfg.Env)
	log.Info("starting lead geocode backfill")

	ctx := context.Background()
	pool, err := db.NewPool(ctx, cfg)
	if err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	defer pool.Close()

	mapsService := maps.NewService(log)

	runGeocodeBackfill(ctx, pool, mapsService, log)
}

func runGeocodeBackfill(ctx context.Context, pool *pgxpool.Pool, mapsService *maps.Service, log *logger.Logger) {
	const batchSize = 25
	for {
		leads, err := listLeadsMissingCoordinates(ctx, pool, batchSize)
		if err != nil {
			log.Error("failed to list leads", "error", err)
			return
		}
		if len(leads) == 0 {
			log.Info("no leads left to geocode")
			return
		}

		progress := false

		for _, lead := range leads {
			if geocodeLead(ctx, pool, mapsService, lead, log) {
				progress = true
			}
		}

		if !progress {
			log.Info("no geocode progress in batch, stopping")
			return
		}
	}
}

func geocodeLead(ctx context.Context, pool *pgxpool.Pool, mapsService *maps.Service, lead leadAddress, log *logger.Logger) bool {
	if isInvalidAddress(lead) {
		log.Info("skipping invalid address", "leadId", lead.id)
		return false
	}

	address := fmt.Sprintf("%s %s, %s %s", lead.street, lead.houseNumber, lead.zipCode, lead.city)
	suggestions, err := mapsService.SearchAddress(ctx, address)
	if err != nil {
		log.Error("geocode failed", "leadId", lead.id, "error", err)
		time.Sleep(time.Second)
		return false
	}
	if len(suggestions) == 0 {
		log.Info("no geocode result", "leadId", lead.id, "address", address)
		time.Sleep(time.Second)
		return false
	}

	lat, err := parseCoordinate("latitude", suggestions[0].Lat, lead.id, log)
	if err != nil {
		time.Sleep(time.Second)
		return false
	}
	long, err := parseCoordinate("longitude", suggestions[0].Lon, lead.id, log)
	if err != nil {
		time.Sleep(time.Second)
		return false
	}

	if err := updateLeadCoordinates(ctx, pool, lead.id, lat, long); err != nil {
		log.Error("failed to update lead", "leadId", lead.id, "error", err)
		time.Sleep(time.Second)
		return false
	}

	log.Info("lead geocoded", "leadId", lead.id, "lat", lat, "lon", long)
	time.Sleep(time.Second)
	return true
}

func isInvalidAddress(lead leadAddress) bool {
	return lead.street == "Unknown" || lead.city == "Unknown" || lead.zipCode == "0000XX"
}

func parseCoordinate(kind string, value string, leadID uuid.UUID, log *logger.Logger) (float64, error) {
	coordinate, err := strconv.ParseFloat(value, 64)
	if err != nil {
		log.Error("invalid "+kind, "leadId", leadID, "value", value)
		return 0, err
	}
	return coordinate, nil
}

func listLeadsMissingCoordinates(ctx context.Context, pool *pgxpool.Pool, limit int) ([]leadAddress, error) {
	rows, err := pool.Query(ctx, `
		SELECT id, address_street, address_house_number, address_zip_code, address_city
		FROM leads
		WHERE deleted_at IS NULL
		  AND (latitude IS NULL OR longitude IS NULL)
		ORDER BY created_at ASC
		LIMIT $1
	`, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	leads := make([]leadAddress, 0)
	for rows.Next() {
		var lead leadAddress
		if err := rows.Scan(&lead.id, &lead.street, &lead.houseNumber, &lead.zipCode, &lead.city); err != nil {
			return nil, err
		}
		leads = append(leads, lead)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return leads, nil
}

func updateLeadCoordinates(ctx context.Context, pool *pgxpool.Pool, id uuid.UUID, lat float64, lon float64) error {
	_, err := pool.Exec(ctx, `
		UPDATE leads
		SET latitude = $2, longitude = $3, updated_at = now()
		WHERE id = $1
	`, id, lat, lon)
	return err
}
</file>

<file path="internal/adapters/appointments_adapter.go">
package adapters

import (
	"context"

	"portal_final_backend/internal/appointments/service"
	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// AppointmentsAdapter adapts the RAC_appointments service for use by the RAC_leads domain.
// It implements the RAC_leads/ports.AppointmentBooker interface.
type AppointmentsAdapter struct {
	apptService *service.Service
}

// NewAppointmentsAdapter creates a new adapter that wraps the RAC_appointments service.
func NewAppointmentsAdapter(apptService *service.Service) *AppointmentsAdapter {
	return &AppointmentsAdapter{apptService: apptService}
}

// BookLeadVisit creates a visit appointment for a specific lead and service.
// It translates the RAC_leads domain's BookVisitParams into the RAC_appointments domain's
// CreateAppointmentRequest and calls the RAC_appointments service.
func (a *AppointmentsAdapter) BookLeadVisit(ctx context.Context, params ports.BookVisitParams) error {
	sendEmail := params.SendConfirmationEmail
	req := transport.CreateAppointmentRequest{
		LeadID:                &params.LeadID,
		LeadServiceID:         &params.LeadServiceID,
		Type:                  transport.AppointmentTypeLeadVisit,
		Title:                 params.Title,
		Description:           params.Description,
		StartTime:             params.StartTime,
		EndTime:               params.EndTime,
		AllDay:                false,
		SendConfirmationEmail: &sendEmail,
	}

	// Call the RAC_appointments service as the user performing the action.
	// We pass isAdmin=false since the agent is booking on their own behalf.
	_, err := a.apptService.Create(ctx, params.UserID, false, params.TenantID, req)
	return err
}

// GetLeadVisitByService retrieves the latest non-cancelled appointment for a lead service.
func (a *AppointmentsAdapter) GetLeadVisitByService(ctx context.Context, tenantID uuid.UUID, leadServiceID uuid.UUID, userID uuid.UUID) (*ports.LeadVisitSummary, error) {
	appt, err := a.apptService.GetByLeadServiceID(ctx, leadServiceID, userID, false, tenantID)
	if err != nil {
		return nil, err
	}

	return &ports.LeadVisitSummary{
		AppointmentID: appt.ID,
		UserID:        appt.UserID,
		StartTime:     appt.StartTime,
		EndTime:       appt.EndTime,
	}, nil
}

// RescheduleLeadVisit updates the time (and optional metadata) for a lead visit appointment.
func (a *AppointmentsAdapter) RescheduleLeadVisit(ctx context.Context, params ports.RescheduleVisitParams) error {
	appt, err := a.apptService.GetByLeadServiceID(ctx, params.LeadServiceID, params.UserID, false, params.TenantID)
	if err != nil {
		return err
	}

	req := transport.UpdateAppointmentRequest{
		Title:       params.Title,
		Description: params.Description,
		StartTime:   &params.StartTime,
		EndTime:     &params.EndTime,
	}

	_, err = a.apptService.Update(ctx, appt.ID, params.UserID, false, params.TenantID, req)
	return err
}

// CancelLeadVisit cancels the lead visit appointment for a lead service.
func (a *AppointmentsAdapter) CancelLeadVisit(ctx context.Context, params ports.CancelVisitParams) error {
	appt, err := a.apptService.GetByLeadServiceID(ctx, params.LeadServiceID, params.UserID, false, params.TenantID)
	if err != nil {
		return err
	}

	req := transport.UpdateAppointmentStatusRequest{Status: transport.AppointmentStatusCancelled}
	_, err = a.apptService.UpdateStatus(ctx, appt.ID, params.UserID, false, params.TenantID, req)
	return err
}

// Compile-time check that AppointmentsAdapter implements ports.AppointmentBooker
var _ ports.AppointmentBooker = (*AppointmentsAdapter)(nil)
</file>

<file path="internal/adapters/appointments_lead_assigner.go">
package adapters

import (
	"context"

	"portal_final_backend/internal/leads/management"

	"github.com/google/uuid"
)

// AppointmentsLeadAssigner adapts lead management for appointment lead ownership checks.
type AppointmentsLeadAssigner struct {
	mgmt *management.Service
}

func NewAppointmentsLeadAssigner(mgmt *management.Service) *AppointmentsLeadAssigner {
	return &AppointmentsLeadAssigner{mgmt: mgmt}
}

func (a *AppointmentsLeadAssigner) GetAssignedAgentID(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) (*uuid.UUID, error) {
	lead, err := a.mgmt.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return nil, err
	}
	return lead.AssignedAgentID, nil
}

func (a *AppointmentsLeadAssigner) AssignLead(ctx context.Context, leadID uuid.UUID, agentID uuid.UUID, tenantID uuid.UUID) error {
	return a.mgmt.AssignIfUnassigned(ctx, leadID, agentID, tenantID)
}
</file>

<file path="internal/adapters/auth_agent_provider.go">
// Package adapters contains adapters that bridge different bounded contexts.
// These adapters implement interfaces defined by consuming domains while
// wrapping services from providing domains.
package adapters

import (
	"context"
	"strings"

	authservice "portal_final_backend/internal/auth/service"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// AuthAgentProvider adapts the auth service to satisfy the RAC_leads domain's
// AgentProvider interface. This is the Anti-Corruption Layer implementation
// that ensures the RAC_leads domain doesn't need to know about auth domain internals.
type AuthAgentProvider struct {
	authSvc *authservice.Service
}

// NewAuthAgentProvider creates a new adapter wrapping the auth service.
func NewAuthAgentProvider(authSvc *authservice.Service) *AuthAgentProvider {
	return &AuthAgentProvider{authSvc: authSvc}
}

// GetAgentByID returns agent information for the given user ID.
func (p *AuthAgentProvider) GetAgentByID(ctx context.Context, agentID uuid.UUID) (ports.Agent, error) {
	profile, err := p.authSvc.GetMe(ctx, agentID)
	if err != nil {
		return ports.Agent{}, err
	}

	return ports.Agent{
		ID:    profile.ID,
		Email: profile.Email,
		Name:  buildDisplayName(profile.FirstName, profile.LastName, profile.Email),
	}, nil
}

// GetAgentsByIDs returns agent information for multiple user IDs.
func (p *AuthAgentProvider) GetAgentsByIDs(ctx context.Context, agentIDs []uuid.UUID) (map[uuid.UUID]ports.Agent, error) {
	result := make(map[uuid.UUID]ports.Agent)

	for _, id := range agentIDs {
		agent, err := p.GetAgentByID(ctx, id)
		if err != nil {
			// Silently omit missing agents
			continue
		}
		result[id] = agent
	}

	return result, nil
}

// ListAgents returns all available agents.
func (p *AuthAgentProvider) ListAgents(ctx context.Context) ([]ports.Agent, error) {
	racUsers, err := p.authSvc.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	agents := make([]ports.Agent, 0, len(racUsers))
	for _, user := range racUsers {
		id, err := uuid.Parse(user.ID)
		if err != nil {
			continue
		}
		agents = append(agents, ports.Agent{
			ID:    id,
			Email: user.Email,
			Name:  buildDisplayName(user.FirstName, user.LastName, user.Email),
		})
	}

	return agents, nil
}

// deriveNameFromEmail creates a display name from an email address.
func buildDisplayName(firstName, lastName *string, email string) string {
	first := ""
	last := ""
	if firstName != nil {
		first = strings.TrimSpace(*firstName)
	}
	if lastName != nil {
		last = strings.TrimSpace(*lastName)
	}
	full := strings.TrimSpace(strings.Join([]string{first, last}, " "))
	if full != "" {
		return full
	}
	return deriveNameFromEmail(email)
}

func deriveNameFromEmail(email string) string {
	parts := strings.Split(email, "@")
	if len(parts) == 0 {
		return email
	}
	name := parts[0]
	name = strings.ReplaceAll(name, ".", " ")
	name = strings.ReplaceAll(name, "_", " ")
	name = strings.ReplaceAll(name, "-", " ")
	return cases.Title(language.Und).String(name)
}

// Compile-time check that AuthAgentProvider implements ports.AgentProvider
var _ ports.AgentProvider = (*AuthAgentProvider)(nil)
</file>

<file path="internal/adapters/energylabel_adapter.go">
package adapters

import (
	"context"
	"strings"
	"unicode"

	"portal_final_backend/internal/energylabel/service"
	"portal_final_backend/internal/leads/ports"
)

// EnergyLabelAdapter adapts the energylabel service for use by the RAC_leads domain.
// It implements the RAC_leads/ports.EnergyLabelEnricher interface.
type EnergyLabelAdapter struct {
	svc *service.Service
}

// NewEnergyLabelAdapter creates a new adapter that wraps the energylabel service.
// Returns nil if the service is nil (disabled).
func NewEnergyLabelAdapter(svc *service.Service) *EnergyLabelAdapter {
	if svc == nil {
		return nil
	}
	return &EnergyLabelAdapter{svc: svc}
}

// EnrichLead fetches energy label data for a lead's address.
// Translates the RAC_leads domain's EnrichLeadParams into energylabel service call
// and maps the response back to the RAC_leads domain's LeadEnergyData.
func (a *EnergyLabelAdapter) EnrichLead(ctx context.Context, params ports.EnrichLeadParams) (*ports.LeadEnergyData, error) {
	if a == nil || a.svc == nil {
		return nil, nil // Graceful degradation when disabled
	}

	normalized, ok := normalizeAddressParams(params)
	if !ok {
		return nil, nil
	}

	label, err := a.svc.GetByAddress(ctx, normalized.Postcode, normalized.Huisnummer, normalized.Huisletter, normalized.Toevoeging, "")
	if err != nil {
		return nil, err
	}

	if label == nil {
		return nil, nil // No label found
	}

	// Map energylabel transport to RAC_leads port format
	return &ports.LeadEnergyData{
		Energieklasse:           label.Energieklasse,
		EnergieIndex:            label.EnergieIndex,
		Bouwjaar:                label.Bouwjaar,
		GeldigTot:               label.GeldigTot,
		Gebouwtype:              label.Gebouwtype,
		Registratiedatum:        label.Registratiedatum,
		PrimaireFossieleEnergie: label.PrimaireFossieleEnergie,
		BAGVerblijfsobjectID:    label.BAGVerblijfsobjectID,
	}, nil
}

// Compile-time check that EnergyLabelAdapter implements ports.EnergyLabelEnricher
var _ ports.EnergyLabelEnricher = (*EnergyLabelAdapter)(nil)

func normalizeAddressParams(params ports.EnrichLeadParams) (ports.EnrichLeadParams, bool) {
	postcode := sanitizePostcode(params.Postcode)
	if postcode == "" {
		return ports.EnrichLeadParams{}, false
	}

	huisnummer, huisletter, toevoeging := splitHouseComponents(params.Huisnummer)

	if huisnummer == "" {
		return ports.EnrichLeadParams{}, false
	}

	// Preserve explicit letter or addition provided by caller when available.
	if params.Huisletter != "" {
		huisletter = params.Huisletter
	}
	if params.Toevoeging != "" {
		toevoeging = params.Toevoeging
	}

	return ports.EnrichLeadParams{
		Postcode:   postcode,
		Huisnummer: huisnummer,
		Huisletter: huisletter,
		Toevoeging: toevoeging,
	}, true
}

func sanitizePostcode(value string) string {
	upper := strings.ToUpper(strings.ReplaceAll(value, " ", ""))
	upper = strings.ReplaceAll(upper, "-", "")
	return strings.TrimSpace(upper)
}

func splitHouseComponents(raw string) (number string, letter string, addition string) {
	cleaned := strings.TrimSpace(strings.ToUpper(raw))
	if cleaned == "" {
		return "", "", ""
	}

	// Extract leading digits as house number
	var digitsBuilder strings.Builder
	var idx int
	for idx < len(cleaned) {
		r := rune(cleaned[idx])
		if !unicode.IsDigit(r) {
			break
		}
		digitsBuilder.WriteRune(r)
		idx++
	}

	number = digitsBuilder.String()
	if number == "" {
		return "", "", ""
	}

	remainder := strings.TrimSpace(cleaned[idx:])
	if remainder == "" {
		return number, "", ""
	}

	// Single trailing letter (e.g., 46B)
	if len(remainder) == 1 && unicode.IsLetter(rune(remainder[0])) {
		return number, remainder, ""
	}

	// Remainder may contain separators (e.g., 46-2, 46 A1)
	remainder = strings.TrimLeft(remainder, "- /")
	if remainder == "" {
		return number, "", ""
	}

	if unicode.IsLetter(rune(remainder[0])) && len(remainder) > 1 {
		letter = string(remainder[0])
		addition = strings.TrimLeft(remainder[1:], "- /")
		return number, letter, addition
	}

	if unicode.IsLetter(rune(remainder[0])) {
		return number, string(remainder[0]), ""
	}

	return number, "", remainder
}
</file>

<file path="internal/adapters/lead_enrichment_adapter.go">
package adapters

import (
	"context"

	"portal_final_backend/internal/leadenrichment/service"
	"portal_final_backend/internal/leads/ports"
)

// LeadEnrichmentAdapter adapts the lead enrichment service for the RAC_leads domain.
type LeadEnrichmentAdapter struct {
	svc *service.Service
}

// NewLeadEnrichmentAdapter creates a new adapter that wraps the lead enrichment service.
// Returns nil if the service is nil (disabled).
func NewLeadEnrichmentAdapter(svc *service.Service) *LeadEnrichmentAdapter {
	if svc == nil {
		return nil
	}
	return &LeadEnrichmentAdapter{svc: svc}
}

// EnrichLead fetches enrichment data for a lead's postcode.
func (a *LeadEnrichmentAdapter) EnrichLead(ctx context.Context, postcode string) (*ports.LeadEnrichmentData, error) {
	if a == nil || a.svc == nil {
		return nil, nil
	}

	data, err := a.svc.GetByPostcode(ctx, postcode)
	if err != nil || data == nil {
		return nil, err
	}

	return &ports.LeadEnrichmentData{
		Source:                    data.Source,
		Postcode6:                 data.Postcode6,
		Postcode4:                 data.Postcode4,
		Buurtcode:                 data.Buurtcode,
		DataYear:                  data.DataYear,
		GemAardgasverbruik:        data.GemAardgasverbruik,
		GemElektriciteitsverbruik: data.GemElektriciteitsverbruik,
		HuishoudenGrootte:         data.HuishoudenGrootte,
		KoopwoningenPct:           data.KoopwoningenPct,
		BouwjaarVanaf2000Pct:      data.BouwjaarVanaf2000Pct,
		WOZWaarde:                 data.WOZWaarde,
		MediaanVermogenX1000:      data.MediaanVermogenX1000,
		GemInkomenHuishouden:      data.GemInkomenHuishouden,
		PctHoogInkomen:            data.PctHoogInkomen,
		PctLaagInkomen:            data.PctLaagInkomen,
		HuishoudensMetKinderenPct: data.HuishoudensMetKinderenPct,
		Stedelijkheid:             data.Stedelijkheid,
		Confidence:                data.Confidence,
	}, nil
}

// Compile-time check.
var _ ports.LeadEnricher = (*LeadEnrichmentAdapter)(nil)
</file>

<file path="internal/adapters/quote_activity_writer.go">
package adapters

import (
	"context"
	"encoding/json"
	"time"

	"portal_final_backend/internal/quotes/repository"

	"github.com/google/uuid"
)

// QuoteActivityWriterAdapter implements notification.QuoteActivityWriter
// by delegating to the quotes repository.
type QuoteActivityWriterAdapter struct {
	repo *repository.Repository
}

// NewQuoteActivityWriter creates a new adapter that persists quote activity to the DB.
func NewQuoteActivityWriter(repo *repository.Repository) *QuoteActivityWriterAdapter {
	return &QuoteActivityWriterAdapter{repo: repo}
}

// CreateActivity persists a single quote activity record.
func (a *QuoteActivityWriterAdapter) CreateActivity(ctx context.Context, quoteID, orgID uuid.UUID, eventType, message string, metadata map[string]interface{}) error {
	var metaJSON []byte
	if metadata != nil {
		var err error
		metaJSON, err = json.Marshal(metadata)
		if err != nil {
			metaJSON = nil
		}
	}

	activity := &repository.QuoteActivity{
		ID:             uuid.New(),
		QuoteID:        quoteID,
		OrganizationID: orgID,
		EventType:      eventType,
		Message:        message,
		Metadata:       metaJSON,
		CreatedAt:      time.Now(),
	}
	return a.repo.CreateActivity(ctx, activity)
}
</file>

<file path="internal/adapters/quotes_timeline_writer.go">
package adapters

import (
	"context"

	leadsrepo "portal_final_backend/internal/leads/repository"
	quotesvc "portal_final_backend/internal/quotes/service"
)

// QuotesTimelineWriter adapts the leads TimelineEventStore for the quotes domain.
// It implements quotes/service.TimelineWriter using interface-segregation.
type QuotesTimelineWriter struct {
	store leadsrepo.TimelineEventStore
}

// NewQuotesTimelineWriter creates a new timeline writer adapter.
func NewQuotesTimelineWriter(store leadsrepo.TimelineEventStore) *QuotesTimelineWriter {
	return &QuotesTimelineWriter{store: store}
}

// CreateTimelineEvent writes a timeline event from the quotes domain into the leads timeline.
func (a *QuotesTimelineWriter) CreateTimelineEvent(ctx context.Context, params quotesvc.TimelineEventParams) error {
	_, err := a.store.CreateTimelineEvent(ctx, leadsrepo.CreateTimelineEventParams{
		LeadID:         params.LeadID,
		ServiceID:      params.ServiceID,
		OrganizationID: params.OrganizationID,
		ActorType:      params.ActorType,
		ActorName:      params.ActorName,
		EventType:      params.EventType,
		Title:          params.Title,
		Summary:        params.Summary,
		Metadata:       params.Metadata,
	})
	return err
}

// Compile-time check that QuotesTimelineWriter implements quotes/service.TimelineWriter.
var _ quotesvc.TimelineWriter = (*QuotesTimelineWriter)(nil)
</file>

<file path="internal/adapters/storage/client.go">
package storage

import (
	"context"
	"fmt"
	"io"
	"net/url"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
)

const (
	// PresignedURLTTL is the default expiration time for presigned URLs (15 minutes).
	PresignedURLTTL = 15 * time.Minute
)

// MinIOService implements StorageService using MinIO.
type MinIOService struct {
	client      *minio.Client
	maxFileSize int64
}

// NewMinIOService creates a new MinIO storage service.
func NewMinIOService(cfg Config) (*MinIOService, error) {
	if !cfg.IsMinIOEnabled() {
		return nil, fmt.Errorf("MinIO is not configured")
	}

	client, err := minio.New(cfg.GetMinIOEndpoint(), &minio.Options{
		Creds:  credentials.NewStaticV4(cfg.GetMinIOAccessKey(), cfg.GetMinIOSecretKey(), ""),
		Secure: cfg.GetMinIOUseSSL(),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create MinIO client: %w", err)
	}

	return &MinIOService{
		client:      client,
		maxFileSize: cfg.GetMinIOMaxFileSize(),
	}, nil
}

// EnsureBucketExists creates the bucket if it doesn't exist.
func (s *MinIOService) EnsureBucketExists(ctx context.Context, bucket string) error {
	exists, err := s.client.BucketExists(ctx, bucket)
	if err != nil {
		return fmt.Errorf("failed to check bucket existence: %w", err)
	}

	if !exists {
		err = s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})
		if err != nil {
			return fmt.Errorf("failed to create bucket %s: %w", bucket, err)
		}
	}

	return nil
}

// GenerateUploadURL creates a presigned URL for uploading a file.
func (s *MinIOService) GenerateUploadURL(ctx context.Context, bucket, folder, fileName, contentType string, sizeBytes int64) (*PresignedURL, error) {
	// Validate inputs
	if err := s.ValidateContentType(contentType); err != nil {
		return nil, err
	}
	if err := s.ValidateFileSize(sizeBytes); err != nil {
		return nil, err
	}

	// Generate unique file key with UUID to prevent overwrites
	ext := path.Ext(fileName)
	baseName := strings.TrimSuffix(fileName, ext)
	uniqueFileName := fmt.Sprintf("%s_%s%s", baseName, uuid.New().String()[:8], ext)
	fileKey := filepath.ToSlash(filepath.Join(folder, uniqueFileName))

	// Generate presigned PUT URL
	expiresAt := time.Now().Add(PresignedURLTTL)
	presignedURL, err := s.client.PresignedPutObject(ctx, bucket, fileKey, PresignedURLTTL)
	if err != nil {
		return nil, fmt.Errorf("failed to generate presigned upload URL: %w", err)
	}

	return &PresignedURL{
		URL:       presignedURL.String(),
		FileKey:   fileKey,
		ExpiresAt: expiresAt,
	}, nil
}

// GenerateDownloadURL creates a presigned URL for downloading a file.
func (s *MinIOService) GenerateDownloadURL(ctx context.Context, bucket, fileKey string) (*PresignedURL, error) {
	expiresAt := time.Now().Add(PresignedURLTTL)

	// Set request parameters for download
	reqParams := make(url.Values)

	presignedURL, err := s.client.PresignedGetObject(ctx, bucket, fileKey, PresignedURLTTL, reqParams)
	if err != nil {
		return nil, fmt.Errorf("failed to generate presigned download URL: %w", err)
	}

	return &PresignedURL{
		URL:       presignedURL.String(),
		FileKey:   fileKey,
		ExpiresAt: expiresAt,
	}, nil
}

// DownloadFile downloads a file directly from storage.
// The caller is responsible for closing the returned io.ReadCloser.
func (s *MinIOService) DownloadFile(ctx context.Context, bucket, fileKey string) (io.ReadCloser, error) {
	obj, err := s.client.GetObject(ctx, bucket, fileKey, minio.GetObjectOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get object %s: %w", fileKey, err)
	}
	return obj, nil
}

// DeleteObject removes an object from storage.
func (s *MinIOService) DeleteObject(ctx context.Context, bucket, fileKey string) error {
	err := s.client.RemoveObject(ctx, bucket, fileKey, minio.RemoveObjectOptions{})
	if err != nil {
		return fmt.Errorf("failed to delete object %s: %w", fileKey, err)
	}
	return nil
}

// UploadFile uploads a file directly to storage from an io.Reader and returns the file key.
func (s *MinIOService) UploadFile(ctx context.Context, bucket, folder, fileName, contentType string, reader io.Reader, size int64) (string, error) {
	ext := path.Ext(fileName)
	baseName := strings.TrimSuffix(fileName, ext)
	uniqueFileName := fmt.Sprintf("%s_%s%s", baseName, uuid.New().String()[:8], ext)
	fileKey := filepath.ToSlash(filepath.Join(folder, uniqueFileName))

	_, err := s.client.PutObject(ctx, bucket, fileKey, reader, size, minio.PutObjectOptions{
		ContentType: contentType,
	})
	if err != nil {
		return "", fmt.Errorf("failed to upload file %s: %w", fileKey, err)
	}
	return fileKey, nil
}

// GetMaxFileSize returns the configured maximum file size in bytes.
func (s *MinIOService) GetMaxFileSize() int64 {
	return s.maxFileSize
}
</file>

<file path="internal/adapters/storage/service.go">
// Package storage provides a domain-agnostic interface for S3-compatible object storage.
// This adapter can be reused across different domains (RAC_leads, RAC_appointments, etc.).
package storage

import (
	"context"
	"io"
	"time"
)

// PresignedURL contains the URL and metadata for a presigned upload/download operation.
type PresignedURL struct {
	URL       string    `json:"url"`
	FileKey   string    `json:"fileKey"`
	ExpiresAt time.Time `json:"expiresAt"`
}

// StorageService defines the interface for object storage operations.
// This interface is designed to be domain-agnostic and can be used by any module.
type StorageService interface {
	// GenerateUploadURL creates a presigned URL for uploading a file.
	// The folder parameter defines the path prefix (e.g., "{org}/{lead}/{service}").
	// Returns the presigned URL, the full file key, and expiration time.
	GenerateUploadURL(ctx context.Context, bucket, folder, fileName, contentType string, sizeBytes int64) (*PresignedURL, error)

	// GenerateDownloadURL creates a presigned URL for downloading a file.
	GenerateDownloadURL(ctx context.Context, bucket, fileKey string) (*PresignedURL, error)

	// DownloadFile downloads a file directly from storage.
	// The caller is responsible for closing the returned io.ReadCloser.
	DownloadFile(ctx context.Context, bucket, fileKey string) (io.ReadCloser, error)

	// DeleteObject removes an object from storage.
	DeleteObject(ctx context.Context, bucket, fileKey string) error

	// UploadFile uploads a file directly to storage from an io.Reader.
	// Returns the full file key used for storage.
	UploadFile(ctx context.Context, bucket, folder, fileName, contentType string, reader io.Reader, size int64) (string, error)

	// EnsureBucketExists creates the bucket if it doesn't exist.
	EnsureBucketExists(ctx context.Context, bucket string) error

	// ValidateContentType checks if the content type is allowed.
	ValidateContentType(contentType string) error

	// ValidateFileSize checks if the file size is within limits.
	ValidateFileSize(sizeBytes int64) error

	// GetMaxFileSize returns the configured maximum file size in bytes.
	GetMaxFileSize() int64
}

// Config defines the configuration interface for storage.
type Config interface {
	GetMinIOEndpoint() string
	GetMinIOAccessKey() string
	GetMinIOSecretKey() string
	GetMinIOUseSSL() bool
	GetMinIOMaxFileSize() int64
	IsMinIOEnabled() bool
}
</file>

<file path="internal/adapters/storage/validation.go">
package storage

import (
	"fmt"
	"strings"
)

// AllowedContentTypes defines the allowed MIME types for uploads.
var AllowedContentTypes = map[string]bool{
	// Images
	"image/jpeg":    true,
	"image/png":     true,
	"image/gif":     true,
	"image/webp":    true,
	"image/svg+xml": true,

	// Documents
	"application/pdf":                                                               true,
	"application/msword":                                                            true,
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document":       true,
	"application/vnd.ms-excel":                                                      true,
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":             true,
	"application/vnd.ms-powerpoint":                                                 true,
	"application/vnd.openxmlformats-officedocument.presentationml.presentation":     true,
	"text/plain":                                                                    true,
	"text/csv":                                                                      true,

	// Video
	"video/mp4":       true,
	"video/webm":      true,
	"video/quicktime": true,
	"video/x-msvideo": true,
	"video/mpeg":      true,

	// Audio
	"audio/mpeg":  true,
	"audio/wav":   true,
	"audio/ogg":   true,
	"audio/webm":  true,
	"audio/x-wav": true,
}

// ValidateContentType checks if the content type is allowed.
func (s *MinIOService) ValidateContentType(contentType string) error {
	// Normalize content type (remove parameters like charset)
	normalized := strings.Split(contentType, ";")[0]
	normalized = strings.TrimSpace(strings.ToLower(normalized))

	if !AllowedContentTypes[normalized] {
		return fmt.Errorf("content type %q is not allowed", contentType)
	}
	return nil
}

// ValidateFileSize checks if the file size is within limits.
func (s *MinIOService) ValidateFileSize(sizeBytes int64) error {
	if sizeBytes <= 0 {
		return fmt.Errorf("file size must be greater than 0")
	}
	if sizeBytes > s.maxFileSize {
		return fmt.Errorf("file size %d bytes exceeds maximum allowed size of %d bytes", sizeBytes, s.maxFileSize)
	}
	return nil
}

// GetAllowedContentTypes returns a list of allowed content types.
// Useful for frontend validation.
func GetAllowedContentTypes() []string {
	types := make([]string, 0, len(AllowedContentTypes))
	for ct := range AllowedContentTypes {
		types = append(types, ct)
	}
	return types
}

// IsImageContentType checks if the content type is an image.
func IsImageContentType(contentType string) bool {
	return strings.HasPrefix(strings.ToLower(contentType), "image/")
}

// IsVideoContentType checks if the content type is a video.
func IsVideoContentType(contentType string) bool {
	return strings.HasPrefix(strings.ToLower(contentType), "video/")
}

// IsDocumentContentType checks if the content type is a document.
func IsDocumentContentType(contentType string) bool {
	ct := strings.ToLower(contentType)
	return strings.HasPrefix(ct, "application/pdf") ||
		strings.HasPrefix(ct, "application/msword") ||
		strings.Contains(ct, "officedocument") ||
		strings.HasPrefix(ct, "text/")
}
</file>

<file path="internal/appointments/handler/handler.go">
package handler

import (
	"net/http"

	"portal_final_backend/internal/appointments/service"
	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

// Handler handles HTTP requests for RAC_appointments
type Handler struct {
	svc *service.Service
	val *validator.Validator
}

// New creates a new RAC_appointments handler
func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

// mustGetTenantID extracts the tenant ID from identity and returns it.
// Returns zero UUID and false if tenant ID is not present.
func mustGetTenantID(c *gin.Context, identity httpkit.Identity) (uuid.UUID, bool) {
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, "tenant ID is required", nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}

// RegisterRoutes registers the appointment routes
func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("", h.List)
	rg.POST("", h.Create)
	rg.GET("/:id", h.GetByID)
	rg.PUT("/:id", h.Update)
	rg.DELETE("/:id", h.Delete)
	rg.PATCH("/:id/status", h.UpdateStatus)
	rg.GET("/:id/visit-report", h.GetVisitReport)
	rg.PUT("/:id/visit-report", h.UpsertVisitReport)
	rg.GET("/:id/attachments", h.ListAttachments)
	rg.POST("/:id/attachments", h.CreateAttachment)

	rg.GET("/availability/rules", h.ListAvailabilityRules)
	rg.POST("/availability/rules", h.CreateAvailabilityRule)
	rg.PUT("/availability/rules/:id", h.UpdateAvailabilityRule)
	rg.DELETE("/availability/rules/:id", h.DeleteAvailabilityRule)

	rg.GET("/availability/overrides", h.ListAvailabilityOverrides)
	rg.POST("/availability/overrides", h.CreateAvailabilityOverride)
	rg.PUT("/availability/overrides/:id", h.UpdateAvailabilityOverride)
	rg.DELETE("/availability/overrides/:id", h.DeleteAvailabilityOverride)

	rg.GET("/availability/slots", h.GetAvailableSlots)
}

// List handles GET /api/RAC_appointments
func (h *Handler) List(c *gin.Context) {
	var req transport.ListAppointmentsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.List(c.Request.Context(), identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Create handles POST /api/RAC_appointments
func (h *Handler) Create(c *gin.Context) {
	var req transport.CreateAppointmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.Create(c.Request.Context(), identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// GetByID handles GET /api/RAC_appointments/:id
func (h *Handler) GetByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.GetByID(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Update handles PUT /api/RAC_appointments/:id
func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateAppointmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.Update(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Delete handles DELETE /api/RAC_appointments/:id
func (h *Handler) Delete(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	if err := h.svc.Delete(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "appointment deleted"})
}

// UpdateStatus handles PATCH /api/RAC_appointments/:id/status
func (h *Handler) UpdateStatus(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateAppointmentStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.UpdateStatus(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// GetVisitReport handles GET /api/RAC_appointments/:id/visit-report
func (h *Handler) GetVisitReport(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.GetVisitReport(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// UpsertVisitReport handles PUT /api/RAC_appointments/:id/visit-report
func (h *Handler) UpsertVisitReport(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpsertVisitReportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.UpsertVisitReport(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// CreateAttachment handles POST /api/RAC_appointments/:id/attachments
func (h *Handler) CreateAttachment(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CreateAppointmentAttachmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.CreateAttachment(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// ListAttachments handles GET /api/RAC_appointments/:id/attachments
func (h *Handler) ListAttachments(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.ListAttachments(c.Request.Context(), id, identity.UserID(), isAdmin, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// CreateAvailabilityRule handles POST /api/RAC_appointments/availability/rules
func (h *Handler) CreateAvailabilityRule(c *gin.Context) {
	var req transport.CreateAvailabilityRuleRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.CreateAvailabilityRule(c.Request.Context(), identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// ListAvailabilityRules handles GET /api/RAC_appointments/availability/rules
func (h *Handler) ListAvailabilityRules(c *gin.Context) {
	var userID *uuid.UUID
	if raw := c.Query("userId"); raw != "" {
		parsed, err := uuid.Parse(raw)
		if err != nil {
			httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
			return
		}
		userID = &parsed
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.ListAvailabilityRules(c.Request.Context(), identity.UserID(), isAdmin, tenantID, userID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// DeleteAvailabilityRule handles DELETE /api/RAC_appointments/availability/rules/:id
func (h *Handler) DeleteAvailabilityRule(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	if err := h.svc.DeleteAvailabilityRule(c.Request.Context(), identity.UserID(), isAdmin, tenantID, id); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "availability rule deleted"})
}

// UpdateAvailabilityRule handles PUT /api/RAC_appointments/availability/rules/:id
func (h *Handler) UpdateAvailabilityRule(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateAvailabilityRuleRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.UpdateAvailabilityRule(c.Request.Context(), identity.UserID(), isAdmin, tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// CreateAvailabilityOverride handles POST /api/RAC_appointments/availability/overrides
func (h *Handler) CreateAvailabilityOverride(c *gin.Context) {
	var req transport.CreateAvailabilityOverrideRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.CreateAvailabilityOverride(c.Request.Context(), identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// ListAvailabilityOverrides handles GET /api/RAC_appointments/availability/overrides
func (h *Handler) ListAvailabilityOverrides(c *gin.Context) {
	var userID *uuid.UUID
	if raw := c.Query("userId"); raw != "" {
		parsed, err := uuid.Parse(raw)
		if err != nil {
			httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
			return
		}
		userID = &parsed
	}

	startDate := c.Query("startDate")
	endDate := c.Query("endDate")
	var startPtr *string
	var endPtr *string
	if startDate != "" {
		startPtr = &startDate
	}
	if endDate != "" {
		endPtr = &endDate
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.ListAvailabilityOverrides(c.Request.Context(), identity.UserID(), isAdmin, tenantID, userID, startPtr, endPtr)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// DeleteAvailabilityOverride handles DELETE /api/RAC_appointments/availability/overrides/:id
func (h *Handler) DeleteAvailabilityOverride(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	if err := h.svc.DeleteAvailabilityOverride(c.Request.Context(), identity.UserID(), isAdmin, tenantID, id); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "availability override deleted"})
}

// UpdateAvailabilityOverride handles PUT /api/RAC_appointments/availability/overrides/:id
func (h *Handler) UpdateAvailabilityOverride(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateAvailabilityOverrideRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.UpdateAvailabilityOverride(c.Request.Context(), identity.UserID(), isAdmin, tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// GetAvailableSlots handles GET /api/RAC_appointments/availability/slots
func (h *Handler) GetAvailableSlots(c *gin.Context) {
	var req transport.GetAvailableSlotsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	isAdmin := containsRole(identity.Roles(), "admin")
	result, err := h.svc.GetAvailableSlots(c.Request.Context(), identity.UserID(), isAdmin, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func containsRole(roles []string, role string) bool {
	for _, r := range roles {
		if r == role {
			return true
		}
	}
	return false
}
</file>

<file path="internal/appointments/repository/visit_reports.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type VisitReport struct {
	AppointmentID    uuid.UUID
	OrganizationID   uuid.UUID
	Measurements     *string
	AccessDifficulty *string
	Notes            *string
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

type AppointmentAttachment struct {
	ID            uuid.UUID
	AppointmentID uuid.UUID
	OrganizationID uuid.UUID
	FileKey       string
	FileName      string
	ContentType   *string
	SizeBytes     *int64
	CreatedAt     time.Time
}

func (r *Repository) GetVisitReport(ctx context.Context, appointmentID uuid.UUID, organizationID uuid.UUID) (*VisitReport, error) {
	var report VisitReport
	query := `SELECT appointment_id, organization_id, measurements, access_difficulty, notes, created_at, updated_at
		FROM RAC_appointment_visit_reports WHERE appointment_id = $1 AND organization_id = $2`

	err := r.pool.QueryRow(ctx, query, appointmentID, organizationID).Scan(
		&report.AppointmentID,
		&report.OrganizationID,
		&report.Measurements,
		&report.AccessDifficulty,
		&report.Notes,
		&report.CreatedAt,
		&report.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, apperr.NotFound("visit report not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get visit report: %w", err)
	}

	return &report, nil
}

func (r *Repository) UpsertVisitReport(ctx context.Context, report VisitReport) (*VisitReport, error) {
	query := `
		INSERT INTO RAC_appointment_visit_reports
			(appointment_id, organization_id, measurements, access_difficulty, notes, created_at, updated_at)
		VALUES
			($1, $2, $3, $4, $5, now(), now())
		ON CONFLICT (appointment_id)
		DO UPDATE SET
			measurements = EXCLUDED.measurements,
			access_difficulty = EXCLUDED.access_difficulty,
			notes = EXCLUDED.notes,
			updated_at = now()
		RETURNING appointment_id, organization_id, measurements, access_difficulty, notes, created_at, updated_at`

	var saved VisitReport
	err := r.pool.QueryRow(ctx, query,
		report.AppointmentID,
		report.OrganizationID,
		report.Measurements,
		report.AccessDifficulty,
		report.Notes,
	).Scan(
		&saved.AppointmentID,
		&saved.OrganizationID,
		&saved.Measurements,
		&saved.AccessDifficulty,
		&saved.Notes,
		&saved.CreatedAt,
		&saved.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to upsert visit report: %w", err)
	}

	return &saved, nil
}

func (r *Repository) CreateAttachment(ctx context.Context, attachment AppointmentAttachment) (*AppointmentAttachment, error) {
	query := `
		INSERT INTO RAC_appointment_attachments
			(id, appointment_id, organization_id, file_key, file_name, content_type, size_bytes)
		VALUES
			($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, appointment_id, organization_id, file_key, file_name, content_type, size_bytes, created_at`

	var saved AppointmentAttachment
	err := r.pool.QueryRow(ctx, query,
		attachment.ID,
		attachment.AppointmentID,
		attachment.OrganizationID,
		attachment.FileKey,
		attachment.FileName,
		attachment.ContentType,
		attachment.SizeBytes,
	).Scan(
		&saved.ID,
		&saved.AppointmentID,
		&saved.OrganizationID,
		&saved.FileKey,
		&saved.FileName,
		&saved.ContentType,
		&saved.SizeBytes,
		&saved.CreatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create appointment attachment: %w", err)
	}

	return &saved, nil
}

func (r *Repository) ListAttachments(ctx context.Context, appointmentID uuid.UUID, organizationID uuid.UUID) ([]AppointmentAttachment, error) {
	query := `SELECT id, appointment_id, organization_id, file_key, file_name, content_type, size_bytes, created_at
		FROM RAC_appointment_attachments WHERE appointment_id = $1 AND organization_id = $2 ORDER BY created_at ASC`

	rows, err := r.pool.Query(ctx, query, appointmentID, organizationID)
	if err != nil {
		return nil, fmt.Errorf("failed to list appointment attachments: %w", err)
	}
	defer rows.Close()

	items := make([]AppointmentAttachment, 0)
	for rows.Next() {
		var item AppointmentAttachment
		if err := rows.Scan(
			&item.ID,
			&item.AppointmentID,
			&item.OrganizationID,
			&item.FileKey,
			&item.FileName,
			&item.ContentType,
			&item.SizeBytes,
			&item.CreatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan appointment attachment: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate appointment attachments: %w", err)
	}

	return items, nil
}
</file>

<file path="internal/auth/adapter/user_provider.go">
// Package adapter provides implementations of external interfaces that other domains need.
// This follows the Anti-Corruption Layer pattern - auth domain provides adapters
// that satisfy consumer-driven interfaces defined by other domains.
package adapter

import (
	"context"

	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// UserProviderAdapter implements leads/ports.UserProvider using the auth repository.
// This allows the leads domain to get user information without depending on auth internals.
type UserProviderAdapter struct {
	repo repository.UserReader
}

// NewUserProviderAdapter creates a new adapter for providing user info to other domains.
func NewUserProviderAdapter(repo repository.UserReader) *UserProviderAdapter {
	return &UserProviderAdapter{repo: repo}
}

// GetUserByID implements ports.UserProvider.
func (a *UserProviderAdapter) GetUserByID(ctx context.Context, userID uuid.UUID) (ports.UserInfo, error) {
	user, err := a.repo.GetUserByID(ctx, userID)
	if err != nil {
		return ports.UserInfo{}, err
	}

	return ports.UserInfo{
		ID:    user.ID,
		Email: user.Email,
		// Roles would need to be fetched separately if needed
	}, nil
}

// Ensure UserProviderAdapter implements ports.UserProvider
var _ ports.UserProvider = (*UserProviderAdapter)(nil)

// UserExistenceAdapter implements RAC_leads/ports.UserExistenceChecker.
type UserExistenceAdapter struct {
	repo repository.UserReader
}

// NewUserExistenceAdapter creates a new adapter for checking user existence.
func NewUserExistenceAdapter(repo repository.UserReader) *UserExistenceAdapter {
	return &UserExistenceAdapter{repo: repo}
}

// UserExists implements ports.UserExistenceChecker.
func (a *UserExistenceAdapter) UserExists(ctx context.Context, userID uuid.UUID) (bool, error) {
	_, err := a.repo.GetUserByID(ctx, userID)
	if err != nil {
		if err == repository.ErrNotFound {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

// Ensure UserExistenceAdapter implements ports.UserExistenceChecker
var _ ports.UserExistenceChecker = (*UserExistenceAdapter)(nil)
</file>

<file path="internal/auth/auth.go">
// Package auth provides authentication and authorization functionality.
// This file defines the public API of the auth bounded context.
// Only types and interfaces defined here should be imported by other domains.
package auth

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// Profile represents user information that can be shared with other domains.
type Profile struct {
	ID            uuid.UUID
	Email         string
	EmailVerified bool
	FirstName     *string
	LastName      *string
	PreferredLang string
	Roles         []string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

// UserSummary represents minimal user information for listing purposes.
type UserSummary struct {
	ID    string   `json:"id"`
	Email string   `json:"email"`
	Roles []string `json:"roles"`
}

// Service defines the public interface for authentication operations.
// Other domains should depend on this interface, not on concrete implementations.
type Service interface {
	// GetMe returns the profile of the user with the given ID.
	GetMe(ctx context.Context, userID uuid.UUID) (Profile, error)
	// ListUsers returns a list of all RAC_users (for admin purposes).
	ListUsers(ctx context.Context) ([]UserSummary, error)
}

// UserProvider is an interface that other domains can use to get user information.
// This abstracts authentication details from other bounded contexts.
type UserProvider interface {
	// GetUserByID returns basic user information needed by other domains.
	GetUserByID(ctx context.Context, userID uuid.UUID) (Profile, error)
	// GetUsersByIDs returns user information for multiple RAC_users at once.
	GetUsersByIDs(ctx context.Context, userIDs []uuid.UUID) (map[uuid.UUID]Profile, error)
}
</file>

<file path="internal/auth/db/db.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
</file>

<file path="internal/auth/db/models.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"github.com/jackc/pgx/v5/pgtype"
)

type RacRefreshToken struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	RevokedAt pgtype.Timestamptz `json:"revoked_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type RacRole struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

type RacUser struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
}

type RacUserRole struct {
	UserID    pgtype.UUID        `json:"user_id"`
	RoleID    pgtype.UUID        `json:"role_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type RacUserSetting struct {
	UserID            pgtype.UUID        `json:"user_id"`
	PreferredLanguage string             `json:"preferred_language"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

type RacUserToken struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	Type      string             `json:"type"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}
</file>

<file path="internal/auth/db/querier.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error
	// Auth Domain SQL Queries
	CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error)
	CreateUserToken(ctx context.Context, arg CreateUserTokenParams) error
	DeleteUserRoles(ctx context.Context, userID pgtype.UUID) error
	GetRefreshToken(ctx context.Context, tokenHash string) (GetRefreshTokenRow, error)
	GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error)
	GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error)
	GetUserRoles(ctx context.Context, userID pgtype.UUID) ([]string, error)
	GetUserToken(ctx context.Context, arg GetUserTokenParams) (GetUserTokenRow, error)
	GetValidRoles(ctx context.Context, dollar_1 []string) ([]string, error)
	InsertUserRoles(ctx context.Context, arg InsertUserRolesParams) error
	ListUsers(ctx context.Context) ([]ListUsersRow, error)
	MarkEmailVerified(ctx context.Context, id pgtype.UUID) error
	RevokeAllRefreshTokens(ctx context.Context, userID pgtype.UUID) error
	RevokeRefreshToken(ctx context.Context, tokenHash string) error
	UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error
	UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error)
	UseUserToken(ctx context.Context, arg UseUserTokenParams) error
}

var _ Querier = (*Queries)(nil)
</file>

<file path="internal/auth/db/queries.sql.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package authdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO RAC_refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO RAC_users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

type CreateUserRow struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Auth Domain SQL Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserToken = `-- name: CreateUserToken :exec
INSERT INTO RAC_user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateUserTokenParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	Type      string             `json:"type"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateUserToken(ctx context.Context, arg CreateUserTokenParams) error {
	_, err := q.db.Exec(ctx, createUserToken,
		arg.UserID,
		arg.TokenHash,
		arg.Type,
		arg.ExpiresAt,
	)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM RAC_user_roles WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM RAC_refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL
`

type GetRefreshTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, tokenHash string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, tokenHash)
	var i GetRefreshTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at FROM RAC_users WHERE email = $1
`

type GetUserByEmailRow struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at FROM RAC_users WHERE id = $1
`

type GetUserByIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.name FROM RAC_roles r
JOIN RAC_user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserToken = `-- name: GetUserToken :one
SELECT user_id, expires_at FROM RAC_user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type GetUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

type GetUserTokenRow struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetUserToken(ctx context.Context, arg GetUserTokenParams) (GetUserTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserToken, arg.TokenHash, arg.Type)
	var i GetUserTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getValidRoles = `-- name: GetValidRoles :many
SELECT name FROM RAC_roles WHERE name = ANY($1::text[])
`

func (q *Queries) GetValidRoles(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getValidRoles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserRoles = `-- name: InsertUserRoles :exec
INSERT INTO RAC_user_roles (user_id, role_id)
SELECT $1, id FROM RAC_roles WHERE name = ANY($2::text[])
`

type InsertUserRolesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 []string    `json:"column_2"`
}

func (q *Queries) InsertUserRoles(ctx context.Context, arg InsertUserRolesParams) error {
	_, err := q.db.Exec(ctx, insertUserRoles, arg.UserID, arg.Column2)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.email, COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles FROM RAC_users u
LEFT JOIN RAC_user_roles ur ON ur.user_id = u.id
LEFT JOIN RAC_roles r ON r.id = ur.role_id
GROUP BY u.id
ORDER BY u.email
`

type ListUsersRow struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
	Roles interface{} `json:"roles"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(&i.ID, &i.Email, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailVerified = `-- name: MarkEmailVerified :exec
UPDATE RAC_users SET is_email_verified = true, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkEmailVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markEmailVerified, id)
	return err
}

const revokeAllRefreshTokens = `-- name: RevokeAllRefreshTokens :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllRefreshTokens(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, tokenHash)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE RAC_users SET password_hash = $2, updated_at = now() WHERE id = $1
`

type UpdatePasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE RAC_users
SET email = $2, is_email_verified = false, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
`

type UpdateUserEmailParams struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
}

type UpdateUserEmailRow struct {
	ID              pgtype.UUID        `json:"id"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"password_hash"`
	IsEmailVerified bool               `json:"is_email_verified"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (UpdateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i UpdateUserEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.IsEmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const useUserToken = `-- name: UseUserToken :exec
UPDATE RAC_user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
`

type UseUserTokenParams struct {
	TokenHash string `json:"token_hash"`
	Type      string `json:"type"`
}

func (q *Queries) UseUserToken(ctx context.Context, arg UseUserTokenParams) error {
	_, err := q.db.Exec(ctx, useUserToken, arg.TokenHash, arg.Type)
	return err
}
</file>

<file path="internal/auth/migrations/001_init.sql">
-- Auth Domain: Core user tables
-- This migration is isolated to the auth domain

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS RAC_users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  is_email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS RAC_refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  revoked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON RAC_refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON RAC_refresh_tokens(expires_at);

CREATE TABLE IF NOT EXISTS RAC_user_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  type TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_user_tokens_user_id ON RAC_user_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tokens_type ON RAC_user_tokens(type);
CREATE INDEX IF NOT EXISTS idx_user_tokens_expires ON RAC_user_tokens(expires_at);
</file>

<file path="internal/auth/migrations/002_roles.sql">
-- Auth Domain: Roles and user-role assignments

CREATE TABLE IF NOT EXISTS RAC_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS RAC_user_roles (
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES RAC_roles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, role_id)
);

-- Seed default RAC_roles
-- Added 'partner' for contractors/installation partners
INSERT INTO RAC_roles (name)
VALUES ('admin'), ('user'), ('agent'), ('scout'), ('partner')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="internal/auth/migrations/003_user_profile_settings.sql">
ALTER TABLE RAC_users
  ADD COLUMN IF NOT EXISTS first_name TEXT,
  ADD COLUMN IF NOT EXISTS last_name TEXT;

CREATE TABLE IF NOT EXISTS RAC_user_settings (
  user_id UUID PRIMARY KEY REFERENCES RAC_users(id) ON DELETE CASCADE,
  preferred_language TEXT NOT NULL DEFAULT 'nl',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

INSERT INTO RAC_user_settings (user_id)
SELECT id FROM RAC_users
ON CONFLICT (user_id) DO NOTHING;
</file>

<file path="internal/auth/module.go">
// Package auth provides the authentication bounded context module.
// This file defines the module that encapsulates all auth setup and route registration.
package auth

import (
	"portal_final_backend/internal/auth/handler"
	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/auth/service"
	authvalidator "portal_final_backend/internal/auth/validator"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	identityservice "portal_final_backend/internal/identity/service"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// AuthModuleConfig combines the config interfaces needed by the auth module.
// This ensures the module only receives the configuration it actually needs.
type AuthModuleConfig interface {
	config.AuthServiceConfig
	config.CookieConfig
}

// Module is the auth bounded context module implementing http.Module.
type Module struct {
	handler    *handler.Handler
	service    *service.Service
	repository *repository.Repository
}

// NewModule creates and initializes the auth module with all its dependencies.
func NewModule(pool *pgxpool.Pool, identityService *identityservice.Service, cfg AuthModuleConfig, eventBus events.Bus, log *logger.Logger, val *validator.Validator) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, identityService, cfg, eventBus, log)

	// Register auth-specific validations on the injected validator
	_ = authvalidator.RegisterAuthValidations(val)

	h := handler.New(svc, cfg, val)

	return &Module{
		handler:    h,
		service:    svc,
		repository: repo,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "auth"
}

// Service returns the auth service for use by adapters (e.g., AgentProvider).
func (m *Module) Service() *service.Service {
	return m.service
}

// Repository returns the auth repository for use by adapters (e.g., agent email lookup).
func (m *Module) Repository() *repository.Repository {
	return m.repository
}

// RegisterRoutes mounts auth routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// Public auth routes with stricter rate limiting
	authGroup := ctx.V1.Group("/auth")
	authGroup.Use(ctx.AuthRateLimiter.RateLimit())
	m.handler.RegisterRoutes(authGroup)

	// Protected user routes
	ctx.Protected.GET("/users/me", m.handler.GetMe)
	ctx.Protected.GET("/users", m.handler.ListUsers)
	ctx.Protected.PATCH("/users/me", m.handler.UpdateMe)
	ctx.Protected.POST("/users/me/password", m.handler.ChangePassword)
	ctx.Protected.POST("/users/me/onboarding", m.handler.CompleteOnboarding)

	// Admin routes
	ctx.Admin.PUT("/users/:id/roles", m.handler.SetUserRoles)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/auth/password/password.go">
package password

import "golang.org/x/crypto/bcrypt"

func Hash(plain string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(plain), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

func Compare(hash, plain string) error {
	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(plain))
}
</file>

<file path="internal/auth/repository/interface.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// =====================================
// Segregated Interfaces (Interface Segregation Principle)
// =====================================

// UserReader provides read-only access to user data.
type UserReader interface {
	GetUserByEmail(ctx context.Context, email string) (User, error)
	GetUserByID(ctx context.Context, userID uuid.UUID) (User, error)
}

// UserWriter provides write operations for user management.
type UserWriter interface {
	CreateUser(ctx context.Context, email, passwordHash string) (User, error)
	MarkEmailVerified(ctx context.Context, userID uuid.UUID) error
	UpdatePassword(ctx context.Context, userID uuid.UUID, passwordHash string) error
	UpdateUserEmail(ctx context.Context, userID uuid.UUID, email string) (User, error)
	ListUsers(ctx context.Context) ([]UserWithRoles, error)
}

// TokenStore manages one-time tokens (email verification, password reset).
type TokenStore interface {
	CreateUserToken(ctx context.Context, userID uuid.UUID, tokenHash string, tokenType string, expiresAt time.Time) error
	GetUserToken(ctx context.Context, tokenHash string, tokenType string) (uuid.UUID, time.Time, error)
	UseUserToken(ctx context.Context, tokenHash string, tokenType string) error
}

// RefreshTokenStore manages refresh tokens for session management.
type RefreshTokenStore interface {
	CreateRefreshToken(ctx context.Context, userID uuid.UUID, tokenHash string, expiresAt time.Time) error
	GetRefreshToken(ctx context.Context, tokenHash string) (uuid.UUID, time.Time, error)
	RevokeRefreshToken(ctx context.Context, tokenHash string) error
	RevokeAllRefreshTokens(ctx context.Context, userID uuid.UUID) error
}

// RoleManager provides role-based access control operations.
type RoleManager interface {
	GetUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error)
	SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error
}

// =====================================
// Composite Interface (for backward compatibility)
// =====================================

// AuthRepository defines the complete interface for authentication data operations.
// Composed of smaller, focused interfaces for better testability and flexibility.
type AuthRepository interface {
	UserReader
	UserWriter
	TokenStore
	RefreshTokenStore
	RoleManager
}

// Ensure Repository implements AuthRepository
var _ AuthRepository = (*Repository)(nil)
</file>

<file path="internal/auth/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrNotFound = errors.New("not found")
var ErrInvalidRole = errors.New("invalid role")

const (
	TokenTypeEmailVerify   = "EMAIL_VERIFY"
	TokenTypePasswordReset = "PASSWORD_RESET"
)

type Repository struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

func (r *Repository) BeginTx(ctx context.Context) (pgx.Tx, error) {
	return r.pool.Begin(ctx)
}

type User struct {
	ID            uuid.UUID
	Email         string
	PasswordHash  string
	EmailVerified bool
	FirstName     *string
	LastName      *string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type UserWithRoles struct {
	ID        uuid.UUID
	Email     string
	FirstName *string
	LastName  *string
	Roles     []string
}

func (r *Repository) CreateUser(ctx context.Context, email, passwordHash string) (User, error) {
	var user User
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return User{}, err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback(ctx)
		}
	}()

	err = tx.QueryRow(ctx, `
		INSERT INTO RAC_users (email, password_hash, is_email_verified)
		VALUES ($1, $2, false)
		RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
	`, email, passwordHash).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err != nil {
		return User{}, err
	}

	if _, err = tx.Exec(ctx, `
		INSERT INTO RAC_user_settings (user_id)
		VALUES ($1)
		ON CONFLICT (user_id) DO NOTHING
	`, user.ID); err != nil {
		return User{}, err
	}

	if err = tx.Commit(ctx); err != nil {
		return User{}, err
	}

	return user, nil
}

func (r *Repository) CreateUserTx(ctx context.Context, tx pgx.Tx, email, passwordHash string) (User, error) {
	var user User
	err := tx.QueryRow(ctx, `
		INSERT INTO RAC_users (email, password_hash, is_email_verified)
		VALUES ($1, $2, false)
		RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
	`, email, passwordHash).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err != nil {
		return User{}, err
	}

	if _, err = tx.Exec(ctx, `
		INSERT INTO RAC_user_settings (user_id)
		VALUES ($1)
		ON CONFLICT (user_id) DO NOTHING
	`, user.ID); err != nil {
		return User{}, err
	}

	return user, nil
}

func (r *Repository) GetUserByEmail(ctx context.Context, email string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
		FROM RAC_users WHERE email = $1
	`, email).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return User{}, ErrNotFound
	}
	return user, err
}

func (r *Repository) GetUserByID(ctx context.Context, userID uuid.UUID) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
		FROM RAC_users WHERE id = $1
	`, userID).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return User{}, ErrNotFound
	}
	return user, err
}

func (r *Repository) MarkEmailVerified(ctx context.Context, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_users SET is_email_verified = true, updated_at = now()
		WHERE id = $1
	`, userID)
	return err
}

func (r *Repository) UpdatePassword(ctx context.Context, userID uuid.UUID, passwordHash string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_users SET password_hash = $2, updated_at = now()
		WHERE id = $1
	`, userID, passwordHash)
	return err
}

func (r *Repository) UpdateUserEmail(ctx context.Context, userID uuid.UUID, email string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		UPDATE RAC_users
		SET email = $2, is_email_verified = false, updated_at = now()
		WHERE id = $1
		RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
	`, userID, email).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	return user, err
}

func (r *Repository) UpdateUserNames(ctx context.Context, userID uuid.UUID, firstName, lastName *string) (User, error) {
	var user User
	err := r.pool.QueryRow(ctx, `
		UPDATE RAC_users
		SET first_name = $2, last_name = $3, updated_at = now()
		WHERE id = $1
		RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at
	`, userID, firstName, lastName).Scan(
		&user.ID,
		&user.Email,
		&user.PasswordHash,
		&user.EmailVerified,
		&user.FirstName,
		&user.LastName,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	return user, err
}

func (r *Repository) EnsureUserSettings(ctx context.Context, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		INSERT INTO RAC_user_settings (user_id)
		VALUES ($1)
		ON CONFLICT (user_id) DO NOTHING
	`, userID)
	return err
}

func (r *Repository) GetUserSettings(ctx context.Context, userID uuid.UUID) (string, error) {
	var preferredLanguage string
	err := r.pool.QueryRow(ctx, `
		SELECT preferred_language
		FROM RAC_user_settings
		WHERE user_id = $1
	`, userID).Scan(&preferredLanguage)
	if errors.Is(err, pgx.ErrNoRows) {
		return "", ErrNotFound
	}
	return preferredLanguage, err
}

func (r *Repository) UpdateUserSettings(ctx context.Context, userID uuid.UUID, preferredLanguage string) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback(ctx)
		}
	}()

	if _, err = tx.Exec(ctx, `
		INSERT INTO RAC_user_settings (user_id, preferred_language)
		VALUES ($1, $2)
		ON CONFLICT (user_id) DO UPDATE
		SET preferred_language = EXCLUDED.preferred_language, updated_at = now()
	`, userID, preferredLanguage); err != nil {
		return err
	}

	if _, err = tx.Exec(ctx, `
		UPDATE RAC_users SET updated_at = now() WHERE id = $1
	`, userID); err != nil {
		return err
	}

	return tx.Commit(ctx)
}

func (r *Repository) CreateUserToken(ctx context.Context, userID uuid.UUID, tokenHash string, tokenType string, expiresAt time.Time) error {
	_, err := r.pool.Exec(ctx, `
		INSERT INTO RAC_user_tokens (user_id, token_hash, type, expires_at)
		VALUES ($1, $2, $3, $4)
	`, userID, tokenHash, tokenType, expiresAt)
	return err
}

func (r *Repository) GetUserToken(ctx context.Context, tokenHash string, tokenType string) (uuid.UUID, time.Time, error) {
	var userID uuid.UUID
	var expiresAt time.Time
	err := r.pool.QueryRow(ctx, `
		SELECT user_id, expires_at FROM RAC_user_tokens
		WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
	`, tokenHash, tokenType).Scan(&userID, &expiresAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return uuid.UUID{}, time.Time{}, ErrNotFound
	}
	return userID, expiresAt, err
}

func (r *Repository) UseUserToken(ctx context.Context, tokenHash string, tokenType string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_user_tokens SET used_at = now()
		WHERE token_hash = $1 AND type = $2 AND used_at IS NULL
	`, tokenHash, tokenType)
	return err
}

func (r *Repository) CreateRefreshToken(ctx context.Context, userID uuid.UUID, tokenHash string, expiresAt time.Time) error {
	_, err := r.pool.Exec(ctx, `
		INSERT INTO RAC_refresh_tokens (user_id, token_hash, expires_at)
		VALUES ($1, $2, $3)
	`, userID, tokenHash, expiresAt)
	return err
}

func (r *Repository) GetRefreshToken(ctx context.Context, tokenHash string) (uuid.UUID, time.Time, error) {
	var userID uuid.UUID
	var expiresAt time.Time
	err := r.pool.QueryRow(ctx, `
		SELECT user_id, expires_at FROM RAC_refresh_tokens
		WHERE token_hash = $1 AND revoked_at IS NULL
	`, tokenHash).Scan(&userID, &expiresAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return uuid.UUID{}, time.Time{}, ErrNotFound
	}
	return userID, expiresAt, err
}

func (r *Repository) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_refresh_tokens SET revoked_at = now()
		WHERE token_hash = $1 AND revoked_at IS NULL
	`, tokenHash)
	return err
}

func (r *Repository) RevokeAllRefreshTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_refresh_tokens SET revoked_at = now()
		WHERE user_id = $1 AND revoked_at IS NULL
	`, userID)
	return err
}

func (r *Repository) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT r.name
		FROM RAC_roles r
		JOIN RAC_user_roles ur ON ur.role_id = r.id
		WHERE ur.user_id = $1
		ORDER BY r.name
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	roles := make([]string, 0)
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		roles = append(roles, name)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return roles, nil
}

func (r *Repository) SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error {
	if len(roles) == 0 {
		return ErrInvalidRole
	}

	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback(ctx)
		}
	}()

	rows, err := tx.Query(ctx, `SELECT name FROM RAC_roles WHERE name = ANY($1)`, roles)
	if err != nil {
		return err
	}
	defer rows.Close()

	valid := make(map[string]struct{})
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return err
		}
		valid[name] = struct{}{}
	}
	if rows.Err() != nil {
		return rows.Err()
	}
	if len(valid) != len(uniqueStrings(roles)) {
		return ErrInvalidRole
	}

	if _, err := tx.Exec(ctx, `DELETE FROM RAC_user_roles WHERE user_id = $1`, userID); err != nil {
		return err
	}

	if _, err := tx.Exec(ctx, `
		INSERT INTO RAC_user_roles (user_id, role_id)
		SELECT $1, id FROM RAC_roles WHERE name = ANY($2)
	`, userID, roles); err != nil {
		return err
	}

	if err := tx.Commit(ctx); err != nil {
		return err
	}

	return nil
}

func (r *Repository) SetUserRolesTx(ctx context.Context, tx pgx.Tx, userID uuid.UUID, roles []string) error {
	if len(roles) == 0 {
		return ErrInvalidRole
	}

	rows, err := tx.Query(ctx, `SELECT name FROM RAC_roles WHERE name = ANY($1)`, roles)
	if err != nil {
		return err
	}
	defer rows.Close()

	valid := make(map[string]struct{})
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return err
		}
		valid[name] = struct{}{}
	}
	if rows.Err() != nil {
		return rows.Err()
	}
	if len(valid) != len(uniqueStrings(roles)) {
		return ErrInvalidRole
	}

	if _, err := tx.Exec(ctx, `DELETE FROM RAC_user_roles WHERE user_id = $1`, userID); err != nil {
		return err
	}

	if _, err := tx.Exec(ctx, `
		INSERT INTO RAC_user_roles (user_id, role_id)
		SELECT $1, id FROM RAC_roles WHERE name = ANY($2)
	`, userID, roles); err != nil {
		return err
	}

	return nil
}

func (r *Repository) ListUsers(ctx context.Context) ([]UserWithRoles, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT u.id, u.email, u.first_name, u.last_name,
			COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles
		FROM RAC_users u
		LEFT JOIN RAC_user_roles ur ON ur.user_id = u.id
		LEFT JOIN RAC_roles r ON r.id = ur.role_id
		GROUP BY u.id
		ORDER BY u.email
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	users := make([]UserWithRoles, 0)
	for rows.Next() {
		var user UserWithRoles
		if err := rows.Scan(&user.ID, &user.Email, &user.FirstName, &user.LastName, &user.Roles); err != nil {
			return nil, err
		}
		users = append(users, user)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return users, nil
}

func uniqueStrings(values []string) []string {
	seen := make(map[string]struct{}, len(values))
	result := make([]string, 0, len(values))
	for _, value := range values {
		if _, ok := seen[value]; ok {
			continue
		}
		seen[value] = struct{}{}
		result = append(result, value)
	}
	return result
}
</file>

<file path="internal/auth/sql/queries.sql">
-- Auth Domain SQL Queries

-- name: CreateUser :one
INSERT INTO RAC_users (email, password_hash, is_email_verified)
VALUES ($1, $2, false)
RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at;

-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at FROM RAC_users WHERE email = $1;

-- name: GetUserByID :one
SELECT id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at FROM RAC_users WHERE id = $1;

-- name: MarkEmailVerified :exec
UPDATE RAC_users SET is_email_verified = true, updated_at = now() WHERE id = $1;

-- name: UpdatePassword :exec
UPDATE RAC_users SET password_hash = $2, updated_at = now() WHERE id = $1;

-- name: UpdateUserEmail :one
UPDATE RAC_users
SET email = $2, is_email_verified = false, updated_at = now()
WHERE id = $1
RETURNING id, email, password_hash, is_email_verified, first_name, last_name, created_at, updated_at;

-- name: CreateUserToken :exec
INSERT INTO RAC_user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4);

-- name: GetUserToken :one
SELECT user_id, expires_at FROM RAC_user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: UseUserToken :exec
UPDATE RAC_user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: CreateRefreshToken :exec
INSERT INTO RAC_refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3);

-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM RAC_refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeRefreshToken :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeAllRefreshTokens :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL;

-- name: GetUserRoles :many
SELECT r.name FROM RAC_roles r
JOIN RAC_user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY r.name;

-- name: ListUsers :many
SELECT u.id, u.email, COALESCE(array_agg(r.name) FILTER (WHERE r.name IS NOT NULL), '{}') AS roles FROM RAC_users u
LEFT JOIN RAC_user_roles ur ON ur.user_id = u.id
LEFT JOIN RAC_roles r ON r.id = ur.role_id
GROUP BY u.id
ORDER BY u.email;

-- name: DeleteUserRoles :exec
DELETE FROM RAC_user_roles WHERE user_id = $1;

-- name: InsertUserRoles :exec
INSERT INTO RAC_user_roles (user_id, role_id)
SELECT $1, id FROM RAC_roles WHERE name = ANY($2::text[]);

-- name: GetValidRoles :many
SELECT name FROM RAC_roles WHERE name = ANY($1::text[]);
</file>

<file path="internal/auth/token/token.go">
package token

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
)

func GenerateRandomToken(size int) (string, error) {
	b := make([]byte, size)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}

func HashSHA256(token string) string {
	h := sha256.Sum256([]byte(token))
	return hex.EncodeToString(h[:])
}
</file>

<file path="internal/auth/validator/validator.go">
package validator

import (
	"regexp"
	"unicode"

	"portal_final_backend/platform/validator"

	gpvalidator "github.com/go-playground/validator/v10"
)

// Validate is an alias to the platform validator for convenience within the auth domain.
// DEPRECATED: Use injected validator instead. This is kept for backward compatibility.
var Validate = validator.Validate

// RegisterAuthValidations registers auth-specific validation rules on a validator instance.
// This should be called once during module initialization with the injected validator.
func RegisterAuthValidations(v *validator.Validator) error {
	return v.RegisterValidation("strongpassword", validateStrongPassword)
}

func init() {
	// Register on the global validator for backward compatibility
	_ = Validate.RegisterValidation("strongpassword", validateStrongPassword)
}

// validateStrongPassword checks for password complexity:
// - At least 8 characters
// - At least one uppercase letter
// - At least one lowercase letter
// - At least one digit
// - At least one special character
func validateStrongPassword(fl gpvalidator.FieldLevel) bool {
	password := fl.Field().String()

	if len(password) < 8 {
		return false
	}

	var (
		hasUpper   bool
		hasLower   bool
		hasDigit   bool
		hasSpecial bool
	)

	for _, char := range password {
		switch {
		case unicode.IsUpper(char):
			hasUpper = true
		case unicode.IsLower(char):
			hasLower = true
		case unicode.IsDigit(char):
			hasDigit = true
		case unicode.IsPunct(char) || unicode.IsSymbol(char):
			hasSpecial = true
		}
	}

	return hasUpper && hasLower && hasDigit && hasSpecial
}

// PasswordPolicy describes the password requirements for API error messages
const PasswordPolicy = "Password must be at least 8 characters and include: uppercase letter, lowercase letter, number, and special character"

// IsValidEmail validates email format
func IsValidEmail(email string) bool {
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return emailRegex.MatchString(email)
}
</file>

<file path="internal/catalog/db/db.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package catalogdb

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
</file>

<file path="internal/catalog/db/models.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package catalogdb

import (
	"github.com/jackc/pgx/v5/pgtype"
)

type RacCatalogProduct struct {
	ID             pgtype.UUID        `json:"id"`
	OrganizationID pgtype.UUID        `json:"organization_id"`
	VatRateID      pgtype.UUID        `json:"vat_rate_id"`
	Title          string             `json:"title"`
	Reference      string             `json:"reference"`
	Description    pgtype.Text        `json:"description"`
	PriceCents     int32              `json:"price_cents"`
	Type           string             `json:"type"`
	PeriodCount    pgtype.Int4        `json:"period_count"`
	PeriodUnit     pgtype.Text        `json:"period_unit"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type RacCatalogProductMaterial struct {
	OrganizationID pgtype.UUID        `json:"organization_id"`
	ProductID      pgtype.UUID        `json:"product_id"`
	MaterialID     pgtype.UUID        `json:"material_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type RacCatalogVatRate struct {
	ID             pgtype.UUID        `json:"id"`
	OrganizationID pgtype.UUID        `json:"organization_id"`
	Name           string             `json:"name"`
	RateBps        int32              `json:"rate_bps"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}
</file>

<file path="internal/catalog/db/querier.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package catalogdb

import (
	"context"
)

type Querier interface {
	// Materials
	AddProductMaterials(ctx context.Context, arg AddProductMaterialsParams) error
	CountProducts(ctx context.Context, arg CountProductsParams) (int64, error)
	CountVatRates(ctx context.Context, arg CountVatRatesParams) (int64, error)
	// Products
	CreateProduct(ctx context.Context, arg CreateProductParams) (RacCatalogProduct, error)
	// Catalog Domain SQL Queries
	// VAT Rates
	CreateVatRate(ctx context.Context, arg CreateVatRateParams) (RacCatalogVatRate, error)
	DeleteProduct(ctx context.Context, arg DeleteProductParams) error
	DeleteVatRate(ctx context.Context, arg DeleteVatRateParams) error
	GetProductByID(ctx context.Context, arg GetProductByIDParams) (RacCatalogProduct, error)
	GetProductsByIDs(ctx context.Context, arg GetProductsByIDsParams) ([]RacCatalogProduct, error)
	GetVatRateByID(ctx context.Context, arg GetVatRateByIDParams) (RacCatalogVatRate, error)
	HasProductMaterials(ctx context.Context, arg HasProductMaterialsParams) (bool, error)
	HasProductsWithVatRate(ctx context.Context, arg HasProductsWithVatRateParams) (bool, error)
	ListProductMaterials(ctx context.Context, arg ListProductMaterialsParams) ([]RacCatalogProduct, error)
	ListProducts(ctx context.Context, arg ListProductsParams) ([]RacCatalogProduct, error)
	ListVatRates(ctx context.Context, arg ListVatRatesParams) ([]RacCatalogVatRate, error)
	RemoveProductMaterials(ctx context.Context, arg RemoveProductMaterialsParams) error
	UpdateProduct(ctx context.Context, arg UpdateProductParams) (RacCatalogProduct, error)
	UpdateVatRate(ctx context.Context, arg UpdateVatRateParams) (RacCatalogVatRate, error)
}

var _ Querier = (*Queries)(nil)
</file>

<file path="internal/catalog/db/queries.sql.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package catalogdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProductMaterials = `-- name: AddProductMaterials :exec

INSERT INTO RAC_catalog_product_materials (organization_id, product_id, material_id)
SELECT $1, $2, material_id
FROM RAC_catalog_products p
CROSS JOIN LATERAL unnest($3::uuid[]) AS material_id
WHERE p.id = $2 AND p.organization_id = $1
ON CONFLICT DO NOTHING
`

type AddProductMaterialsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	ProductID      pgtype.UUID   `json:"product_id"`
	Column3        []pgtype.UUID `json:"column_3"`
}

// Materials
func (q *Queries) AddProductMaterials(ctx context.Context, arg AddProductMaterialsParams) error {
	_, err := q.db.Exec(ctx, addProductMaterials, arg.OrganizationID, arg.ProductID, arg.Column3)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4)
`

type CountProductsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Column3        interface{} `json:"column_3"`
	Column4        pgtype.UUID `json:"column_4"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVatRates = `-- name: CountVatRates :one
SELECT COUNT(*) FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2)
`

type CountVatRatesParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
}

func (q *Queries) CountVatRates(ctx context.Context, arg CountVatRatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVatRates, arg.OrganizationID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO RAC_catalog_products (
  organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at
`

type CreateProductParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	Title          string      `json:"title"`
	Reference      string      `json:"reference"`
	Description    pgtype.Text `json:"description"`
	PriceCents     int32       `json:"price_cents"`
	Type           string      `json:"type"`
	PeriodCount    pgtype.Int4 `json:"period_count"`
	PeriodUnit     pgtype.Text `json:"period_unit"`
}

// Products
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.OrganizationID,
		arg.VatRateID,
		arg.Title,
		arg.Reference,
		arg.Description,
		arg.PriceCents,
		arg.Type,
		arg.PeriodCount,
		arg.PeriodUnit,
	)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVatRate = `-- name: CreateVatRate :one


INSERT INTO RAC_catalog_vat_rates (organization_id, name, rate_bps)
VALUES ($1, $2, $3)
RETURNING id, organization_id, name, rate_bps, created_at, updated_at
`

type CreateVatRateParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Name           string      `json:"name"`
	RateBps        int32       `json:"rate_bps"`
}

// Catalog Domain SQL Queries
// VAT Rates
func (q *Queries) CreateVatRate(ctx context.Context, arg CreateVatRateParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, createVatRate, arg.OrganizationID, arg.Name, arg.RateBps)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2
`

type DeleteProductParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.OrganizationID)
	return err
}

const deleteVatRate = `-- name: DeleteVatRate :exec
DELETE FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2
`

type DeleteVatRateParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) DeleteVatRate(ctx context.Context, arg DeleteVatRateParams) error {
	_, err := q.db.Exec(ctx, deleteVatRate, arg.ID, arg.OrganizationID)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2
`

type GetProductByIDParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.OrganizationID)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsByIDs = `-- name: GetProductsByIDs :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1 AND id = ANY($2::uuid[])
`

type GetProductsByIDsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	Column2        []pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetProductsByIDs(ctx context.Context, arg GetProductsByIDsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, arg.OrganizationID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVatRateByID = `-- name: GetVatRateByID :one
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2
`

type GetVatRateByIDParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) GetVatRateByID(ctx context.Context, arg GetVatRateByIDParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, getVatRateByID, arg.ID, arg.OrganizationID)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasProductMaterials = `-- name: HasProductMaterials :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_product_materials WHERE organization_id = $1 AND product_id = $2)
`

type HasProductMaterialsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	ProductID      pgtype.UUID `json:"product_id"`
}

func (q *Queries) HasProductMaterials(ctx context.Context, arg HasProductMaterialsParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasProductMaterials, arg.OrganizationID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasProductsWithVatRate = `-- name: HasProductsWithVatRate :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_products WHERE vat_rate_id = $1 AND organization_id = $2)
`

type HasProductsWithVatRateParams struct {
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
}

func (q *Queries) HasProductsWithVatRate(ctx context.Context, arg HasProductsWithVatRateParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasProductsWithVatRate, arg.VatRateID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listProductMaterials = `-- name: ListProductMaterials :many
SELECT p.id, p.organization_id, p.vat_rate_id, p.title, p.reference, p.description, p.price_cents, p.type, p.period_count, p.period_unit, p.created_at, p.updated_at FROM RAC_catalog_products p
JOIN RAC_catalog_product_materials pm
  ON pm.material_id = p.id AND pm.organization_id = p.organization_id
WHERE pm.organization_id = $1 AND pm.product_id = $2
ORDER BY p.title ASC
`

type ListProductMaterialsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	ProductID      pgtype.UUID `json:"product_id"`
}

func (q *Queries) ListProductMaterials(ctx context.Context, arg ListProductMaterialsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, listProductMaterials, arg.OrganizationID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListProductsParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Column3        interface{} `json:"column_3"`
	Column4        pgtype.UUID `json:"column_4"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]RacCatalogProduct, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogProduct
	for rows.Next() {
		var i RacCatalogProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.VatRateID,
			&i.Title,
			&i.Reference,
			&i.Description,
			&i.PriceCents,
			&i.Type,
			&i.PeriodCount,
			&i.PeriodUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVatRates = `-- name: ListVatRates :many
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2)
ORDER BY name ASC
LIMIT $3 OFFSET $4
`

type ListVatRatesParams struct {
	OrganizationID pgtype.UUID `json:"organization_id"`
	Column2        interface{} `json:"column_2"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListVatRates(ctx context.Context, arg ListVatRatesParams) ([]RacCatalogVatRate, error) {
	rows, err := q.db.Query(ctx, listVatRates,
		arg.OrganizationID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacCatalogVatRate
	for rows.Next() {
		var i RacCatalogVatRate
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.RateBps,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProductMaterials = `-- name: RemoveProductMaterials :exec
DELETE FROM RAC_catalog_product_materials
WHERE organization_id = $1 AND product_id = $2 AND material_id = ANY($3::uuid[])
`

type RemoveProductMaterialsParams struct {
	OrganizationID pgtype.UUID   `json:"organization_id"`
	ProductID      pgtype.UUID   `json:"product_id"`
	Column3        []pgtype.UUID `json:"column_3"`
}

func (q *Queries) RemoveProductMaterials(ctx context.Context, arg RemoveProductMaterialsParams) error {
	_, err := q.db.Exec(ctx, removeProductMaterials, arg.OrganizationID, arg.ProductID, arg.Column3)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE RAC_catalog_products
SET
  vat_rate_id = COALESCE($3, vat_rate_id),
  title = COALESCE($4, title),
  reference = COALESCE($5, reference),
  description = COALESCE($6, description),
  price_cents = COALESCE($7, price_cents),
  type = COALESCE($8, type),
  period_count = COALESCE($9, period_count),
  period_unit = COALESCE($10, period_unit),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at
`

type UpdateProductParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	VatRateID      pgtype.UUID `json:"vat_rate_id"`
	Title          string      `json:"title"`
	Reference      string      `json:"reference"`
	Description    pgtype.Text `json:"description"`
	PriceCents     int32       `json:"price_cents"`
	Type           string      `json:"type"`
	PeriodCount    pgtype.Int4 `json:"period_count"`
	PeriodUnit     pgtype.Text `json:"period_unit"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (RacCatalogProduct, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.OrganizationID,
		arg.VatRateID,
		arg.Title,
		arg.Reference,
		arg.Description,
		arg.PriceCents,
		arg.Type,
		arg.PeriodCount,
		arg.PeriodUnit,
	)
	var i RacCatalogProduct
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.VatRateID,
		&i.Title,
		&i.Reference,
		&i.Description,
		&i.PriceCents,
		&i.Type,
		&i.PeriodCount,
		&i.PeriodUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVatRate = `-- name: UpdateVatRate :one
UPDATE RAC_catalog_vat_rates
SET
  name = COALESCE($3, name),
  rate_bps = COALESCE($4, rate_bps),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, rate_bps, created_at, updated_at
`

type UpdateVatRateParams struct {
	ID             pgtype.UUID `json:"id"`
	OrganizationID pgtype.UUID `json:"organization_id"`
	Name           string      `json:"name"`
	RateBps        int32       `json:"rate_bps"`
}

func (q *Queries) UpdateVatRate(ctx context.Context, arg UpdateVatRateParams) (RacCatalogVatRate, error) {
	row := q.db.QueryRow(ctx, updateVatRate,
		arg.ID,
		arg.OrganizationID,
		arg.Name,
		arg.RateBps,
	)
	var i RacCatalogVatRate
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Name,
		&i.RateBps,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
</file>

<file path="internal/catalog/migrations/001_catalog.sql">
-- Migration: Create catalog tables for products and VAT rates

CREATE TABLE IF NOT EXISTS RAC_catalog_vat_rates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  name TEXT NOT NULL,
  rate_bps INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_catalog_vat_rates_org_name
  ON RAC_catalog_vat_rates(organization_id, name);

CREATE INDEX IF NOT EXISTS idx_catalog_vat_rates_org
  ON RAC_catalog_vat_rates(organization_id);

CREATE TABLE IF NOT EXISTS RAC_catalog_products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  vat_rate_id UUID NOT NULL REFERENCES RAC_catalog_vat_rates(id),
  title TEXT NOT NULL,
  reference TEXT NOT NULL,
  description TEXT,
  price_cents INTEGER NOT NULL,
  type TEXT NOT NULL,
  period_count INTEGER,
  period_unit TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT catalog_products_type_check
    CHECK (type IN ('digital_service', 'service', 'product', 'material')),
  CONSTRAINT catalog_products_period_check
    CHECK (
      (period_count IS NULL AND period_unit IS NULL)
      OR
      (period_count IS NOT NULL AND period_count > 0 AND period_unit IN ('day', 'week', 'month', 'quarter', 'year'))
    )
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_catalog_products_org_reference
  ON RAC_catalog_products(organization_id, reference);

CREATE UNIQUE INDEX IF NOT EXISTS idx_catalog_products_id_org
  ON RAC_catalog_products(id, organization_id);

CREATE INDEX IF NOT EXISTS idx_catalog_products_org
  ON RAC_catalog_products(organization_id);

CREATE INDEX IF NOT EXISTS idx_catalog_products_org_type
  ON RAC_catalog_products(organization_id, type);

CREATE INDEX IF NOT EXISTS idx_catalog_products_org_vat
  ON RAC_catalog_products(organization_id, vat_rate_id);

CREATE TABLE IF NOT EXISTS RAC_catalog_product_materials (
  organization_id UUID NOT NULL REFERENCES organizations(id),
  product_id UUID NOT NULL,
  material_id UUID NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (organization_id, product_id, material_id),
  CONSTRAINT catalog_product_materials_product_fk
    FOREIGN KEY (product_id, organization_id)
    REFERENCES RAC_catalog_products(id, organization_id)
    ON DELETE CASCADE,
  CONSTRAINT catalog_product_materials_material_fk
    FOREIGN KEY (material_id, organization_id)
    REFERENCES RAC_catalog_products(id, organization_id)
    ON DELETE CASCADE,
  CONSTRAINT catalog_product_materials_no_self
    CHECK (product_id <> material_id)
);

CREATE INDEX IF NOT EXISTS idx_catalog_product_materials_product
  ON RAC_catalog_product_materials(organization_id, product_id);

CREATE INDEX IF NOT EXISTS idx_catalog_product_materials_material
  ON RAC_catalog_product_materials(organization_id, material_id);
</file>

<file path="internal/catalog/repository/assets.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"

	"portal_final_backend/platform/apperr"
)

const productAssetNotFoundMessage = "product asset not found"

// CreateProductAsset creates a catalog product asset.
func (r *Repo) CreateProductAsset(ctx context.Context, params CreateProductAssetParams) (ProductAsset, error) {
	query := `
        INSERT INTO RAC_catalog_product_assets (
            organization_id, product_id, asset_type, file_key, file_name, content_type, size_bytes, url
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, organization_id, product_id, asset_type, file_key, file_name, content_type, size_bytes, url, created_at`

	var asset ProductAsset
	var createdAt time.Time
	if err := r.pool.QueryRow(ctx, query,
		params.OrganizationID,
		params.ProductID,
		params.AssetType,
		params.FileKey,
		params.FileName,
		params.ContentType,
		params.SizeBytes,
		params.URL,
	).Scan(
		&asset.ID,
		&asset.OrganizationID,
		&asset.ProductID,
		&asset.AssetType,
		&asset.FileKey,
		&asset.FileName,
		&asset.ContentType,
		&asset.SizeBytes,
		&asset.URL,
		&createdAt,
	); err != nil {
		return ProductAsset{}, fmt.Errorf("create product asset: %w", err)
	}

	asset.CreatedAt = createdAt.Format(time.RFC3339)
	return asset, nil
}

// GetProductAssetByID retrieves a product asset by ID.
func (r *Repo) GetProductAssetByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (ProductAsset, error) {
	query := `
        SELECT id, organization_id, product_id, asset_type, file_key, file_name, content_type, size_bytes, url, created_at
        FROM RAC_catalog_product_assets
        WHERE id = $1 AND organization_id = $2`

	var asset ProductAsset
	var createdAt time.Time
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&asset.ID,
		&asset.OrganizationID,
		&asset.ProductID,
		&asset.AssetType,
		&asset.FileKey,
		&asset.FileName,
		&asset.ContentType,
		&asset.SizeBytes,
		&asset.URL,
		&createdAt,
	); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return ProductAsset{}, apperr.NotFound(productAssetNotFoundMessage)
		}
		return ProductAsset{}, fmt.Errorf("get product asset by id: %w", err)
	}

	asset.CreatedAt = createdAt.Format(time.RFC3339)
	return asset, nil
}

// ListProductAssets lists assets for a product with optional type filter.
func (r *Repo) ListProductAssets(ctx context.Context, params ListProductAssetsParams) ([]ProductAsset, error) {
	whereClause := "organization_id = $1 AND product_id = $2"
	args := []interface{}{params.OrganizationID, params.ProductID}

	if params.AssetType != nil {
		whereClause += " AND asset_type = $3"
		args = append(args, *params.AssetType)
	}

	query := fmt.Sprintf(`
        SELECT id, organization_id, product_id, asset_type, file_key, file_name, content_type, size_bytes, url, created_at
        FROM RAC_catalog_product_assets
        WHERE %s
        ORDER BY created_at DESC`, whereClause)

	rows, err := r.pool.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("list product assets: %w", err)
	}
	defer rows.Close()

	items := make([]ProductAsset, 0)
	for rows.Next() {
		var asset ProductAsset
		var createdAt time.Time
		if err := rows.Scan(
			&asset.ID,
			&asset.OrganizationID,
			&asset.ProductID,
			&asset.AssetType,
			&asset.FileKey,
			&asset.FileName,
			&asset.ContentType,
			&asset.SizeBytes,
			&asset.URL,
			&createdAt,
		); err != nil {
			return nil, fmt.Errorf("scan product asset: %w", err)
		}
		asset.CreatedAt = createdAt.Format(time.RFC3339)
		items = append(items, asset)
	}
	if rows.Err() != nil {
		return nil, fmt.Errorf("iterate product assets: %w", rows.Err())
	}

	return items, nil
}

// DeleteProductAsset deletes a product asset by ID.
func (r *Repo) DeleteProductAsset(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error {
	query := `DELETE FROM RAC_catalog_product_assets WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("delete product asset: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(productAssetNotFoundMessage)
	}
	return nil
}
</file>

<file path="internal/catalog/repository/interface.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// VatRate represents a VAT rate for catalog pricing.
type VatRate struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	Name           string    `db:"name"`
	RateBps        int       `db:"rate_bps"`
	CreatedAt      string    `db:"created_at"`
	UpdatedAt      string    `db:"updated_at"`
}

// Product represents a catalog product or service.
type Product struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	VatRateID      uuid.UUID `db:"vat_rate_id"`
	Title          string    `db:"title"`
	Reference      string    `db:"reference"`
	Description    *string   `db:"description"`
	PriceCents     int64     `db:"price_cents"`
	UnitPriceCents int64     `db:"unit_price_cents"`
	UnitLabel      *string   `db:"unit_label"`
	LaborTimeText  *string   `db:"labor_time_text"`
	Type           string    `db:"type"`
	PeriodCount    *int      `db:"period_count"`
	PeriodUnit     *string   `db:"period_unit"`
	CreatedAt      string    `db:"created_at"`
	UpdatedAt      string    `db:"updated_at"`
}

// ProductAsset represents an asset linked to a catalog product.
type ProductAsset struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	ProductID      uuid.UUID `db:"product_id"`
	AssetType      string    `db:"asset_type"`
	FileKey        *string   `db:"file_key"`
	FileName       *string   `db:"file_name"`
	ContentType    *string   `db:"content_type"`
	SizeBytes      *int64    `db:"size_bytes"`
	URL            *string   `db:"url"`
	CreatedAt      string    `db:"created_at"`
}

// CreateVatRateParams contains data for creating a VAT rate.
type CreateVatRateParams struct {
	OrganizationID uuid.UUID
	Name           string
	RateBps        int
}

// UpdateVatRateParams contains data for updating a VAT rate.
type UpdateVatRateParams struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Name           *string
	RateBps        *int
}

// ListVatRatesParams defines filters for listing VAT rates.
type ListVatRatesParams struct {
	OrganizationID uuid.UUID
	Search         string
	Offset         int
	Limit          int
	SortBy         string
	SortOrder      string
}

// CreateProductParams contains data for creating a product.
type CreateProductParams struct {
	OrganizationID uuid.UUID
	VatRateID      uuid.UUID
	Title          string
	Reference      string
	Description    *string
	PriceCents     int64
	UnitPriceCents int64
	UnitLabel      *string
	LaborTimeText  *string
	Type           string
	PeriodCount    *int
	PeriodUnit     *string
}

// UpdateProductParams contains data for updating a product.
type UpdateProductParams struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	VatRateID      *uuid.UUID
	Title          *string
	Reference      *string
	Description    *string
	PriceCents     *int64
	UnitPriceCents *int64
	UnitLabel      *string
	LaborTimeText  *string
	Type           *string
	PeriodCount    *int
	PeriodUnit     *string
}

// CreateProductAssetParams contains data for creating a product asset.
type CreateProductAssetParams struct {
	OrganizationID uuid.UUID
	ProductID      uuid.UUID
	AssetType      string
	FileKey        *string
	FileName       *string
	ContentType    *string
	SizeBytes      *int64
	URL            *string
}

// ListProductAssetsParams defines filters for listing product assets.
type ListProductAssetsParams struct {
	OrganizationID uuid.UUID
	ProductID      uuid.UUID
	AssetType      *string
}

// ListProductsParams defines filters for listing products.
type ListProductsParams struct {
	OrganizationID uuid.UUID
	Search         string
	Title          string
	Reference      string
	Type           string
	VatRateID      *uuid.UUID
	CreatedAtFrom  *time.Time
	CreatedAtTo    *time.Time
	UpdatedAtFrom  *time.Time
	UpdatedAtTo    *time.Time
	Offset         int
	Limit          int
	SortBy         string
	SortOrder      string
}

// Repository defines catalog storage operations.
type Repository interface {
	CreateVatRate(ctx context.Context, params CreateVatRateParams) (VatRate, error)
	UpdateVatRate(ctx context.Context, params UpdateVatRateParams) (VatRate, error)
	DeleteVatRate(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error
	GetVatRateByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (VatRate, error)
	ListVatRates(ctx context.Context, params ListVatRatesParams) ([]VatRate, int, error)
	HasProductsWithVatRate(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error)

	CreateProduct(ctx context.Context, params CreateProductParams) (Product, error)
	UpdateProduct(ctx context.Context, params UpdateProductParams) (Product, error)
	DeleteProduct(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error
	GetProductByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (Product, error)
	ListProducts(ctx context.Context, params ListProductsParams) ([]Product, int, error)
	GetProductsByIDs(ctx context.Context, organizationID uuid.UUID, ids []uuid.UUID) ([]Product, error)

	CreateProductAsset(ctx context.Context, params CreateProductAssetParams) (ProductAsset, error)
	GetProductAssetByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (ProductAsset, error)
	ListProductAssets(ctx context.Context, params ListProductAssetsParams) ([]ProductAsset, error)
	DeleteProductAsset(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error

	AddProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error
	RemoveProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error
	ListProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID) ([]Product, error)
	HasProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID) (bool, error)
}
</file>

<file path="internal/catalog/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"

	"portal_final_backend/platform/apperr"
)

const (
	vatRateNotFoundMessage = "vat rate not found"
	productNotFoundMessage = "product not found"
)

// productSortFields maps API field names to allowed database sort columns.
var productSortFields = map[string]string{
	"title":      "title",
	"reference":  "reference",
	"priceCents": "price_cents",
	"type":       "type",
	"vatRateId":  "vat_rate_id",
	"createdAt":  "created_at",
	"updatedAt":  "updated_at",
}

// mapProductSortColumn returns the validated database sort column.
func mapProductSortColumn(sortBy string) (string, error) {
	if sortBy == "" {
		return "created_at", nil
	}
	if column, ok := productSortFields[sortBy]; ok {
		return column, nil
	}
	return "", apperr.BadRequest("invalid sort field")
}

// mapVatRateSortColumn returns the validated database sort column.
func mapVatRateSortColumn(sortBy string) (string, error) {
	if sortBy == "" {
		return "name", nil
	}
	switch sortBy {
	case "name":
		return "name", nil
	case "rateBps":
		return "rate_bps", nil
	case "createdAt":
		return "created_at", nil
	case "updatedAt":
		return "updated_at", nil
	default:
		return "", apperr.BadRequest("invalid sort field")
	}
}

// mapSortOrder returns validated sort order key.
func mapSortOrder(sortOrder string) (string, error) {
	if sortOrder == "" {
		return "desc", nil
	}
	switch sortOrder {
	case "asc", "desc":
		return sortOrder, nil
	default:
		return "", apperr.BadRequest("invalid sort order")
	}
}

// Repo implements the catalog repository.
type Repo struct {
	pool *pgxpool.Pool
}

// New creates a new catalog repository.
func New(pool *pgxpool.Pool) *Repo {
	return &Repo{pool: pool}
}

// Compile-time check that Repo implements Repository.
var _ Repository = (*Repo)(nil)

// CreateVatRate creates a VAT rate.
func (r *Repo) CreateVatRate(ctx context.Context, params CreateVatRateParams) (VatRate, error) {
	query := `
		INSERT INTO RAC_catalog_vat_rates (organization_id, name, rate_bps)
		VALUES ($1, $2, $3)
		RETURNING id, organization_id, name, rate_bps, created_at, updated_at`

	var rate VatRate
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query, params.OrganizationID, params.Name, params.RateBps).Scan(
		&rate.ID, &rate.OrganizationID, &rate.Name, &rate.RateBps, &createdAt, &updatedAt,
	); err != nil {
		return VatRate{}, fmt.Errorf("create vat rate: %w", err)
	}

	rate.CreatedAt = createdAt.Format(time.RFC3339)
	rate.UpdatedAt = updatedAt.Format(time.RFC3339)
	return rate, nil
}

// UpdateVatRate updates a VAT rate.
func (r *Repo) UpdateVatRate(ctx context.Context, params UpdateVatRateParams) (VatRate, error) {
	query := `
		UPDATE RAC_catalog_vat_rates
		SET name = COALESCE($3, name),
			rate_bps = COALESCE($4, rate_bps),
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, name, rate_bps, created_at, updated_at`

	var rate VatRate
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query,
		params.ID, params.OrganizationID, params.Name, params.RateBps,
	).Scan(&rate.ID, &rate.OrganizationID, &rate.Name, &rate.RateBps, &createdAt, &updatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return VatRate{}, apperr.NotFound(vatRateNotFoundMessage)
		}
		return VatRate{}, fmt.Errorf("update vat rate: %w", err)
	}

	rate.CreatedAt = createdAt.Format(time.RFC3339)
	rate.UpdatedAt = updatedAt.Format(time.RFC3339)
	return rate, nil
}

// DeleteVatRate deletes a VAT rate.
func (r *Repo) DeleteVatRate(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error {
	query := `DELETE FROM RAC_catalog_vat_rates WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("delete vat rate: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(vatRateNotFoundMessage)
	}
	return nil
}

// GetVatRateByID retrieves a VAT rate by ID.
func (r *Repo) GetVatRateByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (VatRate, error) {
	query := `
		SELECT id, organization_id, name, rate_bps, created_at, updated_at
		FROM RAC_catalog_vat_rates
		WHERE id = $1 AND organization_id = $2`

	var rate VatRate
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&rate.ID, &rate.OrganizationID, &rate.Name, &rate.RateBps, &createdAt, &updatedAt,
	); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return VatRate{}, apperr.NotFound(vatRateNotFoundMessage)
		}
		return VatRate{}, fmt.Errorf("get vat rate by id: %w", err)
	}

	rate.CreatedAt = createdAt.Format(time.RFC3339)
	rate.UpdatedAt = updatedAt.Format(time.RFC3339)
	return rate, nil
}

// ListVatRates lists VAT rates with filters and pagination.
func (r *Repo) ListVatRates(ctx context.Context, params ListVatRatesParams) ([]VatRate, int, error) {
	var searchParam interface{}
	if params.Search != "" {
		searchParam = "%" + params.Search + "%"
	}

	sortBy, err := mapVatRateSortColumn(params.SortBy)
	if err != nil {
		return nil, 0, err
	}
	sortOrder, err := mapSortOrder(params.SortOrder)
	if err != nil {
		return nil, 0, err
	}

	countQuery := `
		SELECT COUNT(*)
		FROM RAC_catalog_vat_rates
		WHERE organization_id = $1
			AND ($2::text IS NULL OR name ILIKE $2)
	`

	var total int
	if err := r.pool.QueryRow(ctx, countQuery, params.OrganizationID, searchParam).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("count vat rates: %w", err)
	}

	orderBy := fmt.Sprintf("%s %s, name ASC", sortBy, sortOrder)
	query := fmt.Sprintf(`
		SELECT id, organization_id, name, rate_bps, created_at, updated_at
		FROM RAC_catalog_vat_rates
		WHERE organization_id = $1
			AND ($2::text IS NULL OR name ILIKE $2)
		ORDER BY %s
		LIMIT $3 OFFSET $4
	`, orderBy)

	rows, err := r.pool.Query(ctx, query, params.OrganizationID, searchParam, params.Limit, params.Offset)
	if err != nil {
		return nil, 0, fmt.Errorf("list vat rates: %w", err)
	}
	defer rows.Close()

	items := make([]VatRate, 0)
	for rows.Next() {
		var rate VatRate
		var createdAt, updatedAt time.Time
		if err := rows.Scan(&rate.ID, &rate.OrganizationID, &rate.Name, &rate.RateBps, &createdAt, &updatedAt); err != nil {
			return nil, 0, fmt.Errorf("scan vat rate: %w", err)
		}
		rate.CreatedAt = createdAt.Format(time.RFC3339)
		rate.UpdatedAt = updatedAt.Format(time.RFC3339)
		items = append(items, rate)
	}
	if rows.Err() != nil {
		return nil, 0, fmt.Errorf("iterate vat rates: %w", rows.Err())
	}

	return items, total, nil
}

// HasProductsWithVatRate checks if any products reference a VAT rate.
func (r *Repo) HasProductsWithVatRate(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM RAC_catalog_products WHERE vat_rate_id = $1 AND organization_id = $2)`
	var exists bool
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check vat rate usage: %w", err)
	}
	return exists, nil
}

// CreateProduct creates a product.
func (r *Repo) CreateProduct(ctx context.Context, params CreateProductParams) (Product, error) {
	query := `
		INSERT INTO RAC_catalog_products (
			organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
		RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit, created_at, updated_at`

	var product Product
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query,
		params.OrganizationID, params.VatRateID, params.Title, params.Reference, params.Description,
		params.PriceCents, params.UnitPriceCents, params.UnitLabel, params.LaborTimeText, params.Type, params.PeriodCount, params.PeriodUnit,
	).Scan(
		&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
		&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
		&createdAt, &updatedAt,
	); err != nil {
		return Product{}, fmt.Errorf("create product: %w", err)
	}

	product.CreatedAt = createdAt.Format(time.RFC3339)
	product.UpdatedAt = updatedAt.Format(time.RFC3339)
	return product, nil
}

// UpdateProduct updates a product.
func (r *Repo) UpdateProduct(ctx context.Context, params UpdateProductParams) (Product, error) {
	query := `
		UPDATE RAC_catalog_products
		SET
			vat_rate_id = COALESCE($3, vat_rate_id),
			title = COALESCE($4, title),
			reference = COALESCE($5, reference),
			description = COALESCE($6, description),
			price_cents = COALESCE($7, price_cents),
			unit_price_cents = COALESCE($8, unit_price_cents),
			unit_label = COALESCE($9, unit_label),
			labor_time_text = COALESCE($10, labor_time_text),
			type = COALESCE($11, type),
			period_count = COALESCE($12, period_count),
			period_unit = COALESCE($13, period_unit),
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit, created_at, updated_at`

	var product Product
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query,
		params.ID, params.OrganizationID, params.VatRateID, params.Title, params.Reference, params.Description,
		params.PriceCents, params.UnitPriceCents, params.UnitLabel, params.LaborTimeText, params.Type, params.PeriodCount, params.PeriodUnit,
	).Scan(
		&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
		&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
		&createdAt, &updatedAt,
	); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Product{}, apperr.NotFound(productNotFoundMessage)
		}
		return Product{}, fmt.Errorf("update product: %w", err)
	}

	product.CreatedAt = createdAt.Format(time.RFC3339)
	product.UpdatedAt = updatedAt.Format(time.RFC3339)
	return product, nil
}

// DeleteProduct deletes a product.
func (r *Repo) DeleteProduct(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error {
	query := `DELETE FROM RAC_catalog_products WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("delete product: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(productNotFoundMessage)
	}
	return nil
}

// GetProductByID retrieves a product by ID.
func (r *Repo) GetProductByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (Product, error) {
	query := `
		SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit, created_at, updated_at
		FROM RAC_catalog_products
		WHERE id = $1 AND organization_id = $2`

	var product Product
	var createdAt, updatedAt time.Time
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
		&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
		&createdAt, &updatedAt,
	); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Product{}, apperr.NotFound(productNotFoundMessage)
		}
		return Product{}, fmt.Errorf("get product by id: %w", err)
	}

	product.CreatedAt = createdAt.Format(time.RFC3339)
	product.UpdatedAt = updatedAt.Format(time.RFC3339)
	return product, nil
}

// ListProducts lists products with filters and pagination.
func (r *Repo) ListProducts(ctx context.Context, params ListProductsParams) ([]Product, int, error) {
	var searchParam interface{}
	if params.Search != "" {
		searchParam = "%" + params.Search + "%"
	}
	var titleParam interface{}
	if params.Title != "" {
		titleParam = "%" + params.Title + "%"
	}
	var referenceParam interface{}
	if params.Reference != "" {
		referenceParam = "%" + params.Reference + "%"
	}
	var typeParam interface{}
	if params.Type != "" {
		typeParam = params.Type
	}
	var vatRateParam interface{}
	if params.VatRateID != nil {
		vatRateParam = *params.VatRateID
	}
	var createdAtFrom interface{}
	if params.CreatedAtFrom != nil {
		createdAtFrom = *params.CreatedAtFrom
	}
	var createdAtTo interface{}
	if params.CreatedAtTo != nil {
		createdAtTo = *params.CreatedAtTo
	}
	var updatedAtFrom interface{}
	if params.UpdatedAtFrom != nil {
		updatedAtFrom = *params.UpdatedAtFrom
	}
	var updatedAtTo interface{}
	if params.UpdatedAtTo != nil {
		updatedAtTo = *params.UpdatedAtTo
	}

	sortBy, err := mapProductSortColumn(params.SortBy)
	if err != nil {
		return nil, 0, err
	}
	sortOrder, err := mapSortOrder(params.SortOrder)
	if err != nil {
		return nil, 0, err
	}

	countQuery := `
		SELECT COUNT(*)
		FROM RAC_catalog_products
		WHERE organization_id = $1
			AND ($2::text IS NULL OR (title ILIKE $2 OR reference ILIKE $2))
			AND ($3::text IS NULL OR title ILIKE $3)
			AND ($4::text IS NULL OR reference ILIKE $4)
			AND ($5::text IS NULL OR type = $5)
			AND ($6::uuid IS NULL OR vat_rate_id = $6)
			AND ($7::timestamptz IS NULL OR created_at >= $7)
			AND ($8::timestamptz IS NULL OR created_at <= $8)
			AND ($9::timestamptz IS NULL OR updated_at >= $9)
			AND ($10::timestamptz IS NULL OR updated_at <= $10)
	`

	var total int
	if err := r.pool.QueryRow(ctx, countQuery,
		params.OrganizationID,
		searchParam,
		titleParam,
		referenceParam,
		typeParam,
		vatRateParam,
		createdAtFrom,
		createdAtTo,
		updatedAtFrom,
		updatedAtTo,
	).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("count products: %w", err)
	}

	orderBy := fmt.Sprintf("%s %s, created_at DESC", sortBy, sortOrder)
	query := fmt.Sprintf(`
		SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit, created_at, updated_at
		FROM RAC_catalog_products
		WHERE organization_id = $1
			AND ($2::text IS NULL OR (title ILIKE $2 OR reference ILIKE $2))
			AND ($3::text IS NULL OR title ILIKE $3)
			AND ($4::text IS NULL OR reference ILIKE $4)
			AND ($5::text IS NULL OR type = $5)
			AND ($6::uuid IS NULL OR vat_rate_id = $6)
			AND ($7::timestamptz IS NULL OR created_at >= $7)
			AND ($8::timestamptz IS NULL OR created_at <= $8)
			AND ($9::timestamptz IS NULL OR updated_at >= $9)
			AND ($10::timestamptz IS NULL OR updated_at <= $10)
		ORDER BY %s
		LIMIT $11 OFFSET $12
	`, orderBy)

	rows, err := r.pool.Query(ctx, query,
		params.OrganizationID,
		searchParam,
		titleParam,
		referenceParam,
		typeParam,
		vatRateParam,
		createdAtFrom,
		createdAtTo,
		updatedAtFrom,
		updatedAtTo,
		params.Limit,
		params.Offset,
	)
	if err != nil {
		return nil, 0, fmt.Errorf("list products: %w", err)
	}
	defer rows.Close()

	items, err := scanProducts(rows)
	if err != nil {
		return nil, 0, err
	}
	return items, total, nil
}

func scanProducts(rows pgx.Rows) ([]Product, error) {
	items := make([]Product, 0)
	for rows.Next() {
		var product Product
		var createdAt, updatedAt time.Time
		if err := rows.Scan(
			&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
			&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
			&createdAt, &updatedAt,
		); err != nil {
			return nil, fmt.Errorf("scan product: %w", err)
		}
		product.CreatedAt = createdAt.Format(time.RFC3339)
		product.UpdatedAt = updatedAt.Format(time.RFC3339)
		items = append(items, product)
	}
	if rows.Err() != nil {
		return nil, fmt.Errorf("iterate products: %w", rows.Err())
	}
	return items, nil
}

// GetProductsByIDs retrieves products by IDs within an organization.
func (r *Repo) GetProductsByIDs(ctx context.Context, organizationID uuid.UUID, ids []uuid.UUID) ([]Product, error) {
	query := `
		SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, unit_price_cents, unit_label, labor_time_text, type, period_count, period_unit, created_at, updated_at
		FROM RAC_catalog_products
		WHERE organization_id = $1 AND id = ANY($2)
	`

	rows, err := r.pool.Query(ctx, query, organizationID, ids)
	if err != nil {
		return nil, fmt.Errorf("get products by ids: %w", err)
	}
	defer rows.Close()

	items := make([]Product, 0)
	for rows.Next() {
		var product Product
		var createdAt, updatedAt time.Time
		if err := rows.Scan(
			&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
			&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
			&createdAt, &updatedAt,
		); err != nil {
			return nil, fmt.Errorf("scan product: %w", err)
		}
		product.CreatedAt = createdAt.Format(time.RFC3339)
		product.UpdatedAt = updatedAt.Format(time.RFC3339)
		items = append(items, product)
	}
	if rows.Err() != nil {
		return nil, fmt.Errorf("iterate products by ids: %w", rows.Err())
	}

	return items, nil
}

// AddProductMaterials adds materials to a product.
func (r *Repo) AddProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error {
	query := `
		INSERT INTO RAC_catalog_product_materials (organization_id, product_id, material_id)
		SELECT $1, $2, unnest($3::uuid[])
		ON CONFLICT DO NOTHING`

	if _, err := r.pool.Exec(ctx, query, organizationID, productID, materialIDs); err != nil {
		return fmt.Errorf("add product materials: %w", err)
	}
	return nil
}

// RemoveProductMaterials removes materials from a product.
func (r *Repo) RemoveProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error {
	query := `
		DELETE FROM RAC_catalog_product_materials
		WHERE organization_id = $1 AND product_id = $2 AND material_id = ANY($3::uuid[])`

	if _, err := r.pool.Exec(ctx, query, organizationID, productID, materialIDs); err != nil {
		return fmt.Errorf("remove product materials: %w", err)
	}
	return nil
}

// ListProductMaterials lists materials for a product.
func (r *Repo) ListProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID) ([]Product, error) {
	query := `
		SELECT p.id, p.organization_id, p.vat_rate_id, p.title, p.reference, p.description, p.price_cents, p.unit_price_cents, p.unit_label, p.labor_time_text, p.type, p.period_count, p.period_unit, p.created_at, p.updated_at
		FROM RAC_catalog_products p
		JOIN RAC_catalog_product_materials pm
		  ON pm.material_id = p.id AND pm.organization_id = p.organization_id
		WHERE pm.organization_id = $1 AND pm.product_id = $2
		ORDER BY p.title ASC`

	rows, err := r.pool.Query(ctx, query, organizationID, productID)
	if err != nil {
		return nil, fmt.Errorf("list product materials: %w", err)
	}
	defer rows.Close()

	items := make([]Product, 0)
	for rows.Next() {
		var product Product
		var createdAt, updatedAt time.Time
		if err := rows.Scan(
			&product.ID, &product.OrganizationID, &product.VatRateID, &product.Title, &product.Reference,
			&product.Description, &product.PriceCents, &product.UnitPriceCents, &product.UnitLabel, &product.LaborTimeText, &product.Type, &product.PeriodCount, &product.PeriodUnit,
			&createdAt, &updatedAt,
		); err != nil {
			return nil, fmt.Errorf("scan product material: %w", err)
		}
		product.CreatedAt = createdAt.Format(time.RFC3339)
		product.UpdatedAt = updatedAt.Format(time.RFC3339)
		items = append(items, product)
	}
	if rows.Err() != nil {
		return nil, fmt.Errorf("iterate product materials: %w", rows.Err())
	}

	return items, nil
}

// HasProductMaterials checks if a product has any materials linked.
func (r *Repo) HasProductMaterials(ctx context.Context, organizationID uuid.UUID, productID uuid.UUID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM RAC_catalog_product_materials WHERE organization_id = $1 AND product_id = $2)`
	var exists bool
	if err := r.pool.QueryRow(ctx, query, organizationID, productID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check product materials: %w", err)
	}
	return exists, nil
}
</file>

<file path="internal/catalog/sql/queries.sql">
-- Catalog Domain SQL Queries

-- VAT Rates

-- name: CreateVatRate :one
INSERT INTO RAC_catalog_vat_rates (organization_id, name, rate_bps)
VALUES ($1, $2, $3)
RETURNING id, organization_id, name, rate_bps, created_at, updated_at;

-- name: GetVatRateByID :one
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2;

-- name: ListVatRates :many
SELECT id, organization_id, name, rate_bps, created_at, updated_at FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2)
ORDER BY name ASC
LIMIT $3 OFFSET $4;

-- name: CountVatRates :one
SELECT COUNT(*) FROM RAC_catalog_vat_rates
WHERE organization_id = $1
  AND ($2 = '' OR name ILIKE $2);

-- name: UpdateVatRate :one
UPDATE RAC_catalog_vat_rates
SET
  name = COALESCE($3, name),
  rate_bps = COALESCE($4, rate_bps),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, name, rate_bps, created_at, updated_at;

-- name: DeleteVatRate :exec
DELETE FROM RAC_catalog_vat_rates
WHERE id = $1 AND organization_id = $2;

-- name: HasProductsWithVatRate :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_products WHERE vat_rate_id = $1 AND organization_id = $2);

-- Products

-- name: CreateProduct :one
INSERT INTO RAC_catalog_products (
  organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at;

-- name: GetProductByID :one
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2;

-- name: ListProducts :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6;

-- name: CountProducts :one
SELECT COUNT(*) FROM RAC_catalog_products
WHERE organization_id = $1
  AND ($2 = '' OR title ILIKE $2 OR reference ILIKE $2)
  AND ($3 = '' OR type = $3)
  AND ($4::uuid IS NULL OR vat_rate_id = $4);

-- name: UpdateProduct :one
UPDATE RAC_catalog_products
SET
  vat_rate_id = COALESCE($3, vat_rate_id),
  title = COALESCE($4, title),
  reference = COALESCE($5, reference),
  description = COALESCE($6, description),
  price_cents = COALESCE($7, price_cents),
  type = COALESCE($8, type),
  period_count = COALESCE($9, period_count),
  period_unit = COALESCE($10, period_unit),
  updated_at = now()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at;

-- name: DeleteProduct :exec
DELETE FROM RAC_catalog_products
WHERE id = $1 AND organization_id = $2;

-- name: GetProductsByIDs :many
SELECT id, organization_id, vat_rate_id, title, reference, description, price_cents, type, period_count, period_unit, created_at, updated_at FROM RAC_catalog_products
WHERE organization_id = $1 AND id = ANY($2::uuid[]);

-- Materials

-- name: AddProductMaterials :exec
INSERT INTO RAC_catalog_product_materials (organization_id, product_id, material_id)
SELECT $1, $2, material_id
FROM RAC_catalog_products p
CROSS JOIN LATERAL unnest($3::uuid[]) AS material_id
WHERE p.id = $2 AND p.organization_id = $1
ON CONFLICT DO NOTHING;

-- name: RemoveProductMaterials :exec
DELETE FROM RAC_catalog_product_materials
WHERE organization_id = $1 AND product_id = $2 AND material_id = ANY($3::uuid[]);

-- name: ListProductMaterials :many
SELECT p.id, p.organization_id, p.vat_rate_id, p.title, p.reference, p.description, p.price_cents, p.type, p.period_count, p.period_unit, p.created_at, p.updated_at FROM RAC_catalog_products p
JOIN RAC_catalog_product_materials pm
  ON pm.material_id = p.id AND pm.organization_id = p.organization_id
WHERE pm.organization_id = $1 AND pm.product_id = $2
ORDER BY p.title ASC;

-- name: HasProductMaterials :one
SELECT EXISTS(SELECT 1 FROM RAC_catalog_product_materials WHERE organization_id = $1 AND product_id = $2);
</file>

<file path="internal/energylabel/client/client.go">
// Package client provides the HTTP client for EP-Online energy label API.
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"portal_final_backend/internal/energylabel/transport"
	"portal_final_backend/platform/logger"
)

// flexTime handles EP-Online timestamps that may lack timezone info.
type flexTime struct {
	time.Time
}

func (ft *flexTime) UnmarshalJSON(data []byte) error {
	s := strings.Trim(string(data), `"`)
	if s == "" || s == "null" {
		return nil
	}

	// Try standard RFC3339 first
	if t, err := time.Parse(time.RFC3339, s); err == nil {
		ft.Time = t
		return nil
	}

	// EP-Online often returns local timestamps without timezone
	layouts := []string{
		"2006-01-02T15:04:05.9999999",
		"2006-01-02T15:04:05.999999",
		"2006-01-02T15:04:05.99999",
		"2006-01-02T15:04:05.9999",
		"2006-01-02T15:04:05.999",
		"2006-01-02T15:04:05.99",
		"2006-01-02T15:04:05.9",
		"2006-01-02T15:04:05",
		"2006-01-02",
	}

	for _, layout := range layouts {
		if t, err := time.Parse(layout, s); err == nil {
			ft.Time = t
			return nil
		}
	}

	return fmt.Errorf("cannot parse %q as time", s)
}

func (ft *flexTime) ToTimePtr() *time.Time {
	if ft == nil || ft.IsZero() {
		return nil
	}
	t := ft.Time
	return &t
}

const (
	baseURL    = "https://public.ep-online.nl"
	apiVersion = "v5"
)

// Client is the HTTP client for EP-Online API.
type Client struct {
	httpClient *http.Client
	apiKey     string
	log        *logger.Logger
}

// New creates a new EP-Online API client.
func New(apiKey string, log *logger.Logger) *Client {
	return &Client{
		httpClient: &http.Client{Timeout: 10 * time.Second},
		apiKey:     apiKey,
		log:        log,
	}
}

// GetByAddress fetches energy label by address.
func (c *Client) GetByAddress(ctx context.Context, postcode, huisnummer, huisletter, toevoeging, detail string) ([]transport.EnergyLabel, error) {
	params := url.Values{}
	params.Set("postcode", postcode)
	params.Set("huisnummer", huisnummer)
	if huisletter != "" {
		params.Set("huisletter", huisletter)
	}
	if toevoeging != "" {
		params.Set("huisnummertoevoeging", toevoeging)
	}
	if detail != "" {
		params.Set("detailaanduiding", detail)
	}

	reqURL := fmt.Sprintf("%s/api/%s/PandEnergielabel/Adres?%s", baseURL, apiVersion, params.Encode())
	return c.doRequest(ctx, reqURL)
}

// GetByBAGObjectID fetches energy label by BAG adresseerbaar object ID.
func (c *Client) GetByBAGObjectID(ctx context.Context, objectID string) ([]transport.EnergyLabel, error) {
	reqURL := fmt.Sprintf("%s/api/%s/PandEnergielabel/AdresseerbaarObject/%s", baseURL, apiVersion, url.PathEscape(objectID))
	return c.doRequest(ctx, reqURL)
}

// Ping checks if the API is available.
func (c *Client) Ping(ctx context.Context) error {
	reqURL := fmt.Sprintf("%s/api/%s/Ping", baseURL, apiVersion)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("ping failed: status %d", resp.StatusCode)
	}

	return nil
}

func (c *Client) doRequest(ctx context.Context, reqURL string) ([]transport.EnergyLabel, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}

	req.Header.Set("Authorization", c.apiKey)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("ep-online request failed", "error", err, "url", reqURL)
		return nil, fmt.Errorf("http request: %w", err)
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	switch resp.StatusCode {
	case http.StatusOK:
		// Success - continue to decode
	case http.StatusUnauthorized:
		c.log.Error("ep-online unauthorized", "status", resp.StatusCode)
		return nil, fmt.Errorf("unauthorized: invalid API key")
	case http.StatusNotFound:
		// No energy label found for this address - not an error
		c.log.Debug("ep-online no label found", "url", reqURL)
		return nil, nil
	case http.StatusBadRequest:
		c.log.Error("ep-online bad request", "status", resp.StatusCode, "url", reqURL)
		return nil, fmt.Errorf("bad request: invalid parameters")
	default:
		c.log.Error("ep-online upstream error", "status", resp.StatusCode, "url", reqURL)
		return nil, fmt.Errorf("upstream error: status %d", resp.StatusCode)
	}

	var apiLabels []apiEnergyLabel
	if err := json.NewDecoder(resp.Body).Decode(&apiLabels); err != nil {
		c.log.Error("ep-online decode failed", "error", err)
		return nil, fmt.Errorf("decode response: %w", err)
	}

	labels := make([]transport.EnergyLabel, 0, len(apiLabels))
	for _, api := range apiLabels {
		labels = append(labels, api.toTransport())
	}

	return labels, nil
}

// apiEnergyLabel is the raw response from EP-Online API (PandEnergielabelV5).
type apiEnergyLabel struct {
	Registratiedatum                        *flexTime `json:"Registratiedatum"`
	Opnamedatum                             *flexTime `json:"Opnamedatum"`
	GeldigTot                               *flexTime `json:"Geldig_tot"`
	Certificaathouder                       *string   `json:"Certificaathouder"`
	SoortOpname                             *string   `json:"Soort_opname"`
	Status                                  *string   `json:"Status"`
	Berekeningstype                         *string   `json:"Berekeningstype"`
	IsVereenvoudigdLabel                    *bool     `json:"IsVereenvoudigdLabel"`
	OpBasisVanReferentiegebouw              bool      `json:"Op_basis_van_referentiegebouw"`
	Gebouwklasse                            *string   `json:"Gebouwklasse"`
	Gebouwtype                              *string   `json:"Gebouwtype"`
	Gebouwsubtype                           *string   `json:"Gebouwsubtype"`
	SBIcode                                 *string   `json:"SBIcode"`
	Postcode                                *string   `json:"Postcode"`
	Huisnummer                              int       `json:"Huisnummer"`
	Huisletter                              *string   `json:"Huisletter"`
	Huisnummertoevoeging                    *string   `json:"Huisnummertoevoeging"`
	Detailaanduiding                        *string   `json:"Detailaanduiding"`
	BAGVerblijfsobjectID                    *string   `json:"BAGVerblijfsobjectID"`
	BAGLigplaatsID                          *string   `json:"BAGLigplaatsID"`
	BAGStandplaatsID                        *string   `json:"BAGStandplaatsID"`
	BAGPandIDs                              []string  `json:"BAGPandIDs"`
	Bouwjaar                                int       `json:"Bouwjaar"`
	GebruiksoppervlakteThermischeZone       *float64  `json:"Gebruiksoppervlakte_thermische_zone"`
	Compactheid                             *float64  `json:"Compactheid"`
	Energieklasse                           *string   `json:"Energieklasse"`
	EnergieIndex                            *float64  `json:"EnergieIndex"`
	EnergieIndexEMGForfaitair               *float64  `json:"EnergieIndex_EMG_forfaitair"`
	Energiebehoefte                         *float64  `json:"Energiebehoefte"`
	PrimaireFossieleEnergie                 *float64  `json:"PrimaireFossieleEnergie"`
	PrimaireFossieleEnergieEMGForfaitair    *float64  `json:"Primaire_fossiele_energie_EMG_forfaitair"`
	AandeelHernieuwbareEnergie              *float64  `json:"Aandeel_hernieuwbare_energie"`
	AandeelHernieuwbareEnergieEMGForfaitair *float64  `json:"Aandeel_hernieuwbare_energie_EMG_forfaitair"`
	Temperatuuroverschrijding               *float64  `json:"Temperatuuroverschrijding"`
	Warmtebehoefte                          *float64  `json:"Warmtebehoefte"`
	EisEnergiebehoefte                      *float64  `json:"Eis_energiebehoefte"`
	EisPrimaireFossieleEnergie              *float64  `json:"Eis_primaire_fossiele_energie"`
	EisAandeelHernieuwbareEnergie           *float64  `json:"Eis_aandeel_hernieuwbare_energie"`
	EisTemperatuuroverschrijding            *float64  `json:"Eis_temperatuuroverschrijding"`
	BerekendeCO2Emissie                     *float64  `json:"BerekendeCO2Emissie"`
	BerekendeEnergieverbruik                *float64  `json:"BerekendeEnergieverbruik"`
}

func (a *apiEnergyLabel) toTransport() transport.EnergyLabel {
	label := transport.EnergyLabel{
		Registratiedatum:                  a.Registratiedatum.ToTimePtr(),
		Opnamedatum:                       a.Opnamedatum.ToTimePtr(),
		GeldigTot:                         a.GeldigTot.ToTimePtr(),
		Huisnummer:                        a.Huisnummer,
		Bouwjaar:                          a.Bouwjaar,
		OpBasisVanReferentiegebouw:        a.OpBasisVanReferentiegebouw,
		BAGPandIDs:                        a.BAGPandIDs,
		IsVereenvoudigdLabel:              a.IsVereenvoudigdLabel,
		EnergieIndex:                      a.EnergieIndex,
		Energiebehoefte:                   a.Energiebehoefte,
		PrimaireFossieleEnergie:           a.PrimaireFossieleEnergie,
		AandeelHernieuwbareEnergie:        a.AandeelHernieuwbareEnergie,
		Temperatuuroverschrijding:         a.Temperatuuroverschrijding,
		GebruiksoppervlakteThermischeZone: a.GebruiksoppervlakteThermischeZone,
		Compactheid:                       a.Compactheid,
		Warmtebehoefte:                    a.Warmtebehoefte,
		BerekendeCO2Emissie:               a.BerekendeCO2Emissie,
		BerekendeEnergieverbruik:          a.BerekendeEnergieverbruik,
	}

	// Copy string pointers
	if a.Energieklasse != nil {
		label.Energieklasse = *a.Energieklasse
	}
	if a.Certificaathouder != nil {
		label.Certificaathouder = *a.Certificaathouder
	}
	if a.SoortOpname != nil {
		label.SoortOpname = *a.SoortOpname
	}
	if a.Status != nil {
		label.Status = *a.Status
	}
	if a.Berekeningstype != nil {
		label.Berekeningstype = *a.Berekeningstype
	}
	if a.Gebouwklasse != nil {
		label.Gebouwklasse = *a.Gebouwklasse
	}
	if a.Gebouwtype != nil {
		label.Gebouwtype = *a.Gebouwtype
	}
	if a.Gebouwsubtype != nil {
		label.Gebouwsubtype = *a.Gebouwsubtype
	}
	if a.Postcode != nil {
		label.Postcode = *a.Postcode
	}
	if a.Huisletter != nil {
		label.Huisletter = *a.Huisletter
	}
	if a.Huisnummertoevoeging != nil {
		label.Huisnummertoevoeging = *a.Huisnummertoevoeging
	}
	if a.Detailaanduiding != nil {
		label.Detailaanduiding = *a.Detailaanduiding
	}
	if a.BAGVerblijfsobjectID != nil {
		label.BAGVerblijfsobjectID = *a.BAGVerblijfsobjectID
	}
	if a.BAGLigplaatsID != nil {
		label.BAGLigplaatsID = *a.BAGLigplaatsID
	}
	if a.BAGStandplaatsID != nil {
		label.BAGStandplaatsID = *a.BAGStandplaatsID
	}

	return label
}
</file>

<file path="internal/energylabel/energylabel.go">
// Package energylabel provides the energy label bounded context.
// This file defines the public interfaces exposed to other domains.
package energylabel

import (
	"context"

	"portal_final_backend/internal/energylabel/transport"
)

// EnergyLabelService defines the public interface for energy label lookups.
// Other domains should depend on this interface, not the concrete implementation.
type EnergyLabelService interface {
	// GetByAddress fetches the energy label for a given Dutch address.
	// Returns nil if no label is found for the address.
	GetByAddress(ctx context.Context, postcode, huisnummer, huisletter, toevoeging, detail string) (*transport.EnergyLabel, error)

	// GetByBAGObjectID fetches the energy label for a BAG adresseerbaar object ID.
	// Returns nil if no label is found for the object.
	GetByBAGObjectID(ctx context.Context, objectID string) (*transport.EnergyLabel, error)

	// Ping checks if the EP-Online API is available.
	Ping(ctx context.Context) error
}
</file>

<file path="internal/energylabel/module.go">
// Package energylabel provides the energy label bounded context module.
// This file defines the module that encapsulates all energy label setup.
package energylabel

import (
	"portal_final_backend/internal/energylabel/client"
	"portal_final_backend/internal/energylabel/service"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
)

// Module is the energy label bounded context module.
type Module struct {
	service *service.Service
	enabled bool
}

// NewModule creates and initializes the energy label module.
// Returns nil if energy label API is not configured (graceful degradation).
func NewModule(cfg config.EnergyLabelConfig, log *logger.Logger) *Module {
	if !cfg.IsEnergyLabelEnabled() {
		log.Info("energy label module disabled: EP_ONLINE_API_KEY not configured")
		return &Module{enabled: false}
	}

	apiClient := client.New(cfg.GetEPOnlineAPIKey(), log)
	svc := service.New(apiClient, log)

	log.Info("energy label module initialized")

	return &Module{
		service: svc,
		enabled: true,
	}
}

// Service returns the energy label service for external use.
// Returns nil if the module is disabled.
func (m *Module) Service() *service.Service {
	if m == nil || !m.enabled {
		return nil
	}
	return m.service
}

// IsEnabled returns true if the energy label module is configured and enabled.
func (m *Module) IsEnabled() bool {
	return m != nil && m.enabled
}
</file>

<file path="internal/energylabel/service/service.go">
// Package service provides business logic for energy label lookups.
package service

import (
	"context"
	"sync"
	"time"

	"portal_final_backend/internal/energylabel/client"
	"portal_final_backend/internal/energylabel/transport"
	"portal_final_backend/platform/logger"
)

// cacheEntry holds a cached energy label with expiration.
type cacheEntry struct {
	labels    []transport.EnergyLabel
	expiresAt time.Time
}

// Service handles energy label lookups with caching.
type Service struct {
	client   *client.Client
	log      *logger.Logger
	cache    map[string]cacheEntry
	cacheMu  sync.RWMutex
	cacheTTL time.Duration
}

// New creates a new energy label service.
func New(client *client.Client, log *logger.Logger) *Service {
	return &Service{
		client:   client,
		log:      log,
		cache:    make(map[string]cacheEntry),
		cacheTTL: 24 * time.Hour, // Energy labels don't change often
	}
}

// GetByAddress fetches energy label by address, using cache when available.
func (s *Service) GetByAddress(ctx context.Context, postcode, huisnummer, huisletter, toevoeging, detail string) (*transport.EnergyLabel, error) {
	cacheKey := buildAddressCacheKey(postcode, huisnummer, huisletter, toevoeging, detail)

	// Check cache first
	if labels := s.getFromCache(cacheKey); labels != nil {
		if len(labels) > 0 {
			return &labels[0], nil
		}
		return nil, nil
	}

	// Fetch from API
	labels, err := s.client.GetByAddress(ctx, postcode, huisnummer, huisletter, toevoeging, detail)
	if err != nil {
		return nil, err
	}

	// Cache result (even if empty to avoid repeated lookups for non-existent labels)
	s.setCache(cacheKey, labels)

	if len(labels) == 0 {
		return nil, nil
	}

	return &labels[0], nil
}

// GetByBAGObjectID fetches energy label by BAG object ID, using cache when available.
func (s *Service) GetByBAGObjectID(ctx context.Context, objectID string) (*transport.EnergyLabel, error) {
	cacheKey := "bag:" + objectID

	// Check cache first
	if labels := s.getFromCache(cacheKey); labels != nil {
		if len(labels) > 0 {
			return &labels[0], nil
		}
		return nil, nil
	}

	// Fetch from API
	labels, err := s.client.GetByBAGObjectID(ctx, objectID)
	if err != nil {
		return nil, err
	}

	// Cache result
	s.setCache(cacheKey, labels)

	if len(labels) == 0 {
		return nil, nil
	}

	return &labels[0], nil
}

// Ping checks if the EP-Online API is available.
func (s *Service) Ping(ctx context.Context) error {
	return s.client.Ping(ctx)
}

// ClearCache removes all cached entries.
func (s *Service) ClearCache() {
	s.cacheMu.Lock()
	defer s.cacheMu.Unlock()
	s.cache = make(map[string]cacheEntry)
}

func (s *Service) getFromCache(key string) []transport.EnergyLabel {
	s.cacheMu.RLock()
	defer s.cacheMu.RUnlock()

	entry, ok := s.cache[key]
	if !ok {
		return nil
	}

	if time.Now().After(entry.expiresAt) {
		return nil
	}

	return entry.labels
}

func (s *Service) setCache(key string, labels []transport.EnergyLabel) {
	s.cacheMu.Lock()
	defer s.cacheMu.Unlock()

	s.cache[key] = cacheEntry{
		labels:    labels,
		expiresAt: time.Now().Add(s.cacheTTL),
	}
}

func buildAddressCacheKey(postcode, huisnummer, huisletter, toevoeging, detail string) string {
	return "addr:" + postcode + ":" + huisnummer + ":" + huisletter + ":" + toevoeging + ":" + detail
}
</file>

<file path="internal/energylabel/transport/dto.go">
// Package transport provides DTOs for the energy label domain.
package transport

import "time"

// EnergyLabel represents the energy label data from EP-Online.
type EnergyLabel struct {
	// Core label information
	Energieklasse string   `json:"energieklasse"` // A+++, A++, A+, A, B, C, D, E, F, G
	EnergieIndex  *float64 `json:"energieIndex,omitempty"`

	// Registration info
	Registratiedatum *time.Time `json:"registratiedatum,omitempty"`
	Opnamedatum      *time.Time `json:"opnamedatum,omitempty"`
	GeldigTot        *time.Time `json:"geldigTot,omitempty"`

	// Building info
	Gebouwklasse  string `json:"gebouwklasse,omitempty"`  // Woning or Utiliteitsgebouw
	Gebouwtype    string `json:"gebouwtype,omitempty"`    // Type of dwelling
	Gebouwsubtype string `json:"gebouwsubtype,omitempty"` // Apartment position in building
	Bouwjaar      int    `json:"bouwjaar,omitempty"`

	// Address info (from BAG)
	Postcode             string `json:"postcode,omitempty"`
	Huisnummer           int    `json:"huisnummer,omitempty"`
	Huisletter           string `json:"huisletter,omitempty"`
	Huisnummertoevoeging string `json:"huisnummertoevoeging,omitempty"`
	Detailaanduiding     string `json:"detailaanduiding,omitempty"`

	// BAG identifiers
	BAGVerblijfsobjectID string   `json:"bagVerblijfsobjectId,omitempty"`
	BAGLigplaatsID       string   `json:"bagLigplaatsId,omitempty"`
	BAGStandplaatsID     string   `json:"bagStandplaatsId,omitempty"`
	BAGPandIDs           []string `json:"bagPandIds,omitempty"`

	// Energy performance metrics (NTA 8800)
	Energiebehoefte                   *float64 `json:"energiebehoefte,omitempty"`                   // kWh/m2jaar
	PrimaireFossieleEnergie           *float64 `json:"primaireFossieleEnergie,omitempty"`           // kWh/m2jaar
	AandeelHernieuwbareEnergie        *float64 `json:"aandeelHernieuwbareEnergie,omitempty"`        // %
	Temperatuuroverschrijding         *float64 `json:"temperatuuroverschrijding,omitempty"`         // TOjuli or GTO
	GebruiksoppervlakteThermischeZone *float64 `json:"gebruiksoppervlakteThermischeZone,omitempty"` // m2
	Compactheid                       *float64 `json:"compactheid,omitempty"`                       // ratio
	Warmtebehoefte                    *float64 `json:"warmtebehoefte,omitempty"`                    // kWh/m2jaar (EPV)
	BerekendeCO2Emissie               *float64 `json:"berekendeCO2Emissie,omitempty"`               // kg/m2jaar
	BerekendeEnergieverbruik          *float64 `json:"berekendeEnergieverbruik,omitempty"`          // kWh/m2jaar

	// Label metadata
	Certificaathouder          string `json:"certificaathouder,omitempty"`
	SoortOpname                string `json:"soortOpname,omitempty"` // Basis or Detail
	Status                     string `json:"status,omitempty"`
	Berekeningstype            string `json:"berekeningstype,omitempty"`
	IsVereenvoudigdLabel       *bool  `json:"isVereenvoudigdLabel,omitempty"` // VEL indicator
	OpBasisVanReferentiegebouw bool   `json:"opBasisVanReferentiegebouw,omitempty"`
}

// GetByAddressRequest contains parameters for looking up energy label by address.
type GetByAddressRequest struct {
	Postcode             string `json:"postcode" validate:"required,len=6"`
	Huisnummer           string `json:"huisnummer" validate:"required,min=1,max=5"`
	Huisletter           string `json:"huisletter,omitempty" validate:"omitempty,len=1"`
	Huisnummertoevoeging string `json:"huisnummertoevoeging,omitempty" validate:"omitempty,max=4"`
	Detailaanduiding     string `json:"detailaanduiding,omitempty"`
}

// GetByBAGObjectIDRequest contains parameters for looking up energy label by BAG ID.
type GetByBAGObjectIDRequest struct {
	AdresseerbaarObjectID string `json:"adresseerbaarObjectId" validate:"required,len=16"`
}
</file>

<file path="internal/events/bus.go">
// Package events re-exports the platform event bus for convenience.
// This allows internal modules to import events from internal/events
// while the implementation lives in platform/events.
package events

import (
	platformevents "portal_final_backend/platform/events"
	"portal_final_backend/platform/logger"
)

// InMemoryBus is a type alias to the platform InMemoryBus
type InMemoryBus = platformevents.InMemoryBus

// NewInMemoryBus creates a new in-memory event bus.
// This is a convenience re-export from platform/events.
func NewInMemoryBus(log *logger.Logger) *InMemoryBus {
	return platformevents.NewInMemoryBus(log)
}
</file>

<file path="internal/http/app.go">
// Package http provides HTTP server infrastructure including module registration.
package http

import (
	"context"
	"portal_final_backend/internal/events"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
)

// RouterConfig combines the config interfaces needed by the HTTP router.
type RouterConfig interface {
	config.HTTPConfig
	config.JWTConfig
}

// HealthChecker exposes minimal functionality for readiness checks.
type HealthChecker interface {
	Ping(ctx context.Context) error
}

// App holds the fully initialized application dependencies.
// This is populated by main.go (the composition root) and passed to the router.
type App struct {
	// Config holds the router configuration (HTTP and JWT settings only).
	Config RouterConfig
	// Logger is the structured logger.
	Logger *logger.Logger
	// Health is used for readiness/health checks (e.g., DB ping).
	Health HealthChecker
	// EventBus is the domain event bus for cross-module communication.
	EventBus events.Bus
	// Modules contains all HTTP-facing domain modules.
	Modules []Module
}
</file>

<file path="internal/http/middleware/middleware.go">
package middleware

import (
	"errors"
	"net/http"
	"strings"
	"sync"
	"time"

	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/time/rate"
)

const (
	ContextUserIDKey = "userID"
	ContextRolesKey  = "RAC_roles"
	errMissingToken  = "missing token"
	errInvalidToken  = "invalid token"
)

// RequestLogger logs HTTP requests with timing
func RequestLogger(log *logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		clientIP := c.ClientIP()

		log.HTTPRequest(c.Request.Method, path, status, float64(latency.Milliseconds()), clientIP)
	}
}

// SecurityHeaders adds security headers to responses
func SecurityHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		c.Header("Content-Security-Policy", "default-src 'self'")
		c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()")

		// Only add HSTS in production
		if c.Request.TLS != nil {
			c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}

		c.Next()
	}
}

// IPRateLimiter manages per-IP rate limiters
type IPRateLimiter struct {
	limiters sync.Map
	rate     rate.Limit
	burst    int
	log      *logger.Logger
}

// NewIPRateLimiter creates a new IP-based rate limiter
func NewIPRateLimiter(r rate.Limit, burst int, log *logger.Logger) *IPRateLimiter {
	return &IPRateLimiter{
		rate:  r,
		burst: burst,
		log:   log,
	}
}

func (i *IPRateLimiter) getLimiter(ip string) *rate.Limiter {
	limiter, exists := i.limiters.Load(ip)
	if !exists {
		newLimiter := rate.NewLimiter(i.rate, i.burst)
		i.limiters.Store(ip, newLimiter)
		return newLimiter
	}
	return limiter.(*rate.Limiter)
}

// RateLimit returns a middleware that rate limits by IP
func (i *IPRateLimiter) RateLimit() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()
		limiter := i.getLimiter(ip)

		if !limiter.Allow() {
			if i.log != nil {
				i.log.RateLimitExceeded(ip, c.Request.URL.Path)
			}
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"error": "rate limit exceeded",
			})
			return
		}

		c.Next()
	}
}

// AuthRateLimiter is a stricter rate limiter for auth endpoints
type AuthRateLimiter struct {
	*IPRateLimiter
}

// NewAuthRateLimiter creates a rate limiter for authentication endpoints
// with stricter limits (e.g., 5 requests per minute)
func NewAuthRateLimiter(log *logger.Logger) *AuthRateLimiter {
	return &AuthRateLimiter{
		IPRateLimiter: NewIPRateLimiter(rate.Limit(5.0/60.0), 5, log), // 5 requests per minute, burst of 5
	}
}

func AuthRequired(cfg config.JWTConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		rawToken, ok := extractBearerToken(c.GetHeader("Authorization"))
		if !ok {
			abortUnauthorized(c, errMissingToken)
			return
		}

		claims, err := parseAccessClaims(rawToken, cfg)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		userID, err := parseUserID(claims)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		roles := extractRoles(claims["RAC_roles"])
		c.Set(ContextUserIDKey, userID)
		c.Set(ContextRolesKey, roles)
		c.Next()
	}
}

func RequireRole(role string) gin.HandlerFunc {
	return func(c *gin.Context) {
		roles, ok := c.Get(ContextRolesKey)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		roleList, ok := roles.([]string)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		for _, item := range roleList {
			if item == role {
				c.Next()
				return
			}
		}

		c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
	}
}

func extractRoles(value interface{}) []string {
	roles := make([]string, 0)
	if value == nil {
		return roles
	}

	switch typed := value.(type) {
	case []string:
		return append(roles, typed...)
	case []interface{}:
		for _, item := range typed {
			if text, ok := item.(string); ok {
				roles = append(roles, text)
			}
		}
	}

	return roles
}

func extractBearerToken(authHeader string) (string, bool) {
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return "", false
	}

	rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
	if rawToken == "" {
		return "", false
	}

	return rawToken, true
}

func parseAccessClaims(rawToken string, cfg config.JWTConfig) (jwt.MapClaims, error) {
	parsed, err := jwt.Parse(rawToken, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("invalid signing method")
		}
		return []byte(cfg.GetJWTAccessSecret()), nil
	})
	if err != nil || !parsed.Valid {
		return nil, errors.New(errInvalidToken)
	}

	claims, ok := parsed.Claims.(jwt.MapClaims)
	if !ok {
		return nil, errors.New(errInvalidToken)
	}

	if tokenType, _ := claims["type"].(string); tokenType != "access" {
		return nil, errors.New(errInvalidToken)
	}

	return claims, nil
}

func parseUserID(claims jwt.MapClaims) (uuid.UUID, error) {
	userIDRaw, _ := claims["sub"].(string)
	return uuid.Parse(userIDRaw)
}

func abortUnauthorized(c *gin.Context, message string) {
	c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": message})
}
</file>

<file path="internal/http/module.go">
// Package http provides HTTP server infrastructure including the Module interface
// that all domain modules must implement for route registration.
package http

import (
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"

	"github.com/gin-gonic/gin"
)

// Module represents a bounded context that can register its HTTP routes.
// Each domain module implements this interface to encapsulate its own
// route setup, keeping the main router decoupled from specific endpoints.
type Module interface {
	// Name returns the module's identifier for logging purposes.
	Name() string
	// RegisterRoutes mounts the module's routes on the provided router group.
	// The RouterContext provides access to shared middleware and configuration.
	RegisterRoutes(ctx *RouterContext)
}

// RouterContext provides shared dependencies for module route registration.
// This avoids passing many parameters to each module's RegisterRoutes method.
type RouterContext struct {
	// Engine is the root Gin engine for modules that need engine-level access.
	Engine *gin.Engine
	// V1 is the /api/v1 route group.
	V1 *gin.RouterGroup
	// Protected is the authenticated route group under /api/v1.
	Protected *gin.RouterGroup
	// Admin is the admin-only route group under /api/v1/admin.
	Admin *gin.RouterGroup
	// Config is the JWT configuration for auth middleware (scoped access).
	Config config.JWTConfig
	// AuthMiddleware provides the authentication middleware.
	AuthMiddleware gin.HandlerFunc
	// AuthRateLimiter is the stricter rate limiter for auth routes.
	AuthRateLimiter *httpkit.AuthRateLimiter
}
</file>

<file path="internal/http/response/response.go">
package response

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type ErrorResponse struct {
	Error   string      `json:"error"`
	Details interface{} `json:"details,omitempty"`
}

func JSON(c *gin.Context, status int, payload interface{}) {
	c.JSON(status, payload)
}

func Error(c *gin.Context, status int, message string, details interface{}) {
	c.JSON(status, ErrorResponse{Error: message, Details: details})
}

func OK(c *gin.Context, payload interface{}) {
	c.JSON(http.StatusOK, payload)
}
</file>

<file path="internal/http/router/portal_final.code-workspace">
{
	"folders": [
		{
			"path": "../../../../portal_final"
		},
		{
			"path": "../../.."
		}
	],
	"settings": {}
}
</file>

<file path="internal/identity/identity.go">
// Package identity provides the identity and tenancy bounded context API.
package identity

import (
	"context"

	"github.com/google/uuid"
)

// Service defines the public interface for tenancy operations.
// Other domains should depend on this interface, not on concrete implementations.
type Service interface {
	// GetUserOrganizationID returns the organization ID for a user.
	GetUserOrganizationID(ctx context.Context, userID uuid.UUID) (uuid.UUID, error)
}
</file>

<file path="internal/leadenrichment/client/client.go">
// Package client provides HTTP clients for PDOK lead enrichment lookups.
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"portal_final_backend/platform/logger"
)

const (
	pdokPC4Endpoint       = "https://api.pdok.nl/cbs/postcode4/ogc/v1/collections/postcode4/items"
	pdokPC6Endpoint       = "https://api.pdok.nl/cbs/postcode6/ogc/v1/collections/postcode6/items"
	pdokLocatieEndpoint   = "https://api.pdok.nl/bzk/locatieserver/search/v3_1/free"
	pdokBuurtenEndpoint   = "https://api.pdok.nl/cbs/wijken-en-buurten-2024/ogc/v1/collections/buurten/items"
	cbsODataEndpoint      = "https://opendata.cbs.nl/ODataApi/odata/85618NED/TypedDataSet" // Kerncijfers wijken en buurten 2024
	defaultHTTPTimeout    = 10 * time.Second
	blockedValueThreshold = -99990 // CBS uses -99995, -99997, etc. for privacy-suppressed data
	pc6LatestYear         = 2024
)

// FlexNumber handles JSON values that can be either string or number.
type FlexNumber float64

func (f *FlexNumber) UnmarshalJSON(data []byte) error {
	// Try as number first
	var num float64
	if err := json.Unmarshal(data, &num); err == nil {
		*f = FlexNumber(num)
		return nil
	}
	// Try as string
	var str string
	if err := json.Unmarshal(data, &str); err == nil {
		if str == "" {
			*f = 0
			return nil
		}
		parsed, err := strconv.ParseFloat(str, 64)
		if err != nil {
			return err
		}
		*f = FlexNumber(parsed)
		return nil
	}
	return fmt.Errorf("cannot unmarshal %s into FlexNumber", string(data))
}

// Client handles PDOK requests.
type Client struct {
	httpClient *http.Client
	log        *logger.Logger
}

// New creates a new PDOK client.
func New(log *logger.Logger) *Client {
	return &Client{
		httpClient: &http.Client{Timeout: defaultHTTPTimeout},
		log:        log,
	}
}

// PC6Properties holds PC6 properties from PDOK CBS Postcode6 API.
// Field names match the actual API response. Some fields use FlexNumber
// because the API inconsistently returns them as strings or numbers.
type PC6Properties struct {
	// Fields from PDOK CBS Postcode6 API
	GemiddeldGasverbruikWoning      *FlexNumber `json:"gemiddeld_gasverbruik_woning"`
	GemiddeldElektriciteitsverbruik *FlexNumber `json:"gemiddeld_elektriciteitsverbruik_woning"`
	GemiddeldHuishoudensgrootte     *FlexNumber `json:"gemiddelde_huishoudensgrootte"`
	GemiddeldWOZWaarde              *FlexNumber `json:"gemiddelde_woz_waarde_woning"`
	AantalWoningen                  *FlexNumber `json:"aantal_woningen"`
	AantalInwoners                  *FlexNumber `json:"aantal_inwoners"`
	AantalHuishoudens               *FlexNumber `json:"aantal_part_huishoudens"`

	// Percentage fields
	KoopwoningenPct           *FlexNumber `json:"percentage_koopwoningen"`
	HuurwoningenPct           *FlexNumber `json:"percentage_huurwoningen"`
	HuishoudensMetKinderenPct *FlexNumber `json:"percentage_huishoudens_met_kinderen"` // Derived from household types

	// Income/wealth fields (these can be strings in the API response!)
	MediaanInkomenHuishouden *FlexNumber `json:"mediaan_inkomen_huishouden"`

	// Age breakdown percentages
	Inwoners0Tot15Pct  *FlexNumber `json:"percentage_personen_0_tot_15_jaar"`
	Inwoners15Tot25Pct *FlexNumber `json:"percentage_personen_15_tot_25_jaar"`
	Inwoners25Tot45Pct *FlexNumber `json:"percentage_personen_25_tot_45_jaar"`
	Inwoners45Tot65Pct *FlexNumber `json:"percentage_personen_45_tot_65_jaar"`
	Inwoners65PlusPct  *FlexNumber `json:"percentage_personen_65_jaar_en_ouder"`

	// Building age counts (for calculating percentage built after 2000)
	WoningenBouwjaar05Tot15   *FlexNumber `json:"aantal_woningen_bouwjaar_05_tot_15"`
	WoningenBouwjaar15EnLater *FlexNumber `json:"aantal_woningen_bouwjaar_15_en_later"`
}

type pc6Response struct {
	Features []struct {
		Properties PC6Properties `json:"properties"`
	} `json:"features"`
}

// GetPC6 fetches PC6-level statistics from PDOK.
func (c *Client) GetPC6(ctx context.Context, postcode6 string) (*PC6Properties, bool, error) {
	params := url.Values{}
	params.Set("f", "json")
	params.Set("postcode6", postcode6)
	params.Set("jaarcode", fmt.Sprintf("%d", pc6LatestYear))
	params.Set("limit", "1")

	payload, err := c.fetchPC6(ctx, params)
	if err != nil {
		return nil, false, err
	}
	if len(payload.Features) == 0 {
		params.Del("jaarcode")
		payload, err = c.fetchPC6(ctx, params)
		if err != nil {
			return nil, false, err
		}
		if len(payload.Features) == 0 {
			return nil, false, nil
		}
	}

	props := payload.Features[0].Properties
	if isPC6Blocked(props) {
		return &props, true, nil
	}
	return &props, false, nil
}

func (c *Client) fetchPC6(ctx context.Context, params url.Values) (pc6Response, error) {
	reqURL := fmt.Sprintf("%s?%s", pdokPC6Endpoint, params.Encode())
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return pc6Response{}, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("pdok pc6 request failed", "error", err)
		return pc6Response{}, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		c.log.Error("pdok pc6 request error", "status", resp.StatusCode)
		return pc6Response{}, fmt.Errorf("pdok pc6 status %d", resp.StatusCode)
	}

	var payload pc6Response
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		c.log.Error("pdok pc6 decode failed", "error", err)
		return pc6Response{}, err
	}

	return payload, nil
}

func isPC6Blocked(props PC6Properties) bool {
	// Check if key fields have valid data (not privacy-suppressed)
	checks := []struct {
		hasValue  bool
		isBlocked bool
	}{
		checkBlockedFlexNumber(props.AantalInwoners),
		checkBlockedFlexNumber(props.AantalHuishoudens),
		checkBlockedFlexNumber(props.KoopwoningenPct),
	}

	for _, c := range checks {
		if !c.hasValue || c.isBlocked {
			return true
		}
	}
	return false
}

func checkBlockedFlexNumber(value *FlexNumber) struct {
	hasValue  bool
	isBlocked bool
} {
	if value == nil {
		return struct {
			hasValue  bool
			isBlocked bool
		}{false, false}
	}
	return struct {
		hasValue  bool
		isBlocked bool
	}{true, float64(*value) <= blockedValueThreshold}
}

// ToFloat64Ptr converts FlexNumber pointer to float64 pointer, filtering blocked values.
func (f *FlexNumber) ToFloat64Ptr() *float64 {
	if f == nil {
		return nil
	}
	val := float64(*f)
	if val <= blockedValueThreshold {
		return nil
	}
	return &val
}

// ToIntPtr converts FlexNumber pointer to int pointer, filtering blocked values.
func (f *FlexNumber) ToIntPtr() *int {
	if f == nil {
		return nil
	}
	val := int(*f)
	if float64(*f) <= blockedValueThreshold {
		return nil
	}
	return &val
}

// BuurtProperties holds properties from PDOK CBS Wijken en Buurten 2024 API.
// These provide richer statistics at the neighborhood (buurt) level.
type BuurtProperties struct {
	Buurtcode    string `json:"buurtcode"`
	Buurtnaam    string `json:"buurtnaam"`
	Gemeentenaam string `json:"gemeentenaam"`

	// Housing & ownership
	AantalWoningen     *FlexNumber `json:"aantal_woningen"`
	KoopwoningenPct    *FlexNumber `json:"percentage_koopwoningen"`
	HuurwoningenPct    *FlexNumber `json:"percentage_huurwoningen"`
	GemiddeldWOZWaarde *FlexNumber `json:"gemiddelde_woningwaarde"`

	// Building age
	BouwjaarVanaf2000Pct *FlexNumber `json:"percentage_bouwjaarklasse_vanaf_2000"`

	// Demographics
	AantalInwoners        *FlexNumber `json:"aantal_inwoners"`
	AantalHuishoudens     *FlexNumber `json:"aantal_particuliere_huishoudens"`
	GemHuishoudensgrootte *FlexNumber `json:"gemiddelde_huishoudensgrootte"`

	// Household types
	HuishoudensMetKinderenPct *FlexNumber `json:"percentage_huishoudens_met_kinderen"`
	EenpersoonsHuishoudensPct *FlexNumber `json:"percentage_eenpersoonshuishoudens"`

	// Income & wealth
	MediaanInkomen  *FlexNumber `json:"mediaan_besteedbaar_inkomen_per_inwoner"`
	MediaanVermogen *FlexNumber `json:"mediaan_vermogen_van_particuliere_huish"`

	// Energy usage
	GemiddeldGasverbruik     *FlexNumber `json:"gemiddeld_gasverbruik_totaal"`
	GemiddeldElektraverbruik *FlexNumber `json:"gemiddeld_elektriciteitsverbruik_totaal"`

	// Age breakdown
	Inwoners0Tot15Pct  *FlexNumber `json:"percentage_personen_0_tot_15_jaar"`
	Inwoners15Tot25Pct *FlexNumber `json:"percentage_personen_15_tot_25_jaar"`
	Inwoners25Tot45Pct *FlexNumber `json:"percentage_personen_25_tot_45_jaar"`
	Inwoners45Tot65Pct *FlexNumber `json:"percentage_personen_45_tot_65_jaar"`
	Inwoners65PlusPct  *FlexNumber `json:"percentage_personen_65_jaar_en_ouder"`
}

type buurtResponse struct {
	Features []struct {
		Properties BuurtProperties `json:"properties"`
	} `json:"features"`
}

type locatieResponse struct {
	Response struct {
		Docs []struct {
			Buurtcode string `json:"buurtcode"`
			Buurtnaam string `json:"buurtnaam"`
		} `json:"docs"`
	} `json:"response"`
}

// GetBuurtcode fetches the buurtcode for a postcode from PDOK locatieserver.
func (c *Client) GetBuurtcode(ctx context.Context, postcode6 string) (string, error) {
	params := url.Values{}
	params.Set("q", postcode6)
	params.Set("fq", "type:adres") // Use adres type - postcode type doesn't include buurtcode
	params.Set("rows", "1")
	params.Set("fl", "buurtcode,buurtnaam")

	reqURL := fmt.Sprintf("%s?%s", pdokLocatieEndpoint, params.Encode())
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return "", err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("pdok locatie request failed", "error", err)
		return "", err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("pdok locatie status %d", resp.StatusCode)
	}

	var payload locatieResponse
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		c.log.Error("pdok locatie decode failed", "error", err)
		return "", err
	}

	if len(payload.Response.Docs) == 0 {
		return "", nil
	}

	return payload.Response.Docs[0].Buurtcode, nil
}

// GetBuurt fetches buurt-level statistics from PDOK CBS Wijken en Buurten 2024.
func (c *Client) GetBuurt(ctx context.Context, buurtcode string) (*BuurtProperties, bool, error) {
	if buurtcode == "" {
		return nil, false, nil
	}

	params := url.Values{}
	params.Set("f", "json")
	params.Set("buurtcode", buurtcode)
	params.Set("limit", "1")

	reqURL := fmt.Sprintf("%s?%s", pdokBuurtenEndpoint, params.Encode())
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, false, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("pdok buurt request failed", "error", err)
		return nil, false, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		c.log.Error("pdok buurt request error", "status", resp.StatusCode)
		return nil, false, fmt.Errorf("pdok buurt status %d", resp.StatusCode)
	}

	var payload buurtResponse
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		c.log.Error("pdok buurt decode failed", "error", err)
		return nil, false, err
	}

	if len(payload.Features) == 0 {
		return nil, false, nil
	}

	props := payload.Features[0].Properties
	if isBuurtBlocked(props) {
		return &props, true, nil
	}
	return &props, false, nil
}

func isBuurtBlocked(props BuurtProperties) bool {
	// Only consider buurt blocked if primary demographic fields are ALL blocked
	// (AantalInwoners OR AantalHuishoudens must be valid for any useful data)
	inwonersCheck := checkBlockedFlexNumber(props.AantalInwoners)
	huishoudensCheck := checkBlockedFlexNumber(props.AantalHuishoudens)

	// If neither population indicator is available/valid, buurt data is useless
	if (!inwonersCheck.hasValue || inwonersCheck.isBlocked) &&
		(!huishoudensCheck.hasValue || huishoudensCheck.isBlocked) {
		return true
	}
	return false
}

// CBSBuurtData holds data from CBS OData API for a buurt.
type CBSBuurtData struct {
	MediaanVermogen *float64 // Mediaan vermogen van particuliere huishoudens ( 1000 EUR)
}

type cbsODataResponse struct {
	Value []struct {
		MediaanVermogen *float64 `json:"MediaanVermogenVanParticuliereHuish_91"`
	} `json:"value"`
}

// GetCBSBuurtData fetches additional buurt data from CBS OData API (mediaan vermogen).
func (c *Client) GetCBSBuurtData(ctx context.Context, buurtcode string) (*CBSBuurtData, error) {
	if buurtcode == "" {
		return nil, nil
	}

	// CBS OData uses padded buurtcodes (e.g., "BU03580003  " with trailing spaces to 10 chars)
	paddedBuurtcode := fmt.Sprintf("%-10s", buurtcode)

	params := url.Values{}
	params.Set("$filter", fmt.Sprintf("WijkenEnBuurten eq '%s'", paddedBuurtcode))
	params.Set("$select", "MediaanVermogenVanParticuliereHuish_91")

	reqURL := fmt.Sprintf("%s?%s", cbsODataEndpoint, params.Encode())
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("cbs odata request failed", "error", err)
		return nil, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		c.log.Error("cbs odata request error", "status", resp.StatusCode)
		return nil, fmt.Errorf("cbs odata status %d", resp.StatusCode)
	}

	var payload cbsODataResponse
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		c.log.Error("cbs odata decode failed", "error", err)
		return nil, err
	}

	if len(payload.Value) == 0 {
		return nil, nil
	}

	return &CBSBuurtData{
		MediaanVermogen: payload.Value[0].MediaanVermogen,
	}, nil
}

// PC4Properties holds PC4 properties from PDOK CBS Postcode4 API.
// PC4 has richer data than PC6, including gas, electricity, income, WOZ.
type PC4Properties struct {
	Postcode4 int `json:"postcode"`
	Jaarcode  int `json:"jaarcode"`
	DataYear  int // Populated by the fetching code

	// Energy usage
	GemiddeldGasverbruikWoning      *FlexNumber `json:"gemiddeld_gasverbruik_woning"`
	GemiddeldElektriciteitsverbruik *FlexNumber `json:"gemiddeld_elektriciteitsverbruik_woning"`

	// Housing
	AantalWoningen              *FlexNumber `json:"aantal_woningen"`
	GemiddeldHuishoudensgrootte *FlexNumber `json:"gemiddelde_huishoudensgrootte"`
	GemiddeldWOZWaarde          *FlexNumber `json:"gemiddelde_woz_waarde_woning"`
	KoopwoningenPct             *FlexNumber `json:"percentage_koopwoningen"`
	HuurwoningenPct             *FlexNumber `json:"percentage_huurwoningen"`

	// Income
	GemiddeldInkomen *FlexNumber `json:"gemiddeld_inkomen_huishouden"`
	PctHoogInkomen   *FlexNumber `json:"percentage_hoog_inkomen_huishouden"`
	PctLaagInkomen   *FlexNumber `json:"percentage_laag_inkomen_huishouden"`

	// Demographics
	AantalInwoners    *FlexNumber `json:"aantal_inwoners"`
	AantalHuishoudens *FlexNumber `json:"aantal_part_huishoudens"`
	Stedelijkheid     *FlexNumber `json:"stedelijkheid"`

	// Building age counts (for calculating percentage built after 2000)
	WoningenBouwjaarVoor1945  *FlexNumber `json:"aantal_woningen_bouwjaar_voor_1945"`
	WoningenBouwjaar45Tot65   *FlexNumber `json:"aantal_woningen_bouwjaar_45_tot_65"`
	WoningenBouwjaar65Tot75   *FlexNumber `json:"aantal_woningen_bouwjaar_65_tot_75"`
	WoningenBouwjaar75Tot85   *FlexNumber `json:"aantal_woningen_bouwjaar_75_tot_85"`
	WoningenBouwjaar85Tot95   *FlexNumber `json:"aantal_woningen_bouwjaar_85_tot_95"`
	WoningenBouwjaar95Tot05   *FlexNumber `json:"aantal_woningen_bouwjaar_95_tot_05"`
	WoningenBouwjaar05Tot15   *FlexNumber `json:"aantal_woningen_bouwjaar_05_tot_15"`
	WoningenBouwjaar15EnLater *FlexNumber `json:"aantal_woningen_bouwjaar_15_en_later"`

	// Household composition
	AantalEenouderhuishoudens  *FlexNumber `json:"aantal_eenouderhuishoudens"`
	AantalTweeouderhuishoudens *FlexNumber `json:"aantal_tweeouderhuishoudens"`
}

type pc4Response struct {
	Features []struct {
		Properties PC4Properties `json:"properties"`
	} `json:"features"`
}

// PC4YearlyData contains PC4 data merged from multiple years.
type PC4YearlyData struct {
	Properties PC4Properties
	Year       int  // Primary year (newest year with any data)
	Blocked    bool // True if no useful data found across all years
}

// GetPC4 fetches PC4-level statistics from PDOK, merging data from years 2024 -> 2023 -> 2022.
// For each field, uses the newest available non-blocked value.
func (c *Client) GetPC4(ctx context.Context, postcode4 string) (*PC4YearlyData, error) {
	years := []int{2024, 2023, 2022}

	// Collect data from all years
	var allData []*PC4Properties
	var primaryYear int
	for _, year := range years {
		data, _, err := c.fetchPC4Year(ctx, postcode4, year)
		if err != nil {
			c.log.Debug("pc4 fetch failed", "postcode4", postcode4, "year", year, "error", err)
			continue
		}
		if data == nil {
			continue
		}
		data.DataYear = year
		allData = append(allData, data)
		if primaryYear == 0 {
			primaryYear = year
		}
	}

	if len(allData) == 0 {
		return nil, nil
	}

	// Merge data: for each field, use newest non-blocked value
	merged := mergePC4Data(allData)
	merged.DataYear = primaryYear

	return &PC4YearlyData{
		Properties: merged,
		Year:       primaryYear,
		Blocked:    false,
	}, nil
}

// mergePC4Data merges PC4 data from multiple years, preferring newer years.
// allData should be sorted newest-first.
func mergePC4Data(allData []*PC4Properties) PC4Properties {
	if len(allData) == 0 {
		return PC4Properties{}
	}

	// Start with the newest data as base
	result := *allData[0]

	// For each older year, fill in any blocked/missing fields
	for i := 1; i < len(allData); i++ {
		older := allData[i]
		fillIfBlocked(&result.GemiddeldGasverbruikWoning, older.GemiddeldGasverbruikWoning)
		fillIfBlocked(&result.GemiddeldElektriciteitsverbruik, older.GemiddeldElektriciteitsverbruik)
		fillIfBlocked(&result.GemiddeldWOZWaarde, older.GemiddeldWOZWaarde)
		fillIfBlocked(&result.GemiddeldInkomen, older.GemiddeldInkomen)
		fillIfBlocked(&result.PctHoogInkomen, older.PctHoogInkomen)
		fillIfBlocked(&result.PctLaagInkomen, older.PctLaagInkomen)
		fillIfBlocked(&result.Stedelijkheid, older.Stedelijkheid)
		fillIfBlocked(&result.KoopwoningenPct, older.KoopwoningenPct)
		fillIfBlocked(&result.HuurwoningenPct, older.HuurwoningenPct)
		fillIfBlocked(&result.AantalWoningen, older.AantalWoningen)
		fillIfBlocked(&result.AantalInwoners, older.AantalInwoners)
		fillIfBlocked(&result.AantalHuishoudens, older.AantalHuishoudens)
		fillIfBlocked(&result.GemiddeldHuishoudensgrootte, older.GemiddeldHuishoudensgrootte)
		fillIfBlocked(&result.AantalEenouderhuishoudens, older.AantalEenouderhuishoudens)
		fillIfBlocked(&result.AantalTweeouderhuishoudens, older.AantalTweeouderhuishoudens)
		fillIfBlocked(&result.WoningenBouwjaar05Tot15, older.WoningenBouwjaar05Tot15)
		fillIfBlocked(&result.WoningenBouwjaar15EnLater, older.WoningenBouwjaar15EnLater)
	}

	return result
}

// fillIfBlocked fills dst with src if dst is nil or blocked.
func fillIfBlocked(dst **FlexNumber, src *FlexNumber) {
	if *dst == nil || float64(**dst) <= blockedValueThreshold {
		if src != nil && float64(*src) > blockedValueThreshold {
			*dst = src
		}
	}
}

func (c *Client) fetchPC4Year(ctx context.Context, postcode4 string, year int) (*PC4Properties, bool, error) {
	params := url.Values{}
	params.Set("f", "json")
	params.Set("postcode", postcode4)
	params.Set("jaarcode", fmt.Sprintf("%d", year))
	params.Set("limit", "1")

	reqURL := fmt.Sprintf("%s?%s", pdokPC4Endpoint, params.Encode())
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, false, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		c.log.Error("pdok pc4 request failed", "error", err)
		return nil, false, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		c.log.Error("pdok pc4 request error", "status", resp.StatusCode)
		return nil, false, fmt.Errorf("pdok pc4 status %d", resp.StatusCode)
	}

	var payload pc4Response
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		c.log.Error("pdok pc4 decode failed", "error", err)
		return nil, false, err
	}

	if len(payload.Features) == 0 {
		return nil, false, nil
	}

	props := payload.Features[0].Properties
	if isPC4Blocked(props) {
		return &props, true, nil
	}
	return &props, false, nil
}

func isPC4Blocked(props PC4Properties) bool {
	// PC4 data is considered blocked if the key VALUE fields we care about are blocked.
	// We want gas, electricity, income, WOZ - if ALL of these are blocked, try older year.
	// Note: AantalInwoners/Huishoudens/KoopwoningenPct are often valid even when value fields are blocked.
	valueChecks := []struct {
		hasValue  bool
		isBlocked bool
	}{
		checkBlockedFlexNumber(props.GemiddeldGasverbruikWoning),
		checkBlockedFlexNumber(props.GemiddeldElektriciteitsverbruik),
		checkBlockedFlexNumber(props.GemiddeldInkomen),
		checkBlockedFlexNumber(props.GemiddeldWOZWaarde),
	}

	// Count how many value fields are blocked
	blockedCount := 0
	for _, c := range valueChecks {
		if !c.hasValue || c.isBlocked {
			blockedCount++
		}
	}

	// If ALL 4 value fields are blocked, consider this data blocked and try older year
	return blockedCount == 4
}

// HuishoudensMetKinderenPct calculates percentage of households with children from PC4 data.
func (p *PC4Properties) HuishoudensMetKinderenPct() *float64 {
	huishoudens := p.AantalHuishoudens.ToIntPtr()
	eenouder := p.AantalEenouderhuishoudens.ToIntPtr()
	tweeouder := p.AantalTweeouderhuishoudens.ToIntPtr()

	if huishoudens == nil || *huishoudens == 0 {
		return nil
	}

	var metKinderen int
	if eenouder != nil {
		metKinderen += *eenouder
	}
	if tweeouder != nil {
		metKinderen += *tweeouder
	}

	pct := float64(metKinderen) / float64(*huishoudens) * 100
	return &pct
}

// BouwjaarVanaf2000Pct calculates percentage of buildings built after 2000 from PC4 data.
func (p *PC4Properties) BouwjaarVanaf2000Pct() *float64 {
	totaal := p.AantalWoningen.ToFloat64Ptr()
	if totaal == nil || *totaal == 0 {
		return nil
	}

	var recent float64
	if v := p.WoningenBouwjaar95Tot05.ToFloat64Ptr(); v != nil {
		recent += *v
	}
	if v := p.WoningenBouwjaar05Tot15.ToFloat64Ptr(); v != nil {
		recent += *v
	}
	if v := p.WoningenBouwjaar15EnLater.ToFloat64Ptr(); v != nil {
		recent += *v
	}

	pct := (recent / *totaal) * 100
	return &pct
}
</file>

<file path="internal/leadenrichment/module.go">
// Package leadenrichment provides the composition root for lead enrichment.
package leadenrichment

import (
	"portal_final_backend/internal/leadenrichment/client"
	"portal_final_backend/internal/leadenrichment/service"
	"portal_final_backend/platform/logger"
)

// Module wires the lead enrichment service.
type Module struct {
	service *service.Service
}

// NewModule creates a new lead enrichment module.
func NewModule(log *logger.Logger) *Module {
	cli := client.New(log)
	svc := service.New(cli, log)
	return &Module{service: svc}
}

// Service returns the enrichment service.
func (m *Module) Service() *service.Service {
	return m.service
}
</file>

<file path="internal/leadenrichment/service/service.go">
// Package service provides lead enrichment logic with caching.
package service

import (
	"context"
	"strings"
	"sync"
	"time"

	"portal_final_backend/internal/leadenrichment/client"
	"portal_final_backend/platform/logger"
)

const (
	cacheTTL = 365 * 24 * time.Hour
)

// EnrichmentData contains lead enrichment values from PDOK CBS APIs.
// Data is sourced from PC4 (most complete), PC6, and Buurt levels.
type EnrichmentData struct {
	Source    string
	Postcode6 string
	Postcode4 string
	Buurtcode string
	DataYear  *int // Year of PC4/PC6 data (e.g., 2022, 2023, 2024)

	// Energy - from PC4
	GemAardgasverbruik        *float64
	GemElektriciteitsverbruik *float64

	// Housing - from PC4/PC6
	HuishoudenGrootte    *float64
	KoopwoningenPct      *float64
	BouwjaarVanaf2000Pct *float64
	WOZWaarde            *float64 // PC4: gemiddelde_woz_waarde_woning

	// Income - from PC4
	MediaanVermogenX1000     *float64
	GemInkomenHuishouden     *float64 // PC4: gemiddeld_inkomen_huishouden (in 1000s)
	PctHoogInkomen           *float64 // PC4: percentage_hoog_inkomen_huishouden
	PctLaagInkomen           *float64 // PC4: percentage_laag_inkomen_huishouden
	MediaanInkomenHuishouden *float64 // PC6: mediaan_inkomen_huishouden (legacy)

	// Demographics
	HuishoudensMetKinderenPct *float64
	AantalHuishoudens         *int
	Stedelijkheid             *int // PC4: 1=zeer sterk, 5=niet stedelijk

	Confidence *float64
	FetchedAt  time.Time
}

type cacheEntry struct {
	data      *EnrichmentData
	expiresAt time.Time
}

// Service handles lead enrichment lookups with caching and fallback.
type Service struct {
	client   *client.Client
	log      *logger.Logger
	cache    map[string]cacheEntry
	cacheMu  sync.RWMutex
	cacheTTL time.Duration
}

// New creates a new lead enrichment service.
func New(client *client.Client, log *logger.Logger) *Service {
	return &Service{
		client:   client,
		log:      log,
		cache:    make(map[string]cacheEntry),
		cacheTTL: cacheTTL,
	}
}

// GetByPostcode fetches enrichment data for a postcode.
// Fetches PC4 first (richest data), then PC6, then buurt fallback.
// Returns nil if lookup fails or data is not available.
func (s *Service) GetByPostcode(ctx context.Context, postcode string) (*EnrichmentData, error) {
	normalized := normalizePostcode(postcode)
	if normalized == "" {
		return nil, nil
	}

	if cached := s.getFromCache(normalized); cached != nil {
		return cached, nil
	}

	now := time.Now().UTC()
	result := &EnrichmentData{
		Source:    "pdok",
		Postcode6: normalized,
		FetchedAt: now,
	}

	// Extract PC4 from PC6 (first 4 characters)
	if len(normalized) >= 4 {
		pc4 := normalized[:4]
		result.Postcode4 = pc4
		s.enrichFromPC4(ctx, pc4, result)
	}

	// Enrich with PC6 data
	s.enrichFromPC6(ctx, normalized, result)

	// Fall back to buurt for any still-missing fields
	s.enrichFromBuurt(ctx, normalized, result)

	// Calculate confidence based on data sources
	result.Confidence = s.calculateConfidence(result)

	s.setCache(normalized, result)
	return result, nil
}

// enrichFromPC4 fetches PC4-level data (most complete: gas, electricity, income, WOZ).
func (s *Service) enrichFromPC4(ctx context.Context, pc4 string, result *EnrichmentData) {
	pc4Data, err := s.client.GetPC4(ctx, pc4)
	if err != nil {
		s.log.Debug("pc4 lookup failed", "pc4", pc4, "error", err)
		return
	}
	if pc4Data == nil {
		return
	}

	props := pc4Data.Properties
	result.Source = "pdok_pc4"
	result.DataYear = &pc4Data.Year

	// Energy - PC4 has the best data
	result.GemAardgasverbruik = props.GemiddeldGasverbruikWoning.ToFloat64Ptr()
	result.GemElektriciteitsverbruik = props.GemiddeldElektriciteitsverbruik.ToFloat64Ptr()

	// Housing
	result.HuishoudenGrootte = props.GemiddeldHuishoudensgrootte.ToFloat64Ptr()
	result.KoopwoningenPct = props.KoopwoningenPct.ToFloat64Ptr()
	result.WOZWaarde = props.GemiddeldWOZWaarde.ToFloat64Ptr()
	result.BouwjaarVanaf2000Pct = props.BouwjaarVanaf2000Pct()

	// Income - PC4 has gemiddeld (average), convert to float
	result.GemInkomenHuishouden = props.GemiddeldInkomen.ToFloat64Ptr()
	result.PctHoogInkomen = props.PctHoogInkomen.ToFloat64Ptr()
	result.PctLaagInkomen = props.PctLaagInkomen.ToFloat64Ptr()

	// Demographics
	result.HuishoudensMetKinderenPct = props.HuishoudensMetKinderenPct()
	result.AantalHuishoudens = props.AantalHuishoudens.ToIntPtr()
	if s := props.Stedelijkheid.ToIntPtr(); s != nil {
		result.Stedelijkheid = s
	}
}

// enrichFromPC6 fills in any missing fields from PC6-level data.
func (s *Service) enrichFromPC6(ctx context.Context, postcode string, result *EnrichmentData) {
	pc6Data, _, err := s.client.GetPC6(ctx, postcode)
	if err != nil {
		s.log.Debug("pc6 lookup failed", "postcode", postcode, "error", err)
		return
	}
	if pc6Data == nil {
		return
	}

	fillMissingPC6Fields(result, pc6Data)
	fillPC6BouwjaarPct(result, pc6Data)
	result.Source = appendSource(result.Source, "pc6", "pdok_pc6")
}

func fillMissingPC6Fields(result *EnrichmentData, pc6Data *client.PC6Properties) {
	if result.HuishoudenGrootte == nil {
		result.HuishoudenGrootte = pc6Data.GemiddeldHuishoudensgrootte.ToFloat64Ptr()
	}
	if result.KoopwoningenPct == nil {
		result.KoopwoningenPct = pc6Data.KoopwoningenPct.ToFloat64Ptr()
	}
	if result.HuishoudensMetKinderenPct == nil {
		result.HuishoudensMetKinderenPct = pc6Data.HuishoudensMetKinderenPct.ToFloat64Ptr()
	}
	if result.MediaanInkomenHuishouden == nil {
		result.MediaanInkomenHuishouden = pc6Data.MediaanInkomenHuishouden.ToFloat64Ptr()
	}
	if result.AantalHuishoudens == nil {
		result.AantalHuishoudens = pc6Data.AantalHuishoudens.ToIntPtr()
	}
}

func fillPC6BouwjaarPct(result *EnrichmentData, pc6Data *client.PC6Properties) {
	if result.BouwjaarVanaf2000Pct != nil {
		return
	}
	totalPtr := pc6Data.AantalWoningen.ToFloat64Ptr()
	bouwjaar05Tot15Ptr := pc6Data.WoningenBouwjaar05Tot15.ToFloat64Ptr()
	bouwjaar15EnLaterPtr := pc6Data.WoningenBouwjaar15EnLater.ToFloat64Ptr()
	if totalPtr == nil || bouwjaar05Tot15Ptr == nil || bouwjaar15EnLaterPtr == nil {
		return
	}
	total := *totalPtr
	if total <= 0 {
		return
	}
	recent := *bouwjaar05Tot15Ptr + *bouwjaar15EnLaterPtr
	pct := (recent / total) * 100
	result.BouwjaarVanaf2000Pct = &pct
}

// enrichFromBuurt fills in any missing fields from buurt-level statistics.
func (s *Service) enrichFromBuurt(ctx context.Context, postcode string, result *EnrichmentData) {
	buurtcode := s.getBuurtcode(ctx, postcode)
	if buurtcode == "" {
		return
	}

	result.Buurtcode = buurtcode

	s.applyCBSBuurtData(ctx, buurtcode, result)

	buurtData := s.getBuurtData(ctx, buurtcode)
	if buurtData == nil {
		return
	}

	fillMissingBuurtFields(result, buurtData)
	result.Source = appendSource(result.Source, "buurt", "pdok_buurt")
}

func (s *Service) getBuurtcode(ctx context.Context, postcode string) string {
	buurtcode, err := s.client.GetBuurtcode(ctx, postcode)
	if err != nil {
		s.log.Debug("buurtcode lookup failed", "postcode", postcode, "error", err)
		return ""
	}
	return buurtcode
}

func (s *Service) applyCBSBuurtData(ctx context.Context, buurtcode string, result *EnrichmentData) {
	cbsData, err := s.client.GetCBSBuurtData(ctx, buurtcode)
	if err != nil {
		s.log.Debug("cbs odata lookup failed", "buurtcode", buurtcode, "error", err)
		return
	}
	if cbsData == nil || cbsData.MediaanVermogen == nil {
		return
	}
	result.MediaanVermogenX1000 = cbsData.MediaanVermogen
}

func (s *Service) getBuurtData(ctx context.Context, buurtcode string) *client.BuurtProperties {
	buurtData, _, err := s.client.GetBuurt(ctx, buurtcode)
	if err != nil {
		s.log.Debug("buurt lookup failed", "buurtcode", buurtcode, "error", err)
		return nil
	}
	return buurtData
}

func fillMissingBuurtFields(result *EnrichmentData, buurtData *client.BuurtProperties) {
	if result.KoopwoningenPct == nil {
		result.KoopwoningenPct = buurtData.KoopwoningenPct.ToFloat64Ptr()
	}
	if result.HuishoudensMetKinderenPct == nil {
		result.HuishoudensMetKinderenPct = buurtData.HuishoudensMetKinderenPct.ToFloat64Ptr()
	}
	if result.BouwjaarVanaf2000Pct == nil {
		result.BouwjaarVanaf2000Pct = buurtData.BouwjaarVanaf2000Pct.ToFloat64Ptr()
	}
	if result.GemAardgasverbruik == nil {
		result.GemAardgasverbruik = buurtData.GemiddeldGasverbruik.ToFloat64Ptr()
	}
	if result.HuishoudenGrootte == nil {
		result.HuishoudenGrootte = buurtData.GemHuishoudensgrootte.ToFloat64Ptr()
	}
	if result.AantalHuishoudens == nil {
		result.AantalHuishoudens = buurtData.AantalHuishoudens.ToIntPtr()
	}
}

func appendSource(current, suffix, replacement string) string {
	if current == "pdok" {
		return replacement
	}
	return current + "+" + suffix
}

// calculateConfidence returns a confidence score based on data completeness.
func (s *Service) calculateConfidence(result *EnrichmentData) *float64 {
	if result == nil {
		return nil
	}

	// Start with base confidence
	confidence := 1.0

	// Reduce confidence if using older data
	if result.DataYear != nil {
		switch *result.DataYear {
		case 2024:
			confidence *= 1.0
		case 2023:
			confidence *= 0.95
		case 2022:
			confidence *= 0.90
		default:
			confidence *= 0.85
		}
	}

	// Reduce confidence for buurt-level data (less precise)
	if strings.Contains(result.Source, "buurt") {
		confidence *= 0.95
	}

	// Reduce confidence for missing key fields
	missingCount := 0
	if result.KoopwoningenPct == nil {
		missingCount++
	}
	if result.GemInkomenHuishouden == nil && result.MediaanInkomenHuishouden == nil {
		missingCount++
	}
	if result.GemAardgasverbruik == nil {
		missingCount++
	}
	if result.WOZWaarde == nil {
		missingCount++
	}

	// Each missing key field reduces confidence by 5%
	confidence *= (1.0 - float64(missingCount)*0.05)

	return &confidence
}

func (s *Service) getFromCache(key string) *EnrichmentData {
	s.cacheMu.RLock()
	defer s.cacheMu.RUnlock()

	entry, ok := s.cache[key]
	if !ok {
		return nil
	}
	if time.Now().After(entry.expiresAt) {
		return nil
	}
	return entry.data
}

func (s *Service) setCache(key string, data *EnrichmentData) {
	s.cacheMu.Lock()
	defer s.cacheMu.Unlock()

	s.cache[key] = cacheEntry{
		data:      data,
		expiresAt: time.Now().Add(s.cacheTTL),
	}
}

func normalizePostcode(value string) string {
	cleaned := strings.ToUpper(strings.ReplaceAll(value, " ", ""))
	cleaned = strings.ReplaceAll(cleaned, "-", "")
	return strings.TrimSpace(cleaned)
}
</file>

<file path="internal/leads/leads.go">
// Package leads provides lead management functionality.
// This file defines the public API of the leads bounded context.
// Only types and interfaces defined here should be imported by other domains.
package leads

import (
	"context"

	"github.com/google/uuid"
)

// Lead represents the minimal lead information that can be shared with other domains.
type Lead struct {
	ID              uuid.UUID
	ConsumerName    string
	AssignedAgentID *uuid.UUID
}

// Service defines the public interface for lead operations.
// Other domains should depend on this interface, not on concrete implementations.
type Service interface {
	// GetLeadByID returns minimal lead information for a given ID.
	GetLeadByID(ctx context.Context, id uuid.UUID) (Lead, error)
	// GetLeadsForAgent returns RAC_leads assigned to a specific agent.
	GetLeadsForAgent(ctx context.Context, agentID uuid.UUID) ([]Lead, error)
}

// Note: The full RAC_leads service with all CRUD operations is intended for use
// within the HTTP handler layer only. Other domains should use the minimal
// Service interface above or define their own interfaces for the specific
// data they need (see AgentProvider pattern below).
</file>

<file path="internal/leads/migrations/001_leads.sql">
-- Leads Domain: Core RAC_leads table
-- IMPORTANT: This migration uses SOFT REFERENCES to the auth domain.
-- The user_id fields (assigned_agent_id, viewed_by_id, visit_scout_id) are
-- stored as UUIDs WITHOUT foreign key constraints to the RAC_users table.
-- This allows the auth and RAC_leads domains to be independently deployed and
-- potentially split into separate databases in the future.

-- Lead statuses: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling, Closed
-- Consumer RAC_roles: Owner, Tenant, Landlord
-- Service types: Windows, Insulation, Solar
-- Access difficulty: Low, Medium, High

CREATE TABLE IF NOT EXISTS RAC_leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Consumer information
    consumer_first_name TEXT NOT NULL,
    consumer_last_name TEXT NOT NULL,
    consumer_phone TEXT NOT NULL,
    consumer_email TEXT,
    consumer_role TEXT NOT NULL DEFAULT 'Owner' CHECK (consumer_role IN ('Owner', 'Tenant', 'Landlord')),
    
    -- Address information
    address_street TEXT NOT NULL,
    address_house_number TEXT NOT NULL,
    address_zip_code TEXT NOT NULL,
    address_city TEXT NOT NULL,
    
    -- Lead details
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Assignment - SOFT REFERENCES to RAC_users (no FK constraint)
    assigned_agent_id UUID,        -- References RAC_users.id (soft reference)
    viewed_by_id UUID,             -- References RAC_users.id (soft reference)
    viewed_at TIMESTAMPTZ,
    
    -- Visit / Survey information
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID,           -- References RAC_users.id (soft reference)
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Soft delete
    deleted_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_leads_status ON RAC_leads(status);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent ON RAC_leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_scout ON RAC_leads(visit_scout_id);
CREATE INDEX IF NOT EXISTS idx_leads_phone ON RAC_leads(consumer_phone);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON RAC_leads(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_leads_scheduled_date ON RAC_leads(visit_scheduled_date) WHERE visit_scheduled_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_leads_deleted_at ON RAC_leads(deleted_at);
</file>

<file path="internal/leads/migrations/002_lead_activity.sql">
-- Leads Domain: Activity tracking for RAC_leads
-- SOFT REFERENCES: user_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS RAC_lead_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,         -- References RAC_users.id (soft reference)
    action TEXT NOT NULL,
    meta JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_activity_lead_id ON RAC_lead_activity(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_activity_user_id ON RAC_lead_activity(user_id);
</file>

<file path="internal/leads/migrations/003_lead_notes.sql">
-- Leads Domain: Internal notes for RAC_leads
-- SOFT REFERENCES: author_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS RAC_lead_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    author_id UUID NOT NULL,       -- References RAC_users.id (soft reference)
    body TEXT NOT NULL CHECK (char_length(body) >= 1 AND char_length(body) <= 2000),
    type TEXT NOT NULL DEFAULT 'note' CHECK (type IN ('note', 'call', 'text', 'email', 'system')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_notes_lead_id ON RAC_lead_notes(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_notes_created_at ON RAC_lead_notes(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_notes_author_id ON RAC_lead_notes(author_id);
</file>

<file path="internal/leads/migrations/004_lead_services.sql">
-- Leads Domain: Multiple services per lead
-- SOFT REFERENCES: visit_scout_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS RAC_lead_services (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    
    -- Service info
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Visit / Survey information (per service)
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID,           -- References RAC_users.id (soft reference)
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_lead_services_lead_id ON RAC_lead_services(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_services_status ON RAC_lead_services(status);
CREATE INDEX IF NOT EXISTS idx_lead_services_service_type ON RAC_lead_services(service_type);
CREATE INDEX IF NOT EXISTS idx_lead_services_created_at ON RAC_lead_services(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_services_scout_id ON RAC_lead_services(visit_scout_id);
</file>

<file path="internal/leads/migrations/005_visit_history.sql">
-- Leads Domain: Visit history for audit trail
-- SOFT REFERENCES: scout_id stored as UUID without FK constraint

CREATE TABLE IF NOT EXISTS visit_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    scheduled_date TIMESTAMPTZ NOT NULL,
    scout_id UUID,                 -- References RAC_users.id (soft reference)
    outcome TEXT NOT NULL CHECK (outcome IN ('completed', 'no_show', 'rescheduled', 'cancelled')),
    measurements TEXT,
    access_difficulty TEXT CHECK (access_difficulty IN ('Low', 'Medium', 'High')),
    notes TEXT,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_visit_history_lead_id ON visit_history(lead_id);
CREATE INDEX IF NOT EXISTS idx_visit_history_scheduled_date ON visit_history(scheduled_date);
CREATE INDEX IF NOT EXISTS idx_visit_history_scout_id ON visit_history(scout_id);
</file>

<file path="internal/leads/migrations/006_lead_details.sql">
-- Leads Domain: Add details to capture the initial user request

ALTER TABLE RAC_leads
ADD COLUMN IF NOT EXISTS consumer_note TEXT,
ADD COLUMN IF NOT EXISTS source TEXT DEFAULT 'manual';
</file>

<file path="internal/leads/migrations/007_lead_ai_analysis.sql">
-- Lead AI Analysis table for storing AI advisor outputs

CREATE TABLE RAC_lead_ai_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    urgency_level TEXT NOT NULL CHECK (urgency_level IN ('High', 'Medium', 'Low')),
    urgency_reason TEXT,
    talking_points JSONB NOT NULL DEFAULT '[]'::jsonb,
    objection_handling JSONB NOT NULL DEFAULT '[]'::jsonb,
    upsell_opportunities JSONB NOT NULL DEFAULT '[]'::jsonb,
    summary TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_lead_ai_analysis_lead_id ON RAC_lead_ai_analysis(lead_id);
CREATE INDEX idx_lead_ai_analysis_created_at ON RAC_lead_ai_analysis(created_at DESC);
</file>

<file path="internal/leads/migrations/008_leads_filters_indexes.sql">
CREATE INDEX IF NOT EXISTS idx_leads_consumer_first_name ON RAC_leads(consumer_first_name);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_last_name ON RAC_leads(consumer_last_name);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_email ON RAC_leads(consumer_email);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_role ON RAC_leads(consumer_role);
CREATE INDEX IF NOT EXISTS idx_leads_address_street ON RAC_leads(address_street);
CREATE INDEX IF NOT EXISTS idx_leads_address_house_number ON RAC_leads(address_house_number);
CREATE INDEX IF NOT EXISTS idx_leads_address_zip_code ON RAC_leads(address_zip_code);
CREATE INDEX IF NOT EXISTS idx_leads_address_city ON RAC_leads(address_city);
CREATE INDEX IF NOT EXISTS idx_leads_service_type ON RAC_leads(service_type);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent_id ON RAC_leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON RAC_leads(created_at);
</file>

<file path="internal/leads/migrations/009_service_types.sql">
-- Migration: Add service types for leads schema alignment
-- This keeps sqlc schema in sync with the app queries.

CREATE TABLE IF NOT EXISTS RAC_service_types (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    slug TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    color TEXT,
    is_active BOOLEAN NOT NULL DEFAULT true,
    display_order INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_service_types_slug ON RAC_service_types(slug);
CREATE UNIQUE INDEX IF NOT EXISTS idx_service_types_name ON RAC_service_types(name);

ALTER TABLE RAC_lead_services
    ADD COLUMN IF NOT EXISTS service_type_id UUID REFERENCES RAC_service_types(id);

CREATE INDEX IF NOT EXISTS idx_lead_services_service_type_id
    ON RAC_lead_services(service_type_id);
</file>

<file path="internal/leads/migrations/010_pipeline_and_timeline.sql">
CREATE EXTENSION IF NOT EXISTS cube;
CREATE EXTENSION IF NOT EXISTS earthdistance;

CREATE TYPE pipeline_stage AS ENUM (
    'Triage',
    'Nurturing',
    'Ready_For_Estimator',
    'Ready_For_Partner',
    'Partner_Matching',
    'Partner_Assigned',
    'Manual_Intervention',
    'Completed',
    'Lost'
);

ALTER TABLE RAC_lead_services
ADD COLUMN pipeline_stage pipeline_stage NOT NULL DEFAULT 'Triage';

CREATE INDEX idx_lead_services_pipeline ON RAC_lead_services(pipeline_stage);

CREATE TABLE lead_timeline_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    service_id UUID REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,
    actor_type TEXT NOT NULL,
    actor_name TEXT NOT NULL,
    event_type TEXT NOT NULL,
    title TEXT NOT NULL,
    summary TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_timeline_lookup ON lead_timeline_events(lead_id, created_at DESC);
</file>

<file path="internal/leads/ports/agent_provider.go">
// Package ports defines the interfaces that the RAC_leads domain requires from
// external systems. These interfaces form the Anti-Corruption Layer (ACL),
// ensuring the RAC_leads domain only knows about the data it needs, formatted
// the way it wants.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// Agent represents the agent information that the RAC_leads domain needs.
// This is defined by the RAC_leads domain, not by the auth domain.
type Agent struct {
	ID    uuid.UUID
	Email string
	Name  string // Display name, can be derived from email if needed
}

// AgentProvider is the interface that the RAC_leads domain uses to get agent information.
// The implementation is provided by the composition root (main/router) and wraps
// the auth service. This ensures RAC_leads never directly imports the auth domain.
type AgentProvider interface {
	// GetAgentByID returns agent information for the given user ID.
	// Returns an error if the agent is not found.
	GetAgentByID(ctx context.Context, agentID uuid.UUID) (Agent, error)

	// GetAgentsByIDs returns agent information for multiple user IDs.
	// Missing agents are silently omitted from the result map.
	GetAgentsByIDs(ctx context.Context, agentIDs []uuid.UUID) (map[uuid.UUID]Agent, error)

	// ListAgents returns all available agents that can be assigned to RAC_leads.
	ListAgents(ctx context.Context) ([]Agent, error)
}
</file>

<file path="internal/leads/ports/appointments.go">
// Package ports defines the interfaces that the RAC_leads domain requires from
// external systems. These interfaces form the Anti-Corruption Layer (ACL),
// ensuring the RAC_leads domain only knows about the data it needs, formatted
// the way it wants.
package ports

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// BookVisitParams contains the parameters needed to book a lead visit appointment.
// This is defined by the RAC_leads domain, not by the RAC_appointments domain.
type BookVisitParams struct {
	TenantID              uuid.UUID
	UserID                uuid.UUID // The agent booking the visit (and likely attending)
	LeadID                uuid.UUID
	LeadServiceID         uuid.UUID
	StartTime             time.Time
	EndTime               time.Time
	Title                 string
	Description           string
	SendConfirmationEmail bool // If true, sends confirmation email to lead
}

// LeadVisitSummary represents the minimal lead visit details needed by RAC_leads.
type LeadVisitSummary struct {
	AppointmentID uuid.UUID
	UserID        uuid.UUID
	StartTime     time.Time
	EndTime       time.Time
}

// RescheduleVisitParams contains the parameters needed to reschedule a lead visit.
type RescheduleVisitParams struct {
	TenantID      uuid.UUID
	UserID        uuid.UUID
	LeadServiceID uuid.UUID
	StartTime     time.Time
	EndTime       time.Time
	Title         *string
	Description   *string
}

// CancelVisitParams contains the parameters needed to cancel a lead visit.
type CancelVisitParams struct {
	TenantID      uuid.UUID
	UserID        uuid.UUID
	LeadServiceID uuid.UUID
}

// AppointmentBooker is the interface that the RAC_leads domain uses to book RAC_appointments.
// The implementation is provided by the composition root (main/router) and wraps
// the RAC_appointments service. This ensures RAC_leads never directly imports the RAC_appointments domain.
type AppointmentBooker interface {
	// BookLeadVisit creates a visit appointment for a specific lead and service.
	// Returns an error if the appointment cannot be booked.
	BookLeadVisit(ctx context.Context, params BookVisitParams) error
	// GetLeadVisitByService retrieves the latest non-cancelled appointment for a lead service.
	GetLeadVisitByService(ctx context.Context, tenantID uuid.UUID, leadServiceID uuid.UUID, userID uuid.UUID) (*LeadVisitSummary, error)
	// RescheduleLeadVisit updates the time (and optionally title/description) of a lead visit.
	RescheduleLeadVisit(ctx context.Context, params RescheduleVisitParams) error
	// CancelLeadVisit cancels the lead visit appointment for a lead service.
	CancelLeadVisit(ctx context.Context, params CancelVisitParams) error
}
</file>

<file path="internal/leads/ports/energylabel.go">
package ports

import (
	"context"
	"time"
)

// LeadEnergyData contains the energy label data relevant for RAC_leads.
// This is defined by the RAC_leads domain - only the fields RAC_leads cares about.
type LeadEnergyData struct {
	Energieklasse           string     `json:"energieklasse"`                     // Energy label class (A+++, A++, A+, A, B, C, D, E, F, G)
	EnergieIndex            *float64   `json:"energieIndex,omitempty"`            // Energy index value
	Bouwjaar                int        `json:"bouwjaar,omitempty"`                // Construction year
	GeldigTot               *time.Time `json:"geldigTot,omitempty"`               // Label validity end date
	Gebouwtype              string     `json:"gebouwtype,omitempty"`              // Building type
	Registratiedatum        *time.Time `json:"registratiedatum,omitempty"`        // When the label was registered
	PrimaireFossieleEnergie *float64   `json:"primaireFossieleEnergie,omitempty"` // Primary fossil energy use (kWh/m2jaar)
	BAGVerblijfsobjectID    string     `json:"bagVerblijfsobjectId,omitempty"`    // BAG ID for future lookups
}

// EnrichLeadParams contains the address parameters for energy label enrichment.
type EnrichLeadParams struct {
	Postcode   string
	Huisnummer string
	Huisletter string
	Toevoeging string
}

// EnergyLabelEnricher is the interface that the RAC_leads domain uses to enrich RAC_leads
// with energy label data. The implementation is provided by the composition root
// and wraps the energylabel service.
type EnergyLabelEnricher interface {
	// EnrichLead fetches energy label data for a lead's address.
	// Returns nil if no label is found (not an error).
	// Returns error only if the lookup fails unexpectedly.
	EnrichLead(ctx context.Context, params EnrichLeadParams) (*LeadEnergyData, error)
}
</file>

<file path="internal/leads/ports/leadenrichment.go">
package ports

import "context"

// LeadEnrichmentData contains enrichment data relevant for RAC_leads.
type LeadEnrichmentData struct {
	Source    string
	Postcode6 string
	Postcode4 string
	Buurtcode string
	DataYear  *int // Year of PC4/PC6 data (e.g., 2022, 2023, 2024)

	// Energy
	GemAardgasverbruik        *float64
	GemElektriciteitsverbruik *float64

	// Housing
	HuishoudenGrootte    *float64
	KoopwoningenPct      *float64
	BouwjaarVanaf2000Pct *float64
	WOZWaarde            *float64

	// Income
	MediaanVermogenX1000 *float64
	GemInkomenHuishouden *float64
	PctHoogInkomen       *float64
	PctLaagInkomen       *float64

	// Demographics
	HuishoudensMetKinderenPct *float64
	Stedelijkheid             *int

	Confidence *float64
}

// LeadEnricher enriches a lead with PDOK/CBS data.
type LeadEnricher interface {
	EnrichLead(ctx context.Context, postcode string) (*LeadEnrichmentData, error)
}
</file>

<file path="internal/leads/ports/users.go">
// Package ports defines consumer-driven interfaces for external dependencies.
// These interfaces are defined in the Leads domain based on what it needs,
// rather than what other domains choose to offer.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// UserInfo represents the minimal user data the RAC_leads domain needs.
type UserInfo struct {
	ID    uuid.UUID
	Email string
	Roles []string
}

// UserProvider provides user information needed by the RAC_leads domain.
// This interface is defined here (consumer-driven) rather than in the auth domain.
// The auth domain's repository or service can implement this interface.
type UserProvider interface {
	// GetUserByID returns basic user info. Returns error if user not found.
	GetUserByID(ctx context.Context, userID uuid.UUID) (UserInfo, error)
}

// UserExistenceChecker verifies if RAC_users exist without exposing full user data.
// Useful for validating assignee IDs without tight coupling to auth internals.
type UserExistenceChecker interface {
	// UserExists returns true if a user with the given ID exists.
	UserExists(ctx context.Context, userID uuid.UUID) (bool, error)
}

// UserLister provides a list of RAC_users for assignment dropdowns.
type UserLister interface {
	// ListAssignableUsers returns RAC_users that can be assigned to RAC_leads.
	// Implementation may filter by role (e.g., agents, scouts).
	ListAssignableUsers(ctx context.Context) ([]UserInfo, error)
}
</file>

<file path="internal/leads/repository/ai_analysis.go">
package repository

import (
	"context"
	"encoding/json"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// AIAnalysis represents a single AI analysis for a lead service
type AIAnalysis struct {
	ID                      uuid.UUID
	LeadID                  uuid.UUID
	OrganizationID          uuid.UUID
	LeadServiceID           uuid.UUID // The specific service this analysis is for
	UrgencyLevel            string    // High, Medium, Low
	UrgencyReason           *string
	LeadQuality             string // Junk, Low, Potential, High, Urgent
	RecommendedAction       string // Reject, RequestInfo, ScheduleSurvey, CallImmediately
	MissingInformation      []string
	PreferredContactChannel string // WhatsApp, Email
	SuggestedContactMessage string
	Summary                 string
	CreatedAt               time.Time
}

// CreateAIAnalysisParams contains the parameters for creating an AI analysis
type CreateAIAnalysisParams struct {
	LeadID                  uuid.UUID
	OrganizationID          uuid.UUID
	LeadServiceID           uuid.UUID // The specific service this analysis is for
	UrgencyLevel            string
	UrgencyReason           *string
	LeadQuality             string
	RecommendedAction       string
	MissingInformation      []string
	PreferredContactChannel string
	SuggestedContactMessage string
	Summary                 string
}

// CreateAIAnalysis stores a new AI analysis for a lead service
func (r *Repository) CreateAIAnalysis(ctx context.Context, params CreateAIAnalysisParams) (AIAnalysis, error) {
	missingInfo := params.MissingInformation
	if missingInfo == nil {
		missingInfo = []string{}
	}
	missingInfoJSON, _ := json.Marshal(missingInfo)

	var analysis AIAnalysis
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_lead_ai_analysis (
			lead_id, organization_id, lead_service_id, urgency_level, urgency_reason,
			lead_quality, recommended_action, missing_information,
			preferred_contact_channel, suggested_contact_message, summary
		)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		RETURNING id, lead_id, organization_id, lead_service_id, urgency_level, urgency_reason,
			lead_quality, recommended_action, missing_information,
			preferred_contact_channel, suggested_contact_message, summary, created_at
	`,
		params.LeadID, params.OrganizationID, params.LeadServiceID, params.UrgencyLevel, params.UrgencyReason,
		params.LeadQuality, params.RecommendedAction, missingInfoJSON,
		params.PreferredContactChannel, params.SuggestedContactMessage, params.Summary,
	).Scan(
		&analysis.ID, &analysis.LeadID, &analysis.OrganizationID, &analysis.LeadServiceID, &analysis.UrgencyLevel, &analysis.UrgencyReason,
		&analysis.LeadQuality, &analysis.RecommendedAction, &missingInfoJSON,
		&analysis.PreferredContactChannel, &analysis.SuggestedContactMessage, &analysis.Summary, &analysis.CreatedAt,
	)
	if err != nil {
		return AIAnalysis{}, err
	}

	_ = json.Unmarshal(missingInfoJSON, &analysis.MissingInformation)

	return analysis, nil
}

// GetLatestAIAnalysis returns the most recent AI analysis for a service
func (r *Repository) GetLatestAIAnalysis(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) (AIAnalysis, error) {
	var analysis AIAnalysis
	var missingInfoJSON []byte

	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, organization_id, lead_service_id, urgency_level, urgency_reason,
			lead_quality, recommended_action, missing_information,
			preferred_contact_channel, suggested_contact_message, summary, created_at
		FROM RAC_lead_ai_analysis
		WHERE lead_service_id = $1 AND organization_id = $2
		ORDER BY created_at DESC
		LIMIT 1
	`, serviceID, organizationID).Scan(
		&analysis.ID, &analysis.LeadID, &analysis.OrganizationID, &analysis.LeadServiceID, &analysis.UrgencyLevel, &analysis.UrgencyReason,
		&analysis.LeadQuality, &analysis.RecommendedAction, &missingInfoJSON,
		&analysis.PreferredContactChannel, &analysis.SuggestedContactMessage, &analysis.Summary, &analysis.CreatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return AIAnalysis{}, ErrNotFound
	}
	if err != nil {
		return AIAnalysis{}, err
	}

	_ = json.Unmarshal(missingInfoJSON, &analysis.MissingInformation)

	return analysis, nil
}

// ListAIAnalyses returns all AI analyses for a service, ordered by most recent first
func (r *Repository) ListAIAnalyses(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) ([]AIAnalysis, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, organization_id, lead_service_id, urgency_level, urgency_reason,
			lead_quality, recommended_action, missing_information,
			preferred_contact_channel, suggested_contact_message, summary, created_at
		FROM RAC_lead_ai_analysis
		WHERE lead_service_id = $1 AND organization_id = $2
		ORDER BY created_at DESC
	`, serviceID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var analyses []AIAnalysis
	for rows.Next() {
		var analysis AIAnalysis
		var missingInfoJSON []byte

		if err := rows.Scan(
			&analysis.ID, &analysis.LeadID, &analysis.OrganizationID, &analysis.LeadServiceID, &analysis.UrgencyLevel, &analysis.UrgencyReason,
			&analysis.LeadQuality, &analysis.RecommendedAction, &missingInfoJSON,
			&analysis.PreferredContactChannel, &analysis.SuggestedContactMessage, &analysis.Summary, &analysis.CreatedAt,
		); err != nil {
			return nil, err
		}

		_ = json.Unmarshal(missingInfoJSON, &analysis.MissingInformation)

		analyses = append(analyses, analysis)
	}

	return analyses, rows.Err()
}
</file>

<file path="internal/leads/repository/appointments.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// GetLeadAppointmentStats returns appointment statistics for a lead (for scoring purposes).
func (r *Repository) GetLeadAppointmentStats(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (LeadAppointmentStats, error) {
	var stats LeadAppointmentStats

	query := `
		SELECT
			COUNT(*) AS total,
			COUNT(*) FILTER (WHERE status = 'Scheduled') AS scheduled,
			COUNT(*) FILTER (WHERE status = 'Completed') AS completed,
			COUNT(*) FILTER (WHERE status = 'Cancelled') AS cancelled,
			EXISTS(
				SELECT 1 FROM RAC_appointments
				WHERE lead_id = $1 AND organization_id = $2
				AND status = 'Scheduled' AND start_time > NOW()
			) AS has_upcoming
		FROM RAC_appointments
		WHERE lead_id = $1 AND organization_id = $2
	`

	err := r.pool.QueryRow(ctx, query, leadID, organizationID).Scan(
		&stats.Total,
		&stats.Scheduled,
		&stats.Completed,
		&stats.Cancelled,
		&stats.HasUpcoming,
	)
	if err != nil {
		// Return zero stats on error (no RAC_appointments is valid)
		return LeadAppointmentStats{}, nil
	}

	return stats, nil
}

// GetLatestAppointment returns the most recent appointment for a lead.
func (r *Repository) GetLatestAppointment(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*time.Time, string, error) {
	var startTime time.Time
	var status string

	query := `
		SELECT start_time, status
		FROM RAC_appointments
		WHERE lead_id = $1 AND organization_id = $2
		ORDER BY start_time DESC
		LIMIT 1
	`

	err := r.pool.QueryRow(ctx, query, leadID, organizationID).Scan(&startTime, &status)
	if err != nil {
		return nil, "", nil // No appointment found
	}

	return &startTime, status, nil
}
</file>

<file path="internal/leads/repository/metrics.go">
package repository

import (
	"context"

	"github.com/google/uuid"
)

// LeadMetrics aggregates KPI values for the dashboard.
type LeadMetrics struct {
	TotalLeads          int
	DisqualifiedLeads   int
	ProjectedValueCents int64
	Touchpoints         int
}

// GetMetrics returns KPI aggregates for active (non-deleted) RAC_leads within an organization.
func (r *Repository) GetMetrics(ctx context.Context, organizationID uuid.UUID) (LeadMetrics, error) {
	var metrics LeadMetrics
	err := r.pool.QueryRow(ctx, `
		SELECT
			(
				SELECT COUNT(*)
				FROM RAC_leads
				WHERE organization_id = $1 AND deleted_at IS NULL
			) AS total_leads,
			(
				SELECT COUNT(DISTINCT l.id)
				FROM RAC_leads l
				LEFT JOIN RAC_lead_services ls ON ls.lead_id = l.id
				WHERE l.organization_id = $1 AND l.deleted_at IS NULL
					AND ls.status = 'Bad_Lead'
			) AS disqualified_leads,
			(
				SELECT COALESCE(SUM(projected_value_cents), 0)
				FROM RAC_leads
				WHERE organization_id = $1 AND deleted_at IS NULL
			) AS projected_value_cents,
			COALESCE((
				SELECT COUNT(*)
				FROM RAC_lead_activity la
				JOIN RAC_leads l ON l.id = la.lead_id
				WHERE l.organization_id = $1 AND l.deleted_at IS NULL
			), 0) AS touchpoints
		
	`, organizationID).Scan(
		&metrics.TotalLeads,
		&metrics.DisqualifiedLeads,
		&metrics.ProjectedValueCents,
		&metrics.Touchpoints,
	)
	if err != nil {
		return LeadMetrics{}, err
	}
	return metrics, nil
}
</file>

<file path="internal/leads/scoring/service.go">
package scoring

import (
	"context"
	"encoding/json"
	"math"
	"strings"
	"time"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
)

const (
	// scoreVersion tracks the scoring model for debugging and analysis.
	// Bump this when changing scoring logic significantly.
	scoreVersion = "2026-v2"

	// Base score - RAC_leads start at 50 and factors add/subtract from this.
	baseScore = 50.0
)

// serviceWeights defines how important each factor is for a specific service type.
// Values are multipliers (0.0-1.5) applied to base factor scores.
// Based on industry research for energy/home improvement lead qualification.
type serviceWeights struct {
	// Demographic factors
	ownership     float64 // Home ownership importance
	wealth        float64 // Financial capacity (median vermogen)
	income        float64 // Average income relevance
	incomeHigh    float64 // High income concentration
	incomeLow     float64 // Low income concentration (negative signal)
	household     float64 // Household size relevance
	children      float64 // Families with children
	stedelijkheid float64 // Urban/rural classification

	// Property/Energy factors
	energyLabel float64 // Poor energy label = opportunity
	gasUsage    float64 // High gas = heating opportunity
	electricity float64 // High electricity = solar opportunity
	buildingAge float64 // Older = more improvement potential
	wozValue    float64 // Property value indicator

	// Behavioral factors
	leadAge      float64 // Recency importance
	activity     float64 // Notes and engagement
	photo        float64 // Photo analysis available
	status       float64 // Service status indicator
	consumerNote float64 // Customer provided description
	source       float64 // Lead source quality
	assigned     float64 // Has assigned agent
	RAC_appointments float64 // Appointment activity
}

// defaultServiceWeights returns weights for services with unknown/generic type.
var defaultServiceWeights = serviceWeights{
	ownership:     1.0,
	wealth:        1.0,
	income:        1.0,
	incomeHigh:    0.8,
	incomeLow:     0.8,
	household:     1.0,
	children:      1.0,
	stedelijkheid: 0.5,
	energyLabel:   0.5,
	gasUsage:      0.5,
	electricity:   0.5,
	buildingAge:   0.8,
	wozValue:      0.8,
	leadAge:       1.0,
	activity:      1.0,
	photo:         1.0,
	status:        1.0,
	consumerNote:  1.0,
	source:        1.0,
	assigned:      1.0,
	RAC_appointments:  1.0,
}

// Service-type-specific weights based on industry research:
// - Energy services (solar, insulation, HVAC) prioritize energy data and ownership
// - Window replacements care about building age and energy performance
// - General services (plumbing, electrical, handyman) prioritize activity/engagement
var serviceWeightsMap = map[string]serviceWeights{
	// Solar: High electricity usage, ownership critical, wealth important for financing
	"solar": {
		ownership:     1.3,
		wealth:        1.2,
		income:        1.0,
		incomeHigh:    1.2, // High earners invest in solar
		incomeLow:     0.8,
		household:     0.8,
		children:      0.6,
		stedelijkheid: 0.6, // Rural better (more roof space, less shade)
		energyLabel:   0.8, // Less relevant - solar works regardless of label
		gasUsage:      0.2, // Solar doesn't replace gas
		electricity:   1.5, // Critical - high usage = high savings potential
		buildingAge:   0.6, // Less relevant - newer roofs work fine
		wozValue:      1.0,
		leadAge:       1.0,
		activity:      0.9,
		photo:         1.2, // Roof condition matters
		status:        1.0,
		consumerNote:  1.1, // Detailed requests show intent
		source:        1.0,
		assigned:      0.8, // Less important - solar is consultative
		RAC_appointments:  1.1, // Site survey critical
	},

	// Insulation: Poor energy labels are gold, high gas usage, older buildings
	"insulation": {
		ownership:     1.3,
		wealth:        1.0,
		income:        1.0,
		incomeHigh:    1.0,
		incomeLow:     0.9,
		household:     0.9,
		children:      0.8,
		stedelijkheid: 0.8, // Suburban houses often need more insulation
		energyLabel:   1.5, // Critical - E/F/G labels are prime targets
		gasUsage:      1.4, // High gas = poor insulation
		electricity:   0.5,
		buildingAge:   1.3, // Older = worse insulation typically
		wozValue:      0.9,
		leadAge:       1.0,
		activity:      1.0,
		photo:         1.1,
		status:        1.0,
		consumerNote:  1.2, // Problem description helps scope
		source:        1.0,
		assigned:      0.9,
		RAC_appointments:  1.0,
	},

	// HVAC/Heat pumps: High gas usage (replacing boilers), good insulation preferred
	"hvac": {
		ownership:     1.3,
		wealth:        1.3, // Heat pumps are expensive
		income:        1.1,
		incomeHigh:    1.3, // Premium investment
		incomeLow:     0.6, // Cost barrier
		household:     1.0,
		children:      0.8,
		stedelijkheid: 0.7, // Suburban/rural - more space for outdoor unit
		energyLabel:   1.2, // Better labels = ready for heat pump
		gasUsage:      1.4, // High gas = heating replacement opportunity
		electricity:   1.0,
		buildingAge:   0.8,
		wozValue:      1.1,
		leadAge:       1.0,
		activity:      1.0,
		photo:         1.0,
		status:        1.0,
		consumerNote:  1.1,
		source:        1.0,
		assigned:      0.9,
		RAC_appointments:  1.1, // Technical assessment needed
	},

	// Windows: Building age matters, energy performance relevant
	"windows": {
		ownership:     1.2,
		wealth:        1.0,
		income:        1.0,
		incomeHigh:    1.0,
		incomeLow:     0.8,
		household:     0.8,
		children:      0.7,
		stedelijkheid: 0.9, // Slightly less urban (apartments often shared)
		energyLabel:   1.0,
		gasUsage:      0.8, // Drafty windows = gas waste
		electricity:   0.4,
		buildingAge:   1.3, // Older buildings = older windows
		wozValue:      1.0,
		leadAge:       1.0,
		activity:      1.0,
		photo:         1.2, // Window condition visible in photos
		status:        1.0,
		consumerNote:  1.1,
		source:        1.0,
		assigned:      0.9,
		RAC_appointments:  1.0,
	},

	// Plumbing: Less demographic, more activity-focused
	"plumbing": {
		ownership:     0.8,
		wealth:        0.7,
		income:        0.8,
		incomeHigh:    0.6,
		incomeLow:     0.9, // Even low income needs plumbing fixes
		household:     1.1, // Larger households = more plumbing needs
		children:      1.0,
		stedelijkheid: 1.0, // Universal need
		energyLabel:   0.1,
		gasUsage:      0.3, // Gas for water heating
		electricity:   0.1,
		buildingAge:   1.0,
		wozValue:      0.7,
		leadAge:       1.2, // Urgency matters
		activity:      1.3, // Engagement indicates urgency
		photo:         1.3, // Photos show problem severity
		status:        1.1,
		consumerNote:  1.4, // Problem description crucial for plumbing
		source:        1.0,
		assigned:      1.2, // Quick response important
		RAC_appointments:  1.3, // Urgency - need quick appointment
	},

	// Electrical: Similar to plumbing, activity important
	"electrical": {
		ownership:     0.8,
		wealth:        0.8,
		income:        0.8,
		incomeHigh:    0.7,
		incomeLow:     0.9, // Safety-critical, even low income
		household:     0.9,
		children:      0.8,
		stedelijkheid: 1.0, // Universal need
		energyLabel:   0.2,
		gasUsage:      0.1,
		electricity:   0.8, // High usage might indicate electrical issues
		buildingAge:   1.1, // Older wiring needs updates
		wozValue:      0.8,
		leadAge:       1.2,
		activity:      1.3,
		photo:         1.2,
		status:        1.1,
		consumerNote:  1.3, // Safety context important
		source:        1.0,
		assigned:      1.2, // Quick response for safety
		RAC_appointments:  1.2,
	},

	// Carpentry: Building age and property value
	"carpentry": {
		ownership:     0.9,
		wealth:        0.9,
		income:        0.9,
		incomeHigh:    0.9,
		incomeLow:     0.7,
		household:     0.8,
		children:      0.8,
		stedelijkheid: 0.8, // Slightly suburban (more wood structures)
		energyLabel:   0.1,
		gasUsage:      0.1,
		electricity:   0.1,
		buildingAge:   1.0,
		wozValue:      1.0,
		leadAge:       1.1,
		activity:      1.2,
		photo:         1.2,
		status:        1.0,
		consumerNote:  1.2, // Project scope from description
		source:        1.0,
		assigned:      1.0,
		RAC_appointments:  1.0,
	},

	// Handyman: Most activity-focused, least demographic
	"handyman": {
		ownership:     0.6,
		wealth:        0.5,
		income:        0.6,
		incomeHigh:    0.4,
		incomeLow:     1.0, // Budget-conscious choose handyman
		household:     0.8,
		children:      0.9, // Families need more repairs
		stedelijkheid: 1.1, // Urban areas use handyman services more
		energyLabel:   0.0,
		gasUsage:      0.0,
		electricity:   0.0,
		buildingAge:   0.7,
		wozValue:      0.5,
		leadAge:       1.3, // Fresh RAC_leads convert best
		activity:      1.4, // Engagement is key
		photo:         1.3,
		status:        1.2,
		consumerNote:  1.3, // Task description important
		source:        1.1,
		assigned:      1.1,
		RAC_appointments:  1.2,
	},
}

// Result holds scoring output and factor details.
type Result struct {
	Score       int
	ScorePreAI  int
	FactorsJSON []byte
	Version     string
	UpdatedAt   time.Time
}

// Service computes lead scores.
type Service struct {
	repo repository.LeadsRepository
	log  *logger.Logger
}

// New creates a new scoring service.
func New(repo repository.LeadsRepository, log *logger.Logger) *Service {
	return &Service{repo: repo, log: log}
}

// Recalculate computes score for a lead and optionally includes AI adjustments.
func (s *Service) Recalculate(ctx context.Context, leadID uuid.UUID, serviceID *uuid.UUID, tenantID uuid.UUID, includeAI bool) (*Result, error) {
	lead, err := s.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return nil, err
	}

	svc, err := s.resolveService(ctx, leadID, serviceID, tenantID)
	if err != nil {
		return nil, err
	}

	data := s.fetchScoringData(ctx, leadID, tenantID, svc, includeAI)

	now := time.Now().UTC()
	preAI, factors := s.computePreAIScore(lead, svc, data.notes, data.photo, data.apptStats, data.serviceType)
	finalScore, aiFactors := s.applyAIFactors(preAI, data.ai)
	mergeFactors(factors, aiFactors)

	factorsJSON := s.marshalFactors(factors)

	return &Result{
		Score:       finalScore,
		ScorePreAI:  preAI,
		FactorsJSON: factorsJSON,
		Version:     scoreVersion,
		UpdatedAt:   now,
	}, nil
}

// scoringData holds optional data fetched for scoring calculations.
type scoringData struct {
	notes       []repository.LeadNote
	apptStats   repository.LeadAppointmentStats
	photo       *repository.PhotoAnalysis
	ai          *repository.AIAnalysis
	serviceType string
}

// fetchScoringData gathers all optional data needed for score calculation.
func (s *Service) fetchScoringData(ctx context.Context, leadID, tenantID uuid.UUID, svc *repository.LeadService, includeAI bool) scoringData {
	data := scoringData{serviceType: "default"}

	if notes, err := s.repo.ListLeadNotes(ctx, leadID, tenantID); err == nil {
		data.notes = notes
	}

	if stats, err := s.repo.GetLeadAppointmentStats(ctx, leadID, tenantID); err == nil {
		data.apptStats = stats
	}

	if svc == nil {
		return data
	}

	data.serviceType = determineServiceType(svc)

	if photo, err := s.repo.GetLatestPhotoAnalysis(ctx, svc.ID, tenantID); err == nil {
		data.photo = &photo
	}

	if includeAI {
		if ai, err := s.repo.GetLatestAIAnalysis(ctx, svc.ID, tenantID); err == nil {
			data.ai = &ai
		}
	}

	return data
}

// determineServiceType returns the service type in lowercase, defaulting to "default".
func determineServiceType(svc *repository.LeadService) string {
	if svc.ServiceType != "" {
		return strings.ToLower(svc.ServiceType)
	}
	return "default"
}

// mergeFactors copies aiFactors into factors map.
func mergeFactors(factors map[string]float64, aiFactors map[string]float64) {
	for k, v := range aiFactors {
		factors[k] = v
	}
}

// marshalFactors serializes factors to JSON, returning nil on error.
func (s *Service) marshalFactors(factors map[string]float64) []byte {
	data, err := json.Marshal(factors)
	if err != nil {
		if s.log != nil {
			s.log.Error("lead score factors marshal failed", "error", err)
		}
		return nil
	}
	return data
}

func (s *Service) resolveService(ctx context.Context, leadID uuid.UUID, serviceID *uuid.UUID, tenantID uuid.UUID) (*repository.LeadService, error) {
	if serviceID != nil {
		svc, err := s.repo.GetLeadServiceByID(ctx, *serviceID, tenantID)
		if err != nil {
			return nil, err
		}
		return &svc, nil
	}

	svc, err := s.repo.GetCurrentLeadService(ctx, leadID, tenantID)
	if err != nil {
		return nil, nil
	}
	return &svc, nil
}

// getServiceWeights returns the weight profile for a service type.
func getServiceWeights(serviceType string) serviceWeights {
	if w, ok := serviceWeightsMap[serviceType]; ok {
		return w
	}
	return defaultServiceWeights
}

func (s *Service) computePreAIScore(lead repository.Lead, svc *repository.LeadService, notes []repository.LeadNote, photo *repository.PhotoAnalysis, apptStats repository.LeadAppointmentStats, serviceType string) (int, map[string]float64) {
	score := baseScore
	factors := map[string]float64{}
	weights := getServiceWeights(serviceType)

	// Enrichment confidence applies to demographic/property factors
	confidence := 1.0
	if lead.LeadEnrichmentConfidence != nil {
		confidence = *lead.LeadEnrichmentConfidence
	}

	// ========== DEMOGRAPHIC FACTORS (max ~35 points) ==========
	// These factors describe WHO the lead is

	// Ownership: Homeowners can make decisions about improvements
	// Score: -5 to +10 based on % owner-occupied in area
	ownershipScore := s.scoreOwnership(lead) * weights.ownership * confidence
	score += s.addFactor(factors, "ownership", ownershipScore)

	// Wealth: Mediaan vermogen indicates financial capacity
	// Score: 0 to +12 based on wealth brackets
	wealthScore := s.scoreWealth(lead) * weights.wealth * confidence
	score += s.addFactor(factors, "wealth", wealthScore)

	// Income: Average household income
	// Score: 0 to +6 based on income level
	incomeScore := s.scoreIncome(lead) * weights.income * confidence
	score += s.addFactor(factors, "income", incomeScore)

	// Household size: Larger households typically have more needs
	// Score: 0 to +4
	householdScore := s.scoreHousehold(lead) * weights.household * confidence
	score += s.addFactor(factors, "household", householdScore)

	// Children: Families invest more in their homes
	// Score: 0 to +4
	childrenScore := s.scoreChildren(lead) * weights.children * confidence
	score += s.addFactor(factors, "children", childrenScore)

	// Stedelijkheid: Urban/rural affects service demand patterns
	// Score: -2 to +4
	stedelijkheidScore := s.scoreStedelijkheid(lead) * weights.stedelijkheid * confidence
	score += s.addFactor(factors, "stedelijkheid", stedelijkheidScore)

	// High income concentration: Premium service potential
	// Score: 0 to +5
	highIncomeScore := s.scoreHighIncome(lead) * weights.incomeHigh * confidence
	score += s.addFactor(factors, "income_high", highIncomeScore)

	// Low income concentration: Negative signal for premium services
	// Score: -4 to 0
	lowIncomeScore := s.scoreLowIncome(lead) * weights.incomeLow * confidence
	score += s.addFactor(factors, "income_low", lowIncomeScore)

	// ========== PROPERTY/ENERGY FACTORS (max ~30 points) ==========
	// These factors describe the PROPERTY and its energy profile

	// Energy label: Poor labels (E/F/G) = massive improvement opportunity
	// Score: -3 to +12
	energyLabelScore := s.scoreEnergyLabel(lead) * weights.energyLabel
	score += s.addFactor(factors, "energy_label", energyLabelScore)

	// Gas usage: High gas consumption indicates heating/insulation needs
	// Score: -4 to +8
	gasScore := s.scoreGas(lead) * weights.gasUsage * confidence
	score += s.addFactor(factors, "gas_usage", gasScore)

	// Electricity: High usage = solar opportunity
	// Score: 0 to +8
	electricityScore := s.scoreElectricity(lead) * weights.electricity * confidence
	score += s.addFactor(factors, "electricity", electricityScore)

	// Building age: Older buildings often need more work
	// Score: 0 to +6
	buildingAgeScore := s.scoreBuildingAge(lead) * weights.buildingAge
	score += s.addFactor(factors, "building_age", buildingAgeScore)

	// WOZ value: Property value indicates investment potential
	// Score: 0 to +4
	wozScore := s.scoreWOZ(lead) * weights.wozValue * confidence
	score += s.addFactor(factors, "woz_value", wozScore)

	// ========== BEHAVIORAL FACTORS (max ~25 points) ==========
	// These factors describe lead ENGAGEMENT and TIMING

	// Lead age: Fresh RAC_leads convert better (recency bias)
	// Score: -6 to +8
	leadAgeScore := s.scoreLeadAge(lead) * weights.leadAge
	score += s.addFactor(factors, "lead_age", leadAgeScore)

	// Service status: Where they are in the funnel
	// Score: -5 to +5
	statusScore := s.scoreServiceStatus(svc) * weights.status
	score += s.addFactor(factors, "service_status", statusScore)

	// Notes activity: Engagement level
	// Score: 0 to +6
	notesScore := s.scoreNotes(notes) * weights.activity
	score += s.addFactor(factors, "activity", notesScore)

	// Photo analysis: Shows serious intent
	// Score: 0 to +8
	photoScore := s.scorePhoto(photo) * weights.photo
	score += s.addFactor(factors, "photo", photoScore)

	// Consumer note: Customer's description of their need
	// Score: 0 to +8 based on length and content
	consumerNoteScore := s.scoreConsumerNote(svc) * weights.consumerNote
	score += s.addFactor(factors, "consumer_note", consumerNoteScore)

	// Lead source: Quality of acquisition channel
	// Score: -2 to +6
	sourceScore := s.scoreSource(lead, svc) * weights.source
	score += s.addFactor(factors, "source", sourceScore)

	// Assigned agent: Lead is being actively worked
	// Score: 0 to +4
	assignedScore := s.scoreAssigned(lead) * weights.assigned
	score += s.addFactor(factors, "assigned", assignedScore)

	// Appointments: Scheduled/completed RAC_appointments show commitment
	// Score: -3 to +10
	appointmentScore := s.scoreAppointments(apptStats) * weights.RAC_appointments
	score += s.addFactor(factors, "RAC_appointments", appointmentScore)

	return clampScore(score), factors
}

func (s *Service) applyAIFactors(preAI int, ai *repository.AIAnalysis) (int, map[string]float64) {
	if ai == nil {
		return preAI, map[string]float64{}
	}

	delta := 0.0
	factors := map[string]float64{}

	// AI urgency assessment: How time-sensitive is this lead?
	switch ai.UrgencyLevel {
	case "High":
		delta += 10
		factors["ai_urgency"] = 10
	case "Medium":
		delta += 4
		factors["ai_urgency"] = 4
	case "Low":
		delta -= 3
		factors["ai_urgency"] = -3
	}

	// AI quality assessment: How likely to convert?
	switch ai.LeadQuality {
	case "Urgent":
		delta += 12
		factors["ai_quality"] = 12
	case "High":
		delta += 7
		factors["ai_quality"] = 7
	case "Potential":
		delta += 2
		factors["ai_quality"] = 2
	case "Low":
		delta -= 8
		factors["ai_quality"] = -8
	case "Junk":
		delta -= 25
		factors["ai_quality"] = -25
	}

	return clampScore(float64(preAI) + delta), factors
}

func (s *Service) addFactor(factors map[string]float64, key string, value float64) float64 {
	if math.Abs(value) < 0.01 {
		return 0
	}
	// Round to 1 decimal place for cleaner factor display
	factors[key] = math.Round(value*10) / 10
	return value
}

// scoreOwnership evaluates home ownership percentage in the area.
// Homeowners are the primary decision-makers for home improvements.
// Thresholds based on CBS data: NL average is ~57% owner-occupied.
func (s *Service) scoreOwnership(lead repository.Lead) float64 {
	if lead.LeadEnrichmentKoopwoningenPct == nil {
		return 0
	}
	pct := *lead.LeadEnrichmentKoopwoningenPct
	switch {
	case pct >= 80:
		return 10 // Very high ownership area
	case pct >= 65:
		return 7 // Above average ownership
	case pct >= 50:
		return 4 // Average ownership
	case pct >= 35:
		return 0 // Below average
	default:
		return -5 // Very low ownership (rental dominated)
	}
}

// scoreWealth evaluates median household wealth (vermogen).
// Higher wealth = better ability to finance larger projects.
// Thresholds based on CBS wealth distribution data.
func (s *Service) scoreWealth(lead repository.Lead) float64 {
	if lead.LeadEnrichmentMediaanVermogenX1000 == nil {
		return 0
	}
	val := *lead.LeadEnrichmentMediaanVermogenX1000
	switch {
	case val >= 300:
		return 12 // Very wealthy area
	case val >= 150:
		return 8 // Above average wealth
	case val >= 75:
		return 5 // Average wealth
	case val >= 25:
		return 2 // Below average
	case val > 0:
		return 0 // Low wealth but positive
	default:
		return -2 // Negative median wealth (debt)
	}
}

// scoreIncome evaluates average household income.
// Income indicates short-term affordability.
func (s *Service) scoreIncome(lead repository.Lead) float64 {
	if lead.LeadEnrichmentGemInkomen == nil {
		return 0
	}
	val := *lead.LeadEnrichmentGemInkomen // in thousands EUR
	switch {
	case val >= 55:
		return 6 // High income area
	case val >= 40:
		return 4 // Above average
	case val >= 30:
		return 2 // Average
	default:
		return 0 // Below average
	}
}

// scoreGas evaluates average gas consumption.
// High gas usage indicates heating/insulation improvement potential.
// Based on CBS average of ~1200 m/year for Dutch households.
func (s *Service) scoreGas(lead repository.Lead) float64 {
	if lead.LeadEnrichmentGemAardgasverbruik == nil {
		return 0
	}
	val := *lead.LeadEnrichmentGemAardgasverbruik
	switch {
	case val >= 2000:
		return 8 // Very high - major opportunity
	case val >= 1500:
		return 6 // High usage
	case val >= 1200:
		return 3 // Average usage
	case val >= 800:
		return 1 // Below average
	case val >= 400:
		return -2 // Low usage (likely already efficient)
	default:
		return -4 // Very low or no gas (electric/district heating)
	}
}

// scoreElectricity evaluates average electricity consumption.
// High electricity usage = good solar candidate.
// Based on CBS average of ~2700 kWh/year for Dutch households.
func (s *Service) scoreElectricity(lead repository.Lead) float64 {
	if lead.LeadEnrichmentGemElektriciteitsverbruik == nil {
		return 0
	}
	val := *lead.LeadEnrichmentGemElektriciteitsverbruik
	switch {
	case val >= 4500:
		return 8 // Very high - excellent solar candidate
	case val >= 3500:
		return 6 // High usage
	case val >= 2700:
		return 3 // Average
	case val >= 1800:
		return 1 // Below average
	default:
		return 0 // Low usage
	}
}

// scoreHousehold evaluates household size.
// Larger households have more needs and higher energy consumption.
func (s *Service) scoreHousehold(lead repository.Lead) float64 {
	if lead.LeadEnrichmentHuishoudenGrootte == nil {
		return 0
	}
	val := *lead.LeadEnrichmentHuishoudenGrootte
	switch {
	case val >= 3.0:
		return 4 // Large household
	case val >= 2.3:
		return 3 // Family-sized
	case val >= 1.8:
		return 1 // Couple
	default:
		return 0 // Single-person
	}
}

// scoreChildren evaluates percentage of households with children.
// Families tend to invest more in their homes for children's safety/comfort.
func (s *Service) scoreChildren(lead repository.Lead) float64 {
	if lead.LeadEnrichmentHuishoudensMetKinderenPct == nil {
		return 0
	}
	pct := *lead.LeadEnrichmentHuishoudensMetKinderenPct
	switch {
	case pct >= 45:
		return 4 // High family concentration
	case pct >= 30:
		return 2 // Above average
	default:
		return 0 // Lower family concentration
	}
}

// scoreStedelijkheid evaluates urban/rural classification.
// CBS stedelijkheid scale: 1 = very urban, 5 = rural
// Different services have different urban/rural demand patterns.
func (s *Service) scoreStedelijkheid(lead repository.Lead) float64 {
	if lead.LeadEnrichmentStedelijkheid == nil {
		return 0
	}
	val := *lead.LeadEnrichmentStedelijkheid
	switch val {
	case 1:
		return -2 // Very urban - limited for some services (solar roof space)
	case 2:
		return 0 // Urban
	case 3:
		return 2 // Suburban - often sweet spot
	case 4:
		return 3 // Semi-rural - good for energy services
	case 5:
		return 4 // Rural - more space, homeowners, DIY culture but also isolation
	default:
		return 0
	}
}

// scoreHighIncome evaluates percentage of high income households.
// High income concentration indicates premium service potential.
func (s *Service) scoreHighIncome(lead repository.Lead) float64 {
	if lead.LeadEnrichmentPctHoogInkomen == nil {
		return 0
	}
	pct := *lead.LeadEnrichmentPctHoogInkomen
	switch {
	case pct >= 30:
		return 5 // Very affluent area
	case pct >= 20:
		return 3 // Above average affluence
	case pct >= 10:
		return 1 // Some high earners
	default:
		return 0 // Low affluent area
	}
}

// scoreLowIncome evaluates percentage of low income households.
// High concentration of low income is a negative signal for premium services
// but neutral/positive for essential repairs (plumbing, electrical safety).
func (s *Service) scoreLowIncome(lead repository.Lead) float64 {
	if lead.LeadEnrichmentPctLaagInkomen == nil {
		return 0
	}
	pct := *lead.LeadEnrichmentPctLaagInkomen
	switch {
	case pct >= 40:
		return -4 // Very high low-income concentration
	case pct >= 25:
		return -2 // Above average low-income
	case pct >= 15:
		return -1 // Some low-income
	default:
		return 0 // Low concentration of low-income
	}
}

// scoreEnergyLabel evaluates the energy efficiency label.
// Poor labels (E/F/G) represent major improvement opportunities.
// This is one of the most predictive factors for energy services.
func (s *Service) scoreEnergyLabel(lead repository.Lead) float64 {
	delta := 0.0

	if lead.EnergyClass != nil {
		cls := strings.ToUpper(strings.TrimSpace(*lead.EnergyClass))
		switch cls {
		case "G":
			delta += 12 // Worst label = best opportunity
		case "F":
			delta += 10
		case "E":
			delta += 7
		case "D":
			delta += 4
		case "C":
			delta += 1
		case "B":
			delta -= 1
		case "A", "A+", "A++", "A+++", "A++++":
			delta -= 3 // Already efficient
		}
	}

	// Energy index provides more granular data
	if lead.EnergyIndex != nil {
		idx := *lead.EnergyIndex
		switch {
		case idx > 2.5:
			delta += 4 // Very poor efficiency
		case idx > 2.0:
			delta += 2
		case idx >= 1.4:
			delta += 1
		case idx < 0.8:
			delta -= 1 // Very efficient
		}
	}

	return delta
}

// scoreBuildingAge evaluates when the property was built.
// Older buildings typically need more improvements.
func (s *Service) scoreBuildingAge(lead repository.Lead) float64 {
	score := 0.0

	// Use EP-Online construction year if available
	if lead.EnergyBouwjaar != nil {
		year := *lead.EnergyBouwjaar
		switch {
		case year < 1960:
			score += 6 // Very old - significant improvement needs
		case year < 1980:
			score += 4 // Pre-insulation mandate
		case year < 1992:
			score += 2 // Before stricter building codes
		case year < 2010:
			score += 1
		default:
			score -= 1 // Modern building
		}
	}

	// Use CBS bouwjaar percentage as fallback/supplement
	if lead.LeadEnrichmentBouwjaarVanaf2000Pct != nil {
		pct := *lead.LeadEnrichmentBouwjaarVanaf2000Pct
		// Low percentage = mostly older buildings in area
		if pct <= 15 {
			score += 2
		} else if pct >= 70 {
			score -= 1
		}
	}

	return clampFloat(score, -2, 8)
}

// scoreWOZ evaluates property value as indicator of investment potential.
func (s *Service) scoreWOZ(lead repository.Lead) float64 {
	if lead.LeadEnrichmentWOZWaarde == nil {
		return 0
	}
	val := *lead.LeadEnrichmentWOZWaarde // in thousands EUR
	switch {
	case val >= 500:
		return 4 // High value property
	case val >= 350:
		return 3 // Above average
	case val >= 250:
		return 2 // Average
	case val >= 150:
		return 1 // Below average
	default:
		return 0 // Low value
	}
}

// scoreLeadAge evaluates how fresh the lead is.
// Fresh RAC_leads have higher conversion rates (recency bias).
func (s *Service) scoreLeadAge(lead repository.Lead) float64 {
	age := time.Since(lead.CreatedAt)
	hours := age.Hours()
	switch {
	case hours <= 24:
		return 8 // Same day - hot lead
	case hours <= 72:
		return 5 // Very fresh
	case hours <= 24*7:
		return 2 // Week old
	case hours <= 24*14:
		return 0 // Two weeks
	case hours <= 24*30:
		return -3 // Month old - cooling down
	default:
		return -6 // Stale lead
	}
}

// scoreServiceStatus evaluates where the lead is in the sales funnel.
func (s *Service) scoreServiceStatus(svc *repository.LeadService) float64 {
	if svc == nil {
		return 0
	}
	switch svc.Status {
	case "New":
		return 5 // Fresh opportunity
	case "Attempted_Contact":
		return 2 // In progress
	case "Contacted":
		return 1 // Engaged
	case "Scheduled":
		return -2 // Already scheduled, lower priority for scoring
	case "Completed", "Closed":
		return -5 // Done, shouldn't be prioritized
	default:
		return 0
	}
}

// scoreNotes evaluates engagement through note activity.
// More notes and recent activity indicates engaged prospect.
func (s *Service) scoreNotes(notes []repository.LeadNote) float64 {
	if len(notes) == 0 {
		return 0
	}

	score := 0.0

	// Note count indicates engagement depth
	switch {
	case len(notes) >= 5:
		score += 3 // High engagement
	case len(notes) >= 2:
		score += 2 // Some engagement
	default:
		score += 1 // Minimal engagement
	}

	// Recency of latest note
	latest := notes[0].CreatedAt
	for _, note := range notes {
		if note.CreatedAt.After(latest) {
			latest = note.CreatedAt
		}
	}

	hoursSince := time.Since(latest).Hours()
	switch {
	case hoursSince <= 24:
		score += 3 // Active today
	case hoursSince <= 72:
		score += 2 // Recent activity
	case hoursSince <= 24*7:
		score += 1 // Activity this week
	}

	return clampFloat(score, 0, 6)
}

// scorePhoto evaluates photo analysis data.
// Photos show serious intent and help qualify scope.
func (s *Service) scorePhoto(photo *repository.PhotoAnalysis) float64 {
	if photo == nil {
		return 0
	}

	score := 0.0

	// Having photos at all shows intent
	score += 2

	// Confidence in analysis
	switch photo.ConfidenceLevel {
	case "High":
		score += 2
	case "Medium":
		score += 1
	}

	// Scope indicates project size
	switch photo.ScopeAssessment {
	case "Large":
		score += 2
	case "Medium":
		score += 1
	}

	// Safety concerns indicate urgency
	if len(photo.SafetyConcerns) > 0 {
		score += 2
	}

	return clampFloat(score, 0, 8)
}

// scoreConsumerNote evaluates the customer's description of their need.
// Longer, more detailed descriptions indicate serious intent.
func (s *Service) scoreConsumerNote(svc *repository.LeadService) float64 {
	if svc == nil || svc.ConsumerNote == nil {
		return 0
	}

	note := strings.TrimSpace(*svc.ConsumerNote)
	length := len(note)

	// Length indicates effort/seriousness
	score := 0.0
	switch {
	case length == 0:
		return 0 // No note
	case length >= 300:
		score += 6 // Very detailed description
	case length >= 150:
		score += 4 // Good description
	case length >= 50:
		score += 2 // Basic description
	default:
		score += 1 // Minimal text
	}

	// Keywords indicating urgency
	lowerNote := strings.ToLower(note)
	urgentKeywords := []string{"urgent", "dringend", "snel", "asap", "lekkage", "kapot", "broken", "emergency", "noodgeval"}
	for _, kw := range urgentKeywords {
		if strings.Contains(lowerNote, kw) {
			score += 2
			break // Only count once
		}
	}

	return clampFloat(score, 0, 8)
}

// sourceScoreTable maps source keywords to their quality scores.
// Higher scores indicate better lead quality based on conversion rates.
var sourceScoreTable = []struct {
	keywords []string
	score    float64
}{
	// Best: Direct/referrals show high intent
	{[]string{"referral", "verwijzing"}, 6},
	{[]string{"direct", "inbound"}, 5},
	{[]string{"website", "organic"}, 4},
	// Good: Targeted campaigns
	{[]string{"email", "newsletter"}, 3},
	{[]string{"social", "facebook", "linkedin"}, 2},
	// Average: Paid acquisition
	{[]string{"google", "search"}, 2},
	{[]string{"partner", "affiliate"}, 1},
	// Lower: Mass market
	{[]string{"cold", "outbound"}, -1},
	{[]string{"purchased", "bought"}, -2},
}

// scoreSource evaluates lead acquisition channel quality.
// Different sources have different conversion rates.
func (s *Service) scoreSource(lead repository.Lead, svc *repository.LeadService) float64 {
	source := ""
	if svc != nil && svc.Source != nil {
		source = strings.ToLower(*svc.Source)
	} else if lead.Source != nil {
		source = strings.ToLower(*lead.Source)
	}

	if source == "" {
		return 0
	}

	for _, entry := range sourceScoreTable {
		if containsAny(source, entry.keywords) {
			return entry.score
		}
	}
	return 0 // Unknown source
}

// containsAny checks if s contains any of the keywords.
func containsAny(s string, keywords []string) bool {
	for _, kw := range keywords {
		if strings.Contains(s, kw) {
			return true
		}
	}
	return false
}

// scoreAssigned evaluates whether an agent is actively working the lead.
// Assigned RAC_leads have follow-up in progress, unassigned haven't started.
func (s *Service) scoreAssigned(lead repository.Lead) float64 {
	if lead.AssignedAgentID == nil {
		return 0 // Not assigned - neutral
	}
	// Having an assigned agent shows organization commitment
	return 4
}

// scoreAppointments evaluates appointment activity.
// Scheduled/completed RAC_appointments indicate serious buyer engagement.
func (s *Service) scoreAppointments(stats repository.LeadAppointmentStats) float64 {
	if stats.Total == 0 {
		return 0 // No RAC_appointments yet - neutral
	}

	score := 0.0

	// Has upcoming appointment - very engaged
	if stats.HasUpcoming {
		score += 4
	}

	// Completed RAC_appointments show progress
	score += float64(stats.Completed) * 2
	if stats.Completed >= 2 {
		score += 2 // Multiple visits = serious
	}

	// Scheduled but not completed yet
	score += float64(stats.Scheduled) * 1.5

	// Cancelled RAC_appointments are negative signal
	if stats.Cancelled > 0 {
		cancellationRate := float64(stats.Cancelled) / float64(stats.Total)
		if cancellationRate >= 0.5 {
			score -= 3 // High cancellation rate
		} else {
			score -= float64(stats.Cancelled)
		}
	}

	return clampFloat(score, -3, 10)
}

func clampScore(value float64) int {
	rounded := int(math.Round(value))
	if rounded < 0 {
		return 0
	}
	if rounded > 100 {
		return 100
	}
	return rounded
}

func clampFloat(value float64, min float64, max float64) float64 {
	if value < min {
		return min
	}
	if value > max {
		return max
	}
	return value
}
</file>

<file path="internal/leads/transport/attachments.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

// PresignedUploadRequest is the request for generating a presigned upload URL.
type PresignedUploadRequest struct {
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// PresignedUploadResponse is the response containing the presigned URL for uploading.
type PresignedUploadResponse struct {
	UploadURL string `json:"uploadUrl"`
	FileKey   string `json:"fileKey"`
	ExpiresAt int64  `json:"expiresAt"` // Unix timestamp
}

// CreateAttachmentRequest creates an attachment record after successful upload.
type CreateAttachmentRequest struct {
	FileKey     string `json:"fileKey" validate:"required,min=1,max=500"`
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// AttachmentResponse is the response DTO for an attachment.
type AttachmentResponse struct {
	ID          uuid.UUID  `json:"id"`
	FileKey     string     `json:"fileKey"`
	FileName    string     `json:"fileName"`
	ContentType string     `json:"contentType"`
	SizeBytes   int64      `json:"sizeBytes"`
	UploadedBy  *uuid.UUID `json:"uploadedBy,omitempty"`
	CreatedAt   time.Time  `json:"createdAt"`
	DownloadURL *string    `json:"downloadUrl,omitempty"` // Presigned download URL when requested
}

// AttachmentListResponse is the list of attachments for a service.
type AttachmentListResponse struct {
	Items []AttachmentResponse `json:"items"`
}

// PresignedDownloadResponse is the response containing the presigned URL for downloading.
type PresignedDownloadResponse struct {
	DownloadURL string `json:"downloadUrl"`
	ExpiresAt   int64  `json:"expiresAt"` // Unix timestamp
}
</file>

<file path="internal/leads/transport/optional.go">
package transport

import (
	"encoding/json"

	"github.com/google/uuid"
)

type OptionalUUID struct {
	Value *uuid.UUID
	Set   bool
}

func (o OptionalUUID) IsZero() bool {
	return !o.Set
}

func (o *OptionalUUID) UnmarshalJSON(data []byte) error {
	o.Set = true
	if string(data) == "null" {
		o.Value = nil
		return nil
	}

	var raw string
	if err := json.Unmarshal(data, &raw); err == nil {
		if raw == "" {
			o.Value = nil
			return nil
		}

		parsed, err := uuid.Parse(raw)
		if err != nil {
			return err
		}

		o.Value = &parsed
		return nil
	}

	var parsed uuid.UUID
	if err := json.Unmarshal(data, &parsed); err != nil {
		return err
	}

	o.Value = &parsed
	return nil
}
</file>

<file path="internal/maps/handler.go">
package maps

import (
	"net/http"

	"portal_final_backend/platform/httpkit"

	"github.com/gin-gonic/gin"
)

// Handler exposes the maps search endpoint.
type Handler struct {
	svc *Service
}

func NewHandler(svc *Service) *Handler {
	return &Handler{svc: svc}
}

// LookupAddress handles GET /api/v1/maps/address-lookup?q=...
func (h *Handler) LookupAddress(c *gin.Context) {
	var req LookupRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "query 'q' is required (min 3 chars)", nil)
		return
	}

	results, err := h.svc.SearchAddress(c.Request.Context(), req.Query)
	if err != nil {
		httpkit.Error(c, http.StatusBadGateway, "address lookup service unavailable", nil)
		return
	}

	httpkit.OK(c, results)
}
</file>

<file path="internal/maps/module.go">
package maps

import (
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/logger"
)

// Module wires the maps address lookup HTTP routes.
type Module struct {
	handler *Handler
}

func NewModule(log *logger.Logger) *Module {
	svc := NewService(log)
	h := NewHandler(svc)
	return &Module{handler: h}
}

func (m *Module) Name() string {
	return "maps"
}

func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	group := ctx.Protected.Group("/maps")
	group.GET("/address-lookup", m.handler.LookupAddress)
}

var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/maps/service.go">
package maps

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"portal_final_backend/platform/logger"
)

const nominatimURL = "https://nominatim.openstreetmap.org/search"

type Service struct {
	client *http.Client
	log    *logger.Logger
}

func NewService(log *logger.Logger) *Service {
	return &Service{
		client: &http.Client{Timeout: 5 * time.Second},
		log:    log,
	}
}

func (s *Service) SearchAddress(ctx context.Context, query string) ([]AddressSuggestion, error) {
	params := url.Values{}
	params.Add("q", query)
	params.Add("format", "json")
	params.Add("addressdetails", "1")
	params.Add("limit", "5")
	params.Add("countrycodes", "nl")

	reqURL := fmt.Sprintf("%s?%s", nominatimURL, params.Encode())

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", "PortalApp/1.0")

	resp, err := s.client.Do(req)
	if err != nil {
		s.log.Error("nominatim request failed", "error", err)
		return nil, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		s.log.Error("nominatim upstream error", "status", resp.StatusCode)
		return nil, fmt.Errorf("upstream api error: %d", resp.StatusCode)
	}

	var rawResults []nominatimResponse
	if err := json.NewDecoder(resp.Body).Decode(&rawResults); err != nil {
		s.log.Error("failed to decode nominatim payload", "error", err)
		return nil, err
	}

	suggestions := make([]AddressSuggestion, 0, len(rawResults))
	for _, raw := range rawResults {
		suggestion, ok := buildSuggestion(raw)
		if !ok {
			continue
		}

		suggestions = append(suggestions, suggestion)
	}

	return suggestions, nil
}

func buildSuggestion(raw nominatimResponse) (AddressSuggestion, bool) {
	if raw.Address.Road == "" {
		return AddressSuggestion{}, false
	}

	city := pickCity(raw.Address)
	if city == "" {
		return AddressSuggestion{}, false
	}

	suggestion := AddressSuggestion{
		Street:      raw.Address.Road,
		HouseNumber: raw.Address.HouseNumber,
		ZipCode:     raw.Address.Postcode,
		City:        city,
		Lat:         raw.Lat,
		Lon:         raw.Lon,
	}

	suggestion.Label = buildLabel(suggestion)

	return suggestion, true
}

func pickCity(address nominatimAddress) string {
	if address.City != "" {
		return address.City
	}
	if address.Town != "" {
		return address.Town
	}
	if address.Village != "" {
		return address.Village
	}
	if address.Municipality != "" {
		return address.Municipality
	}
	return address.Hamlet
}

func buildLabel(suggestion AddressSuggestion) string {
	parts := []string{suggestion.Street}
	if suggestion.HouseNumber != "" {
		parts = append(parts, suggestion.HouseNumber)
	}
	parts = append(parts, ",")
	if suggestion.ZipCode != "" {
		parts = append(parts, suggestion.ZipCode)
	}
	parts = append(parts, suggestion.City)

	label := strings.Join(parts, " ")
	label = strings.ReplaceAll(label, " ,", ",")
	return strings.TrimSpace(label)
}
</file>

<file path="internal/maps/types.go">
package maps

// LookupRequest represents the query parameters from the frontend.
type LookupRequest struct {
	Query string `form:"q" binding:"required,min=3"`
}

// AddressSuggestion is the normalized data returned to the frontend form.
type AddressSuggestion struct {
	Label       string `json:"label"`
	Street      string `json:"street"`
	HouseNumber string `json:"houseNumber"`
	ZipCode     string `json:"zipCode"`
	City        string `json:"city"`
	Lat         string `json:"lat"`
	Lon         string `json:"lon"`
}

type nominatimAddress struct {
	Road         string `json:"road"`
	HouseNumber  string `json:"house_number"`
	Postcode     string `json:"postcode"`
	City         string `json:"city"`
	Town         string `json:"town"`
	Village      string `json:"village"`
	Municipality string `json:"municipality"`
	Hamlet       string `json:"hamlet"`
}

// nominatimResponse mirrors the relevant parts of the OSM search payload.
type nominatimResponse struct {
	DisplayName string           `json:"display_name"`
	Lat         string           `json:"lat"`
	Lon         string           `json:"lon"`
	Address     nominatimAddress `json:"address"`
}
</file>

<file path="internal/partners/transport/logo.go">
package transport

// PartnerLogoPresignRequest is the request for a presigned logo upload URL.
type PartnerLogoPresignRequest struct {
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// PartnerLogoPresignResponse returns a presigned logo upload URL.
type PartnerLogoPresignResponse struct {
	UploadURL string `json:"uploadUrl"`
	FileKey   string `json:"fileKey"`
	ExpiresAt int64  `json:"expiresAt"`
}

// SetPartnerLogoRequest stores logo metadata after upload.
type SetPartnerLogoRequest struct {
	FileKey     string `json:"fileKey" validate:"required,min=1,max=500"`
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// PartnerLogoDownloadResponse returns a presigned download URL.
type PartnerLogoDownloadResponse struct {
	DownloadURL string `json:"downloadUrl"`
	ExpiresAt   int64  `json:"expiresAt"`
}
</file>

<file path="internal/pdf/templates/cover.html">
<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <style>
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 210mm;
            height: 297mm;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            color: #111827;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }

        @media print {
            html, body {
                width: 210mm;
                height: 297mm;
            }
        }

        .cover {
            position: relative;
            width: 210mm;
            height: 297mm;
            background: #111827;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Blueprint grid pattern */
        .cover::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(rgba(245, 158, 11, 0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(245, 158, 11, 0.06) 1px, transparent 1px);
            background-size: 24px 24px;
            z-index: 1;
        }

        /* Corner triangle graphic */
        .corner-graphic {
            position: absolute;
            top: 0;
            right: 0;
            width: 280px;
            height: 280px;
            z-index: 2;
            overflow: hidden;
        }

        .corner-graphic::before {
            content: '';
            position: absolute;
            top: -1px;
            right: -1px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 280px 280px 0;
            border-color: transparent #F59E0B transparent transparent;
        }

        /* Hatched pattern overlay on triangle */
        .corner-graphic::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 280px;
            height: 280px;
            background-image: repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 4px,
                rgba(17, 24, 39, 0.15) 4px,
                rgba(17, 24, 39, 0.15) 5px
            );
            clip-path: polygon(100% 0, 0 0, 100% 100%);
        }

        /* Top section with logo */
        .top-section {
            position: relative;
            z-index: 3;
            padding: 48px 56px 32px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo-img {
            max-height: 56px;
            max-width: 200px;
            object-fit: contain;
        }

        .org-name-fallback {
            font-size: 28px;
            font-weight: 800;
            color: #F59E0B;
            letter-spacing: -0.5px;
        }

        /* Main content area  push to center-ish */
        .main-content {
            position: relative;
            z-index: 3;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 56px;
        }

        .document-label {
            font-size: 13px;
            font-weight: 600;
            color: #F59E0B;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 12px;
        }

        .title {
            font-size: 52px;
            font-weight: 900;
            color: #FFFFFF;
            line-height: 1.05;
            letter-spacing: -1.5px;
            margin-bottom: 8px;
        }

        .sequence-number {
            font-size: 52px;
            font-weight: 900;
            color: #F59E0B;
            line-height: 1.05;
            letter-spacing: -1.5px;
            margin-bottom: 32px;
        }

        .divider {
            width: 64px;
            height: 4px;
            background: #F59E0B;
            margin-bottom: 32px;
            border-radius: 2px;
        }

        .customer-label {
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 6px;
        }

        .customer-name {
            font-size: 28px;
            font-weight: 700;
            color: #FFFFFF;
            letter-spacing: -0.5px;
        }

        /* Bottom section with metadata */
        .bottom-section {
            position: relative;
            z-index: 3;
            padding: 0 56px 48px;
        }

        .meta-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-top: 1px solid rgba(245, 158, 11, 0.25);
            padding-top: 24px;
        }

        .meta-left {
            display: flex;
            gap: 40px;
        }

        .meta-item {
            display: flex;
            flex-direction: column;
        }

        .meta-label {
            font-size: 9px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 4px;
        }

        .meta-value {
            font-size: 13px;
            font-weight: 600;
            color: #FFFFFF;
        }

        .meta-right {
            text-align: right;
        }

        .org-contact-line {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="cover">
        <div class="corner-graphic"></div>

        <!-- Top: Logo -->
        <div class="top-section">
            <div class="logo-container">
                {{if .LogoBase64}}
                    <img class="logo-img" src="data:{{.LogoMimeType}};base64,{{.LogoBase64}}" alt="{{.OrganizationName}}">
                {{else}}
                    <span class="org-name-fallback">{{.OrganizationName}}</span>
                {{end}}
            </div>
        </div>

        <!-- Center: Title & Customer -->
        <div class="main-content">
            <div class="document-label">Offerte</div>
            <div class="title">{{.QuoteNumber}}</div>
            {{if .QuoteSequenceNumber}}
                <div class="sequence-number">#{{.QuoteSequenceNumber}}</div>
            {{end}}
            <div class="divider"></div>
            <div class="customer-label">Opgesteld voor</div>
            <div class="customer-name">{{.CustomerName}}</div>
        </div>

        <!-- Bottom: Metadata -->
        <div class="bottom-section">
            <div class="meta-bar">
                <div class="meta-left">
                    <div class="meta-item">
                        <span class="meta-label">Datum</span>
                        <span class="meta-value">{{.CreatedAtFormatted}}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Geldig tot</span>
                        <span class="meta-value">{{.ValidUntilFormatted}}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Referentie</span>
                        <span class="meta-value">{{.QuoteNumber}}</span>
                    </div>
                </div>
                <div class="meta-right">
                    {{if .OrgAddressLine1}}<div class="org-contact-line">{{.OrgAddressLine1}}, {{.OrgPostalCode}} {{.OrgCity}}</div>{{end}}
                    {{if .OrgPhone}}<div class="org-contact-line">{{.OrgPhone}}</div>{{end}}
                    {{if .OrgEmail}}<div class="org-contact-line">{{.OrgEmail}}</div>{{end}}
                </div>
            </div>
        </div>
    </div>
</body>
</html>
</file>

<file path="internal/pdf/templates/footer.html">
<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            font-size: 7pt;
            color: #6b7280;
            margin: 0;
            padding: 0;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
        .footer {
            width: 100%;
            text-align: center;
            border-top: 2px solid #F59E0B;
            padding-top: 6px;
            padding-bottom: 0;
        }
        .footer-text {
            font-size: 6.5pt;
            color: #9ca3af;
            letter-spacing: 0.3px;
            font-weight: 500;
        }
        .page-number {
            font-size: 6.5pt;
            color: #9ca3af;
            margin-top: 2px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="footer">
        <div class="footer-text">{{.FooterText}}</div>
        <div class="page-number">Pagina <span class="pageNumber"></span> van <span class="totalPages"></span></div>
    </div>
</body>
</html>
</file>

<file path="internal/quotes/service/calculator.go">
package service

import (
	"math"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"portal_final_backend/internal/quotes/transport"
)

var quantityRegex = regexp.MustCompile(`^([\d.,]+)`)

// parseQuantityNumber extracts numeric value from free-form quantity string.
// Examples: "5 x" -> 5.0, "10 m" -> 10.0, "3.5 uur" -> 3.5
func parseQuantityNumber(quantity string) float64 {
	matches := quantityRegex.FindStringSubmatch(strings.TrimSpace(quantity))
	if len(matches) < 2 {
		return 1.0
	}
	// Support Dutch comma decimal separator
	cleaned := strings.ReplaceAll(matches[1], ",", ".")
	val, err := strconv.ParseFloat(cleaned, 64)
	if err != nil || val <= 0 {
		return 1.0
	}
	return val
}

// roundCents rounds a float to the nearest cent (integer)
func roundCents(v float64) int64 {
	return int64(math.Round(v))
}

// computeLineNetPrice returns the net (excl. tax) unit price given the pricing mode.
func computeLineNetPrice(unitPriceCents int64, taxRateBps int, pricingMode string) float64 {
	price := float64(unitPriceCents)
	if pricingMode == "inclusive" && taxRateBps > 0 {
		price /= 1.0 + float64(taxRateBps)/10000.0
	}
	return price
}

// computeDiscount returns the discount amount in float-cents, capped at the subtotal.
func computeDiscount(subtotalFloat float64, discountType string, discountValue int64) float64 {
	var amount float64
	switch {
	case discountType == "percentage" && discountValue > 0:
		amount = subtotalFloat * (float64(discountValue) / 100.0)
	case discountType == "fixed" && discountValue > 0:
		amount = float64(discountValue)
	}
	if amount > subtotalFloat {
		return subtotalFloat
	}
	return amount
}

// computeVatBreakdown applies the proportional discount multiplier to each VAT rate
// and returns the total VAT in cents plus a sorted breakdown slice.
func computeVatBreakdown(vatMap map[int]float64, multiplier float64) (int64, []transport.VatBreakdown) {
	var vatTotal int64
	breakdown := make([]transport.VatBreakdown, 0, len(vatMap))
	for rate, amount := range vatMap {
		adjusted := roundCents(amount * multiplier)
		vatTotal += adjusted
		breakdown = append(breakdown, transport.VatBreakdown{RateBps: rate, AmountCents: adjusted})
	}
	sort.Slice(breakdown, func(i, j int) bool { return breakdown[i].RateBps < breakdown[j].RateBps })
	return vatTotal, breakdown
}

// CalculateQuote computes financial totals for a set of line items.
// Per Dutch/EU accounting rules: VAT is calculated per line, summed, then discount
// is applied proportionally. Optional items get full calculation for transparency
// but are excluded from the grand total.
func CalculateQuote(req transport.QuoteCalculationRequest) transport.QuoteCalculationResponse {
	pricingMode := req.PricingMode
	if pricingMode == "" {
		pricingMode = "exclusive"
	}
	discountType := req.DiscountType
	if discountType == "" {
		discountType = "percentage"
	}

	var subtotalFloat float64
	vatMap := make(map[int]float64)
	calculatedLines := make([]transport.CalculatedLineItem, 0, len(req.Items))

	for _, item := range req.Items {
		qty := parseQuantityNumber(item.Quantity)
		netUnitPrice := computeLineNetPrice(item.UnitPriceCents, item.TaxRateBps, pricingMode)
		lineSubtotal := qty * netUnitPrice
		lineVat := lineSubtotal * (float64(item.TaxRateBps) / 10000.0)

		calculatedLines = append(calculatedLines, transport.CalculatedLineItem{
			Description:         item.Description,
			Quantity:            item.Quantity,
			UnitPriceCents:      item.UnitPriceCents,
			TaxRateBps:          item.TaxRateBps,
			IsOptional:          item.IsOptional,
			IsSelected:          item.IsSelected,
			TotalBeforeTaxCents: roundCents(lineSubtotal),
			TotalTaxCents:       roundCents(lineVat),
			LineTotalCents:      roundCents(lineSubtotal + lineVat),
		})

		// Include in totals if: non-optional, OR optional AND selected by customer
		if !item.IsOptional || item.IsSelected {
			subtotalFloat += lineSubtotal
			vatMap[item.TaxRateBps] += lineVat
		}
	}

	subtotalCents := roundCents(subtotalFloat)
	discountAmountFloat := computeDiscount(subtotalFloat, discountType, req.DiscountValue)
	discountAmountCents := roundCents(discountAmountFloat)

	// Proportional VAT reduction: if you give 10% off, you owe 10% less VAT
	multiplier := 1.0
	if subtotalFloat > 0 && discountAmountFloat > 0 {
		multiplier = (subtotalFloat - discountAmountFloat) / subtotalFloat
	}

	vatTotal, breakdown := computeVatBreakdown(vatMap, multiplier)
	totalCents := subtotalCents - discountAmountCents + vatTotal

	return transport.QuoteCalculationResponse{
		Lines:               calculatedLines,
		SubtotalCents:       subtotalCents,
		DiscountAmountCents: discountAmountCents,
		VatTotalCents:       vatTotal,
		VatBreakdown:        breakdown,
		TotalCents:          totalCents,
	}
}
</file>

<file path="migrations/001_init.sql">
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS RAC_users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  is_email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS RAC_refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  revoked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON RAC_refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON RAC_refresh_tokens(expires_at);

CREATE TABLE IF NOT EXISTS RAC_user_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  token_hash TEXT NOT NULL UNIQUE,
  type TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_user_tokens_user_id ON RAC_user_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tokens_type ON RAC_user_tokens(type);
CREATE INDEX IF NOT EXISTS idx_user_tokens_expires ON RAC_user_tokens(expires_at);
</file>

<file path="migrations/002_roles.sql">
CREATE TABLE IF NOT EXISTS RAC_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS RAC_user_roles (
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES RAC_roles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, role_id)
);

-- Seed default RAC_roles
INSERT INTO RAC_roles (name)
VALUES ('admin'), ('user'), ('agent'), ('scout'), ('partner')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="migrations/003_leads.sql">
-- Lead statuses: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling
-- Consumer RAC_roles: Owner, Tenant, Landlord
-- Service types: Windows, Insulation, Solar
-- Access difficulty: Low, Medium, High

CREATE TABLE IF NOT EXISTS RAC_leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Consumer information
    consumer_first_name TEXT NOT NULL,
    consumer_last_name TEXT NOT NULL,
    consumer_phone TEXT NOT NULL,
    consumer_email TEXT,
    consumer_role TEXT NOT NULL DEFAULT 'Owner' CHECK (consumer_role IN ('Owner', 'Tenant', 'Landlord')),
    
    -- Address information
    address_street TEXT NOT NULL,
    address_house_number TEXT NOT NULL,
    address_zip_code TEXT NOT NULL,
    address_city TEXT NOT NULL,
    
    -- Lead details
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling')),
    
    -- Assignment
    assigned_agent_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL,
    viewed_by_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL,
    viewed_at TIMESTAMPTZ,
    
    -- Visit / Survey information
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL,
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_leads_status ON RAC_leads(status);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent ON RAC_leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_scout ON RAC_leads(visit_scout_id);
CREATE INDEX IF NOT EXISTS idx_leads_phone ON RAC_leads(consumer_phone);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON RAC_leads(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_leads_scheduled_date ON RAC_leads(visit_scheduled_date) WHERE visit_scheduled_date IS NOT NULL;

-- Add agent and scout RAC_roles
INSERT INTO RAC_roles (name)
VALUES ('agent'), ('scout')
ON CONFLICT (name) DO NOTHING;
</file>

<file path="migrations/004_lead_activity.sql">
-- Track actions performed on RAC_leads for auditing purposes

CREATE TABLE IF NOT EXISTS RAC_lead_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    action TEXT NOT NULL,
    meta JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_activity_lead_id ON RAC_lead_activity(lead_id);
</file>

<file path="migrations/005_leads_soft_delete.sql">
ALTER TABLE RAC_leads
ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_leads_deleted_at ON RAC_leads(deleted_at);
</file>

<file path="migrations/006_lead_notes.sql">
-- Lead notes for internal comments

CREATE TABLE IF NOT EXISTS RAC_lead_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    body TEXT NOT NULL CHECK (char_length(body) >= 1 AND char_length(body) <= 2000),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_notes_lead_id ON RAC_lead_notes(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_notes_created_at ON RAC_lead_notes(created_at DESC);
</file>

<file path="migrations/007_lead_services.sql">
-- Lead services table: allows multiple services per lead with per-service status and visit info

CREATE TABLE IF NOT EXISTS RAC_lead_services (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    
    -- Service info
    service_type TEXT NOT NULL CHECK (service_type IN ('Windows', 'Insulation', 'Solar')),
    status TEXT NOT NULL DEFAULT 'New' CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed')),
    
    -- Visit / Survey information (per service)
    visit_scheduled_date TIMESTAMPTZ,
    visit_scout_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL,
    visit_measurements TEXT,
    visit_access_difficulty TEXT CHECK (visit_access_difficulty IS NULL OR visit_access_difficulty IN ('Low', 'Medium', 'High')),
    visit_notes TEXT,
    visit_completed_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_lead_services_lead_id ON RAC_lead_services(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_services_status ON RAC_lead_services(status);
CREATE INDEX IF NOT EXISTS idx_lead_services_service_type ON RAC_lead_services(service_type);
CREATE INDEX IF NOT EXISTS idx_lead_services_created_at ON RAC_lead_services(created_at DESC);

-- Migrate existing RAC_leads into RAC_lead_services
INSERT INTO RAC_lead_services (
    lead_id,
    service_type,
    status,
    visit_scheduled_date,
    visit_scout_id,
    visit_measurements,
    visit_access_difficulty,
    visit_notes,
    visit_completed_at,
    created_at,
    updated_at
)
SELECT id, service_type, status, visit_scheduled_date, visit_scout_id, visit_measurements,
    visit_access_difficulty, visit_notes, visit_completed_at, created_at, updated_at
FROM RAC_leads
WHERE deleted_at IS NULL;

-- Add 'Closed' to RAC_leads status constraint (for backward compatibility during transition)
ALTER TABLE RAC_leads DROP CONSTRAINT IF EXISTS leads_status_check;
ALTER TABLE RAC_leads ADD CONSTRAINT leads_status_check CHECK (status IN ('New', 'Attempted_Contact', 'Scheduled', 'Surveyed', 'Bad_Lead', 'Needs_Rescheduling', 'Closed'));
</file>

<file path="migrations/007_visit_history.sql">
-- Track visit history for audit trail
-- Each row represents a scheduled visit attempt

CREATE TABLE IF NOT EXISTS visit_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    scheduled_date TIMESTAMPTZ NOT NULL,
    scout_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL,
    outcome TEXT NOT NULL CHECK (outcome IN ('completed', 'no_show', 'rescheduled', 'cancelled')),
    measurements TEXT,
    access_difficulty TEXT CHECK (access_difficulty IN ('Low', 'Medium', 'High')),
    notes TEXT,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_visit_history_lead_id ON visit_history(lead_id);
CREATE INDEX IF NOT EXISTS idx_visit_history_scheduled_date ON visit_history(scheduled_date);
</file>

<file path="migrations/008_lead_notes_type.sql">
-- Add note type to lead notes

ALTER TABLE RAC_lead_notes
  ADD COLUMN IF NOT EXISTS type TEXT NOT NULL DEFAULT 'note';

DO $$
BEGIN
  IF NOT EXISTS (
    -- nosemgrep: system catalog query required for idempotent constraint creation
    SELECT 1 FROM pg_constraint WHERE conname = 'lead_notes_type_check'
  ) THEN
    ALTER TABLE RAC_lead_notes
      ADD CONSTRAINT lead_notes_type_check
      CHECK (type IN ('note', 'call', 'text', 'email', 'system'));
  END IF;
END $$;
</file>

<file path="migrations/009_lead_details.sql">
-- Add details to capture the initial user request
ALTER TABLE RAC_leads 
ADD COLUMN consumer_note TEXT,
ADD COLUMN source TEXT DEFAULT 'manual'; -- e.g., 'website', 'referral', 'manual'
</file>

<file path="migrations/010_lead_ai_analysis.sql">
CREATE TABLE RAC_lead_ai_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    urgency_level TEXT NOT NULL CHECK (urgency_level IN ('High', 'Medium', 'Low')),
    urgency_reason TEXT,
    talking_points JSONB NOT NULL DEFAULT '[]'::jsonb,
    objection_handling JSONB NOT NULL DEFAULT '[]'::jsonb,
    upsell_opportunities JSONB NOT NULL DEFAULT '[]'::jsonb,
    summary TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_lead_ai_analysis_lead_id ON RAC_lead_ai_analysis(lead_id);
CREATE INDEX idx_lead_ai_analysis_created_at ON RAC_lead_ai_analysis(created_at DESC);
</file>

<file path="migrations/011_service_types.sql">
-- Migration: Create RAC_service_types table for dynamic service management
-- This replaces the hardcoded ServiceType enum (Windows, Insulation, Solar)

CREATE TABLE IF NOT EXISTS RAC_service_types (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE,
    slug TEXT NOT NULL UNIQUE,
    description TEXT,
    icon TEXT,  -- icon name (e.g., "wrench", "flame") or URL
    color TEXT, -- hex color code for UI
    is_active BOOLEAN NOT NULL DEFAULT true,
    display_order INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for common queries
CREATE INDEX idx_service_types_slug ON RAC_service_types(slug);
CREATE INDEX idx_service_types_active ON RAC_service_types(is_active) WHERE is_active = true;
CREATE INDEX idx_service_types_display_order ON RAC_service_types(display_order);

-- Seed initial service types (migrate from existing hardcoded values)
INSERT INTO RAC_service_types (name, slug, description, icon, color, display_order) VALUES
    ('Windows', 'windows', 'Window and door installation, replacement, and repairs', 'window', '#3B82F6', 1),
    ('Insulation', 'insulation', 'Home insulation services including roof, wall, and floor insulation', 'home', '#10B981', 2),
    ('Solar', 'solar', 'Solar panel installation and maintenance', 'sun', '#F59E0B', 3),
    -- New service types for the expanded marketplace
    ('Plumbing', 'plumbing', 'Plumbing repairs, installations, and drain services', 'droplet', '#0EA5E9', 4),
    ('HVAC', 'hvac', 'Heating, ventilation, air conditioning, and heat pumps', 'flame', '#EF4444', 5),
    ('Electrical', 'electrical', 'Electrical installations, repairs, and upgrades', 'zap', '#8B5CF6', 6),
    ('Carpentry', 'carpentry', 'Woodwork, doors, floors, and furniture repairs', 'hammer', '#D97706', 7),
    ('Handyman', 'handyman', 'General repairs and small home improvement tasks', 'tool', '#6B7280', 8);

-- Add service_type_id column to RAC_lead_services (keep service_type TEXT temporarily for migration)
ALTER TABLE RAC_lead_services ADD COLUMN IF NOT EXISTS service_type_id UUID REFERENCES RAC_service_types(id);

-- Migrate existing RAC_lead_services data
UPDATE RAC_lead_services ls 
SET service_type_id = st.id
FROM RAC_service_types st 
WHERE LOWER(st.slug) = LOWER(ls.service_type)
  AND ls.service_type_id IS NULL;

-- For any unmapped service types, default to 'handyman'
UPDATE RAC_lead_services 
SET service_type_id = (SELECT id FROM RAC_service_types WHERE slug = 'handyman')
WHERE service_type_id IS NULL;

-- Now make service_type_id required
ALTER TABLE RAC_lead_services ALTER COLUMN service_type_id SET NOT NULL;

-- Drop the old CHECK constraint and TEXT column
ALTER TABLE RAC_lead_services DROP CONSTRAINT IF EXISTS lead_services_service_type_check;
ALTER TABLE RAC_lead_services DROP COLUMN IF EXISTS service_type;
</file>

<file path="migrations/012_lead_projected_value.sql">
-- Adds projected value in cents for KPI metrics

ALTER TABLE RAC_leads
ADD COLUMN IF NOT EXISTS projected_value_cents BIGINT NOT NULL DEFAULT 0;
</file>

<file path="migrations/013_lead_coordinates.sql">
ALTER TABLE RAC_leads
  ADD COLUMN IF NOT EXISTS latitude DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS longitude DOUBLE PRECISION;

CREATE INDEX IF NOT EXISTS idx_leads_coordinates
  ON RAC_leads (latitude, longitude)
  WHERE latitude IS NOT NULL AND longitude IS NOT NULL;
</file>

<file path="migrations/014_user_profile_settings.sql">
ALTER TABLE RAC_users
  ADD COLUMN IF NOT EXISTS first_name TEXT,
  ADD COLUMN IF NOT EXISTS last_name TEXT;

CREATE TABLE IF NOT EXISTS RAC_user_settings (
  user_id UUID PRIMARY KEY REFERENCES RAC_users(id) ON DELETE CASCADE,
  preferred_language TEXT NOT NULL DEFAULT 'nl',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

INSERT INTO RAC_user_settings (user_id)
SELECT id FROM RAC_users
ON CONFLICT (user_id) DO NOTHING;
</file>

<file path="migrations/015_leads_filters_indexes.sql">
CREATE INDEX IF NOT EXISTS idx_leads_consumer_first_name ON RAC_leads(consumer_first_name);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_last_name ON RAC_leads(consumer_last_name);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_email ON RAC_leads(consumer_email);
CREATE INDEX IF NOT EXISTS idx_leads_consumer_role ON RAC_leads(consumer_role);
CREATE INDEX IF NOT EXISTS idx_leads_address_street ON RAC_leads(address_street);
CREATE INDEX IF NOT EXISTS idx_leads_address_house_number ON RAC_leads(address_house_number);
CREATE INDEX IF NOT EXISTS idx_leads_address_zip_code ON RAC_leads(address_zip_code);
CREATE INDEX IF NOT EXISTS idx_leads_address_city ON RAC_leads(address_city);
CREATE INDEX IF NOT EXISTS idx_leads_service_type ON RAC_leads(service_type);
CREATE INDEX IF NOT EXISTS idx_leads_assigned_agent_id ON RAC_leads(assigned_agent_id);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON RAC_leads(created_at);
</file>

<file path="migrations/016_multi_service_cleanup.sql">
-- Migration: Clean up legacy single-service fields from RAC_leads table
-- Services are now exclusively managed via RAC_lead_services table

-- 1. Add consumer_note to RAC_lead_services for per-service intake notes
ALTER TABLE RAC_lead_services ADD COLUMN IF NOT EXISTS consumer_note TEXT;

-- 2. Migrate existing consumer_note from RAC_leads to their first service
UPDATE RAC_lead_services ls
SET consumer_note = l.consumer_note
FROM RAC_leads l
WHERE ls.lead_id = l.id
  AND l.consumer_note IS NOT NULL
  AND ls.consumer_note IS NULL
  AND ls.created_at = (
    SELECT MIN(created_at) FROM RAC_lead_services WHERE lead_id = l.id
  );

-- 3. Remove legacy columns from RAC_leads table
-- These are now managed per-service in RAC_lead_services:
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS service_type;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS status;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS consumer_note;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_scheduled_date;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_scout_id;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_measurements;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_access_difficulty;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_notes;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS visit_completed_at;

-- 4. Add index for returning customer lookup by email
CREATE INDEX IF NOT EXISTS idx_leads_email ON RAC_leads(consumer_email) WHERE consumer_email IS NOT NULL;

-- 5. Add composite index for phone+email lookup
CREATE INDEX IF NOT EXISTS idx_leads_phone_email ON RAC_leads(consumer_phone, consumer_email);
</file>

<file path="migrations/017_ai_analysis_per_service.sql">
-- Migration: AI analysis is now per-service instead of per-lead
-- This allows different services on the same lead to have separate AI advice

-- 1. Add lead_service_id column to RAC_lead_ai_analysis
ALTER TABLE RAC_lead_ai_analysis ADD COLUMN IF NOT EXISTS lead_service_id UUID REFERENCES RAC_lead_services(id) ON DELETE CASCADE;

-- 2. Migrate existing analyses to the oldest service of each lead
UPDATE RAC_lead_ai_analysis aa
SET lead_service_id = (
    SELECT ls.id FROM RAC_lead_services ls
    WHERE ls.lead_id = aa.lead_id
    ORDER BY ls.created_at ASC
    LIMIT 1
)
WHERE aa.lead_service_id IS NULL;

-- 3. For any analyses without a matching service, create a placeholder or delete them
-- We'll keep them with NULL for now as some RAC_leads might not have services yet
-- The application will handle this gracefully

-- 4. Create index for efficient lookup by service
CREATE INDEX IF NOT EXISTS idx_lead_ai_analysis_service_id ON RAC_lead_ai_analysis(lead_service_id);

-- 5. Keep lead_id for reference but primary lookup will be by service_id
-- Note: We don't make lead_service_id NOT NULL to handle edge cases
</file>

<file path="migrations/018_lead_service_source.sql">
-- Add source to RAC_lead_services for per-service tracking of lead source
ALTER TABLE RAC_lead_services ADD COLUMN IF NOT EXISTS source TEXT DEFAULT 'manual';

-- Migrate source from RAC_leads to the oldest service per lead (if not already set from previous migration)
UPDATE RAC_lead_services ls
SET source = COALESCE(
    (SELECT l.source FROM RAC_leads l WHERE l.id = ls.lead_id),
    'manual'
)
WHERE ls.source IS NULL OR ls.source = 'manual';
</file>

<file path="migrations/019_appointments.sql">
-- +goose StatementBegin

-- Appointments table for calendar management
-- Supports three types: lead_visit (linked to lead service), standalone (personal), blocked (time off)
CREATE TABLE appointments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    lead_id UUID REFERENCES RAC_leads(id) ON DELETE SET NULL,
    lead_service_id UUID REFERENCES RAC_lead_services(id) ON DELETE SET NULL,
    type TEXT NOT NULL CHECK (type IN ('lead_visit', 'standalone', 'blocked')),
    title TEXT NOT NULL,
    description TEXT,
    location TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'completed', 'cancelled', 'no_show')),
    all_day BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- Constraint: lead_visit type must have lead_id and lead_service_id
    CONSTRAINT chk_lead_visit_refs CHECK (
        type != 'lead_visit' OR (lead_id IS NOT NULL AND lead_service_id IS NOT NULL)
    ),
    -- Constraint: end_time must be after start_time
    CONSTRAINT chk_time_range CHECK (end_time > start_time)
);

-- Indexes for common query patterns
CREATE INDEX idx_appointments_user_id ON appointments(user_id);
CREATE INDEX idx_appointments_lead_id ON appointments(lead_id) WHERE lead_id IS NOT NULL;
CREATE INDEX idx_appointments_start_time ON appointments(start_time);
CREATE INDEX idx_appointments_type ON appointments(type);
CREATE INDEX idx_appointments_status ON appointments(status);

-- Composite index for calendar range queries
CREATE INDEX idx_appointments_user_time_range ON appointments(user_id, start_time, end_time);

-- Index for finding appointments by lead service (for sync with lead visits)
CREATE INDEX idx_appointments_lead_service_id ON appointments(lead_service_id) WHERE lead_service_id IS NOT NULL;

-- +goose StatementEnd
</file>

<file path="migrations/020_identity.sql">
CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  created_by UUID NOT NULL REFERENCES RAC_users(id) ON DELETE RESTRICT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS organization_members (
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (organization_id, user_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_organization_members_user_id
  ON organization_members(user_id);

CREATE TABLE IF NOT EXISTS organization_invites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  created_by UUID NOT NULL REFERENCES RAC_users(id) ON DELETE RESTRICT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  used_at TIMESTAMPTZ,
  used_by UUID REFERENCES RAC_users(id) ON DELETE RESTRICT
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_organization_invites_active_email
  ON organization_invites(organization_id, lower(email))
  WHERE used_at IS NULL;
</file>

<file path="migrations/020_remove_lead_visit_fields.sql">
-- +goose StatementBegin

ALTER TABLE RAC_lead_services
    DROP COLUMN IF EXISTS visit_scheduled_date,
    DROP COLUMN IF EXISTS visit_scout_id,
    DROP COLUMN IF EXISTS visit_measurements,
    DROP COLUMN IF EXISTS visit_access_difficulty,
    DROP COLUMN IF EXISTS visit_notes,
    DROP COLUMN IF EXISTS visit_completed_at;

DROP TABLE IF EXISTS visit_history;

-- +goose StatementEnd
</file>

<file path="migrations/021_appointment_visit_reports.sql">
-- +goose StatementBegin

CREATE TABLE IF NOT EXISTS appointment_visit_reports (
    appointment_id UUID PRIMARY KEY REFERENCES appointments(id) ON DELETE CASCADE,
    measurements TEXT,
    access_difficulty TEXT CHECK (access_difficulty IS NULL OR access_difficulty IN ('Low', 'Medium', 'High')),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS appointment_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    appointment_id UUID NOT NULL REFERENCES appointments(id) ON DELETE CASCADE,
    file_key TEXT NOT NULL,
    file_name TEXT NOT NULL,
    content_type TEXT,
    size_bytes BIGINT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_appointment_attachments_appointment_id ON appointment_attachments(appointment_id);

-- +goose StatementEnd
</file>

<file path="migrations/021_organization_profile.sql">
ALTER TABLE organizations
  ADD COLUMN IF NOT EXISTS email TEXT,
  ADD COLUMN IF NOT EXISTS phone TEXT,
  ADD COLUMN IF NOT EXISTS vat_number TEXT,
  ADD COLUMN IF NOT EXISTS kvk_number TEXT,
  ADD COLUMN IF NOT EXISTS address_line1 TEXT,
  ADD COLUMN IF NOT EXISTS address_line2 TEXT,
  ADD COLUMN IF NOT EXISTS postal_code TEXT,
  ADD COLUMN IF NOT EXISTS city TEXT,
  ADD COLUMN IF NOT EXISTS country TEXT;
</file>

<file path="migrations/022_appointment_availability.sql">
-- +goose StatementBegin

CREATE TABLE IF NOT EXISTS appointment_availability_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    weekday SMALLINT NOT NULL CHECK (weekday BETWEEN 0 AND 6),
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    timezone TEXT NOT NULL DEFAULT 'Europe/Amsterdam',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT chk_availability_time_range CHECK (end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_availability_rules_user_id ON appointment_availability_rules(user_id);

CREATE TABLE IF NOT EXISTS appointment_availability_overrides (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT false,
    start_time TIME,
    end_time TIME,
    timezone TEXT NOT NULL DEFAULT 'Europe/Amsterdam',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT chk_availability_override_time_range CHECK (end_time IS NULL OR start_time IS NULL OR end_time > start_time)
);

CREATE INDEX IF NOT EXISTS idx_availability_overrides_user_date ON appointment_availability_overrides(user_id, date);

-- +goose StatementEnd
</file>

<file path="migrations/023_tenancy_isolation.sql">
-- Migration: 023_tenancy_isolation.sql
-- Purpose: Add organization_id to all tenant-owned tables for strict multi-tenant isolation
-- Note: This migration truncates tables (dev mode) to allow NOT NULL constraints

-- ============================================
-- LEADS DOMAIN
-- ============================================

-- Truncate RAC_leads-related tables (dev mode - no data preservation needed)
TRUNCATE TABLE RAC_lead_ai_analysis CASCADE;
TRUNCATE TABLE RAC_lead_notes CASCADE;
TRUNCATE TABLE RAC_lead_activity CASCADE;
TRUNCATE TABLE RAC_lead_services CASCADE;
TRUNCATE TABLE RAC_leads CASCADE;

-- Add organization_id to RAC_leads table
ALTER TABLE RAC_leads ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to RAC_lead_services table
ALTER TABLE RAC_lead_services ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to RAC_lead_activity table
ALTER TABLE RAC_lead_activity ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to RAC_lead_notes table
ALTER TABLE RAC_lead_notes ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to RAC_lead_ai_analysis table
ALTER TABLE RAC_lead_ai_analysis ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- ============================================
-- APPOINTMENTS DOMAIN
-- ============================================

-- Truncate appointments-related tables (dev mode - no data preservation needed)
TRUNCATE TABLE appointment_attachments CASCADE;
TRUNCATE TABLE appointment_visit_reports CASCADE;
TRUNCATE TABLE appointment_availability_overrides CASCADE;
TRUNCATE TABLE appointment_availability_rules CASCADE;
TRUNCATE TABLE appointments CASCADE;

-- Add organization_id to appointments table
ALTER TABLE appointments ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to appointment_visit_reports table
ALTER TABLE appointment_visit_reports ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to appointment_attachments table
ALTER TABLE appointment_attachments ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to appointment_availability_rules table
ALTER TABLE appointment_availability_rules ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- Add organization_id to appointment_availability_overrides table
ALTER TABLE appointment_availability_overrides ADD COLUMN organization_id UUID NOT NULL REFERENCES organizations(id);

-- ============================================
-- INDEXES (Crucial for performance and isolation)
-- ============================================

-- Leads domain indexes
CREATE INDEX idx_leads_org ON RAC_leads(organization_id);
CREATE INDEX idx_leads_org_deleted ON RAC_leads(organization_id, deleted_at) WHERE deleted_at IS NULL;
CREATE INDEX idx_lead_services_org ON RAC_lead_services(organization_id);
CREATE INDEX idx_lead_activity_org ON RAC_lead_activity(organization_id);
CREATE INDEX idx_lead_notes_org ON RAC_lead_notes(organization_id);
CREATE INDEX idx_lead_ai_analysis_org ON RAC_lead_ai_analysis(organization_id);

-- Appointments domain indexes
CREATE INDEX idx_appointments_org ON appointments(organization_id);
CREATE INDEX idx_appointments_org_user ON appointments(organization_id, user_id);
CREATE INDEX idx_appointment_visit_reports_org ON appointment_visit_reports(organization_id);
CREATE INDEX idx_appointment_attachments_org ON appointment_attachments(organization_id);
CREATE INDEX idx_appointment_availability_rules_org ON appointment_availability_rules(organization_id);
CREATE INDEX idx_appointment_availability_overrides_org ON appointment_availability_overrides(organization_id);

-- Composite indexes for common query patterns
CREATE INDEX idx_leads_org_assigned ON RAC_leads(organization_id, assigned_agent_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_appointments_org_time ON appointments(organization_id, start_time, end_time);
</file>

<file path="migrations/024_service_types_tenancy.sql">
-- Migration: 024_service_types_tenancy.sql
-- Purpose: Scope service types to organizations

-- Add organization_id column (nullable for legacy rows)
ALTER TABLE RAC_service_types ADD COLUMN IF NOT EXISTS organization_id UUID REFERENCES organizations(id);

-- Drop global uniqueness constraints
ALTER TABLE RAC_service_types DROP CONSTRAINT IF EXISTS service_types_name_key;
ALTER TABLE RAC_service_types DROP CONSTRAINT IF EXISTS service_types_slug_key;

-- Add tenant-scoped uniqueness and lookup indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_service_types_org_name ON RAC_service_types(organization_id, name);
CREATE UNIQUE INDEX IF NOT EXISTS idx_service_types_org_slug ON RAC_service_types(organization_id, slug);
CREATE INDEX IF NOT EXISTS idx_service_types_org ON RAC_service_types(organization_id);
</file>

<file path="migrations/025_add_whatsapp_to_analysis.sql">
ALTER TABLE RAC_lead_ai_analysis ADD COLUMN suggested_whatsapp_message TEXT;
</file>

<file path="migrations/026_gatekeeper_refactor.sql">
-- 1. Service types: intake guidelines for tenant-defined requirements
ALTER TABLE RAC_service_types
ADD COLUMN IF NOT EXISTS intake_guidelines TEXT;

-- 2. Lead AI analysis: remove legacy sales fields
ALTER TABLE RAC_lead_ai_analysis
DROP COLUMN IF EXISTS talking_points,
DROP COLUMN IF EXISTS objection_handling,
DROP COLUMN IF EXISTS upsell_opportunities,
DROP COLUMN IF EXISTS suggested_whatsapp_message;

-- 3. Lead AI analysis: add triage-focused fields
ALTER TABLE RAC_lead_ai_analysis
ADD COLUMN IF NOT EXISTS lead_quality TEXT NOT NULL DEFAULT 'Low'
    CHECK (lead_quality IN ('Junk', 'Low', 'Potential', 'High', 'Urgent')),
ADD COLUMN IF NOT EXISTS recommended_action TEXT NOT NULL DEFAULT 'RequestInfo'
    CHECK (recommended_action IN ('Reject', 'RequestInfo', 'ScheduleSurvey', 'CallImmediately')),
ADD COLUMN IF NOT EXISTS missing_information JSONB NOT NULL DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS preferred_contact_channel TEXT NOT NULL DEFAULT 'WhatsApp'
    CHECK (preferred_contact_channel IN ('WhatsApp', 'Email')),
ADD COLUMN IF NOT EXISTS suggested_contact_message TEXT NOT NULL DEFAULT '';

-- 4. Ensure lead_service_id is populated and required
UPDATE RAC_lead_ai_analysis aa
SET lead_service_id = (
    SELECT ls.id FROM RAC_lead_services ls
    WHERE ls.lead_id = aa.lead_id
    ORDER BY ls.created_at DESC
    LIMIT 1
)
WHERE aa.lead_service_id IS NULL;

-- Remove orphaned analyses without a service
DELETE FROM RAC_lead_ai_analysis WHERE lead_service_id IS NULL;

ALTER TABLE RAC_lead_ai_analysis
ALTER COLUMN lead_service_id SET NOT NULL;
</file>

<file path="migrations/027_price_bigint.sql">
-- Upgrade price_cents from INTEGER (max ~$21M) to BIGINT for high-value catalogs.
-- This is a non-breaking change; existing data remains valid.
ALTER TABLE RAC_catalog_products ALTER COLUMN price_cents TYPE BIGINT;
</file>

<file path="migrations/028_lead_service_attachments.sql">
-- Lead service attachments for storing files (photos, documents, videos) per service inquiry
-- Files are stored in MinIO with metadata tracked in this table

CREATE TABLE lead_service_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,
    file_key TEXT NOT NULL,
    file_name TEXT NOT NULL,
    content_type TEXT,
    size_bytes BIGINT,
    uploaded_by UUID REFERENCES RAC_users(id),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Index for listing attachments by service
CREATE INDEX idx_lead_service_attachments_service ON lead_service_attachments(lead_service_id);

-- Index for tenant isolation queries
CREATE INDEX idx_lead_service_attachments_org ON lead_service_attachments(organization_id);

-- Composite index for common query pattern
CREATE INDEX idx_lead_service_attachments_service_org ON lead_service_attachments(lead_service_id, organization_id);

COMMENT ON TABLE lead_service_attachments IS 'Stores metadata for files uploaded to MinIO for lead services';
COMMENT ON COLUMN lead_service_attachments.file_key IS 'The object key in MinIO bucket (path including org/lead/service prefix)';
COMMENT ON COLUMN lead_service_attachments.file_name IS 'Original filename as uploaded by user';
COMMENT ON COLUMN lead_service_attachments.content_type IS 'MIME type of the file';
COMMENT ON COLUMN lead_service_attachments.size_bytes IS 'File size in bytes';
COMMENT ON COLUMN lead_service_attachments.uploaded_by IS 'User who uploaded the file';
</file>

<file path="migrations/029_photo_analysis.sql">
-- Photo analysis table to store AI analysis of lead photos
-- This stores the structured analysis from the PhotoAnalyzer agent

CREATE TABLE IF NOT EXISTS lead_photo_analyses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Analysis content
    summary TEXT NOT NULL,
    observations JSONB NOT NULL DEFAULT '[]', -- Array of observation strings
    scope_assessment VARCHAR(20) NOT NULL CHECK (scope_assessment IN ('Small', 'Medium', 'Large', 'Unclear')),
    cost_indicators TEXT,
    safety_concerns JSONB DEFAULT '[]', -- Array of safety concern strings
    additional_info JSONB DEFAULT '[]', -- Array of additional info strings
    
    -- Metadata
    confidence_level VARCHAR(10) NOT NULL CHECK (confidence_level IN ('High', 'Medium', 'Low')),
    photo_count INTEGER NOT NULL DEFAULT 0,
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for quick lookups
CREATE INDEX IF NOT EXISTS idx_photo_analyses_service_id ON lead_photo_analyses(service_id);
CREATE INDEX IF NOT EXISTS idx_photo_analyses_lead_id ON lead_photo_analyses(lead_id);
CREATE INDEX IF NOT EXISTS idx_photo_analyses_org_id ON lead_photo_analyses(org_id);

-- Comments
COMMENT ON TABLE lead_photo_analyses IS 'AI analysis of photos attached to lead services';
COMMENT ON COLUMN lead_photo_analyses.summary IS 'Concise summary of what photos show';
COMMENT ON COLUMN lead_photo_analyses.observations IS 'Array of specific observations from photos';
COMMENT ON COLUMN lead_photo_analyses.scope_assessment IS 'Assessment of work scope: Small, Medium, Large, or Unclear';
COMMENT ON COLUMN lead_photo_analyses.cost_indicators IS 'Factors that may affect pricing';
COMMENT ON COLUMN lead_photo_analyses.safety_concerns IS 'Array of safety issues found in photos';
COMMENT ON COLUMN lead_photo_analyses.additional_info IS 'Additional info or questions for the consumer';
COMMENT ON COLUMN lead_photo_analyses.confidence_level IS 'Confidence in analysis: High, Medium, Low';
</file>

<file path="migrations/030_lead_energy_label.sql">
-- Add energy label data to RAC_leads table
-- Data is fetched from EP-Online (RVO) API and cached per lead

ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_class TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_index DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_bouwjaar INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_gebouwtype TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_label_valid_until TIMESTAMPTZ;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_label_registered_at TIMESTAMPTZ;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_primair_fossiel DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_bag_verblijfsobject_id TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS energy_label_fetched_at TIMESTAMPTZ;

-- Index for potential reporting queries
CREATE INDEX IF NOT EXISTS idx_leads_energy_class ON RAC_leads(energy_class) WHERE energy_class IS NOT NULL;

COMMENT ON COLUMN RAC_leads.energy_class IS 'Energy label class from EP-Online (A+++, A++, A+, A, B, C, D, E, F, G)';
COMMENT ON COLUMN RAC_leads.energy_index IS 'Energy index value from EP-Online';
COMMENT ON COLUMN RAC_leads.energy_bouwjaar IS 'Construction year from EP-Online';
COMMENT ON COLUMN RAC_leads.energy_gebouwtype IS 'Building type from EP-Online (e.g., Vrijstaande woning)';
COMMENT ON COLUMN RAC_leads.energy_label_valid_until IS 'Energy label validity end date';
COMMENT ON COLUMN RAC_leads.energy_label_registered_at IS 'When the energy label was registered at RVO';
COMMENT ON COLUMN RAC_leads.energy_primair_fossiel IS 'Primary fossil energy use in kWh/m2jaar';
COMMENT ON COLUMN RAC_leads.energy_bag_verblijfsobject_id IS 'BAG adresseerbaar object ID for future lookups';
COMMENT ON COLUMN RAC_leads.energy_label_fetched_at IS 'When we last fetched this energy label data';
</file>

<file path="migrations/031_lead_enrichment.sql">
-- Add lead enrichment and scoring fields to RAC_leads table
-- Data is fetched from PDOK/CBS and cached per lead

ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_source TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_postcode6 TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_buurtcode TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_woningtype_code TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_bouwjaarklasse_code INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_woningeigendom_code INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_inkomen_code INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_gem_aardgasverbruik DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_huishouden_grootte DOUBLE PRECISION;

ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_koopwoningen_pct DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_bouwjaar_vanaf2000_pct DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_mediaan_vermogen_x1000 DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_huishoudens_met_kinderen_pct DOUBLE PRECISION;

ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_confidence DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_fetched_at TIMESTAMPTZ;

ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_score INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_score_pre_ai INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_score_factors JSONB;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_score_version TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_score_updated_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_leads_lead_score ON RAC_leads(lead_score) WHERE lead_score IS NOT NULL;

COMMENT ON COLUMN RAC_leads.lead_enrichment_source IS 'Source for lead enrichment (pc6 or buurt)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_postcode6 IS 'Normalized PC6 postcode used for enrichment';
COMMENT ON COLUMN RAC_leads.lead_enrichment_buurtcode IS 'CBS buurtcode used for fallback enrichment';
COMMENT ON COLUMN RAC_leads.lead_enrichment_woningtype_code IS 'CBS woningtype code (PC6)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_bouwjaarklasse_code IS 'CBS bouwjaarklasse code (PC6)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_woningeigendom_code IS 'CBS woningeigendom code (PC6)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_inkomen_code IS 'CBS inkomen code (PC6 scale 1-10)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_gem_aardgasverbruik IS 'CBS gemiddelde aardgasverbruik (PC6)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_huishouden_grootte IS 'CBS huishouden grootte (PC6)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_koopwoningen_pct IS 'CBS percentage koopwoningen (buurt fallback)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_bouwjaar_vanaf2000_pct IS 'CBS percentage woningen bouwjaar vanaf 2000 (buurt fallback)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_mediaan_vermogen_x1000 IS 'CBS mediaan vermogen (x1000 euro, buurt fallback)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_huishoudens_met_kinderen_pct IS 'CBS percentage huishoudens met kinderen (buurt fallback)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_confidence IS 'Confidence multiplier for enrichment quality (0-1)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_fetched_at IS 'When we last fetched lead enrichment data';
COMMENT ON COLUMN RAC_leads.lead_score IS 'Final lead score (0-100)';
COMMENT ON COLUMN RAC_leads.lead_score_pre_ai IS 'Deterministic pre-AI lead score (0-100)';
COMMENT ON COLUMN RAC_leads.lead_score_factors IS 'JSON factors used to compute the lead score';
COMMENT ON COLUMN RAC_leads.lead_score_version IS 'Scoring model version identifier';
COMMENT ON COLUMN RAC_leads.lead_score_updated_at IS 'When we last calculated lead score';
</file>

<file path="migrations/032_remove_legacy_enrichment_fields.sql">
-- Remove legacy enrichment fields that are not available in PDOK CBS APIs
-- These were from the old CBS OData API which is no longer used

ALTER TABLE RAC_leads DROP COLUMN IF EXISTS lead_enrichment_woningtype_code;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS lead_enrichment_bouwjaarklasse_code;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS lead_enrichment_woningeigendom_code;
ALTER TABLE RAC_leads DROP COLUMN IF EXISTS lead_enrichment_inkomen_code;
</file>

<file path="migrations/033_lead_enrichment_pc4.sql">
-- Add PC4-level enrichment fields with richer CBS data
-- PC4 provides gas, electricity, income, WOZ data that PC6 lacks

-- New fields from CBS Postcode4 API
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_postcode4 TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_data_year INTEGER;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_gem_elektriciteitsverbruik DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_woz_waarde DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_gem_inkomen DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_pct_hoog_inkomen DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_pct_laag_inkomen DOUBLE PRECISION;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_stedelijkheid INTEGER;

COMMENT ON COLUMN RAC_leads.lead_enrichment_postcode4 IS 'Numeric postcode used for PC4 enrichment';
COMMENT ON COLUMN RAC_leads.lead_enrichment_data_year IS 'Year of CBS statistics data (e.g. 2022, 2023, 2024)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_gem_elektriciteitsverbruik IS 'Average electricity usage in kWh per year (PC4)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_woz_waarde IS 'Average WOZ property value in thousands of euros (PC4)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_gem_inkomen IS 'Average household income in thousands of euros (PC4)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_pct_hoog_inkomen IS 'Percentage of households with high income (PC4)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_pct_laag_inkomen IS 'Percentage of households with low income (PC4)';
COMMENT ON COLUMN RAC_leads.lead_enrichment_stedelijkheid IS 'Urbanization level 1=very urban to 5=rural (PC4)';
</file>

<file path="migrations/034_lead_enrichment_mediaan_vermogen.sql">
-- Add mediaan vermogen (median wealth) field from CBS OData API
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS lead_enrichment_mediaan_vermogen_x1000 DOUBLE PRECISION;

COMMENT ON COLUMN RAC_leads.lead_enrichment_mediaan_vermogen_x1000 IS 'Mediaan vermogen van particuliere huishoudens ( 1000 EUR) - from CBS OData API by buurtcode';
</file>

<file path="migrations/035_appointments_meeting_link.sql">
-- +goose StatementBegin

ALTER TABLE appointments
  ADD COLUMN IF NOT EXISTS meeting_link TEXT;

-- +goose StatementEnd
</file>

<file path="migrations/036_catalog_product_assets.sql">
-- Catalog product assets for storing images, documents, and terms URLs
-- Files are stored in MinIO with metadata tracked in this table

CREATE TABLE catalog_product_assets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL,
    product_id UUID NOT NULL REFERENCES RAC_catalog_products(id) ON DELETE CASCADE,
    asset_type TEXT NOT NULL,
    file_key TEXT,
    file_name TEXT,
    content_type TEXT,
    size_bytes BIGINT,
    url TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE catalog_product_assets
    ADD CONSTRAINT catalog_product_assets_asset_type_check
    CHECK (asset_type IN ('image', 'document', 'terms_url'));

ALTER TABLE catalog_product_assets
    ADD CONSTRAINT catalog_product_assets_storage_or_url_check
    CHECK (
        (file_key IS NOT NULL AND url IS NULL)
        OR (file_key IS NULL AND url IS NOT NULL)
    );

CREATE INDEX idx_catalog_product_assets_product ON catalog_product_assets(product_id);
CREATE INDEX idx_catalog_product_assets_org ON catalog_product_assets(organization_id);
CREATE INDEX idx_catalog_product_assets_product_org ON catalog_product_assets(product_id, organization_id);
CREATE INDEX idx_catalog_product_assets_product_type ON catalog_product_assets(product_id, asset_type);

COMMENT ON TABLE catalog_product_assets IS 'Stores metadata for catalog product assets (images, documents, and terms URLs)';
COMMENT ON COLUMN catalog_product_assets.file_key IS 'The object key in MinIO bucket (path including org/product prefix)';
COMMENT ON COLUMN catalog_product_assets.file_name IS 'Original filename or label';
COMMENT ON COLUMN catalog_product_assets.content_type IS 'MIME type of the file';
COMMENT ON COLUMN catalog_product_assets.size_bytes IS 'File size in bytes';
COMMENT ON COLUMN catalog_product_assets.url IS 'External URL for terms and conditions';
</file>

<file path="migrations/037_rename_to_rac.sql">
-- Migration: Rename remaining tables to use RAC_ prefix for consistency with Semgrep rules

-- Organizations
ALTER TABLE organizations RENAME TO RAC_organizations;
ALTER TABLE organization_members RENAME TO RAC_organization_members;
ALTER TABLE organization_invites RENAME TO RAC_organization_invites;

-- Appointments
ALTER TABLE appointments RENAME TO RAC_appointments;
ALTER TABLE appointment_attachments RENAME TO RAC_appointment_attachments;
ALTER TABLE appointment_availability_overrides RENAME TO RAC_appointment_availability_overrides;
ALTER TABLE appointment_availability_rules RENAME TO RAC_appointment_availability_rules;
ALTER TABLE appointment_visit_reports RENAME TO RAC_appointment_visit_reports;

-- Assets & Analysis
ALTER TABLE catalog_product_assets RENAME TO RAC_catalog_product_assets;
ALTER TABLE lead_photo_analyses RENAME TO RAC_lead_photo_analyses;
ALTER TABLE lead_service_attachments RENAME TO RAC_lead_service_attachments;

-- Update foreign keys if necessary? 
-- Postgres handles renaming tables by updating references automatically in existing constraints.
</file>

<file path="migrations/038_partners.sql">
-- Migration: 038_partners.sql
-- Purpose: Add partners domain with tenant isolation and invite support

CREATE TABLE IF NOT EXISTS RAC_partners (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  business_name TEXT NOT NULL,
  kvk_number TEXT NOT NULL,
  vat_number TEXT NOT NULL,
  address_line1 TEXT NOT NULL,
  address_line2 TEXT,
  postal_code TEXT NOT NULL,
  city TEXT NOT NULL,
  country TEXT NOT NULL,
  contact_name TEXT NOT NULL,
  contact_email TEXT NOT NULL,
  contact_phone TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_partners_org_business_name
  ON RAC_partners(organization_id, lower(business_name));

CREATE UNIQUE INDEX IF NOT EXISTS idx_partners_org_kvk
  ON RAC_partners(organization_id, kvk_number);

CREATE UNIQUE INDEX IF NOT EXISTS idx_partners_org_vat
  ON RAC_partners(organization_id, vat_number);

CREATE INDEX IF NOT EXISTS idx_partners_org
  ON RAC_partners(organization_id);

CREATE INDEX IF NOT EXISTS idx_partners_contact_email
  ON RAC_partners(organization_id, lower(contact_email));

CREATE TABLE IF NOT EXISTS RAC_partner_leads (
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  partner_id UUID NOT NULL REFERENCES RAC_partners(id) ON DELETE CASCADE,
  lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (organization_id, partner_id, lead_id)
);

CREATE INDEX IF NOT EXISTS idx_partner_leads_org
  ON RAC_partner_leads(organization_id);

CREATE INDEX IF NOT EXISTS idx_partner_leads_partner
  ON RAC_partner_leads(partner_id);

CREATE INDEX IF NOT EXISTS idx_partner_leads_lead
  ON RAC_partner_leads(lead_id);

CREATE TABLE IF NOT EXISTS RAC_partner_invites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  partner_id UUID NOT NULL REFERENCES RAC_partners(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token_hash TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  created_by UUID NOT NULL REFERENCES RAC_users(id) ON DELETE RESTRICT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  used_at TIMESTAMPTZ,
  used_by UUID REFERENCES RAC_users(id) ON DELETE RESTRICT,
  lead_id UUID REFERENCES RAC_leads(id) ON DELETE SET NULL,
  lead_service_id UUID REFERENCES RAC_lead_services(id) ON DELETE SET NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_partner_invites_active_email
  ON RAC_partner_invites(organization_id, partner_id, lower(email))
  WHERE used_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_partner_invites_org
  ON RAC_partner_invites(organization_id);

CREATE INDEX IF NOT EXISTS idx_partner_invites_partner
  ON RAC_partner_invites(partner_id);

CREATE INDEX IF NOT EXISTS idx_partner_invites_lead
  ON RAC_partner_invites(lead_id);
</file>

<file path="migrations/039_partner_logos_service_types.sql">
ALTER TABLE RAC_partners
  ADD COLUMN logo_file_key text,
  ADD COLUMN logo_file_name text,
  ADD COLUMN logo_content_type text,
  ADD COLUMN logo_size_bytes bigint;

CREATE TABLE RAC_partner_service_types (
  partner_id uuid NOT NULL REFERENCES RAC_partners(id) ON DELETE CASCADE,
  service_type_id uuid NOT NULL REFERENCES RAC_service_types(id) ON DELETE RESTRICT,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (partner_id, service_type_id)
);

CREATE INDEX idx_partner_service_types_service_type_id
  ON RAC_partner_service_types(service_type_id);
</file>

<file path="migrations/040_partner_coordinates.sql">
ALTER TABLE RAC_partners
  ADD COLUMN IF NOT EXISTS latitude DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS longitude DOUBLE PRECISION;

CREATE INDEX IF NOT EXISTS idx_partners_coordinates
  ON RAC_partners (latitude, longitude)
  WHERE latitude IS NOT NULL AND longitude IS NOT NULL;
</file>

<file path="migrations/041_partner_house_number.sql">
ALTER TABLE RAC_partners
  ADD COLUMN IF NOT EXISTS house_number TEXT;

CREATE INDEX IF NOT EXISTS idx_partners_house_number
  ON RAC_partners (house_number);
</file>

<file path="migrations/042_pipeline_and_timeline.sql">
-- 1. Enable earthdistance for partner search (if not enabled)
CREATE EXTENSION IF NOT EXISTS cube;
CREATE EXTENSION IF NOT EXISTS earthdistance;

-- 2. Define the strict Lifecycle Stages
CREATE TYPE pipeline_stage AS ENUM (
    'Triage',              -- New data arrived. Gatekeeper Agent is analyzing.
    'Nurturing',           -- Missing info. Message sent to customer. Waiting.
    'Ready_For_Estimator', -- Intake valid. Technical Agent needs to scope/price.
    'Ready_For_Partner',   -- Scoped & Priced. Dispatcher Agent needs to find match.
    'Partner_Matching',    -- Partners found and invited. Waiting for acceptance.
    'Partner_Assigned',    -- Partner accepted job.
    'Manual_Intervention', -- AI Failure (e.g. 0 partners found). Human must act.
    'Completed',           -- Job done.
    'Lost'                 -- Dead lead / Rejected.
);

-- 3. Add Stage to Service (Current State)
ALTER TABLE RAC_lead_services 
ADD COLUMN pipeline_stage pipeline_stage NOT NULL DEFAULT 'Triage';

CREATE INDEX idx_lead_services_pipeline ON RAC_lead_services(pipeline_stage);

-- 4. Create the Immutable Timeline (History Ledger)
CREATE TABLE lead_timeline_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    service_id UUID REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,
    
    -- WHO did it?
    actor_type TEXT NOT NULL, -- 'AI', 'User', 'System'
    actor_name TEXT NOT NULL, -- 'Gatekeeper', 'John Agent'
    
    -- WHAT happened?
    event_type TEXT NOT NULL, -- 'analysis', 'stage_change', 'note', 'call_log', 'partner_search'
    
    -- The Content
    title TEXT NOT NULL,      -- e.g. "Moved to Manual Intervention"
    summary TEXT,             -- e.g. "No partners found within 25km radius."
    
    -- Technical Data (Snapshots)
    metadata JSONB DEFAULT '{}', 
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_timeline_lookup ON lead_timeline_events(lead_id, created_at DESC);
</file>

<file path="migrations/043_partner_invites.sql">
-- Create partner invites tracking table for dispatcher workflow
CREATE TABLE partner_invites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
    partner_id UUID NOT NULL REFERENCES RAC_partners(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,
    
    -- Invite status tracking
    status TEXT NOT NULL CHECK (status IN ('pending', 'accepted', 'rejected', 'expired')),
    
    -- Timestamps
    invited_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    responded_at TIMESTAMPTZ,
    
    -- Additional metadata
    distance_km NUMERIC(10, 2), -- Distance from lead to partner in km
    invite_metadata JSONB DEFAULT '{}', -- Additional context (price range, urgency, etc.)
    
    CONSTRAINT fk_organization FOREIGN KEY (organization_id) REFERENCES RAC_organizations(id) ON DELETE CASCADE
);

-- Indexes for efficient querying
CREATE INDEX idx_invites_by_service ON partner_invites(lead_service_id, status);
CREATE INDEX idx_invites_by_partner ON partner_invites(partner_id, status, invited_at DESC);
CREATE INDEX idx_invites_by_org ON partner_invites(organization_id, invited_at DESC);

-- Prevent duplicate invites for same partner/service
CREATE UNIQUE INDEX idx_unique_partner_service_invite ON partner_invites(lead_service_id, partner_id);
</file>

<file path="migrations/044_catalog_unit_pricing.sql">
-- Add unit pricing fields to catalog products

ALTER TABLE RAC_catalog_products
  ADD COLUMN unit_price_cents BIGINT NOT NULL DEFAULT 0,
  ADD COLUMN unit_label TEXT;

ALTER TABLE RAC_catalog_products
  ADD CONSTRAINT catalog_products_unit_label_check
  CHECK (
    unit_price_cents = 0
    OR (unit_label IS NOT NULL AND btrim(unit_label) <> '')
  );
</file>

<file path="migrations/045_catalog_unit_pricing_check.sql">
-- Enforce exclusive pricing mode for catalog products

ALTER TABLE RAC_catalog_products
  ADD CONSTRAINT catalog_products_pricing_mode_check
  CHECK (
    (price_cents > 0 AND unit_price_cents = 0)
    OR (price_cents = 0 AND unit_price_cents > 0)
  );
</file>

<file path="migrations/046_catalog_labor_time.sql">
ALTER TABLE RAC_catalog_products
  ADD COLUMN labor_time_text text;
</file>

<file path="migrations/047_organization_logo.sql">
-- Add logo columns to RAC_organizations (matches the partner logo pattern)
ALTER TABLE RAC_organizations
  ADD COLUMN IF NOT EXISTS logo_file_key TEXT,
  ADD COLUMN IF NOT EXISTS logo_file_name TEXT,
  ADD COLUMN IF NOT EXISTS logo_content_type TEXT,
  ADD COLUMN IF NOT EXISTS logo_size_bytes BIGINT;
</file>

<file path="migrations/048_quotes.sql">
-- 048_quotes.sql
-- Quotes (Offertes) feature: header + line items tables

CREATE TYPE quote_status AS ENUM ('Draft', 'Sent', 'Accepted', 'Rejected', 'Expired');

CREATE TABLE RAC_quotes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
    lead_service_id UUID REFERENCES RAC_lead_services(id) ON DELETE SET NULL,

    quote_number TEXT NOT NULL,
    status quote_status NOT NULL DEFAULT 'Draft',
    valid_until TIMESTAMPTZ,
    notes TEXT,
    pricing_mode TEXT NOT NULL DEFAULT 'exclusive', -- 'exclusive' or 'inclusive'

    -- Discount
    discount_type TEXT NOT NULL DEFAULT 'percentage', -- 'percentage' or 'fixed'
    discount_value BIGINT NOT NULL DEFAULT 0,         -- percentage (bps) or fixed (cents)

    -- Calculation Snapshots (stored for performance and history)
    subtotal_cents BIGINT NOT NULL DEFAULT 0,
    discount_amount_cents BIGINT NOT NULL DEFAULT 0,
    tax_total_cents BIGINT NOT NULL DEFAULT 0,
    total_cents BIGINT NOT NULL DEFAULT 0,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE RAC_quote_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_id UUID NOT NULL REFERENCES RAC_quotes(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,

    description TEXT NOT NULL,
    quantity TEXT NOT NULL DEFAULT '1 x',           -- Free-form: "5 x", "10 m", "3 uur"
    quantity_numeric NUMERIC(12, 3) NOT NULL DEFAULT 1,
    unit_price_cents BIGINT NOT NULL DEFAULT 0,
    tax_rate INTEGER NOT NULL DEFAULT 2100,         -- Basis points: 2100 = 21%, 900 = 9%, 0 = 0%

    is_optional BOOLEAN NOT NULL DEFAULT false,
    sort_order INTEGER NOT NULL DEFAULT 0,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Quote counter per organization for quote number generation
CREATE TABLE RAC_quote_counters (
    organization_id UUID PRIMARY KEY REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    last_number INTEGER NOT NULL DEFAULT 0
);

CREATE INDEX idx_quotes_lead ON RAC_quotes(lead_id);
CREATE INDEX idx_quotes_org ON RAC_quotes(organization_id);
CREATE INDEX idx_quote_items_quote ON RAC_quote_items(quote_id);
CREATE UNIQUE INDEX idx_quotes_number_org ON RAC_quotes(organization_id, quote_number);
</file>

<file path="migrations/049_interactive_quotes.sql">
-- 049_interactive_quotes.sql
-- Interactive Quote Proposal System: public access, customer selection, annotations

-- 1. Security & Access columns on quotes
ALTER TABLE RAC_quotes
ADD COLUMN public_token TEXT UNIQUE,
ADD COLUMN public_token_expires_at TIMESTAMPTZ,
ADD COLUMN viewed_at TIMESTAMPTZ,
ADD COLUMN accepted_at TIMESTAMPTZ,
ADD COLUMN rejected_at TIMESTAMPTZ,
ADD COLUMN rejection_reason TEXT,
ADD COLUMN signature_name TEXT,
ADD COLUMN signature_data TEXT,
ADD COLUMN signature_ip TEXT,
ADD COLUMN pdf_file_key TEXT;

-- Partial unique index for non-null tokens (the UNIQUE above handles it, but explicit)
CREATE INDEX idx_quotes_public_token ON RAC_quotes(public_token) WHERE public_token IS NOT NULL;

-- 2. Customer selection state on line items
ALTER TABLE RAC_quote_items
ADD COLUMN is_selected BOOLEAN NOT NULL DEFAULT true;

-- 3. Quote annotations (questions/comments per line item)
CREATE TABLE RAC_quote_annotations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_item_id UUID NOT NULL REFERENCES RAC_quote_items(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    author_type TEXT NOT NULL CHECK (author_type IN ('customer', 'agent')),
    author_id UUID,
    text TEXT NOT NULL,
    is_resolved BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_quote_annotations_item ON RAC_quote_annotations(quote_item_id);
</file>

<file path="migrations/050_quote_activity.sql">
-- Track customer interactions with quotes for auditing / activity timeline

CREATE TABLE IF NOT EXISTS RAC_quote_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_id UUID NOT NULL REFERENCES RAC_quotes(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,
    event_type TEXT NOT NULL,
    message TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_quote_activity_quote_id ON RAC_quote_activity(quote_id);
CREATE INDEX IF NOT EXISTS idx_quote_activity_org_id ON RAC_quote_activity(organization_id);
</file>

<file path="platform/ai/moonshot/model.go">
package moonshot

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"strings"

	"google.golang.org/adk/model"
	"google.golang.org/genai"
)

// Config for Kimi
type Config struct {
	APIKey          string
	BaseURL         string
	Model           string
	DisableThinking bool // Disable thinking mode for kimi-k2.5 (uses temp 0.6 instead of 1.0)
}

// KimiModel adapts Moonshot to the ADK model.LLM interface
type KimiModel struct {
	config Config
	client *http.Client
}

func NewModel(cfg Config) *KimiModel {
	if cfg.BaseURL == "" {
		cfg.BaseURL = "https://api.moonshot.ai/v1"
	}
	if cfg.Model == "" {
		cfg.Model = "kimi-k2-turbo-preview"
	}
	return &KimiModel{
		config: cfg,
		client: &http.Client{},
	}
}

func (m *KimiModel) Name() string {
	return m.config.Model
}

// GenerateContent adapts ADK requests to Kimi's OpenAI-compatible API
func (m *KimiModel) GenerateContent(ctx context.Context, req *model.LLMRequest, stream bool) iter.Seq2[*model.LLMResponse, error] {
	return func(yield func(*model.LLMResponse, error) bool) {
		resp, err := m.generate(ctx, req)
		yield(resp, err)
	}
}

// openAIMessage represents a message in OpenAI/Kimi API format
// Content can be either a string (text-only) or array of content parts (multimodal)
type openAIMessage struct {
	Role       string           `json:"role"`
	Content    interface{}      `json:"content,omitempty"` // string or []contentPart for multimodal
	ToolCalls  []openAIToolCall `json:"tool_calls,omitempty"`
	Name       string           `json:"name,omitempty"`
	ToolCallID string           `json:"tool_call_id,omitempty"`
}

// contentPart represents a part of multimodal content (text or image)
type contentPart struct {
	Type     string    `json:"type"`                // "text" or "image_url"
	Text     string    `json:"text,omitempty"`      // for type="text"
	ImageURL *imageURL `json:"image_url,omitempty"` // for type="image_url"
}

// imageURL contains the URL for an image (base64 data URL for Kimi)
type imageURL struct {
	URL string `json:"url"` // "data:image/png;base64,..." format
}

type openAIToolCall struct {
	ID       string               `json:"id"`
	Type     string               `json:"type"`
	Function openAIToolCallDetail `json:"function"`
}

type openAIToolCallDetail struct {
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
}

type openAIToolDef struct {
	Type     string            `json:"type"`
	Function openAIToolDefFunc `json:"function"`
}

type openAIToolDefFunc struct {
	Name        string      `json:"name"`
	Description string      `json:"description,omitempty"`
	Parameters  interface{} `json:"parameters,omitempty"`
}

type openAIResponse struct {
	Choices []struct {
		Message struct {
			Role      string           `json:"role"`
			Content   string           `json:"content"`
			ToolCalls []openAIToolCall `json:"tool_calls"`
		} `json:"message"`
	} `json:"choices"`
	Error interface{} `json:"error"`
}

func (m *KimiModel) generate(ctx context.Context, req *model.LLMRequest) (*model.LLMResponse, error) {
	payload := m.buildPayload(req)

	result, err := m.doRequest(ctx, payload)
	if err != nil {
		return nil, err
	}

	choice := result.Choices[0].Message
	parts := buildResponseParts(choice)

	return &model.LLMResponse{
		Content: &genai.Content{
			Role:  genai.RoleModel,
			Parts: parts,
		},
	}, nil
}

func (m *KimiModel) buildPayload(req *model.LLMRequest) map[string]interface{} {
	messages := m.convertMessages(req.Contents)
	tools := m.convertTools(req)

	payload := map[string]interface{}{
		"model":    m.config.Model,
		"messages": messages,
	}

	// Handle thinking mode for kimi-k2.5
	if m.config.DisableThinking {
		payload["thinking"] = map[string]string{"type": "disabled"}
		// Non-thinking mode uses fixed temperature 0.6
	} else if req.Config != nil && req.Config.Temperature != nil {
		payload["temperature"] = float64(*req.Config.Temperature)
	}

	if len(tools) > 0 {
		payload["tools"] = tools
		payload["tool_choice"] = "auto"
	}

	return payload
}

func (m *KimiModel) doRequest(ctx context.Context, payload map[string]interface{}) (*openAIResponse, error) {
	jsonBody, _ := json.Marshal(payload)
	httpReq, _ := http.NewRequestWithContext(ctx, "POST", m.config.BaseURL+"/chat/completions", bytes.NewBuffer(jsonBody))
	httpReq.Header.Set("Authorization", "Bearer "+m.config.APIKey)
	httpReq.Header.Set("Content-Type", "application/json")

	resp, err := m.client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	result, err := decodeResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

func decodeResponse(resp *http.Response) (*openAIResponse, error) {
	var result openAIResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode kimi response: %v", err)
	}
	if result.Error != nil {
		return nil, fmt.Errorf("kimi api error: %v", result.Error)
	}
	if len(result.Choices) == 0 {
		return nil, fmt.Errorf("kimi api error: empty choices")
	}
	return &result, nil
}

func buildResponseParts(choice struct {
	Role      string           `json:"role"`
	Content   string           `json:"content"`
	ToolCalls []openAIToolCall `json:"tool_calls"`
}) []*genai.Part {
	parts := make([]*genai.Part, 0, 1+len(choice.ToolCalls))
	if strings.TrimSpace(choice.Content) != "" {
		parts = append(parts, genai.NewPartFromText(choice.Content))
	}
	for _, tc := range choice.ToolCalls {
		parts = append(parts, buildToolCallPart(tc))
	}
	return parts
}

func buildToolCallPart(tc openAIToolCall) *genai.Part {
	args := map[string]any{}
	if tc.Function.Arguments != "" {
		if err := json.Unmarshal([]byte(tc.Function.Arguments), &args); err != nil {
			args = map[string]any{"_raw": tc.Function.Arguments}
		}
	}
	return &genai.Part{
		FunctionCall: &genai.FunctionCall{
			ID:   tc.ID,
			Name: tc.Function.Name,
			Args: args,
		},
	}
}

func (m *KimiModel) convertMessages(contents []*genai.Content) []openAIMessage {
	messages := make([]openAIMessage, 0, len(contents))
	for _, content := range contents {
		if content == nil {
			continue
		}

		role := roleForContent(content.Role)
		contentBody, toolCalls, toolMessages := extractContentMessages(content)
		messages = append(messages, toolMessages...)

		// Check if we have content to add
		hasContent := false
		switch v := contentBody.(type) {
		case string:
			hasContent = v != ""
		case []contentPart:
			hasContent = len(v) > 0
		}

		if hasContent || len(toolCalls) > 0 {
			messages = append(messages, openAIMessage{
				Role:      role,
				Content:   contentBody,
				ToolCalls: toolCalls,
			})
		}
	}
	return messages
}

func roleForContent(role string) string {
	if role == "model" {
		return "assistant"
	}
	return "user"
}

func extractContentMessages(content *genai.Content) (interface{}, []openAIToolCall, []openAIMessage) {
	var toolCalls []openAIToolCall
	var toolMessages []openAIMessage
	var textBuilder strings.Builder
	var imageParts []contentPart
	hasImages := false

	for _, part := range content.Parts {
		if part == nil {
			continue
		}
		if msg, ok := buildToolResponseMessage(part); ok {
			toolMessages = append(toolMessages, msg)
			continue
		}
		if call, ok := buildToolCall(part); ok {
			toolCalls = append(toolCalls, call)
			continue
		}
		// Check for inline image data (multimodal)
		if part.InlineData != nil && strings.HasPrefix(part.InlineData.MIMEType, "image/") {
			hasImages = true
			dataURL := fmt.Sprintf("data:%s;base64,%s",
				part.InlineData.MIMEType,
				base64.StdEncoding.EncodeToString(part.InlineData.Data))
			imageParts = append(imageParts, contentPart{
				Type:     "image_url",
				ImageURL: &imageURL{URL: dataURL},
			})
			continue
		}
		appendText(&textBuilder, part.Text)
	}

	text := strings.TrimSpace(textBuilder.String())

	// If we have images, return multimodal content array
	if hasImages {
		var parts []contentPart
		// Add images first
		parts = append(parts, imageParts...)
		// Add text if present
		if text != "" {
			parts = append(parts, contentPart{
				Type: "text",
				Text: text,
			})
		}
		return parts, toolCalls, toolMessages
	}

	// Text-only: return string
	return text, toolCalls, toolMessages
}

func buildToolResponseMessage(part *genai.Part) (openAIMessage, bool) {
	if part.FunctionResponse == nil {
		return openAIMessage{}, false
	}
	payload, _ := json.Marshal(part.FunctionResponse.Response)
	return openAIMessage{
		Role:       "tool",
		ToolCallID: part.FunctionResponse.ID,
		Content:    string(payload),
		Name:       part.FunctionResponse.Name,
	}, true
}

func buildToolCall(part *genai.Part) (openAIToolCall, bool) {
	if part.FunctionCall == nil {
		return openAIToolCall{}, false
	}
	args, _ := json.Marshal(part.FunctionCall.Args)
	return openAIToolCall{
		ID:   part.FunctionCall.ID,
		Type: "function",
		Function: openAIToolCallDetail{
			Name:      part.FunctionCall.Name,
			Arguments: string(args),
		},
	}, true
}

func appendText(builder *strings.Builder, text string) {
	if strings.TrimSpace(text) == "" {
		return
	}
	if builder.Len() > 0 {
		builder.WriteString("\n")
	}
	builder.WriteString(text)
}

func (m *KimiModel) convertTools(req *model.LLMRequest) []openAIToolDef {
	if req == nil || req.Config == nil || len(req.Config.Tools) == 0 {
		return nil
	}

	var tools []openAIToolDef
	for _, gt := range req.Config.Tools {
		if gt == nil || gt.FunctionDeclarations == nil {
			continue
		}
		for _, decl := range gt.FunctionDeclarations {
			if decl == nil || decl.Name == "" {
				continue
			}
			var params interface{}
			switch {
			case decl.ParametersJsonSchema != nil:
				params = decl.ParametersJsonSchema
			case decl.Parameters != nil:
				params = decl.Parameters
			}
			tools = append(tools, openAIToolDef{
				Type: "function",
				Function: openAIToolDefFunc{
					Name:        decl.Name,
					Description: decl.Description,
					Parameters:  params,
				},
			})
		}
	}

	return tools
}
</file>

<file path="platform/apperr/apperr.go">
// Package apperr provides standardized domain error types for the application.
// Domain services return these typed errors, and the HTTP layer middleware
// automatically maps them to appropriate HTTP status codes.
package apperr

import (
	"fmt"
	"net/http"
)

// Kind represents the category of error.
type Kind int

const (
	// KindUnknown is the default error kind when none is specified.
	KindUnknown Kind = iota
	// KindNotFound indicates a resource was not found.
	KindNotFound
	// KindValidation indicates invalid input data.
	KindValidation
	// KindConflict indicates a conflict with existing state (e.g., duplicate).
	KindConflict
	// KindForbidden indicates the action is not allowed for the user.
	KindForbidden
	// KindUnauthorized indicates authentication is required or failed.
	KindUnauthorized
	// KindBadRequest indicates a malformed or invalid request.
	KindBadRequest
	// KindInternal indicates an unexpected internal error.
	KindInternal
	// KindGone indicates a resource that existed but is no longer available.
	KindGone
)

// Error is a domain error with a typed Kind for HTTP mapping.
type Error struct {
	Kind    Kind
	Message string
	Op      string      // Operation that failed (optional)
	Err     error       // Underlying error (optional)
	Details interface{} // Additional details for response (optional)
}

// Error implements the error interface.
func (e *Error) Error() string {
	if e.Op != "" {
		return fmt.Sprintf("%s: %s", e.Op, e.Message)
	}
	return e.Message
}

// Unwrap returns the underlying error for errors.Is/As support.
func (e *Error) Unwrap() error {
	return e.Err
}

// HTTPStatus returns the appropriate HTTP status code for this error kind.
func (e *Error) HTTPStatus() int {
	switch e.Kind {
	case KindNotFound:
		return http.StatusNotFound
	case KindValidation, KindBadRequest:
		return http.StatusBadRequest
	case KindConflict:
		return http.StatusConflict
	case KindForbidden:
		return http.StatusForbidden
	case KindUnauthorized:
		return http.StatusUnauthorized
	case KindInternal:
		return http.StatusInternalServerError
	case KindGone:
		return http.StatusGone
	default:
		return http.StatusBadRequest
	}
}

// New creates a new domain error with the given kind and message.
func New(kind Kind, message string) *Error {
	return &Error{Kind: kind, Message: message}
}

// Wrap creates a new domain error wrapping an existing error.
func Wrap(kind Kind, message string, err error) *Error {
	return &Error{Kind: kind, Message: message, Err: err}
}

// WithOp returns a copy of the error with the operation set.
func (e *Error) WithOp(op string) *Error {
	e.Op = op
	return e
}

// WithDetails returns a copy of the error with additional details.
func (e *Error) WithDetails(details interface{}) *Error {
	e.Details = details
	return e
}

// Convenience constructors for common error types.

// NotFound creates a not found error.
func NotFound(message string) *Error {
	return New(KindNotFound, message)
}

// Validation creates a validation error.
func Validation(message string) *Error {
	return New(KindValidation, message)
}

// Conflict creates a conflict error (e.g., duplicate resource).
func Conflict(message string) *Error {
	return New(KindConflict, message)
}

// Forbidden creates a forbidden error.
func Forbidden(message string) *Error {
	return New(KindForbidden, message)
}

// Unauthorized creates an unauthorized error.
func Unauthorized(message string) *Error {
	return New(KindUnauthorized, message)
}

// BadRequest creates a bad request error.
func BadRequest(message string) *Error {
	return New(KindBadRequest, message)
}

// Internal creates an internal server error.
func Internal(message string) *Error {
	return New(KindInternal, message)
}

// Gone creates a gone error (resource expired/removed).
func Gone(message string) *Error {
	return New(KindGone, message)
}

// GetKind extracts the error kind from an error.
// Returns KindUnknown if the error is not an *Error.
func GetKind(err error) Kind {
	if e, ok := err.(*Error); ok {
		return e.Kind
	}
	return KindUnknown
}

// Is checks if err is an *Error with the given kind.
func Is(err error, kind Kind) bool {
	return GetKind(err) == kind
}
</file>

<file path="platform/db/db.go">
// Package db provides database connection infrastructure.
// This is part of the platform layer and contains no business logic.
package db

import (
	"context"
	"time"

	"portal_final_backend/platform/config"

	"github.com/jackc/pgx/v5/pgxpool"
)

// PoolAdapter wraps pgxpool.Pool to expose a minimal interface for health checks.
type PoolAdapter struct {
	*pgxpool.Pool
}

// NewPoolAdapter creates a health-check adapter for a pool.
func NewPoolAdapter(pool *pgxpool.Pool) *PoolAdapter {
	return &PoolAdapter{Pool: pool}
}

// NewPool creates a new database connection pool with production-ready settings.
func NewPool(ctx context.Context, cfg config.DatabaseConfig) (*pgxpool.Pool, error) {
	poolConfig, err := pgxpool.ParseConfig(cfg.GetDatabaseURL())
	if err != nil {
		return nil, err
	}

	// Production-ready pool configuration
	poolConfig.MaxConns = 25                       // Maximum number of connections
	poolConfig.MinConns = 5                        // Minimum number of idle connections
	poolConfig.MaxConnLifetime = 1 * time.Hour     // Maximum connection lifetime
	poolConfig.MaxConnIdleTime = 30 * time.Minute  // Maximum idle time before closing
	poolConfig.HealthCheckPeriod = 1 * time.Minute // Health check interval

	pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(ctx); err != nil {
		pool.Close()
		return nil, err
	}

	return pool, nil
}
</file>

<file path="platform/events/bus.go">
// Package events provides event bus infrastructure for decoupled,
// event-driven communication between modules.
// This is part of the platform layer and contains no business logic.
package events

import (
	"context"
	"sync"

	"portal_final_backend/platform/logger"
)

// InMemoryBus is an in-memory implementation of the event Bus interface.
// It executes handlers asynchronously by default for non-blocking event publishing.
type InMemoryBus struct {
	mu       sync.RWMutex
	handlers map[string][]Handler
	log      *logger.Logger
}

// NewInMemoryBus creates a new in-memory event bus.
func NewInMemoryBus(log *logger.Logger) *InMemoryBus {
	return &InMemoryBus{
		handlers: make(map[string][]Handler),
		log:      log,
	}
}

// Publish sends an event to all registered handlers asynchronously.
// Errors are logged but do not propagate back to the publisher.
// Note: Uses context.Background() so handlers aren't canceled when
// the original context (e.g., HTTP request) completes.
func (b *InMemoryBus) Publish(ctx context.Context, event Event) {
	b.mu.RLock()
	handlers := b.handlers[event.EventName()]
	b.mu.RUnlock()

	if len(handlers) == 0 {
		return
	}

	// Execute all handlers asynchronously with a background context
	// to prevent cancellation when the original request completes
	for _, h := range handlers {
		go func(handler Handler) {
			if err := handler.Handle(context.Background(), event); err != nil {
				b.log.Error("event handler failed",
					"event", event.EventName(),
					"error", err,
				)
			}
		}(h)
	}
}

// PublishSync sends an event and waits for all handlers to complete.
// Returns the first error encountered, but all handlers are still executed.
func (b *InMemoryBus) PublishSync(ctx context.Context, event Event) error {
	b.mu.RLock()
	handlers := b.handlers[event.EventName()]
	b.mu.RUnlock()

	if len(handlers) == 0 {
		return nil
	}

	var wg sync.WaitGroup
	errChan := make(chan error, len(handlers))

	for _, h := range handlers {
		wg.Add(1)
		go func(handler Handler) {
			defer wg.Done()
			if err := handler.Handle(ctx, event); err != nil {
				errChan <- err
				b.log.Error("event handler failed",
					"event", event.EventName(),
					"error", err,
				)
			}
		}(h)
	}

	wg.Wait()
	close(errChan)

	// Return first error if any
	for err := range errChan {
		return err
	}

	return nil
}

// Subscribe registers a handler for a specific event type.
func (b *InMemoryBus) Subscribe(eventName string, handler Handler) {
	b.mu.Lock()
	defer b.mu.Unlock()

	b.handlers[eventName] = append(b.handlers[eventName], handler)
	b.log.Debug("event handler subscribed", "event", eventName)
}

// SubscribeFunc is a convenience method to subscribe a function as a handler.
func (b *InMemoryBus) SubscribeFunc(eventName string, fn func(ctx context.Context, event Event) error) {
	b.Subscribe(eventName, HandlerFunc(fn))
}

// Ensure InMemoryBus implements Bus
var _ Bus = (*InMemoryBus)(nil)
</file>

<file path="platform/events/event.go">
// Package events provides event bus infrastructure for decoupled,
// event-driven communication between modules.
// This is part of the platform layer and contains no business logic.
package events

import (
	"context"
	"time"
)

// Event is the base interface all domain events must implement.
type Event interface {
	// EventName returns a unique identifier for the event type.
	EventName() string
	// OccurredAt returns when the event occurred.
	OccurredAt() time.Time
}

// BaseEvent provides common fields for all events.
type BaseEvent struct {
	Timestamp time.Time `json:"timestamp"`
}

// OccurredAt returns when the event occurred.
func (e BaseEvent) OccurredAt() time.Time {
	return e.Timestamp
}

// NewBaseEvent creates a new base event with the current timestamp.
func NewBaseEvent() BaseEvent {
	return BaseEvent{Timestamp: time.Now()}
}

// Handler processes events of a specific type.
type Handler interface {
	Handle(ctx context.Context, event Event) error
}

// HandlerFunc is an adapter to allow ordinary functions to be used as handlers.
type HandlerFunc func(ctx context.Context, event Event) error

// Handle calls the underlying function.
func (f HandlerFunc) Handle(ctx context.Context, event Event) error {
	return f(ctx, event)
}

// Bus is the interface for publishing and subscribing to domain events.
type Bus interface {
	// Publish sends an event to all registered handlers for that event type.
	// Handlers are executed asynchronously by default.
	Publish(ctx context.Context, event Event)

	// PublishSync sends an event and waits for all handlers to complete.
	PublishSync(ctx context.Context, event Event) error

	// Subscribe registers a handler for a specific event type.
	// The eventName should match the value returned by Event.EventName().
	Subscribe(eventName string, handler Handler)
}
</file>

<file path="platform/httpkit/identity.go">
// Package httpkit provides HTTP utilities including identity abstraction.
package httpkit

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// Identity represents the authenticated user's identity.
// This interface abstracts identity extraction from the web framework,
// allowing handlers to access user information without depending on Gin.
type Identity interface {
	// UserID returns the authenticated user's ID.
	UserID() uuid.UUID
	// TenantID returns the organization ID associated with the user.
	TenantID() *uuid.UUID
	// Roles returns the user's assigned roles.
	Roles() []string
	// HasRole checks if the user has a specific role.
	HasRole(role string) bool
	// IsAuthenticated returns true if the user is authenticated.
	IsAuthenticated() bool
}

// identity is the concrete implementation of Identity.
type identity struct {
	userID        uuid.UUID
	tenantID      *uuid.UUID
	roles         []string
	authenticated bool
}

func (i *identity) UserID() uuid.UUID {
	return i.userID
}

func (i *identity) TenantID() *uuid.UUID {
	return i.tenantID
}

func (i *identity) Roles() []string {
	return i.roles
}

func (i *identity) HasRole(role string) bool {
	for _, r := range i.roles {
		if r == role {
			return true
		}
	}
	return false
}

func (i *identity) IsAuthenticated() bool {
	return i.authenticated
}

// GetIdentity extracts the Identity from a Gin context.
// Returns an unauthenticated identity if user info is not present.
func GetIdentity(c *gin.Context) Identity {
	userID, userOK := c.Get(ContextUserIDKey)
	roles, rolesOK := c.Get(ContextRolesKey)
	tenantID, tenantOK := c.Get(ContextTenantIDKey)

	if !userOK {
		return &identity{authenticated: false}
	}

	uid, ok := userID.(uuid.UUID)
	if !ok {
		return &identity{authenticated: false}
	}

	var roleList []string
	if rolesOK {
		roleList, _ = roles.([]string)
	}

	var tenantUUID *uuid.UUID
	if tenantOK {
		if rawTenantID, ok := tenantID.(uuid.UUID); ok {
			tenantUUID = &rawTenantID
		}
	}

	return &identity{
		userID:        uid,
		tenantID:      tenantUUID,
		roles:         roleList,
		authenticated: true,
	}
}

// MustGetIdentity extracts the Identity from a Gin context.
// If the user is not authenticated, it aborts with 401 Unauthorized and returns nil.
func MustGetIdentity(c *gin.Context) Identity {
	id := GetIdentity(c)
	if !id.IsAuthenticated() {
		c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return nil
	}
	if id.TenantID() == nil {
		if !isOnboardingAllowedPath(c) {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "organization required"})
			return nil
		}
	}
	return id
}

func isOnboardingAllowedPath(c *gin.Context) bool {
	path := c.FullPath()
	if path == "" {
		path = c.Request.URL.Path
	}
	path = strings.TrimSpace(path)
	if path == "" {
		return false
	}
	allowed := map[string]bool{
		"/api/v1/users/me":            true,
		"/api/v1/users/me/onboarding": true,
		"/api/v1/users/me/password":   true,
	}
	return allowed[path]
}
</file>

<file path="platform/httpkit/response.go">
// Package httpkit provides HTTP response utilities.
// This is part of the platform layer and contains no business logic.
package httpkit

import (
	"net/http"

	"portal_final_backend/platform/apperr"

	"github.com/gin-gonic/gin"
)

// ErrorResponse is the standard error response format.
type ErrorResponse struct {
	Error   string      `json:"error"`
	Details interface{} `json:"details,omitempty"`
}

// JSON sends a JSON response with the given status code.
func JSON(c *gin.Context, status int, payload interface{}) {
	c.JSON(status, payload)
}

// Error sends an error response with the given status code and message.
func Error(c *gin.Context, status int, message string, details interface{}) {
	c.JSON(status, ErrorResponse{Error: message, Details: details})
}

// OK sends a 200 OK response with the given payload.
func OK(c *gin.Context, payload interface{}) {
	c.JSON(http.StatusOK, payload)
}

// HandleError maps domain errors to HTTP responses.
// If the error is a typed *apperr.Error, it uses the error's Kind to determine
// the HTTP status code. Otherwise, it defaults to 400 Bad Request.
// Returns true if an error was handled, false otherwise.
func HandleError(c *gin.Context, err error) bool {
	if err == nil {
		return false
	}

	if domainErr, ok := err.(*apperr.Error); ok {
		c.JSON(domainErr.HTTPStatus(), ErrorResponse{
			Error:   domainErr.Message,
			Details: domainErr.Details,
		})
		return true
	}

	// Fallback for non-typed errors
	c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
	return true
}
</file>

<file path="platform/logger/logger.go">
// Package logger provides structured logging infrastructure for the application.
// This is part of the platform layer and contains no business logic.
package logger

import (
	"context"
	"log/slog"
	"os"
	"strings"
)

// Context key types for storing values in context
type contextKey string

const (
	// RequestIDKey is the context key for request ID
	RequestIDKey contextKey = "request_id"
	// UserIDKey is the context key for user ID
	UserIDKey contextKey = "user_id"
	// TraceIDKey is the context key for trace ID
	TraceIDKey contextKey = "trace_id"
)

// Logger wraps slog.Logger for structured logging
type Logger struct {
	*slog.Logger
}

// New creates a new logger based on environment
func New(env string) *Logger {
	var handler slog.Handler

	opts := &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}

	if strings.EqualFold(env, "development") {
		opts.Level = slog.LevelDebug
		handler = slog.NewTextHandler(os.Stdout, opts)
	} else {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	}

	return &Logger{
		Logger: slog.New(handler),
	}
}

// WithContext returns a logger with context values extracted.
// Supports request_id, user_id, and trace_id from context.
func (l *Logger) WithContext(ctx context.Context) *Logger {
	if ctx == nil {
		return l
	}

	newLogger := l

	if requestID, ok := ctx.Value(RequestIDKey).(string); ok && requestID != "" {
		newLogger = newLogger.WithRequestID(requestID)
	}

	if userID, ok := ctx.Value(UserIDKey).(string); ok && userID != "" {
		newLogger = newLogger.WithUserID(userID)
	}

	if traceID, ok := ctx.Value(TraceIDKey).(string); ok && traceID != "" {
		newLogger = &Logger{
			Logger: newLogger.With(slog.String("trace_id", traceID)),
		}
	}

	return newLogger
}

// ContextWithRequestID adds a request ID to the context
func ContextWithRequestID(ctx context.Context, requestID string) context.Context {
	return context.WithValue(ctx, RequestIDKey, requestID)
}

// ContextWithUserID adds a user ID to the context
func ContextWithUserID(ctx context.Context, userID string) context.Context {
	return context.WithValue(ctx, UserIDKey, userID)
}

// ContextWithTraceID adds a trace ID to the context
func ContextWithTraceID(ctx context.Context, traceID string) context.Context {
	return context.WithValue(ctx, TraceIDKey, traceID)
}

// WithRequestID returns a logger with request ID
func (l *Logger) WithRequestID(requestID string) *Logger {
	return &Logger{
		Logger: l.With(slog.String("request_id", requestID)),
	}
}

// WithUserID returns a logger with user ID
func (l *Logger) WithUserID(userID string) *Logger {
	return &Logger{
		Logger: l.With(slog.String("user_id", userID)),
	}
}

// HTTPRequest logs an HTTP request
func (l *Logger) HTTPRequest(method, path string, status int, latencyMs float64, clientIP string) {
	l.Info("http_request",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.Float64("latency_ms", latencyMs),
		slog.String("client_ip", clientIP),
	)
}

// HTTPError logs an HTTP error
func (l *Logger) HTTPError(method, path string, status int, err error, clientIP string) {
	l.Error("http_error",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", status),
		slog.String("error", err.Error()),
		slog.String("client_ip", clientIP),
	)
}

// AuthEvent logs authentication events
func (l *Logger) AuthEvent(event, email string, success bool, reason string) {
	if success {
		l.Info("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
		)
	} else {
		l.Warn("auth_event",
			slog.String("event", event),
			slog.String("email", email),
			slog.Bool("success", success),
			slog.String("reason", reason),
		)
	}
}

// DatabaseError logs database errors
func (l *Logger) DatabaseError(operation string, err error) {
	l.Error("database_error",
		slog.String("operation", operation),
		slog.String("error", err.Error()),
	)
}

// RateLimitExceeded logs rate limit events
func (l *Logger) RateLimitExceeded(clientIP, path string) {
	l.Warn("rate_limit_exceeded",
		slog.String("client_ip", clientIP),
		slog.String("path", path),
	)
}
</file>

<file path="platform/phone/normalize.go">
// Package phone provides phone number utilities.
// This is part of the platform layer and contains no business logic.
package phone

import (
	"strings"

	"github.com/nyaruka/phonenumbers"
)

const defaultRegion = "NL"

// NormalizeE164 formats a phone number to E.164. If parsing fails, it returns the trimmed input.
func NormalizeE164(input string) string {
	trimmed := strings.TrimSpace(input)
	if trimmed == "" {
		return trimmed
	}

	number, err := phonenumbers.Parse(trimmed, defaultRegion)
	if err != nil {
		return trimmed
	}

	if !phonenumbers.IsValidNumber(number) {
		return trimmed
	}

	return phonenumbers.Format(number, phonenumbers.E164)
}
</file>

<file path="platform/sanitize/sanitize.go">
// Package sanitize provides text sanitization utilities to prevent XSS attacks.
package sanitize

import (
	"regexp"
	"strings"
)

var (
	// htmlTagRegex matches HTML tags
	htmlTagRegex = regexp.MustCompile(`<[^>]*>`)
	// scriptRegex matches script-like patterns that might bypass simple tag stripping
	scriptRegex = regexp.MustCompile(`(?i)(javascript|on\w+\s*=|<script|<\/script)`)
)

// StripHTML removes all HTML tags from a string, making it safe for text-only display.
// This is a defense-in-depth measure; frontend should also escape output.
func StripHTML(s string) string {
	// Remove HTML tags
	result := htmlTagRegex.ReplaceAllString(s, "")
	// Decode common HTML entities
	result = strings.ReplaceAll(result, "&lt;", "<")
	result = strings.ReplaceAll(result, "&gt;", ">")
	result = strings.ReplaceAll(result, "&amp;", "&")
	result = strings.ReplaceAll(result, "&quot;", "\"")
	result = strings.ReplaceAll(result, "&#39;", "'")
	// Re-strip after entity decode to catch encoded tags
	result = htmlTagRegex.ReplaceAllString(result, "")
	return strings.TrimSpace(result)
}

// StripHTMLPtr is a helper for optional string pointers
func StripHTMLPtr(s *string) *string {
	if s == nil {
		return nil
	}
	result := StripHTML(*s)
	return &result
}

// Text sanitizes a string for safe text storage by stripping HTML
// and normalizing whitespace. Use for user-provided text fields like
// descriptions, notes, and comments.
func Text(s string) string {
	return StripHTML(s)
}

// TextPtr is a helper for optional string pointers
func TextPtr(s *string) *string {
	if s == nil {
		return nil
	}
	result := Text(*s)
	return &result
}

// ContainsDangerousPatterns checks if a string contains potentially dangerous patterns.
// Returns true if the string might contain XSS attempts.
func ContainsDangerousPatterns(s string) bool {
	return scriptRegex.MatchString(s)
}
</file>

<file path="platform/validator/validator.go">
// Package validator provides validation infrastructure for the application.
// This is part of the platform layer and contains no business logic.
package validator

import "github.com/go-playground/validator/v10"

// Validator wraps the go-playground validator for structured validation.
// Using a struct allows for dependency injection and easier testing.
type Validator struct {
	v *validator.Validate
}

// New creates a new Validator instance.
// Domain-specific validation rules can be registered using RegisterValidation.
func New() *Validator {
	return &Validator{
		v: validator.New(),
	}
}

// Struct validates a struct based on validation tags.
func (val *Validator) Struct(s interface{}) error {
	return val.v.Struct(s)
}

// Var validates a single variable against a tag.
func (val *Validator) Var(field interface{}, tag string) error {
	return val.v.Var(field, tag)
}

// RegisterValidation registers a custom validation function.
func (val *Validator) RegisterValidation(tag string, fn validator.Func) error {
	return val.v.RegisterValidation(tag, fn)
}

// Validate is the shared validator instance used across all modules.
// DEPRECATED: Use New() to create and inject a Validator instance instead.
// This global is kept for backward compatibility during migration.
var Validate = validator.New()
</file>

<file path="sql/auth.sql">
-- name: CreateUser :one
INSERT INTO RAC_users (email, password_hash, is_email_verified)
VALUES ($1, $2, false) RETURNING id, email, password_hash, is_email_verified, created_at, updated_at;

-- name: GetUserByEmail :one
SELECT id, email, password_hash, is_email_verified, created_at, updated_at FROM RAC_users WHERE email = $1;

-- name: MarkEmailVerified :exec
UPDATE RAC_users SET is_email_verified = true, updated_at = now() WHERE id = $1;

-- name: UpdatePassword :exec
UPDATE RAC_users SET password_hash = $2, updated_at = now() WHERE id = $1;

-- name: CreateUserToken :exec
INSERT INTO RAC_user_tokens (user_id, token_hash, type, expires_at)
VALUES ($1, $2, $3, $4);

-- name: GetUserToken :one
SELECT user_id, expires_at FROM RAC_user_tokens
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: UseUserToken :exec
UPDATE RAC_user_tokens SET used_at = now()
WHERE token_hash = $1 AND type = $2 AND used_at IS NULL;

-- name: CreateRefreshToken :exec
INSERT INTO RAC_refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3);

-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM RAC_refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeRefreshToken :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE token_hash = $1 AND revoked_at IS NULL;

-- name: RevokeAllRefreshTokens :exec
UPDATE RAC_refresh_tokens SET revoked_at = now()
WHERE user_id = $1 AND revoked_at IS NULL;
</file>

<file path="sqlc.yaml">
version: "2"
sql:
  # Auth Domain - isolated user/authentication queries
  - schema: "internal/auth/migrations"
    queries: "internal/auth/sql"
    engine: "postgresql"
    gen:
      go:
        package: "authdb"
        out: "internal/auth/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false

  # Leads Domain - isolated leads/activity queries
  - schema: "internal/leads/migrations"
    queries: "internal/leads/sql"
    engine: "postgresql"
    gen:
      go:
        package: "leadsdb"
        out: "internal/leads/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false

  # Catalog Domain - products and VAT rates
  - schema: "internal/catalog/migrations"
    queries: "internal/catalog/sql"
    engine: "postgresql"
    gen:
      go:
        package: "catalogdb"
        out: "internal/catalog/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false
</file>

<file path="cmd/scheduler/main.go">
package main

import (
	"context"
	"errors"
	"os"
	"os/signal"
	"syscall"
	"time"

	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/notification"
	"portal_final_backend/internal/scheduler"
	"portal_final_backend/internal/whatsapp"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"

	"github.com/jackc/pgx/v5/pgxpool"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}

	log := logger.New(cfg.Env)
	log.Info("starting scheduler", "env", cfg.Env)

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	var pool *pgxpool.Pool
	if err := withRetry(ctx, log, "database connection", 5, 2*time.Second, func() error {
		p, err := db.NewPool(ctx, cfg)
		if err != nil {
			return err
		}
		pool = p
		return nil
	}); err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	defer pool.Close()

	eventBus := events.NewInMemoryBus(log)

	sender, err := email.NewSender(cfg)
	if err != nil {
		log.Error("failed to initialize email sender", "error", err)
		panic("failed to initialize email sender: " + err.Error())
	}

	notificationModule := notification.New(sender, cfg, log)
	notificationModule.RegisterHandlers(eventBus)
	notificationModule.SetWhatsAppSender(whatsapp.NewClient(cfg, log))

	worker, err := scheduler.NewWorker(cfg, pool, eventBus, log)
	if err != nil {
		log.Error("failed to initialize scheduler worker", "error", err)
		panic("failed to initialize scheduler worker: " + err.Error())
	}

	worker.Run(ctx)
}

func withRetry(ctx context.Context, log *logger.Logger, name string, attempts int, baseDelay time.Duration, fn func() error) error {
	if attempts < 1 {
		return errors.New(name + ": invalid retry attempts")
	}

	var lastErr error
	for attempt := 1; attempt <= attempts; attempt++ {
		if ctx.Err() != nil {
			return ctx.Err()
		}
		if err := fn(); err == nil {
			return nil
		} else {
			lastErr = err
			log.Warn("retryable operation failed", "operation", name, "attempt", attempt, "error", err)
		}

		if attempt < attempts {
			delay := time.Duration(attempt*attempt) * baseDelay
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(delay):
			}
		}
	}

	return errors.New(name + ": " + lastErr.Error())
}
</file>

<file path="go.mod">
module portal_final_backend

go 1.24.12

require (
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-gonic/gin v1.11.0
	github.com/go-playground/validator/v10 v10.30.1
	github.com/golang-jwt/jwt/v5 v5.3.1
	github.com/google/uuid v1.6.0
	github.com/hibiken/asynq v0.25.1
	github.com/jackc/pgx/v5 v5.8.0
	github.com/joho/godotenv v1.5.1
	github.com/minio/minio-go/v7 v7.0.98
	github.com/nyaruka/phonenumbers v1.6.8
	github.com/redis/go-redis/v9 v9.7.0
	golang.org/x/crypto v0.47.0
	golang.org/x/text v0.33.0
	golang.org/x/time v0.14.0
	google.golang.org/adk v0.4.0
	google.golang.org/genai v1.43.0
)

require (
	cloud.google.com/go v0.123.0 // indirect
	cloud.google.com/go/auth v0.17.0 // indirect
	cloud.google.com/go/compute/metadata v0.9.0 // indirect
	github.com/bytedance/sonic v1.14.0 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudwego/base64x v0.1.6 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/gabriel-vasile/mimetype v1.4.12 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-ini/ini v1.67.0 // indirect
	github.com/go-logr/logr v1.4.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/goccy/go-yaml v1.18.0 // indirect
	github.com/google/go-cmp v0.7.0 // indirect
	github.com/google/jsonschema-go v0.3.0 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/google/safehtml v0.1.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.6 // indirect
	github.com/googleapis/gax-go/v2 v2.15.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.18.2 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/klauspost/crc32 v1.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/minio/crc64nvme v1.1.1 // indirect
	github.com/minio/md5-simd v1.1.2 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/philhofer/fwd v1.2.0 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/quic-go/qpack v0.6.0 // indirect
	github.com/quic-go/quic-go v0.57.0 // indirect
	github.com/robfig/cron/v3 v3.0.1 // indirect
	github.com/rs/xid v1.6.0 // indirect
	github.com/spf13/cast v1.7.0 // indirect
	github.com/tinylib/msgp v1.6.1 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	go.opentelemetry.io/auto/sdk v1.2.1 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.63.0 // indirect
	go.opentelemetry.io/otel v1.38.0 // indirect
	go.opentelemetry.io/otel/metric v1.38.0 // indirect
	go.opentelemetry.io/otel/sdk v1.38.0 // indirect
	go.opentelemetry.io/otel/trace v1.38.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/arch v0.20.0 // indirect
	golang.org/x/exp v0.0.0-20250305212735-054e65f0b394 // indirect
	golang.org/x/net v0.48.0 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/sys v0.40.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20251014184007-4626949a642f // indirect
	google.golang.org/grpc v1.76.0 // indirect
	google.golang.org/protobuf v1.36.11 // indirect
	rsc.io/omap v1.2.0 // indirect
	rsc.io/ordered v1.1.1 // indirect
)
</file>

<file path="healthcheck.sh">
#!/bin/sh
set -eu

role="${SERVICE_ROLE:-api}"

if [ "$role" = "scheduler" ]; then
  # Verify the scheduler process is running.
  if ps | grep -q "[s]cheduler"; then
    exit 0
  fi
  echo "scheduler process not running"
  exit 1
fi

addr="${HTTP_ADDR:-:8080}"
case "$addr" in
  :*) hostport="127.0.0.1$addr" ;;
  0.0.0.0:*) hostport="127.0.0.1:${addr#0.0.0.0:}" ;;
  *) hostport="$addr" ;;
esac

if curl -fsS "http://$hostport/api/health" >/dev/null; then
  exit 0
fi

echo "api health check failed"
exit 1
</file>

<file path="internal/adapters/lead_timeline_writer.go">
package adapters

import (
	"context"

	leadsrepo "portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/notification"
)

// LeadTimelineWriter adapts the leads TimelineEventStore for generic lead timeline events.
type LeadTimelineWriter struct {
	store leadsrepo.TimelineEventStore
}

// NewLeadTimelineWriter creates a new lead timeline writer adapter.
func NewLeadTimelineWriter(store leadsrepo.TimelineEventStore) *LeadTimelineWriter {
	return &LeadTimelineWriter{store: store}
}

// CreateTimelineEvent writes a lead timeline event.
func (a *LeadTimelineWriter) CreateTimelineEvent(ctx context.Context, params notification.LeadTimelineEventParams) error {
	_, err := a.store.CreateTimelineEvent(ctx, leadsrepo.CreateTimelineEventParams{
		LeadID:         params.LeadID,
		ServiceID:      params.ServiceID,
		OrganizationID: params.OrgID,
		ActorType:      params.ActorType,
		ActorName:      params.ActorName,
		EventType:      params.EventType,
		Title:          params.Title,
		Summary:        params.Summary,
		Metadata:       params.Metadata,
	})
	return err
}

// Compile-time check.
var _ notification.LeadTimelineWriter = (*LeadTimelineWriter)(nil)
</file>

<file path="internal/adapters/offer_summary_generator_adapter.go">
package adapters

import (
	"context"

	"github.com/google/uuid"

	"portal_final_backend/internal/leads/ports"
	partnersvc "portal_final_backend/internal/partners/service"
)

// OfferSummaryGeneratorAdapter bridges leads summary generation to partners service.
type OfferSummaryGeneratorAdapter struct {
	generator ports.OfferSummaryGenerator
}

func NewOfferSummaryGeneratorAdapter(generator ports.OfferSummaryGenerator) *OfferSummaryGeneratorAdapter {
	return &OfferSummaryGeneratorAdapter{generator: generator}
}

func (a *OfferSummaryGeneratorAdapter) GenerateSummary(ctx context.Context, tenantID uuid.UUID, input partnersvc.OfferSummaryInput) (string, error) {
	if a.generator == nil {
		return "", nil
	}

	mapped := ports.OfferSummaryInput{
		LeadID:        input.LeadID,
		LeadServiceID: input.LeadServiceID,
		ServiceType:   input.ServiceType,
		Scope:         input.Scope,
		UrgencyLevel:  input.UrgencyLevel,
		Items:         make([]ports.OfferSummaryItem, 0, len(input.Items)),
	}

	for _, item := range input.Items {
		mapped.Items = append(mapped.Items, ports.OfferSummaryItem{
			Description: item.Description,
			Quantity:    item.Quantity,
		})
	}

	return a.generator.GenerateOfferSummary(ctx, tenantID, mapped)
}
</file>

<file path="internal/adapters/org_settings_adapter.go">
package adapters

import (
	"context"

	identityrepo "portal_final_backend/internal/identity/repository"
	quotesvc "portal_final_backend/internal/quotes/service"

	"github.com/google/uuid"
)

// OrgSettingsReaderRepo is the narrow interface for fetching organization settings.
type OrgSettingsReaderRepo interface {
	GetOrganizationSettings(ctx context.Context, organizationID uuid.UUID) (identityrepo.OrganizationSettings, error)
}

// OrgSettingsAdapter implements quotes/service.OrgSettingsReader using the
// identity service's organization settings.
type OrgSettingsAdapter struct {
	svc OrgSettingsReaderRepo
}

// NewOrgSettingsAdapter creates a new adapter.
func NewOrgSettingsAdapter(svc OrgSettingsReaderRepo) *OrgSettingsAdapter {
	return &OrgSettingsAdapter{svc: svc}
}

// GetQuoteDefaults returns the organization's configurable quote defaults.
func (a *OrgSettingsAdapter) GetQuoteDefaults(ctx context.Context, organizationID uuid.UUID) (paymentDays int, validDays int, err error) {
	s, err := a.svc.GetOrganizationSettings(ctx, organizationID)
	if err != nil {
		return 7, 14, err
	}
	return s.QuotePaymentDays, s.QuoteValidDays, nil
}

// Compile-time check.
var _ quotesvc.OrgSettingsReader = (*OrgSettingsAdapter)(nil)
</file>

<file path="internal/adapters/partner_offers_timeline_writer.go">
package adapters

import (
	"context"

	leadsrepo "portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/notification"

	"github.com/google/uuid"
)

// PartnerOffersTimelineWriter adapts the leads TimelineEventStore for the partner offers domain.
type PartnerOffersTimelineWriter struct {
	store leadsrepo.TimelineEventStore
}

// NewPartnerOffersTimelineWriter creates a new timeline writer adapter.
func NewPartnerOffersTimelineWriter(store leadsrepo.TimelineEventStore) *PartnerOffersTimelineWriter {
	return &PartnerOffersTimelineWriter{store: store}
}

// WriteOfferEvent writes a timeline event from the partner-offer domain into the leads timeline.
func (a *PartnerOffersTimelineWriter) WriteOfferEvent(ctx context.Context, leadID uuid.UUID, serviceID *uuid.UUID, orgID uuid.UUID, actorType, actorName, eventType, title string, summary *string, metadata map[string]any) error {
	_, err := a.store.CreateTimelineEvent(ctx, leadsrepo.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      serviceID,
		OrganizationID: orgID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      eventType,
		Title:          title,
		Summary:        summary,
		Metadata:       metadata,
	})
	return err
}

// Compile-time check.
var _ notification.PartnerOfferTimelineWriter = (*PartnerOffersTimelineWriter)(nil)
</file>

<file path="internal/appointments/repository/availability.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type AvailabilityRule struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Weekday        int
	StartTime      time.Time
	EndTime        time.Time
	Timezone       string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

type AvailabilityOverride struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	UserID         uuid.UUID
	Date           time.Time
	IsAvailable    bool
	StartTime      *time.Time
	EndTime        *time.Time
	Timezone       string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (r *Repository) CreateAvailabilityRule(ctx context.Context, rule AvailabilityRule) (*AvailabilityRule, error) {
	query := `
		INSERT INTO RAC_appointment_availability_rules
			(id, organization_id, user_id, weekday, start_time, end_time, timezone)
		VALUES
			($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, organization_id, user_id, weekday, start_time, end_time, timezone, created_at, updated_at`

	var saved AvailabilityRule
	err := r.pool.QueryRow(ctx, query,
		rule.ID,
		rule.OrganizationID,
		rule.UserID,
		rule.Weekday,
		rule.StartTime,
		rule.EndTime,
		rule.Timezone,
	).Scan(
		&saved.ID,
		&saved.OrganizationID,
		&saved.UserID,
		&saved.Weekday,
		&saved.StartTime,
		&saved.EndTime,
		&saved.Timezone,
		&saved.CreatedAt,
		&saved.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create availability rule: %w", err)
	}

	return &saved, nil
}

func (r *Repository) ListAvailabilityRules(ctx context.Context, organizationID uuid.UUID, userID uuid.UUID) ([]AvailabilityRule, error) {
	query := `SELECT id, organization_id, user_id, weekday, start_time, end_time, timezone, created_at, updated_at
		FROM RAC_appointment_availability_rules WHERE organization_id = $1 AND user_id = $2 ORDER BY weekday, start_time`

	rows, err := r.pool.Query(ctx, query, organizationID, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list availability rules: %w", err)
	}
	defer rows.Close()

	items := make([]AvailabilityRule, 0)
	for rows.Next() {
		var item AvailabilityRule
		if err := rows.Scan(
			&item.ID,
			&item.OrganizationID,
			&item.UserID,
			&item.Weekday,
			&item.StartTime,
			&item.EndTime,
			&item.Timezone,
			&item.CreatedAt,
			&item.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan availability rule: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate availability rules: %w", err)
	}

	return items, nil
}

func (r *Repository) ListAvailabilityRuleUserIDs(ctx context.Context, organizationID uuid.UUID) ([]uuid.UUID, error) {
	query := `SELECT DISTINCT user_id FROM RAC_appointment_availability_rules WHERE organization_id = $1`
	rows, err := r.pool.Query(ctx, query, organizationID)
	if err != nil {
		return nil, fmt.Errorf("failed to list availability rule users: %w", err)
	}
	defer rows.Close()

	items := make([]uuid.UUID, 0)
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan availability rule user: %w", err)
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate availability rule users: %w", err)
	}

	return items, nil
}

func (r *Repository) GetAvailabilityRuleByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (*AvailabilityRule, error) {
	query := `SELECT id, organization_id, user_id, weekday, start_time, end_time, timezone, created_at, updated_at
		FROM RAC_appointment_availability_rules WHERE id = $1 AND organization_id = $2`

	var item AvailabilityRule
	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&item.ID,
		&item.OrganizationID,
		&item.UserID,
		&item.Weekday,
		&item.StartTime,
		&item.EndTime,
		&item.Timezone,
		&item.CreatedAt,
		&item.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, apperr.NotFound("availability rule not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get availability rule: %w", err)
	}

	return &item, nil
}

func (r *Repository) DeleteAvailabilityRule(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `DELETE FROM RAC_appointment_availability_rules WHERE id = $1 AND organization_id = $2`, id, organizationID)
	if err != nil {
		return fmt.Errorf("failed to delete availability rule: %w", err)
	}
	return nil
}

func (r *Repository) UpdateAvailabilityRule(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, rule AvailabilityRule) (*AvailabilityRule, error) {
	query := `
		UPDATE RAC_appointment_availability_rules SET
			weekday = $3,
			start_time = $4,
			end_time = $5,
			timezone = $6,
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, user_id, weekday, start_time, end_time, timezone, created_at, updated_at`

	var saved AvailabilityRule
	err := r.pool.QueryRow(ctx, query,
		id,
		organizationID,
		rule.Weekday,
		rule.StartTime,
		rule.EndTime,
		rule.Timezone,
	).Scan(
		&saved.ID,
		&saved.OrganizationID,
		&saved.UserID,
		&saved.Weekday,
		&saved.StartTime,
		&saved.EndTime,
		&saved.Timezone,
		&saved.CreatedAt,
		&saved.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, apperr.NotFound("availability rule not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to update availability rule: %w", err)
	}

	return &saved, nil
}

func (r *Repository) CreateAvailabilityOverride(ctx context.Context, override AvailabilityOverride) (*AvailabilityOverride, error) {
	query := `
		INSERT INTO RAC_appointment_availability_overrides
			(id, organization_id, user_id, date, is_available, start_time, end_time, timezone)
		VALUES
			($1, $2, $3, $4, $5, $6, $7, $8)
		RETURNING id, organization_id, user_id, date, is_available, start_time, end_time, timezone, created_at, updated_at`

	var saved AvailabilityOverride
	err := r.pool.QueryRow(ctx, query,
		override.ID,
		override.OrganizationID,
		override.UserID,
		override.Date,
		override.IsAvailable,
		override.StartTime,
		override.EndTime,
		override.Timezone,
	).Scan(
		&saved.ID,
		&saved.OrganizationID,
		&saved.UserID,
		&saved.Date,
		&saved.IsAvailable,
		&saved.StartTime,
		&saved.EndTime,
		&saved.Timezone,
		&saved.CreatedAt,
		&saved.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create availability override: %w", err)
	}

	return &saved, nil
}

func (r *Repository) ListAvailabilityOverrides(ctx context.Context, organizationID uuid.UUID, userID uuid.UUID, startDate *time.Time, endDate *time.Time) ([]AvailabilityOverride, error) {
	query := `SELECT id, organization_id, user_id, date, is_available, start_time, end_time, timezone, created_at, updated_at
		FROM RAC_appointment_availability_overrides
		WHERE organization_id = $1 AND user_id = $2
			AND ($3::date IS NULL OR date >= $3)
			AND ($4::date IS NULL OR date <= $4)
		ORDER BY date ASC`

	var startParam interface{}
	if startDate != nil {
		startParam = *startDate
	}
	var endParam interface{}
	if endDate != nil {
		endParam = *endDate
	}

	rows, err := r.pool.Query(ctx, query, organizationID, userID, startParam, endParam)
	if err != nil {
		return nil, fmt.Errorf("failed to list availability overrides: %w", err)
	}
	defer rows.Close()

	items := make([]AvailabilityOverride, 0)
	for rows.Next() {
		var item AvailabilityOverride
		if err := rows.Scan(
			&item.ID,
			&item.OrganizationID,
			&item.UserID,
			&item.Date,
			&item.IsAvailable,
			&item.StartTime,
			&item.EndTime,
			&item.Timezone,
			&item.CreatedAt,
			&item.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan availability override: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate availability overrides: %w", err)
	}

	return items, nil
}

func (r *Repository) GetAvailabilityOverrideByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (*AvailabilityOverride, error) {
	query := `SELECT id, organization_id, user_id, date, is_available, start_time, end_time, timezone, created_at, updated_at
		FROM RAC_appointment_availability_overrides WHERE id = $1 AND organization_id = $2`

	var item AvailabilityOverride
	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&item.ID,
		&item.OrganizationID,
		&item.UserID,
		&item.Date,
		&item.IsAvailable,
		&item.StartTime,
		&item.EndTime,
		&item.Timezone,
		&item.CreatedAt,
		&item.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, apperr.NotFound("availability override not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get availability override: %w", err)
	}

	return &item, nil
}

func (r *Repository) DeleteAvailabilityOverride(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `DELETE FROM RAC_appointment_availability_overrides WHERE id = $1 AND organization_id = $2`, id, organizationID)
	if err != nil {
		return fmt.Errorf("failed to delete availability override: %w", err)
	}
	return nil
}

func (r *Repository) UpdateAvailabilityOverride(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, override AvailabilityOverride) (*AvailabilityOverride, error) {
	query := `
		UPDATE RAC_appointment_availability_overrides SET
			date = $3,
			is_available = $4,
			start_time = $5,
			end_time = $6,
			timezone = $7,
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, user_id, date, is_available, start_time, end_time, timezone, created_at, updated_at`

	var saved AvailabilityOverride
	err := r.pool.QueryRow(ctx, query,
		id,
		organizationID,
		override.Date,
		override.IsAvailable,
		override.StartTime,
		override.EndTime,
		override.Timezone,
	).Scan(
		&saved.ID,
		&saved.OrganizationID,
		&saved.UserID,
		&saved.Date,
		&saved.IsAvailable,
		&saved.StartTime,
		&saved.EndTime,
		&saved.Timezone,
		&saved.CreatedAt,
		&saved.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, apperr.NotFound("availability override not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to update availability override: %w", err)
	}

	return &saved, nil
}
</file>

<file path="internal/appointments/transport/dto.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

// AppointmentType defines the type of appointment
type AppointmentType string

const (
	AppointmentTypeLeadVisit  AppointmentType = "lead_visit"
	AppointmentTypeStandalone AppointmentType = "standalone"
	AppointmentTypeBlocked    AppointmentType = "blocked"
)

// AppointmentStatus defines the status of an appointment
type AppointmentStatus string

const (
	AppointmentStatusScheduled AppointmentStatus = "scheduled"
	AppointmentStatusRequested AppointmentStatus = "requested"
	AppointmentStatusCompleted AppointmentStatus = "completed"
	AppointmentStatusCancelled AppointmentStatus = "cancelled"
	AppointmentStatusNoShow    AppointmentStatus = "no_show"
)

// AccessDifficulty defines accessibility difficulty for visit reports
type AccessDifficulty string

const (
	AccessDifficultyLow    AccessDifficulty = "Low"
	AccessDifficultyMedium AccessDifficulty = "Medium"
	AccessDifficultyHigh   AccessDifficulty = "High"
)

// CreateAppointmentRequest is the request body for creating an appointment
type CreateAppointmentRequest struct {
	LeadID                *uuid.UUID      `json:"leadId,omitempty"`
	LeadServiceID         *uuid.UUID      `json:"leadServiceId,omitempty"`
	Type                  AppointmentType `json:"type" validate:"required,oneof=lead_visit standalone blocked"`
	Title                 string          `json:"title" validate:"required,min=1,max=200"`
	Description           string          `json:"description,omitempty" validate:"max=2000"`
	Location              string          `json:"location,omitempty" validate:"max=500"`
	MeetingLink           string          `json:"meetingLink,omitempty" validate:"max=500"`
	StartTime             time.Time       `json:"startTime" validate:"required"`
	EndTime               time.Time       `json:"endTime" validate:"required,gtfield=StartTime"`
	AllDay                bool            `json:"allDay"`
	SendConfirmationEmail *bool           `json:"sendConfirmationEmail,omitempty"` // If true, sends confirmation email to lead
}

// UpdateAppointmentRequest is the request body for updating an appointment
type UpdateAppointmentRequest struct {
	Title       *string    `json:"title,omitempty" validate:"omitempty,min=1,max=200"`
	Description *string    `json:"description,omitempty" validate:"omitempty,max=2000"`
	Location    *string    `json:"location,omitempty" validate:"omitempty,max=500"`
	MeetingLink *string    `json:"meetingLink,omitempty" validate:"omitempty,max=500"`
	StartTime   *time.Time `json:"startTime,omitempty"`
	EndTime     *time.Time `json:"endTime,omitempty"`
	AllDay      *bool      `json:"allDay,omitempty"`
}

// UpdateAppointmentStatusRequest is the request body for updating appointment status
type UpdateAppointmentStatusRequest struct {
	Status AppointmentStatus `json:"status" validate:"required,oneof=scheduled requested completed cancelled no_show"`
}

// ListAppointmentsRequest is the query parameters for listing RAC_appointments
type ListAppointmentsRequest struct {
	UserID    string             `form:"userId"`
	LeadID    string             `form:"leadId"`
	Type      *AppointmentType   `form:"type" validate:"omitempty,oneof=lead_visit standalone blocked"`
	Status    *AppointmentStatus `form:"status" validate:"omitempty,oneof=scheduled requested completed cancelled no_show"`
	StartFrom string             `form:"startFrom"` // ISO date
	StartTo   string             `form:"startTo"`   // ISO date
	Search    string             `form:"search"`    // Search term for title/location/meeting link
	SortBy    string             `form:"sortBy" validate:"omitempty,oneof=title type status startTime endTime createdAt"`
	SortOrder string             `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
	Page      int                `form:"page" validate:"omitempty,min=1"`
	PageSize  int                `form:"pageSize" validate:"omitempty,min=1,max=100"`
}

// AppointmentResponse is the response body for an appointment
type AppointmentResponse struct {
	ID            uuid.UUID         `json:"id"`
	UserID        uuid.UUID         `json:"userId"`
	LeadID        *uuid.UUID        `json:"leadId,omitempty"`
	LeadServiceID *uuid.UUID        `json:"leadServiceId,omitempty"`
	Type          AppointmentType   `json:"type"`
	Title         string            `json:"title"`
	Description   *string           `json:"description,omitempty"`
	Location      *string           `json:"location,omitempty"`
	MeetingLink   *string           `json:"meetingLink,omitempty"`
	StartTime     time.Time         `json:"startTime"`
	EndTime       time.Time         `json:"endTime"`
	Status        AppointmentStatus `json:"status"`
	AllDay        bool              `json:"allDay"`
	CreatedAt     time.Time         `json:"createdAt"`
	UpdatedAt     time.Time         `json:"updatedAt"`
	// Embedded lead info for lead_visit type (populated by service)
	Lead *AppointmentLeadInfo `json:"lead,omitempty"`
}

// AppointmentLeadInfo is embedded lead info for appointment responses
type AppointmentLeadInfo struct {
	ID        uuid.UUID `json:"id"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Phone     string    `json:"phone"`
	Address   string    `json:"address"`
}

// AppointmentListResponse is the paginated response for listing RAC_appointments
type AppointmentListResponse struct {
	Items      []AppointmentResponse `json:"items"`
	Total      int                   `json:"total"`
	Page       int                   `json:"page"`
	PageSize   int                   `json:"pageSize"`
	TotalPages int                   `json:"totalPages"`
}

// Visit report DTOs
type UpsertVisitReportRequest struct {
	Measurements     *string           `json:"measurements,omitempty" validate:"omitempty,max=5000"`
	AccessDifficulty *AccessDifficulty `json:"accessDifficulty,omitempty" validate:"omitempty,oneof=Low Medium High"`
	Notes            *string           `json:"notes,omitempty" validate:"omitempty,max=5000"`
}

type AppointmentVisitReportResponse struct {
	AppointmentID    uuid.UUID         `json:"appointmentId"`
	Measurements     *string           `json:"measurements,omitempty"`
	AccessDifficulty *AccessDifficulty `json:"accessDifficulty,omitempty"`
	Notes            *string           `json:"notes,omitempty"`
	CreatedAt        time.Time         `json:"createdAt"`
	UpdatedAt        time.Time         `json:"updatedAt"`
}

// Attachment DTOs
type CreateAppointmentAttachmentRequest struct {
	FileKey     string  `json:"fileKey" validate:"required,min=1,max=500"`
	FileName    string  `json:"fileName" validate:"required,min=1,max=255"`
	ContentType *string `json:"contentType,omitempty" validate:"omitempty,max=200"`
	SizeBytes   *int64  `json:"sizeBytes,omitempty" validate:"omitempty,min=0"`
}

type AppointmentAttachmentResponse struct {
	ID            uuid.UUID `json:"id"`
	AppointmentID uuid.UUID `json:"appointmentId"`
	FileKey       string    `json:"fileKey"`
	FileName      string    `json:"fileName"`
	ContentType   *string   `json:"contentType,omitempty"`
	SizeBytes     *int64    `json:"sizeBytes,omitempty"`
	CreatedAt     time.Time `json:"createdAt"`
}

// Availability DTOs
type CreateAvailabilityRuleRequest struct {
	UserID    *uuid.UUID `json:"userId,omitempty"`
	Weekday   int        `json:"weekday" validate:"min=0,max=6"`
	StartTime string     `json:"startTime" validate:"required"`
	EndTime   string     `json:"endTime" validate:"required"`
	Timezone  string     `json:"timezone,omitempty" validate:"omitempty,max=100"`
}

type UpdateAvailabilityRuleRequest struct {
	Weekday   *int    `json:"weekday,omitempty" validate:"omitempty,min=0,max=6"`
	StartTime *string `json:"startTime,omitempty"`
	EndTime   *string `json:"endTime,omitempty"`
	Timezone  *string `json:"timezone,omitempty" validate:"omitempty,max=100"`
}

type AvailabilityRuleResponse struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"userId"`
	Weekday   int       `json:"weekday"`
	StartTime string    `json:"startTime"`
	EndTime   string    `json:"endTime"`
	Timezone  string    `json:"timezone"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type CreateAvailabilityOverrideRequest struct {
	UserID      *uuid.UUID `json:"userId,omitempty"`
	Date        string     `json:"date" validate:"required"`
	IsAvailable bool       `json:"isAvailable"`
	StartTime   *string    `json:"startTime,omitempty"`
	EndTime     *string    `json:"endTime,omitempty"`
	Timezone    string     `json:"timezone,omitempty" validate:"omitempty,max=100"`
}

type UpdateAvailabilityOverrideRequest struct {
	Date        *string `json:"date,omitempty"`
	IsAvailable *bool   `json:"isAvailable,omitempty"`
	StartTime   *string `json:"startTime,omitempty"`
	EndTime     *string `json:"endTime,omitempty"`
	Timezone    *string `json:"timezone,omitempty" validate:"omitempty,max=100"`
}

type AvailabilityOverrideResponse struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"userId"`
	Date        string    `json:"date"`
	IsAvailable bool      `json:"isAvailable"`
	StartTime   *string   `json:"startTime,omitempty"`
	EndTime     *string   `json:"endTime,omitempty"`
	Timezone    string    `json:"timezone"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// GetAvailableSlotsRequest is the query parameters for getting available slots
type GetAvailableSlotsRequest struct {
	UserID       string `form:"userId"`
	StartDate    string `form:"startDate" validate:"required"` // ISO date YYYY-MM-DD
	EndDate      string `form:"endDate" validate:"required"`   // ISO date YYYY-MM-DD
	SlotDuration int    `form:"slotDuration"`                  // Duration in minutes (default: 60)
}

// TimeSlot represents a single available time slot
type TimeSlot struct {
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
}

// DaySlots represents available slots for a specific day
type DaySlots struct {
	Date  string     `json:"date"` // ISO date YYYY-MM-DD
	Slots []TimeSlot `json:"slots"`
}

// AvailableSlotsResponse is the response for available slots query
type AvailableSlotsResponse struct {
	Days []DaySlots `json:"days"`
}
</file>

<file path="internal/auth/handler/handler.go">
package handler

import (
	"net/http"
	"time"

	"portal_final_backend/internal/auth/service"
	"portal_final_backend/internal/auth/transport"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Handler struct {
	svc *service.Service
	cfg config.CookieConfig
	val *validator.Validator
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

func New(svc *service.Service, cfg config.CookieConfig, val *validator.Validator) *Handler {
	return &Handler{svc: svc, cfg: cfg, val: val}
}

func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.POST("/sign-up", h.SignUp)
	rg.POST("/sign-in", h.SignIn)
	rg.POST("/refresh", h.Refresh)
	rg.POST("/sign-out", h.SignOut)
	rg.POST("/forgot-password", h.ForgotPassword)
	rg.POST("/reset-password", h.ResetPassword)
	rg.POST("/verify-email", h.VerifyEmail)
	rg.GET("/invites/resolve", h.ResolveInvite)
}

func (h *Handler) ListUsers(c *gin.Context) {
	users, err := h.svc.ListUsers(c.Request.Context())
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, users)
}

func (h *Handler) GetMe(c *gin.Context) {
	id := httpkit.MustGetIdentity(c)
	if id == nil {
		return
	}

	profile, err := h.svc.GetMe(c.Request.Context(), id.UserID())
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.ProfileResponse{
		ID:              profile.ID.String(),
		Email:           profile.Email,
		EmailVerified:   profile.EmailVerified,
		FirstName:       profile.FirstName,
		LastName:        profile.LastName,
		PreferredLang:   profile.PreferredLang,
		Roles:           profile.Roles,
		HasOrganization: profile.HasOrganization,
		CreatedAt:       profile.CreatedAt,
		UpdatedAt:       profile.UpdatedAt,
	})
}

func (h *Handler) UpdateMe(c *gin.Context) {
	id := httpkit.MustGetIdentity(c)
	if id == nil {
		return
	}

	var req transport.UpdateProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	profile, err := h.svc.UpdateMe(c.Request.Context(), id.UserID(), req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.ProfileResponse{
		ID:              profile.ID.String(),
		Email:           profile.Email,
		EmailVerified:   profile.EmailVerified,
		FirstName:       profile.FirstName,
		LastName:        profile.LastName,
		PreferredLang:   profile.PreferredLang,
		Roles:           profile.Roles,
		HasOrganization: profile.HasOrganization,
		CreatedAt:       profile.CreatedAt,
		UpdatedAt:       profile.UpdatedAt,
	})
}

func (h *Handler) CompleteOnboarding(c *gin.Context) {
	id := httpkit.MustGetIdentity(c)
	if id == nil {
		return
	}

	var req transport.CompleteOnboardingRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.CompleteOnboarding(c.Request.Context(), id.UserID(), req)) {
		return
	}

	httpkit.OK(c, gin.H{"message": "onboarding complete"})
}

func (h *Handler) ChangePassword(c *gin.Context) {
	id := httpkit.MustGetIdentity(c)
	if id == nil {
		return
	}

	var req transport.ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.ChangePassword(c.Request.Context(), id.UserID(), req.CurrentPassword, req.NewPassword)) {
		return
	}

	httpkit.OK(c, gin.H{"message": "password updated"})
}

func (h *Handler) SignUp(c *gin.Context) {
	var req transport.SignUpRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.SignUp(c.Request.Context(), req.Email, req.Password, req.OrganizationName, req.InviteToken)) {
		return
	}
	httpkit.JSON(c, http.StatusCreated, gin.H{"message": "account created"})
}

func (h *Handler) SignIn(c *gin.Context) {
	var req transport.SignInRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	accessToken, refreshToken, err := h.svc.SignIn(c.Request.Context(), req.Email, req.Password)
	if httpkit.HandleError(c, err) {
		return
	}

	h.setRefreshCookie(c, refreshToken)
	httpkit.OK(c, transport.AuthResponse{AccessToken: accessToken})
}

func (h *Handler) Refresh(c *gin.Context) {
	refreshToken, err := c.Cookie(h.cfg.GetRefreshCookieName())
	if err != nil || refreshToken == "" {
		httpkit.Error(c, http.StatusUnauthorized, "token invalid", nil)
		return
	}

	accessToken, newRefreshToken, err := h.svc.Refresh(c.Request.Context(), refreshToken)
	if httpkit.HandleError(c, err) {
		h.clearRefreshCookie(c)
		return
	}

	h.setRefreshCookie(c, newRefreshToken)
	httpkit.OK(c, transport.AuthResponse{AccessToken: accessToken})
}

func (h *Handler) SignOut(c *gin.Context) {
	if refreshToken, err := c.Cookie(h.cfg.GetRefreshCookieName()); err == nil && refreshToken != "" {
		if httpkit.HandleError(c, h.svc.SignOut(c.Request.Context(), refreshToken)) {
			return
		}
	}

	h.clearRefreshCookie(c)

	httpkit.OK(c, gin.H{"message": "signed out"})
}

func (h *Handler) ForgotPassword(c *gin.Context) {
	var req transport.ForgotPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.ForgotPassword(c.Request.Context(), req.Email)) {
		return
	}
	httpkit.OK(c, gin.H{"message": "if the account exists, a reset link will be sent"})
}

func (h *Handler) ResetPassword(c *gin.Context) {
	var req transport.ResetPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.ResetPassword(c.Request.Context(), req.Token, req.NewPassword)) {
		return
	}

	httpkit.OK(c, gin.H{"message": "password reset"})
}

func (h *Handler) VerifyEmail(c *gin.Context) {
	var req transport.VerifyEmailRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.VerifyEmail(c.Request.Context(), req.Token)) {
		return
	}

	httpkit.OK(c, gin.H{"message": "email verified"})
}

func (h *Handler) ResolveInvite(c *gin.Context) {
	tokenValue := c.Query("token")
	if tokenValue == "" {
		httpkit.Error(c, http.StatusBadRequest, "token is required", nil)
		return
	}

	resp, err := h.svc.ResolveInvite(c.Request.Context(), tokenValue)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, resp)
}

func (h *Handler) SetUserRoles(c *gin.Context) {
	userID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.RoleUpdateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if httpkit.HandleError(c, h.svc.SetUserRoles(c.Request.Context(), userID, req.Roles)) {
		return
	}

	httpkit.OK(c, transport.RoleUpdateResponse{UserID: userID.String(), Roles: req.Roles})
}

func (h *Handler) setRefreshCookie(c *gin.Context, value string) {
	maxAge := int(h.cfg.GetRefreshTokenTTL() / time.Second)
	c.SetSameSite(h.cfg.GetRefreshCookieSameSite())
	c.SetCookie(
		h.cfg.GetRefreshCookieName(),
		value,
		maxAge,
		h.cfg.GetRefreshCookiePath(),
		h.cfg.GetRefreshCookieDomain(),
		h.cfg.GetRefreshCookieSecure(),
		true,
	)
}

func (h *Handler) clearRefreshCookie(c *gin.Context) {
	c.SetSameSite(h.cfg.GetRefreshCookieSameSite())
	c.SetCookie(
		h.cfg.GetRefreshCookieName(),
		"",
		-1,
		h.cfg.GetRefreshCookiePath(),
		h.cfg.GetRefreshCookieDomain(),
		h.cfg.GetRefreshCookieSecure(),
		true,
	)
}
</file>

<file path="internal/auth/service/service.go">
package service

import (
	"context"
	"errors"
	"strings"
	"time"

	"portal_final_backend/internal/auth/password"
	"portal_final_backend/internal/auth/repository"
	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/auth/transport"
	"portal_final_backend/internal/events"
	identityrepo "portal_final_backend/internal/identity/repository"
	identityservice "portal_final_backend/internal/identity/service"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

const (
	accessTokenType     = "access"
	refreshTokenType    = "refresh"
	defaultUserRole     = "user" // Default role for new RAC_users (not admin)
	defaultAdminRole    = "admin"
	tokenInvalidMessage = "token invalid"
	tokenExpiredMessage = "token expired"
)

type Service struct {
	repo     *repository.Repository
	identity *identityservice.Service
	cfg      config.AuthServiceConfig
	eventBus events.Bus
	log      *logger.Logger
}

type Profile struct {
	ID              uuid.UUID
	Email           string
	EmailVerified   bool
	FirstName       *string
	LastName        *string
	PreferredLang   string
	Roles           []string
	HasOrganization bool
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func New(repo *repository.Repository, identity *identityservice.Service, cfg config.AuthServiceConfig, eventBus events.Bus, log *logger.Logger) *Service {
	return &Service{repo: repo, identity: identity, cfg: cfg, eventBus: eventBus, log: log}
}

func (s *Service) SignUp(ctx context.Context, email, plainPassword string, organizationName *string, inviteToken *string) error {
	hash, err := password.Hash(plainPassword)
	if err != nil {
		s.log.Error("failed to hash password", "error", err)
		return err
	}

	trimmedInvite, usingInvite := normalizeInviteToken(inviteToken)

	tx, err := s.repo.BeginTx(ctx)
	if err != nil {
		return err
	}
	committed := false
	defer func() {
		if !committed {
			_ = tx.Rollback(ctx)
		}
	}()

	user, err := s.repo.CreateUserTx(ctx, tx, email, hash)
	if err != nil {
		s.log.Error("failed to create user", "email", email, "error", err)
		return err
	}

	roles := rolesForSignup(usingInvite)
	if err := s.repo.SetUserRolesTx(ctx, tx, user.ID, roles); err != nil {
		s.log.Error("failed to set user RAC_roles", "user_id", user.ID, "error", err)
		return err
	}

	if usingInvite {
		if err := s.applyInvite(ctx, tx, trimmedInvite, email, user.ID); err != nil {
			return err
		}
	}
	// Note: Organization is NOT created here for non-invite RAC_users.
	// It will be created during onboarding when the user provides an organization name.

	if err = tx.Commit(ctx); err != nil {
		return err
	}
	committed = true

	s.log.AuthEvent("signup", email, true, "")

	verifyToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return err
	}

	verifyHash := token.HashSHA256(verifyToken)
	expiresAt := time.Now().Add(s.cfg.GetVerifyTokenTTL())
	if err := s.repo.CreateUserToken(ctx, user.ID, verifyHash, repository.TokenTypeEmailVerify, expiresAt); err != nil {
		return err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.UserSignedUp{
		BaseEvent:   events.NewBaseEvent(),
		UserID:      user.ID,
		Email:       user.Email,
		VerifyToken: verifyToken,
	})

	return nil
}

func normalizeInviteToken(inviteToken *string) (string, bool) {
	if inviteToken == nil {
		return "", false
	}
	trimmed := strings.TrimSpace(*inviteToken)
	return trimmed, trimmed != ""
}

func rolesForSignup(usingInvite bool) []string {
	if usingInvite {
		return []string{defaultUserRole}
	}
	return []string{defaultAdminRole}
}

func (s *Service) applyInvite(ctx context.Context, tx pgx.Tx, tokenValue, email string, userID uuid.UUID) error {
	invite, err := s.identity.ResolveInvite(ctx, tokenValue)
	if err != nil {
		return err
	}
	if !strings.EqualFold(invite.Email, email) {
		return apperr.Forbidden("invite does not match email")
	}
	if err := s.identity.AddMember(ctx, tx, invite.OrganizationID, userID); err != nil {
		return err
	}
	if err := s.identity.UseInvite(ctx, tx, invite.ID, userID); err != nil {
		return err
	}
	return nil
}

func (s *Service) SignIn(ctx context.Context, email, plainPassword string) (string, string, error) {
	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		return "", "", apperr.Unauthorized("invalid credentials")
	}

	if err := password.Compare(user.PasswordHash, plainPassword); err != nil {
		return "", "", apperr.Unauthorized("invalid credentials")
	}

	if !user.EmailVerified {
		return "", "", apperr.Forbidden("email not verified")
	}

	return s.issueTokens(ctx, user.ID)
}

func (s *Service) Refresh(ctx context.Context, refreshToken string) (string, string, error) {
	hash := token.HashSHA256(refreshToken)
	userID, expiresAt, err := s.repo.GetRefreshToken(ctx, hash)
	if err != nil {
		return "", "", apperr.Unauthorized(tokenInvalidMessage)
	}

	if time.Now().After(expiresAt) {
		_ = s.repo.RevokeRefreshToken(ctx, hash)
		return "", "", apperr.Unauthorized(tokenExpiredMessage)
	}

	_ = s.repo.RevokeRefreshToken(ctx, hash)
	return s.issueTokens(ctx, userID)
}

func (s *Service) SignOut(ctx context.Context, refreshToken string) error {
	hash := token.HashSHA256(refreshToken)
	return s.repo.RevokeRefreshToken(ctx, hash)
}

func (s *Service) ForgotPassword(ctx context.Context, email string) error {
	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		return nil
	}

	resetToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return err
	}

	resetHash := token.HashSHA256(resetToken)
	expiresAt := time.Now().Add(s.cfg.GetResetTokenTTL())
	if err := s.repo.CreateUserToken(ctx, user.ID, resetHash, repository.TokenTypePasswordReset, expiresAt); err != nil {
		return err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.PasswordResetRequested{
		BaseEvent:  events.NewBaseEvent(),
		UserID:     user.ID,
		Email:      user.Email,
		ResetToken: resetToken,
	})

	return nil
}

func (s *Service) ResetPassword(ctx context.Context, rawToken, newPassword string) error {
	hash := token.HashSHA256(rawToken)
	userID, expiresAt, err := s.repo.GetUserToken(ctx, hash, repository.TokenTypePasswordReset)
	if err != nil {
		return apperr.Unauthorized(tokenInvalidMessage)
	}

	if time.Now().After(expiresAt) {
		return apperr.Unauthorized(tokenExpiredMessage)
	}

	passwordHash, err := password.Hash(newPassword)
	if err != nil {
		return err
	}

	if err := s.repo.UpdatePassword(ctx, userID, passwordHash); err != nil {
		return err
	}

	_ = s.repo.UseUserToken(ctx, hash, repository.TokenTypePasswordReset)
	_ = s.repo.RevokeAllRefreshTokens(ctx, userID)

	return nil
}

func (s *Service) VerifyEmail(ctx context.Context, rawToken string) error {
	hash := token.HashSHA256(rawToken)
	userID, expiresAt, err := s.repo.GetUserToken(ctx, hash, repository.TokenTypeEmailVerify)
	if err != nil {
		return apperr.Unauthorized(tokenInvalidMessage)
	}

	if time.Now().After(expiresAt) {
		return apperr.Unauthorized(tokenExpiredMessage)
	}

	if err := s.repo.MarkEmailVerified(ctx, userID); err != nil {
		return err
	}

	_ = s.repo.UseUserToken(ctx, hash, repository.TokenTypeEmailVerify)
	return nil
}

func (s *Service) issueTokens(ctx context.Context, userID uuid.UUID) (string, string, error) {
	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return "", "", err
	}

	var tenantID *uuid.UUID
	orgID, err := s.identity.GetUserOrganizationID(ctx, userID)
	if err != nil {
		if errors.Is(err, identityrepo.ErrNotFound) {
			tenantID = nil
		} else {
			return "", "", err
		}
	} else {
		tenantID = &orgID
	}

	accessToken, err := s.signJWT(userID, tenantID, roles, s.cfg.GetAccessTokenTTL(), accessTokenType, s.cfg.GetJWTAccessSecret())
	if err != nil {
		return "", "", err
	}

	refreshToken, err := token.GenerateRandomToken(48)
	if err != nil {
		return "", "", err
	}

	hash := token.HashSHA256(refreshToken)
	expiresAt := time.Now().Add(s.cfg.GetRefreshTokenTTL())
	if err := s.repo.CreateRefreshToken(ctx, userID, hash, expiresAt); err != nil {
		return "", "", err
	}

	return accessToken, refreshToken, nil
}

func (s *Service) signJWT(userID uuid.UUID, tenantID *uuid.UUID, roles []string, ttl time.Duration, tokenType, secret string) (string, error) {
	claims := jwt.MapClaims{
		"sub":   userID.String(),
		"type":  tokenType,
		"roles": roles,
		"exp":   time.Now().Add(ttl).Unix(),
		"iat":   time.Now().Unix(),
	}
	if tenantID != nil {
		claims["tenant_id"] = tenantID.String()
	}

	tokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return tokenObj.SignedString([]byte(secret))
}

func (s *Service) SetUserRoles(ctx context.Context, userID uuid.UUID, roles []string) error {
	return s.repo.SetUserRoles(ctx, userID, roles)
}

func (s *Service) ListUsers(ctx context.Context) ([]transport.UserSummary, error) {
	users, err := s.repo.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]transport.UserSummary, 0, len(users))
	for _, user := range users {
		result = append(result, transport.UserSummary{
			ID:        user.ID.String(),
			Email:     user.Email,
			FirstName: user.FirstName,
			LastName:  user.LastName,
			Roles:     user.Roles,
		})
	}

	return result, nil
}

func (s *Service) GetMe(ctx context.Context, userID uuid.UUID) (Profile, error) {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return Profile{}, apperr.Unauthorized("invalid credentials")
		}
		return Profile{}, err
	}

	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	if err := s.repo.EnsureUserSettings(ctx, userID); err != nil {
		return Profile{}, err
	}

	preferredLang, err := s.repo.GetUserSettings(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	// Check if user belongs to an organization
	_, orgErr := s.identity.GetUserOrganizationID(ctx, userID)
	hasOrganization := orgErr == nil

	return Profile{
		ID:              user.ID,
		Email:           user.Email,
		EmailVerified:   user.EmailVerified,
		FirstName:       user.FirstName,
		LastName:        user.LastName,
		PreferredLang:   preferredLang,
		Roles:           roles,
		HasOrganization: hasOrganization,
		CreatedAt:       user.CreatedAt,
		UpdatedAt:       user.UpdatedAt,
	}, nil
}

func (s *Service) UpdateMe(ctx context.Context, userID uuid.UUID, req transport.UpdateProfileRequest) (Profile, error) {
	current, roles, preferredLang, err := s.loadProfileContext(ctx, userID)
	if err != nil {
		return Profile{}, err
	}

	updatedUser, err := s.applyNameUpdates(ctx, userID, current, req)
	if err != nil {
		return Profile{}, err
	}

	preferredLang, err = s.applyPreferredLanguage(ctx, userID, preferredLang, req)
	if err != nil {
		return Profile{}, err
	}

	updatedUser, err = s.applyEmailUpdate(ctx, userID, current.Email, updatedUser, req)
	if err != nil {
		return Profile{}, err
	}

	return s.buildProfile(updatedUser, roles, preferredLang), nil
}

func (s *Service) loadProfileContext(ctx context.Context, userID uuid.UUID) (repository.User, []string, string, error) {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return repository.User{}, nil, "", err
	}

	roles, err := s.repo.GetUserRoles(ctx, userID)
	if err != nil {
		return repository.User{}, nil, "", err
	}

	if err := s.repo.EnsureUserSettings(ctx, userID); err != nil {
		return repository.User{}, nil, "", err
	}

	preferredLang, err := s.repo.GetUserSettings(ctx, userID)
	if err != nil {
		return repository.User{}, nil, "", err
	}

	return user, roles, preferredLang, nil
}

func (s *Service) applyNameUpdates(ctx context.Context, userID uuid.UUID, current repository.User, req transport.UpdateProfileRequest) (repository.User, error) {
	if req.FirstName == nil && req.LastName == nil {
		return current, nil
	}

	return s.repo.UpdateUserNames(ctx, userID, req.FirstName, req.LastName)
}

func (s *Service) applyPreferredLanguage(ctx context.Context, userID uuid.UUID, currentLang string, req transport.UpdateProfileRequest) (string, error) {
	if req.PreferredLanguage == nil {
		return currentLang, nil
	}

	preferredLang := strings.TrimSpace(*req.PreferredLanguage)
	if err := s.repo.UpdateUserSettings(ctx, userID, preferredLang); err != nil {
		return currentLang, err
	}

	return preferredLang, nil
}

func (s *Service) applyEmailUpdate(ctx context.Context, userID uuid.UUID, currentEmail string, updatedUser repository.User, req transport.UpdateProfileRequest) (repository.User, error) {
	if req.Email == nil || strings.EqualFold(strings.TrimSpace(*req.Email), currentEmail) {
		return updatedUser, nil
	}

	newEmail := strings.TrimSpace(*req.Email)
	if existing, err := s.repo.GetUserByEmail(ctx, newEmail); err == nil && existing.ID != userID {
		return repository.User{}, apperr.Conflict("email already in use")
	} else if err != nil && err != repository.ErrNotFound {
		return repository.User{}, err
	}

	updated, err := s.repo.UpdateUserEmail(ctx, userID, newEmail)
	if err != nil {
		return repository.User{}, err
	}

	if err := s.enqueueEmailVerification(ctx, userID, updated.Email); err != nil {
		return repository.User{}, err
	}

	return updated, nil
}

func (s *Service) enqueueEmailVerification(ctx context.Context, userID uuid.UUID, email string) error {
	verifyToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return err
	}

	verifyHash := token.HashSHA256(verifyToken)
	expiresAt := time.Now().Add(s.cfg.GetVerifyTokenTTL())
	if err := s.repo.CreateUserToken(ctx, userID, verifyHash, repository.TokenTypeEmailVerify, expiresAt); err != nil {
		return err
	}

	// Publish event - notification module handles email sending
	s.eventBus.Publish(ctx, events.EmailVerificationRequested{
		BaseEvent:   events.NewBaseEvent(),
		UserID:      userID,
		Email:       email,
		VerifyToken: verifyToken,
	})

	return nil
}

func (s *Service) buildProfile(user repository.User, roles []string, preferredLang string) Profile {
	return Profile{
		ID:            user.ID,
		Email:         user.Email,
		EmailVerified: user.EmailVerified,
		FirstName:     user.FirstName,
		LastName:      user.LastName,
		PreferredLang: preferredLang,
		Roles:         roles,
		CreatedAt:     user.CreatedAt,
		UpdatedAt:     user.UpdatedAt,
	}
}

func (s *Service) ChangePassword(ctx context.Context, userID uuid.UUID, currentPassword, newPassword string) error {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return err
	}

	if err := password.Compare(user.PasswordHash, currentPassword); err != nil {
		return apperr.Validation("current password is incorrect")
	}

	passwordHash, err := password.Hash(newPassword)
	if err != nil {
		return err
	}

	if err := s.repo.UpdatePassword(ctx, userID, passwordHash); err != nil {
		return err
	}

	_ = s.repo.RevokeAllRefreshTokens(ctx, userID)
	return nil
}

func (s *Service) ResolveInvite(ctx context.Context, rawToken string) (transport.ResolveInviteResponse, error) {
	invite, err := s.identity.ResolveInvite(ctx, rawToken)
	if err != nil {
		return transport.ResolveInviteResponse{}, err
	}

	org, err := s.identity.GetOrganization(ctx, invite.OrganizationID)
	if err != nil {
		return transport.ResolveInviteResponse{}, err
	}

	return transport.ResolveInviteResponse{
		Email:            invite.Email,
		OrganizationName: org.Name,
	}, nil
}

func (s *Service) CompleteOnboarding(ctx context.Context, userID uuid.UUID, req transport.CompleteOnboardingRequest) error {
	// Update user profile
	_, err := s.repo.UpdateUserNames(ctx, userID, &req.FirstName, &req.LastName)
	if err != nil {
		return err
	}

	// Check if user already has an organization
	_, orgErr := s.identity.GetUserOrganizationID(ctx, userID)
	hasOrganization := orgErr == nil

	// If user doesn't have an organization, create one
	if !hasOrganization {
		if req.OrganizationName == nil || strings.TrimSpace(*req.OrganizationName) == "" {
			return apperr.Validation("organization name is required")
		}
		if req.OrganizationEmail == nil || strings.TrimSpace(*req.OrganizationEmail) == "" {
			return apperr.Validation("organization email is required")
		}
		if req.OrganizationPhone == nil || strings.TrimSpace(*req.OrganizationPhone) == "" {
			return apperr.Validation("organization phone is required")
		}

		orgName := strings.TrimSpace(*req.OrganizationName)
		orgID, err := s.identity.CreateOrganizationForUser(ctx, nil, orgName, userID)
		if err != nil {
			return err
		}

		if err := s.identity.AddMember(ctx, nil, orgID, userID); err != nil {
			return err
		}

		if hasOrganizationProfileUpdate(req) {
			_, err = s.identity.UpdateOrganizationProfile(ctx, orgID, identityservice.OrganizationProfileUpdate{
				Email:        req.OrganizationEmail,
				Phone:        req.OrganizationPhone,
				VATNumber:    req.VatNumber,
				KVKNumber:    req.KvkNumber,
				AddressLine1: req.AddressLine1,
				AddressLine2: req.AddressLine2,
				PostalCode:   req.PostalCode,
				City:         req.City,
				Country:      req.Country,
			})
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func hasOrganizationProfileUpdate(req transport.CompleteOnboardingRequest) bool {
	return hasOptionalValue(req.OrganizationEmail) ||
		hasOptionalValue(req.OrganizationPhone) ||
		hasOptionalValue(req.VatNumber) ||
		hasOptionalValue(req.KvkNumber) ||
		hasOptionalValue(req.AddressLine1) ||
		hasOptionalValue(req.AddressLine2) ||
		hasOptionalValue(req.PostalCode) ||
		hasOptionalValue(req.City) ||
		hasOptionalValue(req.Country)
}

func hasOptionalValue(value *string) bool {
	if value == nil {
		return false
	}
	return strings.TrimSpace(*value) != ""
}
</file>

<file path="internal/auth/transport/dto.go">
package transport

import "time"

type SignUpRequest struct {
	Email            string  `json:"email" validate:"required,email"`
	Password         string  `json:"password" validate:"required,strongpassword"`
	OrganizationName *string `json:"organizationName" validate:"omitempty,max=120"`
	InviteToken      *string `json:"inviteToken" validate:"omitempty"`
}

type SignInRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

type ForgotPasswordRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type ResetPasswordRequest struct {
	Token       string `json:"token" validate:"required"`
	NewPassword string `json:"newPassword" validate:"required,strongpassword"`
}

type VerifyEmailRequest struct {
	Token string `json:"token" validate:"required"`
}

type ResolveInviteResponse struct {
	Email            string `json:"email"`
	OrganizationName string `json:"organizationName"`
}

type RoleUpdateRequest struct {
	Roles []string `json:"roles" validate:"required,min=1,dive,required"`
}

type RoleUpdateResponse struct {
	UserID string   `json:"userId"`
	Roles  []string `json:"roles"`
}

type AuthResponse struct {
	AccessToken string `json:"accessToken"`
}

type ProfileResponse struct {
	ID              string    `json:"id"`
	Email           string    `json:"email"`
	EmailVerified   bool      `json:"emailVerified"`
	FirstName       *string   `json:"firstName"`
	LastName        *string   `json:"lastName"`
	PreferredLang   string    `json:"preferredLanguage"`
	Roles           []string  `json:"roles"`
	HasOrganization bool      `json:"hasOrganization"`
	CreatedAt       time.Time `json:"createdAt"`
	UpdatedAt       time.Time `json:"updatedAt"`
}

type UpdateProfileRequest struct {
	Email             *string `json:"email" validate:"omitempty,email"`
	FirstName         *string `json:"firstName" validate:"omitempty,max=100"`
	LastName          *string `json:"lastName" validate:"omitempty,max=100"`
	PreferredLanguage *string `json:"preferredLanguage" validate:"omitempty,oneof=en nl"`
}

type ChangePasswordRequest struct {
	CurrentPassword string `json:"currentPassword" validate:"required"`
	NewPassword     string `json:"newPassword" validate:"required,strongpassword"`
}

type CompleteOnboardingRequest struct {
	FirstName          string  `json:"firstName" validate:"required,max=100"`
	LastName           string  `json:"lastName" validate:"required,max=100"`
	OrganizationName   *string `json:"organizationName" validate:"omitempty,max=120"`
	OrganizationEmail  *string `json:"organizationEmail" validate:"omitempty,email"`
	OrganizationPhone  *string `json:"organizationPhone" validate:"omitempty,max=50"`
	VatNumber          *string `json:"vatNumber" validate:"omitempty,max=20"`
	KvkNumber          *string `json:"kvkNumber" validate:"omitempty,max=20"`
	AddressLine1       *string `json:"addressLine1" validate:"omitempty,max=200"`
	AddressLine2       *string `json:"addressLine2" validate:"omitempty,max=200"`
	PostalCode         *string `json:"postalCode" validate:"omitempty,max=20"`
	City               *string `json:"city" validate:"omitempty,max=120"`
	Country            *string `json:"country" validate:"omitempty,max=120"`
}

type UserSummary struct {
	ID        string   `json:"id"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName"`
	LastName  *string  `json:"lastName"`
	Roles     []string `json:"roles"`
}
</file>

<file path="internal/catalog/handler/handler.go">
package handler

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"

	"portal_final_backend/internal/catalog/service"
	"portal_final_backend/internal/catalog/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"
)

// Handler handles HTTP requests for catalog.
type Handler struct {
	svc *service.Service
	val *validator.Validator
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
	msgInvalidID        = "invalid catalog id"
)

// New creates a new catalog handler.
func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

// ListVatRates retrieves VAT rates.
// GET /api/v1/catalog/vat-rates
func (h *Handler) ListVatRates(c *gin.Context) {
	var req transport.ListVatRatesRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListVatRatesWithFilters(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// GetVatRateByID retrieves a VAT rate by ID.
// GET /api/v1/catalog/vat-rates/:id
func (h *Handler) GetVatRateByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetVatRateByID(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// CreateVatRate creates a new VAT rate.
// POST /api/v1/admin/catalog/vat-rates
func (h *Handler) CreateVatRate(c *gin.Context) {
	var req transport.CreateVatRateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.CreateVatRate(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.JSON(c, http.StatusCreated, result)
}

// UpdateVatRate updates a VAT rate.
// PUT /api/v1/admin/catalog/vat-rates/:id
func (h *Handler) UpdateVatRate(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.UpdateVatRateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.UpdateVatRate(c.Request.Context(), tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// DeleteVatRate deletes a VAT rate.
// DELETE /api/v1/admin/catalog/vat-rates/:id
func (h *Handler) DeleteVatRate(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.DeleteVatRate(c.Request.Context(), tenantID, id); httpkit.HandleError(c, err) {
		return
	}
	c.Status(http.StatusNoContent)
}

// ListProducts retrieves catalog products.
// GET /api/v1/catalog/products
func (h *Handler) ListProducts(c *gin.Context) {
	var req transport.ListProductsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var vatRateID *uuid.UUID
	if req.VatRateID != "" {
		parsed, err := uuid.Parse(req.VatRateID)
		if err != nil {
			httpkit.Error(c, http.StatusBadRequest, "invalid vatRateId", nil)
			return
		}
		vatRateID = &parsed
	}

	result, err := h.svc.ListProductsWithFilters(c.Request.Context(), tenantID, req, vatRateID)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// GetProductByID retrieves a product by ID.
// GET /api/v1/catalog/products/:id
func (h *Handler) GetProductByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetProductByID(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// CreateProduct creates a product.
// POST /api/v1/admin/catalog/products
func (h *Handler) CreateProduct(c *gin.Context) {
	var req transport.CreateProductRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.CreateProduct(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.JSON(c, http.StatusCreated, result)
}

// UpdateProduct updates a product.
// PUT /api/v1/admin/catalog/products/:id
func (h *Handler) UpdateProduct(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.UpdateProductRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.UpdateProduct(c.Request.Context(), tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// DeleteProduct deletes a product.
// DELETE /api/v1/admin/catalog/products/:id
func (h *Handler) DeleteProduct(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.DeleteProduct(c.Request.Context(), tenantID, id); httpkit.HandleError(c, err) {
		return
	}
	c.Status(http.StatusNoContent)
}

// ListProductMaterials lists materials linked to a product.
// GET /api/v1/catalog/products/:id/materials
func (h *Handler) ListProductMaterials(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListProductMaterials(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// AddProductMaterials adds materials to a product.
// POST /api/v1/admin/catalog/products/:id/materials
func (h *Handler) AddProductMaterials(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.ProductMaterialsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.AddProductMaterials(c.Request.Context(), tenantID, id, req.MaterialIDs); httpkit.HandleError(c, err) {
		return
	}
	c.Status(http.StatusNoContent)
}

// RemoveProductMaterials removes materials from a product.
// DELETE /api/v1/admin/catalog/products/:id/materials
func (h *Handler) RemoveProductMaterials(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.ProductMaterialsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.RemoveProductMaterials(c.Request.Context(), tenantID, id, req.MaterialIDs); httpkit.HandleError(c, err) {
		return
	}
	c.Status(http.StatusNoContent)
}

// GetCatalogAssetPresign generates a presigned URL for uploading a catalog asset.
// POST /api/v1/admin/catalog/products/:id/assets/presign
func (h *Handler) GetCatalogAssetPresign(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.PresignCatalogAssetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.svc.GetCatalogAssetPresign(c.Request.Context(), tenantID, productID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// CreateCatalogAsset creates a catalog asset after upload to MinIO.
// POST /api/v1/admin/catalog/products/:id/assets
func (h *Handler) CreateCatalogAsset(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.CreateCatalogAssetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.svc.CreateCatalogAsset(c.Request.Context(), tenantID, productID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// CreateCatalogURLAsset creates a URL-based catalog asset (terms URL).
// POST /api/v1/admin/catalog/products/:id/assets/url
func (h *Handler) CreateCatalogURLAsset(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.CreateCatalogURLAssetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.svc.CreateCatalogURLAsset(c.Request.Context(), tenantID, productID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// ListCatalogAssets lists assets for a product.
// GET /api/v1/catalog/products/:id/assets
func (h *Handler) ListCatalogAssets(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var assetType *string
	if queryType := strings.TrimSpace(c.Query("type")); queryType != "" {
		assetType = &queryType
	}

	result, err := h.svc.ListCatalogAssets(c.Request.Context(), tenantID, productID, assetType)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// GetCatalogAssetDownloadURL returns a presigned download URL or external URL.
// GET /api/v1/catalog/products/:id/assets/:assetId/download
func (h *Handler) GetCatalogAssetDownloadURL(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	assetID, err := uuid.Parse(c.Param("assetId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.svc.GetCatalogAssetDownloadURL(c.Request.Context(), tenantID, productID, assetID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// DeleteCatalogAsset deletes a catalog asset and removes it from storage when applicable.
// DELETE /api/v1/admin/catalog/products/:id/assets/:assetId
func (h *Handler) DeleteCatalogAsset(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	productID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	assetID, err := uuid.Parse(c.Param("assetId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	if err := h.svc.DeleteCatalogAsset(c.Request.Context(), tenantID, productID, assetID); httpkit.HandleError(c, err) {
		return
	}

	c.Status(http.StatusNoContent)
}

// SearchProductsForAutocomplete handles GET /api/v1/catalog/products/search
// Lightweight search endpoint optimized for quote line autocomplete.
func (h *Handler) SearchProductsForAutocomplete(c *gin.Context) {
	var req transport.AutocompleteSearchRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.SearchForAutocomplete(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func mustGetTenantID(c *gin.Context, identity httpkit.Identity) (uuid.UUID, bool) {
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, "tenant ID is required", nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}
</file>

<file path="internal/email/subjects.go">
package email

const (
	subjectVerification                     = "Verifieer uw e-mailadres"
	subjectPasswordReset                    = "Wachtwoord opnieuw instellen"
	subjectVisitInvite                      = "Uw bezoek is ingepland"
	subjectOrganizationInviteFmt            = "U bent uitgenodigd voor %s"
	subjectPartnerInviteFmt                 = "Nieuw werkaanbod van %s"
	subjectQuoteProposalFmt                 = "Offerte %s van %s"
	subjectQuoteAcceptedFmt                 = "Offerte %s geaccepteerd"
	subjectQuoteAcceptedThankYouFmt         = "Bedankt voor uw akkoord  offerte %s"
	subjectPartnerOfferAcceptedFmt          = "Werkaanbod geaccepteerd door %s"
	subjectPartnerOfferAcceptedConfirmation = "Bevestiging: uw acceptatie is ontvangen"
	subjectPartnerOfferRejectedFmt          = "Werkaanbod afgewezen door %s"
)
</file>

<file path="internal/email/templates.go">
package email

import (
	"bytes"
	"embed"
	"fmt"
	"html/template"
)

//go:embed templates/*.html
var templateFS embed.FS

type baseEmailData struct {
	Title      string
	Heading    string
	Subheading string
	CTALabel   string
	CTAURL     string
}

type verificationEmailData struct {
	baseEmailData
}

type passwordResetEmailData struct {
	baseEmailData
}

type visitInviteEmailData struct {
	baseEmailData
	ConsumerName  string
	ScheduledDate string
	Address       string
}

type organizationInviteEmailData struct {
	baseEmailData
	OrganizationName string
}

type partnerInviteEmailData struct {
	baseEmailData
	OrganizationName string
	PartnerName      string
}

type quoteProposalEmailData struct {
	baseEmailData
	ConsumerName     string
	OrganizationName string
	QuoteNumber      string
}

type quoteAcceptedEmailData struct {
	baseEmailData
	AgentName      string
	QuoteNumber    string
	ConsumerName   string
	TotalFormatted string
}

type quoteAcceptedThankYouEmailData struct {
	baseEmailData
	ConsumerName     string
	OrganizationName string
	QuoteNumber      string
	HasAttachments   bool
}

type partnerOfferAcceptedEmailData struct {
	baseEmailData
	PartnerName string
	OfferID     string
}

type partnerOfferAcceptedConfirmationEmailData struct {
	baseEmailData
	PartnerName string
}

type partnerOfferRejectedEmailData struct {
	baseEmailData
	PartnerName string
	OfferID     string
	Reason      string
}

func renderEmailTemplate(name string, data any) (string, error) {
	templates := []string{"templates/base.html", "templates/" + name}
	tmpl, err := template.New("base.html").ParseFS(templateFS, templates...)
	if err != nil {
		return "", fmt.Errorf("parse email template %s: %w", name, err)
	}

	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, "email", data); err != nil {
		return "", fmt.Errorf("execute email template %s: %w", name, err)
	}
	return buf.String(), nil
}

func formatCurrencyEUR(cents int64) string {
	return fmt.Sprintf("%.2f", float64(cents)/100)
}
</file>

<file path="internal/email/templates/base.html">
{{define "email"}}
<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>{{.Title}}</title>
  <style>
    body, table, td, a { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }
    table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }
    img { -ms-interpolation-mode: bicubic; border: 0; height: auto; outline: none; text-decoration: none; }
    table { border-collapse: collapse !important; }
    body {
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
      width: 100% !important;
      background-color: #f3f3f3;
      font-family: 'Arial Black', sans-serif;
    }

    .wrapper { width: 100%; background-color: #f3f3f3; padding: 40px 10px; }

    .main-card {
      background-color: #ffffff;
      border: 6px solid #000000;
      box-shadow: 14px 14px 0px 0px #000000;
    }

    .header-section {
      background-color: #00ffff;
      border-bottom: 6px solid #000000;
      padding: 30px;
    }

    .hero-text {
      font-size: 40px;
      line-height: 0.9;
      color: #000000;
      text-transform: uppercase;
      margin: 0;
      font-weight: 900;
    }

    .body-content {
      padding: 40px;
      color: #000000;
      line-height: 1.4;
      font-size: 18px;
      font-family: 'Helvetica', Arial, sans-serif;
      font-weight: bold;
    }

    .body-content p { margin: 0 0 16px; }
    .body-content p:last-child { margin-bottom: 0; }

    .button-brutal {
      background-color: #ff00ff;
      border: 4px solid #000000;
      color: #ffffff !important;
      display: inline-block;
      font-size: 18px;
      font-weight: 900;
      padding: 15px 25px;
      text-align: center;
      text-decoration: none;
      text-transform: uppercase;
      box-shadow: 6px 6px 0px 0px #000000;
    }

    .details-grid {
      border: 4px solid #000000;
      margin: 30px 0;
      background-color: #ffffff;
    }

    .detail-item {
      border-bottom: 4px solid #000000;
      padding: 15px;
    }

    .detail-item:last-child { border-bottom: none; }

    .label {
      font-family: monospace;
      font-size: 12px;
      text-transform: uppercase;
      background-color: #000;
      color: #fff;
      padding: 2px 6px;
    }

    .footer-text {
      padding: 20px;
      text-align: left;
      color: #000000;
      font-size: 12px;
      font-family: monospace;
      text-transform: uppercase;
    }

    @media screen and (max-width: 600px) {
      .container { width: 100% !important; }
      .hero-text { font-size: 30px !important; }
      .main-card { box-shadow: 8px 8px 0px 0px #000000 !important; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <!--[if (gte mso 9)|(IE)]>
    <table align="center" border="0" cellspacing="0" cellpadding="0" width="600">
    <tr>
    <td align="center" valign="top" width="600">
    <![endif]-->

    <table class="container" align="center" border="0" cellpadding="0" cellspacing="0" width="600">
      <tr>
        <td class="main-card">

          <table border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
              <td class="header-section">
                <h1 class="hero-text">{{.Heading}}</h1>
                {{if .Subheading}}
                <div style="margin-top: 15px; font-family: monospace; font-weight: bold; font-size: 16px;">
                  {{.Subheading}}
                </div>
                {{end}}
              </td>
            </tr>
          </table>

          <table border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
              <td class="body-content">
                {{template "content" .}}

                {{if and .CTAURL .CTALabel}}
                <table border="0" cellpadding="0" cellspacing="0" width="100%" style="margin: 30px 0;">
                  <tr>
                    <td>
                      <a href="{{.CTAURL}}" class="button-brutal">{{.CTALabel}}</a>
                    </td>
                  </tr>
                </table>
                <div style="font-family: monospace; font-size: 12px; text-transform: uppercase;">
                  Als de knop niet werkt, kopieer en plak dan deze link in uw browser:<br />
                  <a href="{{.CTAURL}}" style="color: #000; text-decoration: underline;">{{.CTAURL}}</a>
                </div>
                {{end}}
              </td>
            </tr>
          </table>
        </td>
      </tr>

      {{if and .CTAURL .CTALabel}}
      <tr>
        <td class="footer-text">
          Als de knop niet werkt, kopieer en plak dan deze link in uw browser:<br />
          <a href="{{.CTAURL}}" style="color: #000; text-decoration: underline;">{{.CTAURL}}</a>
        </td>
      </tr>
      {{end}}
    </table>

    <!--[if (gte mso 9)|(IE)]>
    </td>
    </tr>
    </table>
    <![endif]-->
  </div>
</body>
</html>
{{end}}
</file>

<file path="internal/email/templates/organization_invite.html">
{{define "content"}}
<p>U bent uitgenodigd om lid te worden van {{.OrganizationName}}. Klik op de knop hieronder om de uitnodiging te accepteren en uw account aan te maken.</p>
{{end}}
</file>

<file path="internal/email/templates/partner_invite.html">
{{define "content"}}
<p>{{.OrganizationName}} heeft {{.PartnerName}} uitgenodigd voor een nieuw werkaanbod. Klik op de knop hieronder om de details te bekijken en te reageren.</p>
{{end}}
</file>

<file path="internal/email/templates/partner_offer_accepted.html">
{{define "content"}}
<p>{{.PartnerName}} heeft het werkaanbod (ID: {{.OfferID}}) geaccepteerd en beschikbaarheid doorgegeven.</p>
<p>Bekijk de details en plan de inspectie in via het portaal.</p>
{{end}}
</file>

<file path="internal/email/templates/partner_offer_confirmation.html">
{{define "content"}}
<p>Beste {{.PartnerName}},</p>
<p>Bedankt voor het accepteren van het werkaanbod. Uw beschikbaarheid is ontvangen en wij nemen zo snel mogelijk contact met u op om de inspectie in te plannen.</p>
<p>Met vriendelijke groet</p>
{{end}}
</file>

<file path="internal/email/templates/partner_offer_rejected.html">
{{define "content"}}
<p>{{.PartnerName}} heeft het werkaanbod (ID: {{.OfferID}}) afgewezen.</p>
{{if .Reason}}
<p>Reden: {{.Reason}}</p>
{{end}}
<p>U kunt een nieuw aanbod versturen naar een andere vakman via het portaal.</p>
{{end}}
</file>

<file path="internal/email/templates/password_reset.html">
{{define "content"}}
<p>We hebben een verzoek ontvangen om uw wachtwoord opnieuw in te stellen. Gebruik de link hieronder om een nieuw wachtwoord in te stellen.</p>
{{end}}
</file>

<file path="internal/email/templates/quote_accepted.html">
{{define "content"}}
<p>Beste {{.AgentName}},</p>
<p>{{.ConsumerName}} heeft offerte {{.QuoteNumber}} geaccepteerd (totaal: {{.TotalFormatted}}). Bekijk de details in het portaal.</p>
{{end}}
</file>

<file path="internal/email/templates/quote_proposal.html">
{{define "content"}}
<p>Beste {{.ConsumerName}},</p>
<p>{{.OrganizationName}} heeft offerte {{.QuoteNumber}} voor u klaargezet. Bekijk de offerte, selecteer eventuele opties en accepteer of wijs de offerte af.</p>
{{end}}
</file>

<file path="internal/email/templates/quote_thank_you.html">
{{define "content"}}
<p>Beste {{.ConsumerName}},</p>
<p>Bedankt dat u offerte {{.QuoteNumber}} van {{.OrganizationName}} heeft geaccepteerd. Wij nemen zo snel mogelijk contact met u op om de volgende stappen te bespreken.</p>
{{if .HasAttachments}}
<p>In de bijlage vindt u een PDF-kopie van de getekende offerte voor uw administratie.</p>
{{end}}
<p>Met vriendelijke groet,<br />
{{.OrganizationName}}</p>
{{end}}
</file>

<file path="internal/email/templates/verification.html">
{{define "content"}}
<p>Bedankt voor uw registratie. Verifieer uw e-mailadres om uw account te activeren.</p>
{{end}}
</file>

<file path="internal/email/templates/visit_invite.html">
{{define "content"}}
<p>Beste {{.ConsumerName}},</p>
<p>Uw bezoek is ingepland op:</p>
<div class="details-grid">
  <div class="detail-item">
    <div style="font-size: 20px; margin-top: 5px;">{{.ScheduledDate}}</div>
  </div>
  <div class="detail-item" style="background-color: #ffff00;">
    <div style="font-size: 16px; margin-top: 5px;">op<br />{{.Address}}</div>
  </div>
</div>
<p style="font-family: monospace; font-size: 14px; background: #000; color: #00ffff; padding: 15px; border-left: 10px solid #ff00ff;">
  Als u wilt verzetten of vragen heeft, neem dan contact met ons op.
</p>
{{end}}
</file>

<file path="internal/exports/handler.go">
package exports

import (
	"crypto/sha256"
	"encoding/csv"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

const (
	defaultCurrency = "EUR"
	defaultTimezone = "UTC"
	dateLayout      = "2006-01-02"
	noOrgContextMsg = "no organization context"
)

// Handler handles export requests and API key management.
type Handler struct {
	repo *Repository
	val  *validator.Validator
}

// NewHandler creates a new export handler.
func NewHandler(repo *Repository, val *validator.Validator) *Handler {
	return &Handler{repo: repo, val: val}
}

// ---- Admin API Key Management (JWT authenticated) ----

type CreateAPIKeyRequest struct {
	Name string `json:"name" validate:"required,min=1,max=100"`
}

type APIKeyResponse struct {
	ID         uuid.UUID  `json:"id"`
	Name       string     `json:"name"`
	KeyPrefix  string     `json:"keyPrefix"`
	IsActive   bool       `json:"isActive"`
	CreatedAt  string     `json:"createdAt"`
	LastUsedAt *time.Time `json:"lastUsedAt,omitempty"`
}

type CreateAPIKeyResponse struct {
	APIKeyResponse
	Key string `json:"key"`
}

func (h *Handler) HandleCreateAPIKey(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, noOrgContextMsg, nil)
		return
	}

	var req CreateAPIKeyRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid request body", err.Error())
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "validation error", err.Error())
		return
	}

	plaintext, hash, prefix, err := GenerateAPIKey()
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate API key", nil)
		return
	}

	createdBy := identity.UserID()
	key, err := h.repo.CreateAPIKey(c.Request.Context(), *tenantID, req.Name, hash, prefix, &createdBy)
	if httpkit.HandleError(c, err) {
		return
	}

	c.JSON(http.StatusCreated, CreateAPIKeyResponse{
		APIKeyResponse: toAPIKeyResponse(key),
		Key:            plaintext,
	})
}

func (h *Handler) HandleListAPIKeys(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, noOrgContextMsg, nil)
		return
	}

	keys, err := h.repo.ListAPIKeys(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	result := make([]APIKeyResponse, len(keys))
	for i, k := range keys {
		result[i] = toAPIKeyResponse(k)
	}

	httpkit.OK(c, result)
}

func (h *Handler) HandleRevokeAPIKey(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, noOrgContextMsg, nil)
		return
	}

	keyID, err := uuid.Parse(c.Param("keyId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid key id", nil)
		return
	}

	if err := h.repo.RevokeAPIKey(c.Request.Context(), keyID, *tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "api key revoked"})
}

// ---- Google Ads CSV Export (API key authenticated) ----

func (h *Handler) ExportGoogleAdsCSV(c *gin.Context) {
	orgID, ok := getExportOrgID(c)
	if !ok {
		return
	}

	keyID, ok := getExportKeyID(c)
	if ok {
		h.repo.TouchAPIKey(c.Request.Context(), keyID)
	}

	fromDate, toDate, err := parseDateRange(c)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid date range", err.Error())
		return
	}

	limit := parseLimit(c, 5000, 50000)
	currency := strings.ToUpper(strings.TrimSpace(c.DefaultQuery("currency", defaultCurrency)))
	useEnhanced := parseBool(c.Query("enhanced"))

	location, tzName, ok := parseTimezone(c)
	if !ok {
		return
	}

	events, err := h.repo.ListConversionEvents(c.Request.Context(), orgID, fromDate, toDate, limit)
	if httpkit.HandleError(c, err) {
		return
	}

	rows := buildConversionRows(events, location, currency, useEnhanced)
	if len(rows) == 0 {
		writeEmptyCsv(c, tzName, useEnhanced)
		return
	}

	orderIDs := collectOrderIDs(rows)
	exportedKeys, err := h.repo.ListExportedKeys(c.Request.Context(), orgID, orderIDs)
	if httpkit.HandleError(c, err) {
		return
	}

	writer, ok := startCsvResponse(c, tzName, useEnhanced)
	if !ok {
		return
	}

	records, ok := writeConversionRows(writer, rows, exportedKeys, useEnhanced)
	if !ok {
		return
	}

	writer.Flush()
	if err := writer.Error(); err != nil {
		return
	}

	_ = h.repo.RecordExports(c.Request.Context(), orgID, records)
}

// ---- Helpers ----

type conversionRow struct {
	LeadID             uuid.UUID
	LeadServiceID      uuid.UUID
	ConversionName     string
	ConversionTime     time.Time
	ConversionValue    float64
	ConversionCurrency string
	GCLID              string
	OrderID            string
	HashedEmail        string
	HashedPhone        string
}

func (r conversionRow) CSV(useEnhanced bool) []string {
	fields := []string{
		r.GCLID,
		r.ConversionName,
		formatConversionTime(r.ConversionTime),
		formatConversionValue(r.ConversionValue),
		r.ConversionCurrency,
		r.OrderID,
	}
	if useEnhanced {
		fields = append(fields, r.HashedEmail, r.HashedPhone)
	}
	return fields
}

func csvHeaders(useEnhanced bool) []string {
	headers := []string{
		"Google Click ID",
		"Conversion Name",
		"Conversion Time",
		"Conversion Value",
		"Conversion Currency",
		"Order ID",
	}
	if useEnhanced {
		headers = append(headers, "Email", "Phone Number")
	}
	return headers
}

func getExportOrgID(c *gin.Context) (uuid.UUID, bool) {
	orgIDVal, ok := c.Get("exportOrgID")
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "missing organization context", nil)
		return uuid.UUID{}, false
	}
	orgID, ok := orgIDVal.(uuid.UUID)
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "missing organization context", nil)
		return uuid.UUID{}, false
	}
	return orgID, true
}

func getExportKeyID(c *gin.Context) (uuid.UUID, bool) {
	keyIDVal, _ := c.Get("exportKeyID")
	keyID, ok := keyIDVal.(uuid.UUID)
	return keyID, ok
}

func parseTimezone(c *gin.Context) (*time.Location, string, bool) {
	tzName := strings.TrimSpace(c.DefaultQuery("timezone", defaultTimezone))
	location, err := time.LoadLocation(tzName)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid timezone", nil)
		return nil, "", false
	}
	return location, tzName, true
}

func writeEmptyCsv(c *gin.Context, tzName string, useEnhanced bool) {
	_, _ = startCsvResponse(c, tzName, useEnhanced)
}

func collectOrderIDs(rows []conversionRow) []string {
	orderIDs := make([]string, 0, len(rows))
	for _, row := range rows {
		orderIDs = append(orderIDs, row.OrderID)
	}
	return orderIDs
}

func startCsvResponse(c *gin.Context, tzName string, useEnhanced bool) (*csv.Writer, bool) {
	c.Header("Content-Type", "text/csv")
	c.Header("Content-Disposition", "attachment; filename=google-ads-conversions.csv")

	writer := csv.NewWriter(c.Writer)
	if err := writer.Write([]string{fmt.Sprintf("Parameters:TimeZone=%s", tzName)}); err != nil {
		return nil, false
	}
	if err := writer.Write(csvHeaders(useEnhanced)); err != nil {
		return nil, false
	}
	return writer, true
}

func writeConversionRows(writer *csv.Writer, rows []conversionRow, exportedKeys map[string]struct{}, useEnhanced bool) ([]ExportRecord, bool) {
	records := make([]ExportRecord, 0, len(rows))
	for _, row := range rows {
		if _, exists := exportedKeys[row.OrderID+"::"+row.ConversionName]; exists {
			continue
		}
		if err := writer.Write(row.CSV(useEnhanced)); err != nil {
			return nil, false
		}
		records = append(records, ExportRecord{
			LeadID:          row.LeadID,
			LeadServiceID:   row.LeadServiceID,
			ConversionName:  row.ConversionName,
			ConversionTime:  row.ConversionTime,
			ConversionValue: row.ConversionValue,
			GCLID:           row.GCLID,
			OrderID:         row.OrderID,
		})
	}
	return records, true
}

func toAPIKeyResponse(key APIKey) APIKeyResponse {
	return APIKeyResponse{
		ID:         key.ID,
		Name:       key.Name,
		KeyPrefix:  key.KeyPrefix,
		IsActive:   key.IsActive,
		CreatedAt:  key.CreatedAt.Format(time.RFC3339),
		LastUsedAt: key.LastUsedAt,
	}
}

func parseDateRange(c *gin.Context) (time.Time, time.Time, error) {
	now := time.Now().UTC()
	defaultFrom := now.AddDate(0, 0, -90)
	fromStr := strings.TrimSpace(c.DefaultQuery("fromDate", ""))
	toStr := strings.TrimSpace(c.DefaultQuery("toDate", ""))

	from := defaultFrom
	to := now

	if fromStr != "" {
		parsed, err := time.Parse(dateLayout, fromStr)
		if err != nil {
			return time.Time{}, time.Time{}, err
		}
		from = parsed
	}
	if toStr != "" {
		parsed, err := time.Parse(dateLayout, toStr)
		if err != nil {
			return time.Time{}, time.Time{}, err
		}
		to = parsed.Add(23*time.Hour + 59*time.Minute + 59*time.Second)
	}
	if to.Before(from) {
		return time.Time{}, time.Time{}, fmt.Errorf("toDate before fromDate")
	}
	return from, to, nil
}

func parseLimit(c *gin.Context, fallback int, max int) int {
	limit := fallback
	if raw := strings.TrimSpace(c.Query("limit")); raw != "" {
		if parsed, err := strconv.Atoi(raw); err == nil {
			limit = parsed
		}
	}
	if limit > max {
		return max
	}
	if limit < 1 {
		return fallback
	}
	return limit
}

func parseBool(value string) bool {
	switch strings.ToLower(strings.TrimSpace(value)) {
	case "1", "true", "yes", "y":
		return true
	default:
		return false
	}
}

func buildConversionRows(events []ConversionEvent, location *time.Location, currency string, includeEnhanced bool) []conversionRow {
	rows := make([]conversionRow, 0, len(events))
	for _, event := range events {
		conversionName := mapConversionName(event)
		if conversionName == "" {
			continue
		}
		if event.GCLID == "" {
			continue
		}
		conversionTime := event.OccurredAt.In(location)
		conversionValue := mapConversionValue(conversionName, event.ProjectedValueCents)

		hashedEmail := ""
		hashedPhone := ""
		if includeEnhanced {
			if event.ConsumerEmail != nil {
				hashedEmail = hashEmail(*event.ConsumerEmail)
			}
			hashedPhone = hashPhone(event.ConsumerPhone)
		}

		rows = append(rows, conversionRow{
			LeadID:             event.LeadID,
			LeadServiceID:      event.LeadServiceID,
			ConversionName:     conversionName,
			ConversionTime:     conversionTime,
			ConversionValue:    conversionValue,
			ConversionCurrency: currency,
			GCLID:              event.GCLID,
			OrderID:            event.EventID.String(),
			HashedEmail:        hashedEmail,
			HashedPhone:        hashedPhone,
		})
	}
	return rows
}

func mapConversionName(event ConversionEvent) string {
	if event.EventType == "status_changed" && event.Status != nil {
		switch *event.Status {
		case "Scheduled":
			return "Appointment_Scheduled"
		case "Surveyed":
			return "Visit_Completed"
		case "Closed":
			return "Deal_Won"
		}
	}

	if event.EventType == "pipeline_stage_changed" && event.PipelineStage != nil {
		switch *event.PipelineStage {
		case "Nurturing":
			return "Lead_Qualified"
		case "Quote_Sent":
			return "Quote_Sent"
		case "Partner_Assigned":
			return "Partner_Assigned"
		case "Completed":
			return "Job_Completed"
		}
	}

	return ""
}

func mapConversionValue(conversionName string, projectedValueCents int64) float64 {
	if projectedValueCents <= 0 {
		return 0
	}

	switch conversionName {
	case "Deal_Won", "Job_Completed":
		return float64(projectedValueCents) / 100
	default:
		return 0
	}
}

func formatConversionTime(value time.Time) string {
	return value.Format("2006-01-02 15:04:05-0700")
}

func formatConversionValue(value float64) string {
	return strconv.FormatFloat(value, 'f', 2, 64)
}

func hashEmail(value string) string {
	value = strings.TrimSpace(strings.ToLower(value))
	if value == "" {
		return ""
	}

	parts := strings.Split(value, "@")
	if len(parts) == 2 {
		domain := parts[1]
		user := parts[0]
		if domain == "gmail.com" || domain == "googlemail.com" {
			user = strings.ReplaceAll(user, ".", "")
			if plusIndex := strings.Index(user, "+"); plusIndex >= 0 {
				user = user[:plusIndex]
			}
			value = user + "@" + domain
		}
	}

	hash := sha256Sum(value)
	return hash
}

func hashPhone(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return ""
	}
	cleaned := strings.Builder{}
	for _, r := range value {
		if r >= '0' && r <= '9' {
			cleaned.WriteRune(r)
		}
	}

	normalized := cleaned.String()
	if normalized == "" {
		return ""
	}

	return sha256Sum("+" + normalized)
}

func sha256Sum(value string) string {
	hash := sha256.Sum256([]byte(value))
	return fmt.Sprintf("%x", hash)
}
</file>

<file path="internal/exports/middleware.go">
package exports

import (
	"net/http"

	"portal_final_backend/platform/httpkit"

	"github.com/gin-gonic/gin"
)

// APIKeyAuthMiddleware validates export API keys for public export endpoints.
func APIKeyAuthMiddleware(repo *Repository) gin.HandlerFunc {
	return func(c *gin.Context) {
		plaintext := c.GetHeader("X-Export-API-Key")
		if plaintext == "" {
			httpkit.Error(c, http.StatusUnauthorized, "missing export API key", nil)
			return
		}

		hash := HashKey(plaintext)
		key, err := repo.GetAPIKeyByHash(c.Request.Context(), hash)
		if err != nil {
			httpkit.Error(c, http.StatusUnauthorized, "invalid export API key", nil)
			return
		}

		c.Set("exportOrgID", key.OrganizationID)
		c.Set("exportKeyID", key.ID)
		c.Next()
	}
}
</file>

<file path="internal/exports/module.go">
package exports

import (
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the exports bounded context module implementing http.Module.
type Module struct {
	handler *Handler
	repo    *Repository
}

// NewModule creates and initializes the exports module.
func NewModule(pool *pgxpool.Pool, val *validator.Validator) *Module {
	repo := NewRepository(pool)
	handler := NewHandler(repo, val)

	return &Module{
		handler: handler,
		repo:    repo,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "exports"
}

// RegisterRoutes mounts export routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	publicGroup := ctx.V1.Group("/exports")
	publicGroup.Use(APIKeyAuthMiddleware(m.repo))
	publicGroup.GET("/google-ads/conversions.csv", m.handler.ExportGoogleAdsCSV)

	adminGroup := ctx.Admin.Group("/exports/keys")
	adminGroup.POST("", m.handler.HandleCreateAPIKey)
	adminGroup.GET("", m.handler.HandleListAPIKeys)
	adminGroup.DELETE("/:keyId", m.handler.HandleRevokeAPIKey)
}

var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/exports/repository.go">
package exports

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrAPIKeyNotFound = errors.New("export API key not found")

const apiKeyPrefix = "gads_"

// APIKey represents an export API key stored in the database.
type APIKey struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Name           string
	KeyHash        string
	KeyPrefix      string
	IsActive       bool
	CreatedBy      *uuid.UUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
	LastUsedAt     *time.Time
}

// ConversionEvent represents a lead service event used for conversion exports.
type ConversionEvent struct {
	EventID             uuid.UUID
	OrganizationID      uuid.UUID
	LeadID              uuid.UUID
	LeadServiceID       uuid.UUID
	EventType           string
	Status              *string
	PipelineStage       *string
	OccurredAt          time.Time
	GCLID               string
	ConsumerEmail       *string
	ConsumerPhone       string
	ProjectedValueCents int64
}

// Repository provides data access for export operations.
type Repository struct {
	pool *pgxpool.Pool
}

func NewRepository(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

// GenerateAPIKey creates a new random API key and returns the plaintext key and its hash.
func GenerateAPIKey() (plaintext string, hash string, prefix string, err error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", "", "", err
	}
	plaintext = apiKeyPrefix + hex.EncodeToString(bytes)
	h := sha256.Sum256([]byte(plaintext))
	hash = hex.EncodeToString(h[:])
	prefix = plaintext[:12]
	return plaintext, hash, prefix, nil
}

// HashKey hashes a plaintext API key for lookup.
func HashKey(plaintext string) string {
	h := sha256.Sum256([]byte(plaintext))
	return hex.EncodeToString(h[:])
}

// CreateAPIKey creates a new export API key record.
func (r *Repository) CreateAPIKey(ctx context.Context, orgID uuid.UUID, name string, keyHash string, keyPrefix string, createdBy *uuid.UUID) (APIKey, error) {
	var key APIKey
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_export_api_keys (organization_id, name, key_hash, key_prefix, created_by)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, organization_id, name, key_hash, key_prefix, is_active, created_by, created_at, updated_at, last_used_at
	`, orgID, name, keyHash, keyPrefix, createdBy).Scan(
		&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix, &key.IsActive, &key.CreatedBy, &key.CreatedAt, &key.UpdatedAt, &key.LastUsedAt,
	)
	return key, err
}

// GetAPIKeyByHash retrieves an active API key by its hash.
func (r *Repository) GetAPIKeyByHash(ctx context.Context, keyHash string) (APIKey, error) {
	var key APIKey
	err := r.pool.QueryRow(ctx, `
		SELECT id, organization_id, name, key_hash, key_prefix, is_active, created_by, created_at, updated_at, last_used_at
		FROM RAC_export_api_keys
		WHERE key_hash = $1 AND is_active = true
	`, keyHash).Scan(
		&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix, &key.IsActive, &key.CreatedBy, &key.CreatedAt, &key.UpdatedAt, &key.LastUsedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return APIKey{}, ErrAPIKeyNotFound
	}
	return key, err
}

// ListAPIKeys returns all export API keys for an organization.
func (r *Repository) ListAPIKeys(ctx context.Context, orgID uuid.UUID) ([]APIKey, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, organization_id, name, key_hash, key_prefix, is_active, created_by, created_at, updated_at, last_used_at
		FROM RAC_export_api_keys
		WHERE organization_id = $1
		ORDER BY created_at DESC
	`, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	keys := make([]APIKey, 0)
	for rows.Next() {
		var key APIKey
		if err := rows.Scan(
			&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix, &key.IsActive, &key.CreatedBy, &key.CreatedAt, &key.UpdatedAt, &key.LastUsedAt,
		); err != nil {
			return nil, err
		}
		keys = append(keys, key)
	}
	return keys, rows.Err()
}

// RevokeAPIKey deactivates an export API key.
func (r *Repository) RevokeAPIKey(ctx context.Context, keyID uuid.UUID, orgID uuid.UUID) error {
	tag, err := r.pool.Exec(ctx, `
		UPDATE RAC_export_api_keys SET is_active = false, updated_at = now()
		WHERE id = $1 AND organization_id = $2
	`, keyID, orgID)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return ErrAPIKeyNotFound
	}
	return nil
}

// TouchAPIKey updates the last_used_at timestamp for the key.
func (r *Repository) TouchAPIKey(ctx context.Context, keyID uuid.UUID) {
	_, _ = r.pool.Exec(ctx, `
		UPDATE RAC_export_api_keys SET last_used_at = now(), updated_at = now()
		WHERE id = $1
	`, keyID)
}

// ListConversionEvents returns conversion-relevant lead service events.
func (r *Repository) ListConversionEvents(ctx context.Context, orgID uuid.UUID, from time.Time, to time.Time, limit int) ([]ConversionEvent, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT e.id, e.organization_id, e.lead_id, e.lead_service_id, e.event_type, e.status, e.pipeline_stage, e.occurred_at,
			l.gclid, l.consumer_email, l.consumer_phone, l.projected_value_cents
		FROM RAC_lead_service_events e
		JOIN RAC_leads l ON l.id = e.lead_id AND l.organization_id = e.organization_id
		WHERE e.organization_id = $1
			AND l.deleted_at IS NULL
			AND l.gclid IS NOT NULL
			AND e.occurred_at >= $2 AND e.occurred_at <= $3
		ORDER BY e.occurred_at ASC
		LIMIT $4
	`, orgID, from, to, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]ConversionEvent, 0)
	for rows.Next() {
		var item ConversionEvent
		if err := rows.Scan(
			&item.EventID,
			&item.OrganizationID,
			&item.LeadID,
			&item.LeadServiceID,
			&item.EventType,
			&item.Status,
			&item.PipelineStage,
			&item.OccurredAt,
			&item.GCLID,
			&item.ConsumerEmail,
			&item.ConsumerPhone,
			&item.ProjectedValueCents,
		); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	return items, rows.Err()
}

// ListExportedKeys returns a set of order_id + conversion_name that have been exported.
func (r *Repository) ListExportedKeys(ctx context.Context, orgID uuid.UUID, orderIDs []string) (map[string]struct{}, error) {
	if len(orderIDs) == 0 {
		return map[string]struct{}{}, nil
	}
	rows, err := r.pool.Query(ctx, `
		SELECT order_id, conversion_name
		FROM RAC_google_ads_exports
		WHERE organization_id = $1 AND order_id = ANY($2)
	`, orgID, orderIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make(map[string]struct{})
	for rows.Next() {
		var orderID string
		var conversionName string
		if err := rows.Scan(&orderID, &conversionName); err != nil {
			return nil, err
		}
		result[orderID+"::"+conversionName] = struct{}{}
	}
	return result, rows.Err()
}

// RecordExports stores export rows to prevent duplicates.
func (r *Repository) RecordExports(ctx context.Context, orgID uuid.UUID, rows []ExportRecord) error {
	if len(rows) == 0 {
		return nil
	}
	batch := &pgx.Batch{}
	for _, row := range rows {
		batch.Queue(`
			INSERT INTO RAC_google_ads_exports (
				organization_id, lead_id, lead_service_id, conversion_name, conversion_time,
				conversion_value, gclid, order_id
			) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
			ON CONFLICT (organization_id, order_id, conversion_name) DO NOTHING
		`, orgID, row.LeadID, row.LeadServiceID, row.ConversionName, row.ConversionTime, row.ConversionValue, row.GCLID, row.OrderID)
	}
	results := r.pool.SendBatch(ctx, batch)
	defer results.Close()
	for i := 0; i < len(rows); i++ {
		if _, err := results.Exec(); err != nil {
			return err
		}
	}
	return nil
}

// ExportRecord represents a conversion row to persist.
type ExportRecord struct {
	LeadID          uuid.UUID
	LeadServiceID   uuid.UUID
	ConversionName  string
	ConversionTime  time.Time
	ConversionValue float64
	GCLID           string
	OrderID         string
}
</file>

<file path="internal/identity/module.go">
// Package identity provides the identity bounded context module.
package identity

import (
	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/identity/handler"
	"portal_final_backend/internal/identity/repository"
	"portal_final_backend/internal/identity/service"
	"portal_final_backend/internal/whatsapp"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

type Module struct {
	handler *handler.Handler
	service *service.Service
}

func NewModule(pool *pgxpool.Pool, eventBus events.Bus, storageSvc storage.StorageService, logoBucket string, val *validator.Validator, whatsappClient *whatsapp.Client) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, eventBus, storageSvc, logoBucket, whatsappClient)
	h := handler.New(svc, val)

	return &Module{handler: h, service: svc}
}

func (m *Module) Name() string {
	return "identity"
}

func (m *Module) Service() *service.Service {
	return m.service
}

func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	m.handler.RegisterRoutes(ctx.Admin)
}

var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/leads/agent/gatekeeper.go">
package agent

import (
	"context"
	"fmt"
	"log"
	"strings"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/genai"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/moonshot"
)

// Gatekeeper validates intake requirements and advances pipeline stage.
type Gatekeeper struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	repo           repository.LeadsRepository
	toolDeps       *ToolDependencies
	runMu          sync.Mutex
}

// NewGatekeeper creates a Gatekeeper agent.
func NewGatekeeper(apiKey string, repo repository.LeadsRepository, eventBus events.Bus) (*Gatekeeper, error) {
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          apiKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	deps := &ToolDependencies{
		Repo:     repo,
		EventBus: eventBus,
	}

	updateStageTool, err := createUpdatePipelineStageTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build UpdatePipelineStage tool: %w", err)
	}
	saveAnalysisTool, err := createSaveAnalysisTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build SaveAnalysis tool: %w", err)
	}
	updateServiceTypeTool, err := createUpdateLeadServiceTypeTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build UpdateLeadServiceType tool: %w", err)
	}
	updateLeadDetailsTool, err := createUpdateLeadDetailsTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build UpdateLeadDetails tool: %w", err)
	}

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "Gatekeeper",
		Model:       kimi,
		Description: "Validates intake requirements and advances the lead pipeline.",
		Instruction: "You validate intake requirements and advance the pipeline stage.",
		Tools:       []tool.Tool{saveAnalysisTool, updateLeadDetailsTool, updateServiceTypeTool, updateStageTool},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create gatekeeper agent: %w", err)
	}

	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "gatekeeper",
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create gatekeeper runner: %w", err)
	}

	return &Gatekeeper{
		agent:          adkAgent,
		runner:         r,
		sessionService: sessionService,
		appName:        "gatekeeper",
		repo:           repo,
		toolDeps:       deps,
	}, nil
}

// Run executes the gatekeeper for a lead service.
func (g *Gatekeeper) Run(ctx context.Context, leadID, serviceID, tenantID uuid.UUID) error {
	g.runMu.Lock()
	defer g.runMu.Unlock()

	g.toolDeps.SetTenantID(tenantID)
	g.toolDeps.SetLeadContext(leadID, serviceID)
	g.toolDeps.SetActor("AI", "Gatekeeper")
	g.toolDeps.ResetToolCallTracking() // Reset before each run

	lead, err := g.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return err
	}
	service, err := g.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		return err
	}

	notes, err := g.repo.ListNotesByService(ctx, leadID, serviceID, tenantID)
	if err != nil {
		log.Printf("gatekeeper notes fetch failed: %v", err)
		notes = nil
	}

	attachments, err := g.repo.ListAttachmentsByService(ctx, serviceID, tenantID)
	if err != nil {
		log.Printf("gatekeeper attachments fetch failed: %v", err)
		attachments = nil
	}

	intakeContext := g.buildServiceContext(ctx, tenantID)
	promptText := buildGatekeeperPrompt(lead, service, notes, intakeContext, attachments)

	log.Printf("gatekeeper: starting runWithPrompt for lead=%s service=%s", leadID, serviceID)
	if err := g.runWithPrompt(ctx, promptText, leadID); err != nil {
		log.Printf("gatekeeper: runWithPrompt failed for lead=%s: %v", leadID, err)
		return err
	}
	log.Printf("gatekeeper: runWithPrompt completed for lead=%s", leadID)

	// Validate that SaveAnalysis was called - if not, create fallback
	wasCalled := g.toolDeps.WasSaveAnalysisCalled()
	log.Printf("gatekeeper: WasSaveAnalysisCalled()=%v for lead=%s service=%s", wasCalled, leadID, serviceID)
	if !wasCalled {
		log.Printf("gatekeeper: SaveAnalysis was NOT called by agent for lead=%s service=%s, creating fallback", leadID, serviceID)
		g.createFallbackAnalysis(ctx, lead, service, leadID, serviceID, tenantID)
	} else {
		log.Printf("gatekeeper: SaveAnalysis was called successfully for lead=%s service=%s", leadID, serviceID)
	}

	return nil
}

// createFallbackAnalysis creates a minimal analysis when the agent fails to call SaveAnalysis
func (g *Gatekeeper) createFallbackAnalysis(ctx context.Context, lead repository.Lead, service repository.LeadService, leadID, serviceID, tenantID uuid.UUID) {
	_ = service
	// Determine preferred channel based on available contact info
	channel := "Email"
	if strings.TrimSpace(lead.ConsumerPhone) != "" {
		channel = "WhatsApp"
	}

	// Create a default analysis record
	_, err := g.repo.CreateAIAnalysis(ctx, repository.CreateAIAnalysisParams{
		LeadID:                  leadID,
		OrganizationID:          tenantID,
		LeadServiceID:           serviceID,
		UrgencyLevel:            "Medium",
		UrgencyReason:           nil,
		LeadQuality:             "Potential",
		RecommendedAction:       "RequestInfo",
		MissingInformation:      []string{"Intake validatie niet voltooid door AI"},
		PreferredContactChannel: channel,
		SuggestedContactMessage: fmt.Sprintf("Beste %s, bedankt voor uw aanvraag. Kunt u ons meer details geven over uw project?", lead.ConsumerFirstName),
		Summary:                 "AI analyse kon niet worden voltooid. Handmatige beoordeling vereist.",
	})
	if err != nil {
		log.Printf("gatekeeper: failed to create fallback analysis: %v", err)
		return
	}

	// Create timeline event for the fallback
	summary := "AI analyse kon niet worden voltooid. Handmatige beoordeling vereist."
	analysisMetadata := map[string]any{
		"urgencyLevel":            "Medium",
		"recommendedAction":       "RequestInfo",
		"leadQuality":             "Potential",
		"preferredContactChannel": channel,
		"suggestedContactMessage": fmt.Sprintf("Beste %s, bedankt voor uw aanvraag. Kunt u ons meer details geven over uw project?", lead.ConsumerFirstName),
		"missingInformation":      []string{"Intake validatie niet voltooid door AI"},
		"fallback":                true,
	}
	_, _ = g.repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &serviceID,
		OrganizationID: tenantID,
		ActorType:      "AI",
		ActorName:      "Gatekeeper",
		EventType:      "ai",
		Title:          "Gatekeeper-triage (fallback)",
		Summary:        &summary,
		Metadata:       analysisMetadata,
	})

	// Store for stage_change event if needed
	g.toolDeps.SetLastAnalysisMetadata(analysisMetadata)
	log.Printf("gatekeeper: created fallback analysis for lead=%s service=%s", leadID, serviceID)
}

func (g *Gatekeeper) buildServiceContext(ctx context.Context, tenantID uuid.UUID) string {
	services, err := g.repo.ListActiveServiceTypes(ctx, tenantID)
	if err != nil {
		return "No intake requirements available."
	}

	var sb strings.Builder
	for _, svc := range services {
		sb.WriteString(fmt.Sprintf("### %s\n", svc.Name))
		if svc.Description != nil && *svc.Description != "" {
			sb.WriteString(fmt.Sprintf("Description: %s\n", *svc.Description))
		}
		if svc.IntakeGuidelines != nil && *svc.IntakeGuidelines != "" {
			sb.WriteString(fmt.Sprintf("Intake Requirements: %s\n", *svc.IntakeGuidelines))
		} else {
			sb.WriteString("Intake Requirements: Not specified.\n")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func (g *Gatekeeper) runWithPrompt(ctx context.Context, promptText string, leadID uuid.UUID) error {
	sessionID := uuid.New().String()
	userID := "gatekeeper-" + leadID.String()

	_, err := g.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   g.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return fmt.Errorf("failed to create gatekeeper session: %w", err)
	}
	defer func() {
		_ = g.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   g.appName,
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	userMessage := &genai.Content{
		Role:  "user",
		Parts: []*genai.Part{{Text: promptText}},
	}

	runConfig := agent.RunConfig{StreamingMode: agent.StreamingModeNone}
	for event := range g.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		_ = event
	}

	return nil
}
</file>

<file path="internal/leads/agent/helpers.go">
package agent

import (
"fmt"
"strings"
"unicode"

"portal_final_backend/internal/leads/repository"
)

const (
maxNoteLength    = 2000
maxConsumerNote  = 1000
userDataBegin    = "<<<BEGIN_USER_DATA>>>"
userDataEnd      = "<<<END_USER_DATA>>>"
dateTimeLayout   = "02-01-2006 15:04"
dateLayout       = "02-01-2006"
bulletLine       = "- %s\n"
valueNotProvided = "Niet opgegeven"
)

// filterMeaningfulNotes filters out system notes that don't count as meaningful information.
func filterMeaningfulNotes(notes []repository.LeadNote) []repository.LeadNote {
const noteTypeSystem = "system"
var meaningful []repository.LeadNote
for _, note := range notes {
if note.Type != noteTypeSystem {
meaningful = append(meaningful, note)
}
}
return meaningful
}

// sanitizeUserInput removes control characters and truncates to max length.
func sanitizeUserInput(s string, maxLen int) string {
var sb strings.Builder
for _, r := range s {
if unicode.IsControl(r) && r != '\n' && r != '\t' {
continue
}
sb.WriteRune(r)
}
result := sb.String()
if len(result) > maxLen {
result = result[:maxLen] + "... [afgekapt]"
}
return result
}

// wrapUserData wraps user-provided content with markers to isolate it from instructions.
func wrapUserData(content string) string {
return fmt.Sprintf("%s\n%s\n%s", userDataBegin, content, userDataEnd)
}

func getValue(s *string) string {
if s == nil {
return valueNotProvided
}
return *s
}
</file>

<file path="internal/leads/agent/offer_summary_generator.go">
package agent

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"

	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/platform/ai/moonshot"
)

// OfferSummaryGenerator produces short, markdown summaries for partner offers.
type OfferSummaryGenerator struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	runMu          sync.Mutex
}

// NewOfferSummaryGenerator creates a summary generator agent without tools.
func NewOfferSummaryGenerator(apiKey string) (*OfferSummaryGenerator, error) {
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          apiKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "OfferSummaryGenerator",
		Model:       kimi,
		Description: "Generates concise, markdown summaries for partner offers.",
		Instruction: getOfferSummarySystemPrompt(),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create offer summary agent: %w", err)
	}

	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "offer-summary-generator",
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create offer summary runner: %w", err)
	}

	return &OfferSummaryGenerator{
		agent:          adkAgent,
		runner:         r,
		sessionService: sessionService,
		appName:        "offer-summary-generator",
	}, nil
}

// GenerateOfferSummary renders a markdown summary using only allowed fields.
func (g *OfferSummaryGenerator) GenerateOfferSummary(ctx context.Context, tenantID uuid.UUID, input ports.OfferSummaryInput) (string, error) {
	_ = tenantID
	g.runMu.Lock()
	defer g.runMu.Unlock()

	promptText := buildOfferSummaryPrompt(input)
	sessionID := uuid.New().String()
	userID := "offer-summary-" + input.LeadServiceID.String()

	_, err := g.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   g.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return "", fmt.Errorf("offer summary: create session: %w", err)
	}
	defer func() {
		_ = g.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   g.appName,
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{{
			Text: promptText,
		}},
	}

	runConfig := agent.RunConfig{StreamingMode: agent.StreamingModeNone}

	var outputText strings.Builder
	for event, err := range g.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		if err != nil {
			return "", fmt.Errorf("offer summary: run failed: %w", err)
		}
		if event.Content == nil {
			continue
		}
		for _, part := range event.Content.Parts {
			outputText.WriteString(part.Text)
		}
	}

	return strings.TrimSpace(outputText.String()), nil
}

func buildOfferSummaryPrompt(input ports.OfferSummaryInput) string {
	lines := make([]string, 0, len(input.Items))
	for _, item := range input.Items {
		label := strings.TrimSpace(item.Description)
		qty := strings.TrimSpace(item.Quantity)
		if label == "" {
			continue
		}
		if qty != "" {
			label = qty + " " + label
		}
		lines = append(lines, "- "+label)
	}

	scope := ""
	if input.Scope != nil {
		scope = strings.TrimSpace(*input.Scope)
	}
	urgency := ""
	if input.UrgencyLevel != nil {
		urgency = strings.TrimSpace(*input.UrgencyLevel)
	}

	return fmt.Sprintf(`Context:
- Service type: %s
- Scope: %s
- Urgency: %s

Line items:
%s

Task:
Write a short summary for a professional contractor.
Rules:
- Output only markdown, no extra commentary.
- Use Dutch.
- Do NOT include any personal data: no names, addresses, phone numbers, emails.
- Only use the provided service type, scope, urgency, and line items.
- If scope or urgency is missing, omit that label.
- Preferred structure:
  1) Optional first line with **Omvang** and **Urgentie**.
  2) One short sentence describing the job.
  3) Numbered list of up to 3 main items.
`, strings.TrimSpace(input.ServiceType), scope, urgency, strings.Join(lines, "\n"))
}

func getOfferSummarySystemPrompt() string {
	return "You are a concise summary writer for home service work offers. Produce short, accurate markdown summaries without any personal data."
}
</file>

<file path="internal/leads/domain/service_state.go">
// Package domain provides core business rules for the leads bounded context.
package domain

// terminalStatuses are service statuses where no further agent actions should occur.
var terminalStatuses = map[string]bool{
	"Closed":   true,
	"Bad_Lead": true,
	"Surveyed": true,
}

// terminalPipelineStages are pipeline stages where the workflow is complete.
var terminalPipelineStages = map[string]bool{
	"Completed": true,
	"Lost":      true,
}

// IsTerminal returns true if the service is in a terminal state based on
// EITHER status or pipeline stage. A terminal service must not be processed
// by any AI agent (Gatekeeper, Estimator, Dispatcher, Photo Analyzer).
func IsTerminal(status, pipelineStage string) bool {
	return terminalStatuses[status] || terminalPipelineStages[pipelineStage]
}

// IsTerminalStatus returns true if the status alone is terminal.
func IsTerminalStatus(status string) bool {
	return terminalStatuses[status]
}

// IsTerminalPipelineStage returns true if the pipeline stage alone is terminal.
func IsTerminalPipelineStage(stage string) bool {
	return terminalPipelineStages[stage]
}

// ValidateStateCombination checks that a (status, pipelineStage) pair is
// not contradictory. Returns a non-empty reason string when the combination
// is invalid.
func ValidateStateCombination(status, pipelineStage string) string {
	// Bad_Lead status must have Lost pipeline stage (or Triage/Manual_Intervention during transition)
	if status == "Bad_Lead" && pipelineStage != "Lost" && pipelineStage != "Triage" && pipelineStage != "Manual_Intervention" {
		return "Bad_Lead status requires Lost pipeline stage"
	}
	return ""
}
</file>

<file path="internal/leads/management/feed_social.go">
// Package management  social interaction logic for feed reactions, comments, and @-mentions.
package management

import (
	"context"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"

	"github.com/google/uuid"
)

// SocialRepository defines the data access needed by feed social operations.
type SocialRepository interface {
	repository.FeedReactionStore
	repository.FeedCommentStore
	repository.OrgMemberReader
}

// 
// Reactions
// 

// ToggleReaction toggles a reaction on/off and returns the updated summary.
func (s *Service) ToggleReaction(ctx context.Context, eventID, eventSource, reactionType string, userID, orgID uuid.UUID) (transport.ToggleReactionResponse, error) {
	active, err := s.repo.ToggleReaction(ctx, eventID, eventSource, reactionType, userID, orgID)
	if err != nil {
		return transport.ToggleReactionResponse{}, err
	}

	reactions, err := s.repo.ListReactionsByEvent(ctx, eventID, eventSource, orgID)
	if err != nil {
		return transport.ToggleReactionResponse{}, err
	}

	return transport.ToggleReactionResponse{
		Active:    active,
		Reactions: buildReactionSummary(reactions, userID),
	}, nil
}

// ListReactions returns the reaction summary for a single feed event.
func (s *Service) ListReactions(ctx context.Context, eventID, eventSource string, userID, orgID uuid.UUID) ([]transport.ReactionSummary, error) {
	reactions, err := s.repo.ListReactionsByEvent(ctx, eventID, eventSource, orgID)
	if err != nil {
		return nil, err
	}
	return buildReactionSummary(reactions, userID), nil
}

func buildReactionSummary(reactions []repository.FeedReaction, currentUserID uuid.UUID) []transport.ReactionSummary {
	type bucket struct {
		users []string
		me    bool
	}
	groups := map[string]*bucket{}
	order := []string{}

	for _, r := range reactions {
		b, ok := groups[r.ReactionType]
		if !ok {
			b = &bucket{}
			groups[r.ReactionType] = b
			order = append(order, r.ReactionType)
		}
		b.users = append(b.users, r.UserEmail)
		if r.UserID == currentUserID {
			b.me = true
		}
	}

	out := make([]transport.ReactionSummary, 0, len(order))
	for _, t := range order {
		b := groups[t]
		out = append(out, transport.ReactionSummary{
			Type:  t,
			Count: len(b.users),
			Users: b.users,
			Me:    b.me,
		})
	}
	return out
}

// 
// Comments
// 

// CreateComment creates a comment (with optional @-mentions) and returns the full thread.
func (s *Service) CreateComment(ctx context.Context, eventID, eventSource string, userID, orgID uuid.UUID, body string, mentionIDs []uuid.UUID) (transport.CommentListResponse, error) {
	_, err := s.repo.CreateComment(ctx, eventID, eventSource, userID, orgID, body, mentionIDs)
	if err != nil {
		return transport.CommentListResponse{}, err
	}

	return s.ListComments(ctx, eventID, eventSource, orgID)
}

// ListComments returns the full comment thread for a feed event.
func (s *Service) ListComments(ctx context.Context, eventID, eventSource string, orgID uuid.UUID) (transport.CommentListResponse, error) {
	rows, err := s.repo.ListCommentsByEvent(ctx, eventID, eventSource, orgID)
	if err != nil {
		return transport.CommentListResponse{}, err
	}

	items := make([]transport.CommentItem, 0, len(rows))
	for _, c := range rows {
		mentions := make([]transport.MentionItem, 0, len(c.Mentions))
		for _, m := range c.Mentions {
			mentions = append(mentions, transport.MentionItem{UserID: m.UserID.String(), Email: m.Email})
		}
		items = append(items, transport.CommentItem{
			ID:        c.ID.String(),
			UserEmail: c.UserEmail,
			Body:      c.Body,
			Mentions:  mentions,
			CreatedAt: c.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		})
	}

	return transport.CommentListResponse{Comments: items}, nil
}

// DeleteComment removes a comment (only the author can delete).
func (s *Service) DeleteComment(ctx context.Context, commentID, userID, orgID uuid.UUID) error {
	return s.repo.DeleteComment(ctx, commentID, userID, orgID)
}

// 
// Org Members (for @-mention autocomplete)
// 

// ListOrgMembers returns all users in the organisation, for @-mention autocomplete.
func (s *Service) ListOrgMembers(ctx context.Context, orgID uuid.UUID) (transport.OrgMembersResponse, error) {
	members, err := s.repo.ListOrgMembers(ctx, orgID)
	if err != nil {
		return transport.OrgMembersResponse{}, err
	}

	items := make([]transport.OrgMemberItem, 0, len(members))
	for _, m := range members {
		items = append(items, transport.OrgMemberItem{ID: m.ID.String(), Email: m.Email})
	}

	return transport.OrgMembersResponse{Members: items}, nil
}
</file>

<file path="internal/leads/management/mappers.go">
package management

import (
	"encoding/json"
	"strings"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
)

func energyLabelFromLead(lead repository.Lead) *transport.EnergyLabelResponse {
	if lead.EnergyClass == nil {
		return nil
	}

	resp := &transport.EnergyLabelResponse{
		Energieklasse:           *lead.EnergyClass,
		EnergieIndex:            lead.EnergyIndex,
		GeldigTot:               lead.EnergyLabelValidUntil,
		Registratiedatum:        lead.EnergyLabelRegisteredAt,
		PrimaireFossieleEnergie: lead.EnergyPrimairFossiel,
	}

	if lead.EnergyBouwjaar != nil {
		resp.Bouwjaar = *lead.EnergyBouwjaar
	}

	if lead.EnergyGebouwtype != nil {
		resp.Gebouwtype = *lead.EnergyGebouwtype
	}

	return resp
}

func leadEnrichmentFromLead(lead repository.Lead) *transport.LeadEnrichmentResponse {
	if lead.LeadEnrichmentSource == nil && lead.LeadEnrichmentFetchedAt == nil {
		return nil
	}

	return &transport.LeadEnrichmentResponse{
		Source:                    lead.LeadEnrichmentSource,
		Postcode6:                 lead.LeadEnrichmentPostcode6,
		Postcode4:                 lead.LeadEnrichmentPostcode4,
		Buurtcode:                 lead.LeadEnrichmentBuurtcode,
		DataYear:                  lead.LeadEnrichmentDataYear,
		GemAardgasverbruik:        lead.LeadEnrichmentGemAardgasverbruik,
		GemElektriciteitsverbruik: lead.LeadEnrichmentGemElektriciteitsverbruik,
		HuishoudenGrootte:         lead.LeadEnrichmentHuishoudenGrootte,
		KoopwoningenPct:           lead.LeadEnrichmentKoopwoningenPct,
		BouwjaarVanaf2000Pct:      lead.LeadEnrichmentBouwjaarVanaf2000Pct,
		WOZWaarde:                 lead.LeadEnrichmentWOZWaarde,
		MediaanVermogenX1000:      lead.LeadEnrichmentMediaanVermogenX1000,
		GemInkomen:                lead.LeadEnrichmentGemInkomen,
		PctHoogInkomen:            lead.LeadEnrichmentPctHoogInkomen,
		PctLaagInkomen:            lead.LeadEnrichmentPctLaagInkomen,
		HuishoudensMetKinderenPct: lead.LeadEnrichmentHuishoudensMetKinderenPct,
		Stedelijkheid:             lead.LeadEnrichmentStedelijkheid,
		Confidence:                lead.LeadEnrichmentConfidence,
		FetchedAt:                 lead.LeadEnrichmentFetchedAt,
	}
}

func leadScoreFromLead(lead repository.Lead) *transport.LeadScoreResponse {
	if lead.LeadScore == nil && lead.LeadScorePreAI == nil {
		return nil
	}

	var factors json.RawMessage
	if len(lead.LeadScoreFactors) > 0 {
		factors = json.RawMessage(lead.LeadScoreFactors)
	}

	return &transport.LeadScoreResponse{
		Score:     lead.LeadScore,
		PreAI:     lead.LeadScorePreAI,
		Factors:   factors,
		Version:   lead.LeadScoreVersion,
		UpdatedAt: lead.LeadScoreUpdatedAt,
	}
}

// ToLeadResponse converts a repository Lead to a transport LeadResponse.
func ToLeadResponse(lead repository.Lead) transport.LeadResponse {
	return transport.LeadResponse{
		ID:              lead.ID,
		AssignedAgentID: lead.AssignedAgentID,
		ViewedByID:      lead.ViewedByID,
		ViewedAt:        lead.ViewedAt,
		Source:          lead.Source,
		CreatedAt:       lead.CreatedAt,
		UpdatedAt:       lead.UpdatedAt,
		Services:        []transport.LeadServiceResponse{},
		EnergyLabel:     energyLabelFromLead(lead),
		LeadEnrichment:  leadEnrichmentFromLead(lead),
		LeadScore:       leadScoreFromLead(lead),
		Consumer: transport.ConsumerResponse{
			FirstName: lead.ConsumerFirstName,
			LastName:  lead.ConsumerLastName,
			Phone:     lead.ConsumerPhone,
			Email:     lead.ConsumerEmail,
			Role:      transport.ConsumerRole(lead.ConsumerRole),
		},
		Address: transport.AddressResponse{
			Street:      lead.AddressStreet,
			HouseNumber: lead.AddressHouseNumber,
			ZipCode:     lead.AddressZipCode,
			City:        lead.AddressCity,
			Latitude:    lead.Latitude,
			Longitude:   lead.Longitude,
		},
	}
}

// ToLeadResponseWithServices converts a repository Lead with services to a transport LeadResponse.
func ToLeadResponseWithServices(lead repository.Lead, services []repository.LeadService) transport.LeadResponse {
	resp := ToLeadResponse(lead)

	resp.Services = make([]transport.LeadServiceResponse, len(services))
	for i, svc := range services {
		resp.Services[i] = ToLeadServiceResponse(svc)
	}

	// Set current service (first non-terminal or first if all terminal)
	if len(services) > 0 {
		for _, svc := range services {
			if svc.Status != "Closed" && svc.Status != "Bad_Lead" && svc.Status != "Surveyed" {
				svcResp := ToLeadServiceResponse(svc)
				resp.CurrentService = &svcResp
				status := transport.LeadStatus(svc.Status)
				resp.AggregateStatus = &status
				break
			}
		}
		if resp.CurrentService == nil {
			svcResp := ToLeadServiceResponse(services[0])
			resp.CurrentService = &svcResp
			status := transport.LeadStatus(services[0].Status)
			resp.AggregateStatus = &status
		}
	}

	return resp
}

// ToLeadServiceResponse converts a repository LeadService to a transport LeadServiceResponse.
func ToLeadServiceResponse(svc repository.LeadService) transport.LeadServiceResponse {
	resp := transport.LeadServiceResponse{
		ID:            svc.ID,
		ServiceType:   transport.ServiceType(svc.ServiceType),
		Status:        transport.LeadStatus(svc.Status),
		PipelineStage: transport.PipelineStage(svc.PipelineStage),
		Preferences:   leadPreferencesFromService(svc),
		ConsumerNote:  svc.ConsumerNote,
		CreatedAt:     svc.CreatedAt,
		UpdatedAt:     svc.UpdatedAt,
	}

	return resp
}

func leadPreferencesFromService(svc repository.LeadService) *transport.LeadPreferencesResponse {
	if len(svc.CustomerPreferences) == 0 {
		return nil
	}

	var raw struct {
		Budget       string `json:"budget"`
		Timeframe    string `json:"timeframe"`
		Availability string `json:"availability"`
		ExtraNotes   string `json:"extraNotes"`
	}
	if err := json.Unmarshal(svc.CustomerPreferences, &raw); err != nil {
		return nil
	}

	prefs := transport.LeadPreferencesResponse{
		Budget:       normalizePreference(raw.Budget),
		Timeframe:    normalizePreference(raw.Timeframe),
		Availability: normalizePreference(raw.Availability),
		ExtraNotes:   normalizePreference(raw.ExtraNotes),
	}

	if prefs.Budget == nil && prefs.Timeframe == nil && prefs.Availability == nil && prefs.ExtraNotes == nil {
		return nil
	}

	return &prefs
}

func normalizePreference(value string) *string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return nil
	}
	return &trimmed
}
</file>

<file path="internal/leads/notes/service.go">
// Package notes handles lead note operations.
// This is a vertically sliced feature package containing service logic
// for creating and listing notes on RAC_leads.
package notes

import (
	"context"
	"errors"
	"strings"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
)

// ValidNoteTypes defines the allowed note types.
var ValidNoteTypes = map[string]bool{
	"note":   true,
	"call":   true,
	"text":   true,
	"email":  true,
	"system": true,
}

// Repository defines the data access interface needed by the notes service.
// This is a consumer-driven interface - only what notes needs.
type Repository interface {
	// LeadExistenceChecker
	GetByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (repository.Lead, error)
	// NoteStore
	CreateLeadNote(ctx context.Context, params repository.CreateLeadNoteParams) (repository.LeadNote, error)
	ListLeadNotes(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]repository.LeadNote, error)
}

// Service handles lead note operations.
type Service struct {
	repo Repository
}

// New creates a new notes service.
func New(repo Repository) *Service {
	return &Service{repo: repo}
}

// Add adds a new note to a lead.
func (s *Service) Add(ctx context.Context, leadID uuid.UUID, authorID uuid.UUID, tenantID uuid.UUID, req transport.CreateLeadNoteRequest) (transport.LeadNoteResponse, error) {
	body := strings.TrimSpace(req.Body)
	if body == "" || len(body) > 2000 {
		return transport.LeadNoteResponse{}, apperr.Validation("note body must be between 1 and 2000 characters")
	}

	noteType := strings.TrimSpace(req.Type)
	if noteType == "" {
		noteType = "note"
	}
	if !ValidNoteTypes[noteType] {
		return transport.LeadNoteResponse{}, apperr.Validation("invalid note type")
	}

	// Parse optional service ID
	var serviceID *uuid.UUID
	if req.ServiceID != nil && *req.ServiceID != "" {
		parsed, err := uuid.Parse(*req.ServiceID)
		if err != nil {
			return transport.LeadNoteResponse{}, apperr.Validation("invalid serviceId")
		}
		serviceID = &parsed
	}

	// Verify lead exists
	if _, err := s.repo.GetByID(ctx, leadID, tenantID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadNoteResponse{}, apperr.NotFound("lead not found")
		}
		return transport.LeadNoteResponse{}, err
	}

	note, err := s.repo.CreateLeadNote(ctx, repository.CreateLeadNoteParams{
		LeadID:         leadID,
		OrganizationID: tenantID,
		AuthorID:       authorID,
		Type:           noteType,
		Body:           body,
		ServiceID:      serviceID,
	})
	if err != nil {
		return transport.LeadNoteResponse{}, err
	}

	return toLeadNoteResponse(note), nil
}

// List retrieves all notes for a lead.
func (s *Service) List(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) (transport.LeadNotesResponse, error) {
	// Verify lead exists
	if _, err := s.repo.GetByID(ctx, leadID, tenantID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadNotesResponse{}, apperr.NotFound("lead not found")
		}
		return transport.LeadNotesResponse{}, err
	}

	notesList, err := s.repo.ListLeadNotes(ctx, leadID, tenantID)
	if err != nil {
		return transport.LeadNotesResponse{}, err
	}

	items := make([]transport.LeadNoteResponse, len(notesList))
	for i, note := range notesList {
		items[i] = toLeadNoteResponse(note)
	}

	return transport.LeadNotesResponse{Items: items}, nil
}

func toLeadNoteResponse(note repository.LeadNote) transport.LeadNoteResponse {
	return transport.LeadNoteResponse{
		ID:          note.ID,
		LeadID:      note.LeadID,
		AuthorID:    note.AuthorID,
		AuthorEmail: note.AuthorEmail,
		Type:        note.Type,
		Body:        note.Body,
		CreatedAt:   note.CreatedAt,
		UpdatedAt:   note.UpdatedAt,
	}
}
</file>

<file path="internal/leads/photo_analysis_batcher.go">
package leads

import (
	"strings"
	"sync"
	"time"

	"portal_final_backend/internal/leads/handler"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
)

type photoAnalysisBatch struct {
	leadID   uuid.UUID
	tenantID uuid.UUID
	timer    *time.Timer
}

type photoAnalysisBatcher struct {
	mu      sync.Mutex
	window  time.Duration
	batches map[uuid.UUID]*photoAnalysisBatch
	handler *handler.PhotoAnalysisHandler
	log     *logger.Logger
}

func newPhotoAnalysisBatcher(handler *handler.PhotoAnalysisHandler, window time.Duration, log *logger.Logger) *photoAnalysisBatcher {
	return &photoAnalysisBatcher{
		window:  window,
		batches: make(map[uuid.UUID]*photoAnalysisBatch),
		handler: handler,
		log:     log,
	}
}

func (b *photoAnalysisBatcher) OnImageUploaded(leadID, serviceID, tenantID uuid.UUID) {
	if b.handler == nil {
		return
	}

	triggerImmediate := false

	b.mu.Lock()
	batch, exists := b.batches[serviceID]
	if !exists {
		batch = &photoAnalysisBatch{}
		b.batches[serviceID] = batch
		triggerImmediate = true
	}
	batch.leadID = leadID
	batch.tenantID = tenantID

	if batch.timer != nil {
		batch.timer.Stop()
	}

	batch.timer = time.AfterFunc(b.window, func() {
		b.triggerBatch(serviceID)
	})
	b.mu.Unlock()

	if triggerImmediate {
		b.handler.RunAutoAnalysis(leadID, serviceID, tenantID)
	}
}

func (b *photoAnalysisBatcher) triggerBatch(serviceID uuid.UUID) {
	b.mu.Lock()
	batch, ok := b.batches[serviceID]
	if !ok {
		b.mu.Unlock()
		return
	}
	leadID := batch.leadID
	tenantID := batch.tenantID
	delete(b.batches, serviceID)
	b.mu.Unlock()

	b.handler.RunAutoAnalysis(leadID, serviceID, tenantID)
}

func isImageContentType(contentType string) bool {
	return strings.HasPrefix(contentType, "image/")
}
</file>

<file path="internal/leads/ports/offer_summary.go">
package ports

import (
	"context"

	"github.com/google/uuid"
)

// OfferSummaryItem is a minimal summary line item.
type OfferSummaryItem struct {
	Description string
	Quantity    string
}

// OfferSummaryInput contains non-PII fields for summary generation.
type OfferSummaryInput struct {
	LeadID        uuid.UUID
	LeadServiceID uuid.UUID
	ServiceType   string
	Scope         *string
	UrgencyLevel  *string
	Items         []OfferSummaryItem
}

// OfferSummaryGenerator produces a markdown summary for partner offers.
type OfferSummaryGenerator interface {
	GenerateOfferSummary(ctx context.Context, tenantID uuid.UUID, input OfferSummaryInput) (string, error)
}
</file>

<file path="internal/leads/repository/attachments.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var ErrAttachmentNotFound = errors.New("attachment not found")

// Attachment represents a file attachment for a lead service.
type Attachment struct {
	ID             uuid.UUID
	LeadServiceID  uuid.UUID
	OrganizationID uuid.UUID
	FileKey        string
	FileName       string
	ContentType    *string
	SizeBytes      *int64
	UploadedBy     *uuid.UUID
	CreatedAt      time.Time
}

// CreateAttachmentParams contains parameters for creating an attachment record.
type CreateAttachmentParams struct {
	LeadServiceID  uuid.UUID
	OrganizationID uuid.UUID
	FileKey        string
	FileName       string
	ContentType    string
	SizeBytes      int64
	UploadedBy     *uuid.UUID
}

// CreateAttachment inserts a new attachment record.
func (r *Repository) CreateAttachment(ctx context.Context, params CreateAttachmentParams) (Attachment, error) {
	var att Attachment
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_lead_service_attachments (lead_service_id, organization_id, file_key, file_name, content_type, size_bytes, uploaded_by)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, lead_service_id, organization_id, file_key, file_name, content_type, size_bytes, uploaded_by, created_at
	`, params.LeadServiceID, params.OrganizationID, params.FileKey, params.FileName, params.ContentType, params.SizeBytes, params.UploadedBy).Scan(
		&att.ID, &att.LeadServiceID, &att.OrganizationID, &att.FileKey, &att.FileName, &att.ContentType, &att.SizeBytes, &att.UploadedBy, &att.CreatedAt,
	)
	return att, err
}

// GetAttachmentByID retrieves an attachment by ID, scoped to organization.
func (r *Repository) GetAttachmentByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Attachment, error) {
	var att Attachment
	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_service_id, organization_id, file_key, file_name, content_type, size_bytes, uploaded_by, created_at
		FROM RAC_lead_service_attachments
		WHERE id = $1 AND organization_id = $2
	`, id, organizationID).Scan(
		&att.ID, &att.LeadServiceID, &att.OrganizationID, &att.FileKey, &att.FileName, &att.ContentType, &att.SizeBytes, &att.UploadedBy, &att.CreatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Attachment{}, ErrAttachmentNotFound
	}
	return att, err
}

// ListAttachmentsByService retrieves all attachments for a lead service.
func (r *Repository) ListAttachmentsByService(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) ([]Attachment, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_service_id, organization_id, file_key, file_name, content_type, size_bytes, uploaded_by, created_at
		FROM RAC_lead_service_attachments
		WHERE lead_service_id = $1 AND organization_id = $2
		ORDER BY created_at DESC
	`, leadServiceID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	attachments := make([]Attachment, 0)
	for rows.Next() {
		var att Attachment
		if err := rows.Scan(
			&att.ID, &att.LeadServiceID, &att.OrganizationID, &att.FileKey, &att.FileName, &att.ContentType, &att.SizeBytes, &att.UploadedBy, &att.CreatedAt,
		); err != nil {
			return nil, err
		}
		attachments = append(attachments, att)
	}
	return attachments, rows.Err()
}

// DeleteAttachment removes an attachment record by ID.
func (r *Repository) DeleteAttachment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	result, err := r.pool.Exec(ctx, `
		DELETE FROM RAC_lead_service_attachments
		WHERE id = $1 AND organization_id = $2
	`, id, organizationID)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrAttachmentNotFound
	}
	return nil
}
</file>

<file path="internal/leads/repository/feed_social.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// 
// Reaction SQL
// 

func (r *Repository) ToggleReaction(ctx context.Context, eventID, eventSource, reactionType string, userID, orgID uuid.UUID) (exists bool, err error) {
	// Try delete first  if a row was removed, the toggle means "remove"
	tag, err := r.pool.Exec(ctx, `
		DELETE FROM RAC_feed_reactions
		WHERE event_id      = $1
		  AND event_source  = $2
		  AND reaction_type = $3
		  AND user_id       = $4
		  AND org_id        = $5
	`, eventID, eventSource, reactionType, userID, orgID)
	if err != nil {
		return false, err
	}
	if tag.RowsAffected() > 0 {
		return false, nil // removed
	}

	// Not present  insert
	_, err = r.pool.Exec(ctx, `
		INSERT INTO RAC_feed_reactions (event_id, event_source, reaction_type, user_id, org_id)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT DO NOTHING
	`, eventID, eventSource, reactionType, userID, orgID)
	if err != nil {
		return false, err
	}
	return true, nil
}

func (r *Repository) ListReactionsByEvent(ctx context.Context, eventID, eventSource string, orgID uuid.UUID) ([]FeedReaction, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT fr.id, fr.event_id, fr.event_source, fr.reaction_type, fr.user_id, u.email, fr.created_at
		FROM RAC_feed_reactions fr
		JOIN RAC_users u ON u.id = fr.user_id
		WHERE fr.event_id     = $1
		  AND fr.event_source = $2
		  AND fr.org_id       = $3
		ORDER BY fr.created_at
	`, eventID, eventSource, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []FeedReaction
	for rows.Next() {
		var r FeedReaction
		if err := rows.Scan(&r.ID, &r.EventID, &r.EventSource, &r.ReactionType, &r.UserID, &r.UserEmail, &r.CreatedAt); err != nil {
			return nil, err
		}
		out = append(out, r)
	}
	return out, rows.Err()
}

// ListReactionsByEvents returns reactions for a batch of event IDs (used by feed enrichment).
func (r *Repository) ListReactionsByEvents(ctx context.Context, eventIDs []string, orgID uuid.UUID) ([]FeedReaction, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT fr.id, fr.event_id, fr.event_source, fr.reaction_type, fr.user_id, u.email, fr.created_at
		FROM RAC_feed_reactions fr
		JOIN RAC_users u ON u.id = fr.user_id
		WHERE fr.event_id = ANY($1)
		  AND fr.org_id   = $2
		ORDER BY fr.event_id, fr.created_at
	`, eventIDs, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []FeedReaction
	for rows.Next() {
		var r FeedReaction
		if err := rows.Scan(&r.ID, &r.EventID, &r.EventSource, &r.ReactionType, &r.UserID, &r.UserEmail, &r.CreatedAt); err != nil {
			return nil, err
		}
		out = append(out, r)
	}
	return out, rows.Err()
}

// 
// Comment SQL
// 

func (r *Repository) CreateComment(ctx context.Context, eventID, eventSource string, userID, orgID uuid.UUID, body string, mentionIDs []uuid.UUID) (FeedComment, error) {
	var c FeedComment
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_feed_comments (event_id, event_source, user_id, org_id, body)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, event_id, event_source, user_id, org_id, body, created_at, updated_at
	`, eventID, eventSource, userID, orgID, body).Scan(
		&c.ID, &c.EventID, &c.EventSource, &c.UserID, &c.OrgID, &c.Body, &c.CreatedAt, &c.UpdatedAt,
	)
	if err != nil {
		return FeedComment{}, err
	}

	// Insert mentions
	for _, mentionedID := range mentionIDs {
		_, _ = r.pool.Exec(ctx, `
			INSERT INTO RAC_feed_comment_mentions (comment_id, mentioned_user_id)
			VALUES ($1, $2)
			ON CONFLICT DO NOTHING
		`, c.ID, mentionedID)
	}

	return c, nil
}

func (r *Repository) ListCommentsByEvent(ctx context.Context, eventID, eventSource string, orgID uuid.UUID) ([]FeedCommentWithAuthor, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT c.id, c.event_id, c.event_source, c.user_id, u.email, c.body, c.created_at, c.updated_at
		FROM RAC_feed_comments c
		JOIN RAC_users u ON u.id = c.user_id
		WHERE c.event_id     = $1
		  AND c.event_source = $2
		  AND c.org_id       = $3
		ORDER BY c.created_at ASC
	`, eventID, eventSource, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []FeedCommentWithAuthor
	for rows.Next() {
		var c FeedCommentWithAuthor
		if err := rows.Scan(&c.ID, &c.EventID, &c.EventSource, &c.UserID, &c.UserEmail, &c.Body, &c.CreatedAt, &c.UpdatedAt); err != nil {
			return nil, err
		}
		out = append(out, c)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	// Batch-load mentions for all returned comments
	if len(out) > 0 {
		commentIDs := make([]uuid.UUID, len(out))
		for i, c := range out {
			commentIDs[i] = c.ID
		}
		mentions, err := r.listMentionsByComments(ctx, commentIDs)
		if err != nil {
			return nil, err
		}
		for i := range out {
			out[i].Mentions = mentions[out[i].ID]
		}
	}

	return out, nil
}

func (r *Repository) DeleteComment(ctx context.Context, commentID uuid.UUID, userID, orgID uuid.UUID) error {
	tag, err := r.pool.Exec(ctx, `
		DELETE FROM RAC_feed_comments
		WHERE id      = $1
		  AND user_id = $2
		  AND org_id  = $3
	`, commentID, userID, orgID)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

// ListCommentCountsByEvents returns comment counts per event_id for a batch (feed enrichment).
func (r *Repository) ListCommentCountsByEvents(ctx context.Context, eventIDs []string, orgID uuid.UUID) (map[string]int, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT event_id, COUNT(*)::int
		FROM RAC_feed_comments
		WHERE event_id = ANY($1)
		  AND org_id   = $2
		GROUP BY event_id
	`, eventIDs, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	out := make(map[string]int)
	for rows.Next() {
		var id string
		var cnt int
		if err := rows.Scan(&id, &cnt); err != nil {
			return nil, err
		}
		out[id] = cnt
	}
	return out, rows.Err()
}

// 
// Mentions helper
// 

func (r *Repository) listMentionsByComments(ctx context.Context, commentIDs []uuid.UUID) (map[uuid.UUID][]CommentMention, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT m.comment_id, m.mentioned_user_id, u.email
		FROM RAC_feed_comment_mentions m
		JOIN RAC_users u ON u.id = m.mentioned_user_id
		WHERE m.comment_id = ANY($1)
		ORDER BY m.created_at
	`, commentIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	out := make(map[uuid.UUID][]CommentMention)
	for rows.Next() {
		var commentID uuid.UUID
		var m CommentMention
		if err := rows.Scan(&commentID, &m.UserID, &m.Email); err != nil {
			return nil, err
		}
		out[commentID] = append(out[commentID], m)
	}
	return out, rows.Err()
}

// 
// Org members (for @-mention autocomplete)
// 

func (r *Repository) ListOrgMembers(ctx context.Context, orgID uuid.UUID) ([]OrgMember, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT u.id, u.email
		FROM RAC_organization_members om
		JOIN RAC_users u ON u.id = om.user_id
		WHERE om.organization_id = $1
		ORDER BY u.email
	`, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []OrgMember
	for rows.Next() {
		var m OrgMember
		if err := rows.Scan(&m.ID, &m.Email); err != nil {
			return nil, err
		}
		out = append(out, m)
	}
	return out, rows.Err()
}

// 
// Structs
// 

type FeedReaction struct {
	ID           uuid.UUID
	EventID      string
	EventSource  string
	ReactionType string
	UserID       uuid.UUID
	UserEmail    string
	CreatedAt    time.Time
}

type FeedComment struct {
	ID          uuid.UUID
	EventID     string
	EventSource string
	UserID      uuid.UUID
	OrgID       uuid.UUID
	Body        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type FeedCommentWithAuthor struct {
	ID          uuid.UUID
	EventID     string
	EventSource string
	UserID      uuid.UUID
	UserEmail   string
	Body        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Mentions    []CommentMention
}

type CommentMention struct {
	UserID uuid.UUID
	Email  string
}

type OrgMember struct {
	ID    uuid.UUID
	Email string
}
</file>

<file path="internal/leads/repository/notes.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

type LeadNote struct {
	ID             uuid.UUID
	LeadID         uuid.UUID
	OrganizationID uuid.UUID
	AuthorID       uuid.UUID
	AuthorEmail    string
	Type           string
	Body           string
	ServiceID      *uuid.UUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

type CreateLeadNoteParams struct {
	LeadID         uuid.UUID
	OrganizationID uuid.UUID
	AuthorID       uuid.UUID
	Type           string
	Body           string
	ServiceID      *uuid.UUID
}

func (r *Repository) CreateLeadNote(ctx context.Context, params CreateLeadNoteParams) (LeadNote, error) {
	var note LeadNote
	query := `
		WITH inserted AS (
			INSERT INTO RAC_lead_notes (lead_id, organization_id, author_id, type, body, service_id)
			VALUES ($1, $2, $3, $4, $5, $6)
			RETURNING id, lead_id, organization_id, author_id, type, body, service_id, created_at, updated_at
		)
		SELECT inserted.id, inserted.lead_id, inserted.organization_id, inserted.author_id, u.email, inserted.type, inserted.body, inserted.service_id, inserted.created_at, inserted.updated_at
		FROM inserted
		JOIN RAC_users u ON u.id = inserted.author_id
	`

	err := r.pool.QueryRow(ctx, query, params.LeadID, params.OrganizationID, params.AuthorID, params.Type, params.Body, params.ServiceID).Scan(
		&note.ID,
		&note.LeadID,
		&note.OrganizationID,
		&note.AuthorID,
		&note.AuthorEmail,
		&note.Type,
		&note.Body,
		&note.ServiceID,
		&note.CreatedAt,
		&note.UpdatedAt,
	)
	return note, err
}

func (r *Repository) ListLeadNotes(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]LeadNote, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT ln.id, ln.lead_id, ln.organization_id, ln.author_id, u.email, ln.type, ln.body, ln.service_id, ln.created_at, ln.updated_at
		FROM RAC_lead_notes ln
		JOIN RAC_users u ON u.id = ln.author_id
		WHERE ln.lead_id = $1 AND ln.organization_id = $2
		ORDER BY ln.created_at DESC
	`, leadID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	notes := make([]LeadNote, 0)
	for rows.Next() {
		var note LeadNote
		if err := rows.Scan(
			&note.ID,
			&note.LeadID,
			&note.OrganizationID,
			&note.AuthorID,
			&note.AuthorEmail,
			&note.Type,
			&note.Body,
			&note.ServiceID,
			&note.CreatedAt,
			&note.UpdatedAt,
		); err != nil {
			return nil, err
		}
		notes = append(notes, note)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return notes, nil
}

// ListNotesByService returns notes scoped to a specific service (including notes
// with no service_id for backward compatibility with pre-migration data).
func (r *Repository) ListNotesByService(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, organizationID uuid.UUID) ([]LeadNote, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT ln.id, ln.lead_id, ln.organization_id, ln.author_id, u.email, ln.type, ln.body, ln.service_id, ln.created_at, ln.updated_at
		FROM RAC_lead_notes ln
		JOIN RAC_users u ON u.id = ln.author_id
		WHERE ln.lead_id = $1 AND ln.organization_id = $2 AND (ln.service_id = $3 OR ln.service_id IS NULL)
		ORDER BY ln.created_at DESC
	`, leadID, organizationID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	notes := make([]LeadNote, 0)
	for rows.Next() {
		var note LeadNote
		if err := rows.Scan(
			&note.ID,
			&note.LeadID,
			&note.OrganizationID,
			&note.AuthorID,
			&note.AuthorEmail,
			&note.Type,
			&note.Body,
			&note.ServiceID,
			&note.CreatedAt,
			&note.UpdatedAt,
		); err != nil {
			return nil, err
		}
		notes = append(notes, note)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return notes, nil
}
</file>

<file path="internal/leads/repository/partners.go">
package repository

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type PartnerMatch struct {
	ID           uuid.UUID
	BusinessName string
	Email        string
	DistanceKm   float64
}

func (r *Repository) FindMatchingPartners(ctx context.Context, organizationID uuid.UUID, serviceType string, zipCode string, radiusKm int, excludePartnerIDs []uuid.UUID) ([]PartnerMatch, error) {
	lat, lon, ok, err := r.lookupZipCoordinates(ctx, organizationID, zipCode)
	if err != nil {
		return nil, err
	}
	if !ok {
		return []PartnerMatch{}, nil
	}

	rows, err := r.pool.Query(ctx, `
		SELECT p.id, p.business_name, p.contact_email,
			earth_distance(ll_to_earth($2, $1), ll_to_earth(p.latitude, p.longitude)) / 1000.0 AS dist_km
		FROM RAC_partners p
		JOIN RAC_partner_service_types pst ON pst.partner_id = p.id
		JOIN RAC_service_types st ON st.id = pst.service_type_id AND st.organization_id = p.organization_id
		WHERE p.organization_id = $3
			AND st.is_active = true
			AND (st.name = $4 OR st.slug = $4)
			AND p.latitude IS NOT NULL AND p.longitude IS NOT NULL
			AND earth_distance(ll_to_earth($2, $1), ll_to_earth(p.latitude, p.longitude)) <= ($5 * 1000.0)
			AND (CARDINALITY($6::uuid[]) = 0 OR p.id != ALL($6::uuid[]))
		ORDER BY dist_km ASC
		LIMIT 5
	`, lon, lat, organizationID, serviceType, radiusKm, excludePartnerIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	matches := make([]PartnerMatch, 0)
	for rows.Next() {
		var match PartnerMatch
		if err := rows.Scan(&match.ID, &match.BusinessName, &match.Email, &match.DistanceKm); err != nil {
			return nil, err
		}
		matches = append(matches, match)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return matches, nil
}

// GetInvitedPartnerIDs returns IDs of partners who have already received an offer for this service.
func (r *Repository) GetInvitedPartnerIDs(ctx context.Context, serviceID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT partner_id
		FROM RAC_partner_offers
		WHERE lead_service_id = $1
			AND status IN ('rejected', 'expired', 'sent', 'pending')
	`, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ids := make([]uuid.UUID, 0)
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return ids, nil
}

func (r *Repository) lookupZipCoordinates(ctx context.Context, organizationID uuid.UUID, zipCode string) (float64, float64, bool, error) {
	var lat float64
	var lon float64

	err := r.pool.QueryRow(ctx, `
		SELECT latitude, longitude
		FROM RAC_leads
		WHERE organization_id = $1
			AND address_zip_code = $2
			AND latitude IS NOT NULL
			AND longitude IS NOT NULL
		ORDER BY created_at DESC
		LIMIT 1
	`, organizationID, zipCode).Scan(&lat, &lon)
	if errors.Is(err, pgx.ErrNoRows) {
		return 0, 0, false, nil
	}
	if err != nil {
		return 0, 0, false, err
	}

	return lat, lon, true, nil
}
</file>

<file path="internal/leads/repository/photo_analysis.go">
package repository

import (
	"context"
	"encoding/json"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var ErrPhotoAnalysisNotFound = errors.New("photo analysis not found")

// Measurement represents a single measurement extracted from a photo.
type Measurement struct {
	Description string  `json:"description"`
	Value       float64 `json:"value"`
	Unit        string  `json:"unit"`       // m, m, mm, cm, count
	Type        string  `json:"type"`       // dimension, area, count, volume
	Confidence  string  `json:"confidence"` // High, Medium, Low
	PhotoRef    string  `json:"photoRef,omitempty"`
}

// PhotoAnalysis represents a forensic AI analysis of photos for a lead service.
type PhotoAnalysis struct {
	ID              uuid.UUID `json:"id"`
	LeadID          uuid.UUID `json:"leadId"`
	ServiceID       uuid.UUID `json:"serviceId"`
	OrganizationID  uuid.UUID `json:"-"`
	Summary         string    `json:"summary"`
	Observations    []string  `json:"observations"`
	ScopeAssessment string    `json:"scopeAssessment"`
	CostIndicators  string    `json:"costIndicators"`
	SafetyConcerns  []string  `json:"safetyConcerns"`
	AdditionalInfo  []string  `json:"additionalInfo"`
	ConfidenceLevel string    `json:"confidenceLevel"`
	PhotoCount      int       `json:"photoCount"`

	// v2 forensic fields
	Measurements           []Measurement `json:"measurements"`
	NeedsOnsiteMeasurement []string      `json:"needsOnsiteMeasurement"`
	Discrepancies          []string      `json:"discrepancies"`
	ExtractedText          []string      `json:"extractedText"`
	SuggestedSearchTerms   []string      `json:"suggestedSearchTerms"`

	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// CreatePhotoAnalysisParams contains parameters for creating a photo analysis.
type CreatePhotoAnalysisParams struct {
	LeadID          uuid.UUID
	ServiceID       uuid.UUID
	OrganizationID  uuid.UUID
	Summary         string
	Observations    []string
	ScopeAssessment string
	CostIndicators  string
	SafetyConcerns  []string
	AdditionalInfo  []string
	ConfidenceLevel string
	PhotoCount      int

	// v2 forensic fields
	Measurements           []Measurement
	NeedsOnsiteMeasurement []string
	Discrepancies          []string
	ExtractedText          []string
	SuggestedSearchTerms   []string
}

// CreatePhotoAnalysis inserts a new photo analysis record.
func (r *Repository) CreatePhotoAnalysis(ctx context.Context, params CreatePhotoAnalysisParams) (PhotoAnalysis, error) {
	observationsJSON, _ := json.Marshal(params.Observations)
	safetyConcernsJSON, _ := json.Marshal(params.SafetyConcerns)
	additionalInfoJSON, _ := json.Marshal(params.AdditionalInfo)
	measurementsJSON, _ := json.Marshal(params.Measurements)
	needsOnsiteJSON, _ := json.Marshal(params.NeedsOnsiteMeasurement)
	discrepanciesJSON, _ := json.Marshal(params.Discrepancies)
	extractedTextJSON, _ := json.Marshal(params.ExtractedText)
	suggestedTermsJSON, _ := json.Marshal(params.SuggestedSearchTerms)

	var pa PhotoAnalysis
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_lead_photo_analyses 
			(lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			 safety_concerns, additional_info, confidence_level, photo_count,
			 measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
		RETURNING id, lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			safety_concerns, additional_info, confidence_level, photo_count,
			measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms,
			created_at, updated_at
	`, params.LeadID, params.ServiceID, params.OrganizationID, params.Summary, observationsJSON, params.ScopeAssessment,
		params.CostIndicators, safetyConcernsJSON, additionalInfoJSON, params.ConfidenceLevel, params.PhotoCount,
		measurementsJSON, needsOnsiteJSON, discrepanciesJSON, extractedTextJSON, suggestedTermsJSON,
	).Scan(
		&pa.ID, &pa.LeadID, &pa.ServiceID, &pa.OrganizationID, &pa.Summary, &observationsJSON, &pa.ScopeAssessment,
		&pa.CostIndicators, &safetyConcernsJSON, &additionalInfoJSON, &pa.ConfidenceLevel, &pa.PhotoCount,
		&measurementsJSON, &needsOnsiteJSON, &discrepanciesJSON, &extractedTextJSON, &suggestedTermsJSON,
		&pa.CreatedAt, &pa.UpdatedAt,
	)
	if err != nil {
		return PhotoAnalysis{}, err
	}

	// Parse JSON arrays
	_ = json.Unmarshal(observationsJSON, &pa.Observations)
	_ = json.Unmarshal(safetyConcernsJSON, &pa.SafetyConcerns)
	_ = json.Unmarshal(additionalInfoJSON, &pa.AdditionalInfo)
	_ = json.Unmarshal(measurementsJSON, &pa.Measurements)
	_ = json.Unmarshal(needsOnsiteJSON, &pa.NeedsOnsiteMeasurement)
	_ = json.Unmarshal(discrepanciesJSON, &pa.Discrepancies)
	_ = json.Unmarshal(extractedTextJSON, &pa.ExtractedText)
	_ = json.Unmarshal(suggestedTermsJSON, &pa.SuggestedSearchTerms)

	return pa, nil
}

// GetPhotoAnalysisByID retrieves a photo analysis by ID, scoped to organization.
func (r *Repository) GetPhotoAnalysisByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (PhotoAnalysis, error) {
	var pa PhotoAnalysis
	var observationsJSON, safetyConcernsJSON, additionalInfoJSON []byte
	var measurementsJSON, needsOnsiteJSON, discrepanciesJSON, extractedTextJSON, suggestedTermsJSON []byte

	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			safety_concerns, additional_info, confidence_level, photo_count,
			measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms,
			created_at, updated_at
		FROM RAC_lead_photo_analyses
		WHERE id = $1 AND org_id = $2
	`, id, organizationID).Scan(
		&pa.ID, &pa.LeadID, &pa.ServiceID, &pa.OrganizationID, &pa.Summary, &observationsJSON, &pa.ScopeAssessment,
		&pa.CostIndicators, &safetyConcernsJSON, &additionalInfoJSON, &pa.ConfidenceLevel, &pa.PhotoCount,
		&measurementsJSON, &needsOnsiteJSON, &discrepanciesJSON, &extractedTextJSON, &suggestedTermsJSON,
		&pa.CreatedAt, &pa.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return PhotoAnalysis{}, ErrPhotoAnalysisNotFound
	}
	if err != nil {
		return PhotoAnalysis{}, err
	}

	_ = json.Unmarshal(observationsJSON, &pa.Observations)
	_ = json.Unmarshal(safetyConcernsJSON, &pa.SafetyConcerns)
	_ = json.Unmarshal(additionalInfoJSON, &pa.AdditionalInfo)
	_ = json.Unmarshal(measurementsJSON, &pa.Measurements)
	_ = json.Unmarshal(needsOnsiteJSON, &pa.NeedsOnsiteMeasurement)
	_ = json.Unmarshal(discrepanciesJSON, &pa.Discrepancies)
	_ = json.Unmarshal(extractedTextJSON, &pa.ExtractedText)
	_ = json.Unmarshal(suggestedTermsJSON, &pa.SuggestedSearchTerms)

	return pa, nil
}

// GetLatestPhotoAnalysis retrieves the most recent photo analysis for a service.
func (r *Repository) GetLatestPhotoAnalysis(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) (PhotoAnalysis, error) {
	var pa PhotoAnalysis
	var observationsJSON, safetyConcernsJSON, additionalInfoJSON []byte
	var measurementsJSON, needsOnsiteJSON, discrepanciesJSON, extractedTextJSON, suggestedTermsJSON []byte

	err := r.pool.QueryRow(ctx, `
		SELECT id, lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			safety_concerns, additional_info, confidence_level, photo_count,
			measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms,
			created_at, updated_at
		FROM RAC_lead_photo_analyses
		WHERE service_id = $1 AND org_id = $2
		ORDER BY created_at DESC
		LIMIT 1
	`, serviceID, organizationID).Scan(
		&pa.ID, &pa.LeadID, &pa.ServiceID, &pa.OrganizationID, &pa.Summary, &observationsJSON, &pa.ScopeAssessment,
		&pa.CostIndicators, &safetyConcernsJSON, &additionalInfoJSON, &pa.ConfidenceLevel, &pa.PhotoCount,
		&measurementsJSON, &needsOnsiteJSON, &discrepanciesJSON, &extractedTextJSON, &suggestedTermsJSON,
		&pa.CreatedAt, &pa.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return PhotoAnalysis{}, ErrPhotoAnalysisNotFound
	}
	if err != nil {
		return PhotoAnalysis{}, err
	}

	_ = json.Unmarshal(observationsJSON, &pa.Observations)
	_ = json.Unmarshal(safetyConcernsJSON, &pa.SafetyConcerns)
	_ = json.Unmarshal(additionalInfoJSON, &pa.AdditionalInfo)
	_ = json.Unmarshal(measurementsJSON, &pa.Measurements)
	_ = json.Unmarshal(needsOnsiteJSON, &pa.NeedsOnsiteMeasurement)
	_ = json.Unmarshal(discrepanciesJSON, &pa.Discrepancies)
	_ = json.Unmarshal(extractedTextJSON, &pa.ExtractedText)
	_ = json.Unmarshal(suggestedTermsJSON, &pa.SuggestedSearchTerms)

	return pa, nil
}

// ListPhotoAnalysesByService retrieves all photo analyses for a service.
func (r *Repository) ListPhotoAnalysesByService(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) ([]PhotoAnalysis, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			safety_concerns, additional_info, confidence_level, photo_count,
			measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms,
			created_at, updated_at
		FROM RAC_lead_photo_analyses
		WHERE service_id = $1 AND org_id = $2
		ORDER BY created_at DESC
	`, serviceID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	analyses := make([]PhotoAnalysis, 0)
	for rows.Next() {
		var pa PhotoAnalysis
		var observationsJSON, safetyConcernsJSON, additionalInfoJSON []byte
		var measurementsJSON, needsOnsiteJSON, discrepanciesJSON, extractedTextJSON, suggestedTermsJSON []byte

		if err := rows.Scan(
			&pa.ID, &pa.LeadID, &pa.ServiceID, &pa.OrganizationID, &pa.Summary, &observationsJSON, &pa.ScopeAssessment,
			&pa.CostIndicators, &safetyConcernsJSON, &additionalInfoJSON, &pa.ConfidenceLevel, &pa.PhotoCount,
			&measurementsJSON, &needsOnsiteJSON, &discrepanciesJSON, &extractedTextJSON, &suggestedTermsJSON,
			&pa.CreatedAt, &pa.UpdatedAt,
		); err != nil {
			return nil, err
		}

		_ = json.Unmarshal(observationsJSON, &pa.Observations)
		_ = json.Unmarshal(safetyConcernsJSON, &pa.SafetyConcerns)
		_ = json.Unmarshal(additionalInfoJSON, &pa.AdditionalInfo)
		_ = json.Unmarshal(measurementsJSON, &pa.Measurements)
		_ = json.Unmarshal(needsOnsiteJSON, &pa.NeedsOnsiteMeasurement)
		_ = json.Unmarshal(discrepanciesJSON, &pa.Discrepancies)
		_ = json.Unmarshal(extractedTextJSON, &pa.ExtractedText)
		_ = json.Unmarshal(suggestedTermsJSON, &pa.SuggestedSearchTerms)

		analyses = append(analyses, pa)
	}
	return analyses, rows.Err()
}

// ListPhotoAnalysesByLead retrieves all photo analyses for a lead.
func (r *Repository) ListPhotoAnalysesByLead(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]PhotoAnalysis, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, service_id, org_id, summary, observations, scope_assessment, cost_indicators,
			safety_concerns, additional_info, confidence_level, photo_count,
			measurements, needs_onsite_measurement, discrepancies, extracted_text, suggested_search_terms,
			created_at, updated_at
		FROM RAC_lead_photo_analyses
		WHERE lead_id = $1 AND org_id = $2
		ORDER BY created_at DESC
	`, leadID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	analyses := make([]PhotoAnalysis, 0)
	for rows.Next() {
		var pa PhotoAnalysis
		var observationsJSON, safetyConcernsJSON, additionalInfoJSON []byte
		var measurementsJSON, needsOnsiteJSON, discrepanciesJSON, extractedTextJSON, suggestedTermsJSON []byte

		if err := rows.Scan(
			&pa.ID, &pa.LeadID, &pa.ServiceID, &pa.OrganizationID, &pa.Summary, &observationsJSON, &pa.ScopeAssessment,
			&pa.CostIndicators, &safetyConcernsJSON, &additionalInfoJSON, &pa.ConfidenceLevel, &pa.PhotoCount,
			&measurementsJSON, &needsOnsiteJSON, &discrepanciesJSON, &extractedTextJSON, &suggestedTermsJSON,
			&pa.CreatedAt, &pa.UpdatedAt,
		); err != nil {
			return nil, err
		}

		_ = json.Unmarshal(observationsJSON, &pa.Observations)
		_ = json.Unmarshal(safetyConcernsJSON, &pa.SafetyConcerns)
		_ = json.Unmarshal(additionalInfoJSON, &pa.AdditionalInfo)
		_ = json.Unmarshal(measurementsJSON, &pa.Measurements)
		_ = json.Unmarshal(needsOnsiteJSON, &pa.NeedsOnsiteMeasurement)
		_ = json.Unmarshal(discrepanciesJSON, &pa.Discrepancies)
		_ = json.Unmarshal(extractedTextJSON, &pa.ExtractedText)
		_ = json.Unmarshal(suggestedTermsJSON, &pa.SuggestedSearchTerms)

		analyses = append(analyses, pa)
	}
	return analyses, rows.Err()
}
</file>

<file path="internal/leads/repository/public_token.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

func (r *Repository) GetByPublicToken(ctx context.Context, token string) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
        SELECT id, organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
            address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
            assigned_agent_id, source, energy_class, energy_index, energy_bouwjaar, energy_gebouwtype,
            energy_label_valid_until, energy_label_registered_at, energy_primair_fossiel, energy_bag_verblijfsobject_id,
            energy_label_fetched_at,
            lead_enrichment_source, lead_enrichment_postcode6, lead_enrichment_postcode4, lead_enrichment_buurtcode, lead_enrichment_data_year,
            lead_enrichment_gem_aardgasverbruik, lead_enrichment_gem_elektriciteitsverbruik, lead_enrichment_huishouden_grootte,
            lead_enrichment_koopwoningen_pct, lead_enrichment_bouwjaar_vanaf2000_pct, lead_enrichment_woz_waarde,
            lead_enrichment_mediaan_vermogen_x1000, lead_enrichment_gem_inkomen, lead_enrichment_pct_hoog_inkomen, lead_enrichment_pct_laag_inkomen,
            lead_enrichment_huishoudens_met_kinderen_pct, lead_enrichment_stedelijkheid, lead_enrichment_confidence, lead_enrichment_fetched_at,
            lead_score, lead_score_pre_ai, lead_score_factors, lead_score_version, lead_score_updated_at,
            viewed_by_id, viewed_at, created_at, updated_at
        FROM RAC_leads
        WHERE public_token = $1
            AND deleted_at IS NULL
            AND (public_token_expires_at IS NULL OR public_token_expires_at > now())
    `, token).Scan(
		&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
		&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
		&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
		&lead.EnergyLabelFetchedAt,
		&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
		&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
		&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
		&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
		&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
		&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
		&lead.ViewedByID, &lead.ViewedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) SetPublicToken(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, token string, expiresAt time.Time) error {
	_, err := r.pool.Exec(ctx, `
        UPDATE RAC_leads
        SET public_token = $3, public_token_expires_at = $4, updated_at = now()
        WHERE id = $1 AND organization_id = $2
    `, id, organizationID, token, expiresAt)
	return err
}
</file>

<file path="internal/leads/repository/timeline.go">
package repository

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

type TimelineEvent struct {
	ID             uuid.UUID
	LeadID         uuid.UUID
	ServiceID      *uuid.UUID
	OrganizationID uuid.UUID
	ActorType      string
	ActorName      string
	EventType      string
	Title          string
	Summary        *string
	Metadata       map[string]any
	CreatedAt      time.Time
}

type CreateTimelineEventParams struct {
	LeadID         uuid.UUID
	ServiceID      *uuid.UUID
	OrganizationID uuid.UUID
	ActorType      string
	ActorName      string
	EventType      string
	Title          string
	Summary        *string
	Metadata       map[string]any
}

func (r *Repository) CreateTimelineEvent(ctx context.Context, params CreateTimelineEventParams) (TimelineEvent, error) {
	metadataJSON, err := json.Marshal(params.Metadata)
	if err != nil {
		return TimelineEvent{}, err
	}

	var event TimelineEvent
	var rawServiceID *uuid.UUID
	var summary *string
	var rawMetadata []byte

	err = r.pool.QueryRow(ctx, `
		INSERT INTO lead_timeline_events (
			lead_id,
			service_id,
			organization_id,
			actor_type,
			actor_name,
			event_type,
			title,
			summary,
			metadata
		)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
		RETURNING id, lead_id, service_id, organization_id, actor_type, actor_name, event_type, title, summary, metadata, created_at
	`, params.LeadID, params.ServiceID, params.OrganizationID, params.ActorType, params.ActorName, params.EventType, params.Title, params.Summary, metadataJSON).Scan(
		&event.ID,
		&event.LeadID,
		&rawServiceID,
		&event.OrganizationID,
		&event.ActorType,
		&event.ActorName,
		&event.EventType,
		&event.Title,
		&summary,
		&rawMetadata,
		&event.CreatedAt,
	)
	if err != nil {
		return TimelineEvent{}, err
	}

	if rawServiceID != nil {
		event.ServiceID = rawServiceID
	}
	if summary != nil {
		event.Summary = summary
	}
	if len(rawMetadata) > 0 {
		_ = json.Unmarshal(rawMetadata, &event.Metadata)
	}

	return event, nil
}

func (r *Repository) ListTimelineEvents(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]TimelineEvent, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, service_id, organization_id, actor_type, actor_name, event_type, title, summary, metadata, created_at
		FROM lead_timeline_events
		WHERE lead_id = $1 AND organization_id = $2
		ORDER BY created_at DESC
	`, leadID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]TimelineEvent, 0)
	for rows.Next() {
		var event TimelineEvent
		var rawServiceID *uuid.UUID
		var summary *string
		var rawMetadata []byte
		if err := rows.Scan(
			&event.ID,
			&event.LeadID,
			&rawServiceID,
			&event.OrganizationID,
			&event.ActorType,
			&event.ActorName,
			&event.EventType,
			&event.Title,
			&summary,
			&rawMetadata,
			&event.CreatedAt,
		); err != nil {
			return nil, err
		}
		if rawServiceID != nil {
			event.ServiceID = rawServiceID
		}
		if summary != nil {
			event.Summary = summary
		}
		if len(rawMetadata) > 0 {
			_ = json.Unmarshal(rawMetadata, &event.Metadata)
		}
		items = append(items, event)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return items, nil
}

func (r *Repository) ListTimelineEventsByService(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, organizationID uuid.UUID) ([]TimelineEvent, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, lead_id, service_id, organization_id, actor_type, actor_name, event_type, title, summary, metadata, created_at
		FROM lead_timeline_events
		WHERE lead_id = $1 AND organization_id = $2 AND (service_id = $3 OR service_id IS NULL)
		ORDER BY created_at DESC
	`, leadID, organizationID, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]TimelineEvent, 0)
	for rows.Next() {
		var event TimelineEvent
		var rawServiceID *uuid.UUID
		var summary *string
		var rawMetadata []byte
		if err := rows.Scan(
			&event.ID,
			&event.LeadID,
			&rawServiceID,
			&event.OrganizationID,
			&event.ActorType,
			&event.ActorName,
			&event.EventType,
			&event.Title,
			&summary,
			&rawMetadata,
			&event.CreatedAt,
		); err != nil {
			return nil, err
		}
		if rawServiceID != nil {
			event.ServiceID = rawServiceID
		}
		if summary != nil {
			event.Summary = summary
		}
		if len(rawMetadata) > 0 {
			_ = json.Unmarshal(rawMetadata, &event.Metadata)
		}
		items = append(items, event)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return items, nil
}
</file>

<file path="internal/leads/transport/notes.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

type CreateLeadNoteRequest struct {
	Body      string  `json:"body" validate:"required,min=1,max=2000"`
	Type      string  `json:"type" validate:"omitempty,oneof=note call text email system"`
	ServiceID *string `json:"serviceId" validate:"omitempty,uuid"`
}

type LeadNoteResponse struct {
	ID          uuid.UUID `json:"id"`
	LeadID      uuid.UUID `json:"leadId"`
	AuthorID    uuid.UUID `json:"authorId"`
	AuthorEmail string    `json:"authorEmail"`
	Type        string    `json:"type"`
	Body        string    `json:"body"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

type LeadNotesResponse struct {
	Items []LeadNoteResponse `json:"items"`
}
</file>

<file path="internal/partners/handler/public_handler.go">
package handler

import (
	"net/http"

	"portal_final_backend/internal/partners/service"
	"portal_final_backend/internal/partners/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
)

// PublicHandler handles unauthenticated, token-based partner offer endpoints.
type PublicHandler struct {
	svc *service.Service
	val *validator.Validator
}

// NewPublicHandler creates a new public handler for partner offers.
func NewPublicHandler(svc *service.Service, val *validator.Validator) *PublicHandler {
	return &PublicHandler{svc: svc, val: val}
}

// RegisterRoutes mounts public partner offer routes (no auth middleware).
func (h *PublicHandler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("/:token", h.GetOffer)
	rg.POST("/:token/accept", h.AcceptOffer)
	rg.POST("/:token/reject", h.RejectOffer)
}

// GetOffer returns the public-facing offer details for a vakman.
func (h *PublicHandler) GetOffer(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	resp, err := h.svc.GetPublicOffer(c.Request.Context(), token)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, resp)
}

// AcceptOffer processes a vakman's acceptance of an offer.
func (h *PublicHandler) AcceptOffer(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.AcceptOfferRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	if err := h.svc.AcceptOffer(c.Request.Context(), token, req); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"status": "accepted"})
}

// RejectOffer processes a vakman's rejection of an offer.
func (h *PublicHandler) RejectOffer(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.RejectOfferRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// Allow empty body for rejection without reason
		req = transport.RejectOfferRequest{}
	}

	if err := h.svc.RejectOffer(c.Request.Context(), token, req); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"status": "rejected"})
}
</file>

<file path="internal/partners/module.go">
// Package partners provides the partners bounded context module.
package partners

import (
	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/partners/handler"
	"portal_final_backend/internal/partners/repository"
	"portal_final_backend/internal/partners/service"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the partners bounded context module implementing http.Module.
type Module struct {
	handler       *handler.Handler
	publicHandler *handler.PublicHandler
	service       *service.Service
}

// NewModule creates and initializes the partners module with all its dependencies.
func NewModule(
	pool *pgxpool.Pool,
	eventBus events.Bus,
	storageSvc storage.StorageService,
	logoBucket string,
	val *validator.Validator,
) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, eventBus, storageSvc, logoBucket)
	h := handler.New(svc, val)
	ph := handler.NewPublicHandler(svc, val)

	return &Module{handler: h, publicHandler: ph, service: svc}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "partners"
}

// Service returns the service layer for external use.
func (m *Module) Service() *service.Service {
	return m.service
}

// RegisterRoutes mounts partner routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	partnersGroup := ctx.Protected.Group("/partners")
	m.handler.RegisterRoutes(partnersGroup)

	// Public routes for vakman-facing offer pages (no auth middleware)
	publicGroup := ctx.V1.Group("/public/partner-offers")
	m.publicHandler.RegisterRoutes(publicGroup)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/partners/transport/dto.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

type CreatePartnerRequest struct {
	BusinessName   string      `json:"businessName" validate:"required,min=1,max=200"`
	KVKNumber      string      `json:"kvkNumber" validate:"required,max=20"`
	VATNumber      string      `json:"vatNumber" validate:"required,max=20"`
	AddressLine1   string      `json:"addressLine1" validate:"required,max=200"`
	AddressLine2   string      `json:"addressLine2,omitempty" validate:"omitempty,max=200"`
	HouseNumber    string      `json:"houseNumber" validate:"required,max=20"`
	PostalCode     string      `json:"postalCode" validate:"required,max=20"`
	City           string      `json:"city" validate:"required,max=120"`
	Country        string      `json:"country" validate:"required,max=120"`
	Latitude       *float64    `json:"latitude,omitempty" validate:"omitempty,gte=-90,lte=90"`
	Longitude      *float64    `json:"longitude,omitempty" validate:"omitempty,gte=-180,lte=180"`
	ContactName    string      `json:"contactName" validate:"required,max=120"`
	ContactEmail   string      `json:"contactEmail" validate:"required,email"`
	ContactPhone   string      `json:"contactPhone" validate:"required,max=50"`
	ServiceTypeIDs []uuid.UUID `json:"serviceTypeIds,omitempty" validate:"omitempty,dive,required"`
}

type UpdatePartnerRequest struct {
	BusinessName   *string      `json:"businessName,omitempty" validate:"omitempty,min=1,max=200"`
	KVKNumber      *string      `json:"kvkNumber,omitempty" validate:"omitempty,max=20"`
	VATNumber      *string      `json:"vatNumber,omitempty" validate:"omitempty,max=20"`
	AddressLine1   *string      `json:"addressLine1,omitempty" validate:"omitempty,max=200"`
	AddressLine2   *string      `json:"addressLine2,omitempty" validate:"omitempty,max=200"`
	HouseNumber    *string      `json:"houseNumber,omitempty" validate:"omitempty,max=20"`
	PostalCode     *string      `json:"postalCode,omitempty" validate:"omitempty,max=20"`
	City           *string      `json:"city,omitempty" validate:"omitempty,max=120"`
	Country        *string      `json:"country,omitempty" validate:"omitempty,max=120"`
	Latitude       *float64     `json:"latitude,omitempty" validate:"omitempty,gte=-90,lte=90"`
	Longitude      *float64     `json:"longitude,omitempty" validate:"omitempty,gte=-180,lte=180"`
	ContactName    *string      `json:"contactName,omitempty" validate:"omitempty,max=120"`
	ContactEmail   *string      `json:"contactEmail,omitempty" validate:"omitempty,email"`
	ContactPhone   *string      `json:"contactPhone,omitempty" validate:"omitempty,max=50"`
	ServiceTypeIDs *[]uuid.UUID `json:"serviceTypeIds,omitempty" validate:"omitempty,dive,required"`
}

type PartnerResponse struct {
	ID              uuid.UUID   `json:"id"`
	BusinessName    string      `json:"businessName"`
	KVKNumber       string      `json:"kvkNumber"`
	VATNumber       string      `json:"vatNumber"`
	AddressLine1    string      `json:"addressLine1"`
	AddressLine2    *string     `json:"addressLine2,omitempty"`
	HouseNumber     *string     `json:"houseNumber,omitempty"`
	PostalCode      string      `json:"postalCode"`
	City            string      `json:"city"`
	Country         string      `json:"country"`
	Latitude        *float64    `json:"latitude,omitempty"`
	Longitude       *float64    `json:"longitude,omitempty"`
	ContactName     string      `json:"contactName"`
	ContactEmail    string      `json:"contactEmail"`
	ContactPhone    string      `json:"contactPhone"`
	LogoFileKey     *string     `json:"logoFileKey,omitempty"`
	LogoFileName    *string     `json:"logoFileName,omitempty"`
	LogoContentType *string     `json:"logoContentType,omitempty"`
	LogoSizeBytes   *int64      `json:"logoSizeBytes,omitempty"`
	ServiceTypeIDs  []uuid.UUID `json:"serviceTypeIds,omitempty"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
}

type ListPartnersRequest struct {
	Search    string `form:"search" validate:"omitempty,max=100"`
	SortBy    string `form:"sortBy" validate:"omitempty,oneof=businessName contactName createdAt updatedAt"`
	SortOrder string `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
	Page      int    `form:"page" validate:"omitempty,min=1"`
	PageSize  int    `form:"pageSize" validate:"omitempty,min=1,max=100"`
}

type ListPartnersResponse struct {
	Items      []PartnerResponse `json:"items"`
	Total      int               `json:"total"`
	Page       int               `json:"page"`
	PageSize   int               `json:"pageSize"`
	TotalPages int               `json:"totalPages"`
}

type PartnerLeadResponse struct {
	ID        uuid.UUID `json:"id"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Phone     string    `json:"phone"`
	Address   string    `json:"address"`
}

type LinkLeadRequest struct {
	LeadID uuid.UUID `json:"leadId" validate:"required"`
}

type CreatePartnerInviteRequest struct {
	Email         string     `json:"email" validate:"required,email"`
	LeadID        *uuid.UUID `json:"leadId,omitempty"`
	LeadServiceID *uuid.UUID `json:"leadServiceId,omitempty"`
}

type CreatePartnerInviteResponse struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expiresAt"`
}

type PartnerInviteResponse struct {
	ID            uuid.UUID  `json:"id"`
	Email         string     `json:"email"`
	LeadID        *uuid.UUID `json:"leadId,omitempty"`
	LeadServiceID *uuid.UUID `json:"leadServiceId,omitempty"`
	ExpiresAt     time.Time  `json:"expiresAt"`
	CreatedAt     time.Time  `json:"createdAt"`
	UsedAt        *time.Time `json:"usedAt,omitempty"`
}

type ListPartnerInvitesResponse struct {
	Invites []PartnerInviteResponse `json:"invites"`
}
</file>

<file path="internal/pdf/gotenberg.go">
// Package pdf  Gotenberg HTTP client for HTMLPDF conversion and merging.
package pdf

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"time"
)

// GotenbergClient converts HTML to PDF via a Gotenberg instance.
type GotenbergClient struct {
	baseURL  string
	username string
	password string
	http     *http.Client
}

// NewGotenbergClient creates a client pointing at the given Gotenberg URL.
// If username and password are non-empty, every request will include HTTP Basic Auth.
func NewGotenbergClient(baseURL, username, password string) *GotenbergClient {
	return &GotenbergClient{
		baseURL:  baseURL,
		username: username,
		password: password,
		http: &http.Client{
			Timeout: 60 * time.Second,
		},
	}
}

// ConvertOpts configures the HTMLPDF conversion request.
type ConvertOpts struct {
	MarginTop    string
	MarginBottom string
	MarginLeft   string
	MarginRight  string
	FooterHTML   []byte
	// WaitDelay adds a delay before capture (e.g. "2s") for font loading.
	WaitDelay string
}

// DefaultContentOpts returns options for the main quote body pages.
func DefaultContentOpts() ConvertOpts {
	return ConvertOpts{
		MarginTop:    "0.5",
		MarginBottom: "0.7",
		MarginLeft:   "0.5",
		MarginRight:  "0.5",
		WaitDelay:    "1s",
	}
}

// CoverPageOpts returns options for a full-bleed cover page (no margins, no footer).
func CoverPageOpts() ConvertOpts {
	return ConvertOpts{
		MarginTop:    "0",
		MarginBottom: "0",
		MarginLeft:   "0",
		MarginRight:  "0",
		WaitDelay:    "2s",
	}
}

// ConvertHTML sends index.html to Gotenberg and returns the resulting PDF bytes.
func (g *GotenbergClient) ConvertHTML(ctx context.Context, indexHTML []byte, opts ConvertOpts) ([]byte, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	fields := map[string]string{
		"paperWidth":        "8.27",
		"paperHeight":       "11.7",
		"marginTop":         opts.MarginTop,
		"marginBottom":      opts.MarginBottom,
		"marginLeft":        opts.MarginLeft,
		"marginRight":       opts.MarginRight,
		"printBackground":   "true",
		"preferCssPageSize": "false",
	}
	if opts.WaitDelay != "" {
		fields["waitDelay"] = opts.WaitDelay
		fields["skipNetworkIdleEvent"] = "true"
	}
	for k, v := range fields {
		if err := writer.WriteField(k, v); err != nil {
			return nil, fmt.Errorf("write field %s: %w", k, err)
		}
	}

	if err := addHTMLPart(writer, "index.html", indexHTML); err != nil {
		return nil, err
	}

	if len(opts.FooterHTML) > 0 {
		if err := addHTMLPart(writer, "footer.html", opts.FooterHTML); err != nil {
			return nil, err
		}
	}

	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("close multipart writer: %w", err)
	}

	return g.doPost(ctx, "/forms/chromium/convert/html", body, writer.FormDataContentType())
}

// MergePDFs merges multiple PDFs into one using Gotenberg's merge endpoint.
// The PDFs are merged alphanumerically by filename, so prefix with "01_", "02_", etc.
func (g *GotenbergClient) MergePDFs(ctx context.Context, pdfs map[string][]byte) ([]byte, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	for filename, data := range pdfs {
		if err := addFilePart(writer, filename, "application/pdf", data); err != nil {
			return nil, err
		}
	}

	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("close multipart writer: %w", err)
	}

	return g.doPost(ctx, "/forms/pdfengines/merge", body, writer.FormDataContentType())
}

// doPost sends a POST request and reads the response body.
func (g *GotenbergClient) doPost(ctx context.Context, path string, body *bytes.Buffer, contentType string) ([]byte, error) {
	url := g.baseURL + path
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", contentType)
	if g.username != "" && g.password != "" {
		req.SetBasicAuth(g.username, g.password)
	}

	resp, err := g.http.Do(req)
	if err != nil {
		return nil, fmt.Errorf("gotenberg %s: %w", path, err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("gotenberg %s returned %d: %s", path, resp.StatusCode, string(errBody))
	}

	result, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response from %s: %w", path, err)
	}
	return result, nil
}

// addHTMLPart adds an HTML file to the multipart form.
func addHTMLPart(w *multipart.Writer, filename string, content []byte) error {
	return addFilePart(w, filename, "text/html", content)
}

// addFilePart adds a file to the multipart form.
func addFilePart(w *multipart.Writer, filename, mimeType string, content []byte) error {
	h := make(textproto.MIMEHeader)
	h.Set("Content-Disposition", fmt.Sprintf(`form-data; name="files"; filename="%s"`, filename))
	h.Set("Content-Type", mimeType)

	part, err := w.CreatePart(h)
	if err != nil {
		return fmt.Errorf("create part %s: %w", filename, err)
	}
	if _, err := part.Write(content); err != nil {
		return fmt.Errorf("write part %s: %w", filename, err)
	}
	return nil
}
</file>

<file path="internal/pdf/templates/signature.html">
<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Akkoordverklaring</title>
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            color: #111827;
            font-size: 9pt;
            line-height: 1.5;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
        :root {
            --accent: #F59E0B;
            --accent-light: #FEF3C7;
            --dark: #111827;
            --gray-500: #6b7280;
            --gray-400: #9ca3af;
            --gray-200: #e5e7eb;
            --gray-100: #f3f4f6;
            --green-600: #16a34a;
            --green-100: #dcfce7;
        }
        .page { width: 100%; padding: 0; }

        /*  Header  */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 3px solid var(--accent);
        }
        .header-logo img { max-height: 52px; max-width: 180px; }
        .header-logo .org-name-fallback { font-size: 18pt; font-weight: 700; color: var(--dark); }
        .header-title { text-align: right; }
        .header-title h1 { font-size: 16pt; font-weight: 800; color: var(--dark); text-transform: uppercase; letter-spacing: 2px; }
        .header-title .quote-number { font-size: 10pt; color: var(--gray-500); margin-top: 4px; }

        /*  URLs / Terms Section  */
        .urls-section { margin-bottom: 28px; }
        .section-title {
            font-size: 8pt; font-weight: 700; color: var(--accent);
            text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;
        }
        .url-item {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 12px; margin-bottom: 6px;
            background: var(--gray-100); border-radius: 4px;
            font-size: 9pt;
        }
        .url-checkbox {
            width: 14px; height: 14px;
            border: 2px solid var(--gray-400); border-radius: 2px;
            flex-shrink: 0;
        }
        .url-label { color: var(--dark); font-weight: 500; }
        .url-href { color: var(--gray-500); font-size: 8pt; margin-left: auto; word-break: break-all; }

        /*  Signature Block  */
        .signature-block {
            margin-top: 24px; padding-top: 16px;
            border-top: 2px solid var(--accent);
        }
        .sig-title {
            font-size: 8pt; font-weight: 700; color: var(--accent);
            text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;
        }
        .signature-info {
            display: flex; justify-content: space-between; margin-bottom: 12px;
        }
        .sig-name { font-size: 9pt; font-weight: 700; color: var(--dark); }
        .sig-date { font-size: 9pt; color: var(--gray-500); }
        .signature-image-row {
            display: flex; align-items: flex-end; gap: 12px; margin-top: 8px;
        }
        .signature-image-row .sig-label { font-size: 8pt; color: var(--gray-500); padding-bottom: 8px; }
        .signature-image-row img { max-height: 60px; max-width: 200px; border-bottom: 1px solid var(--gray-200); }

        /*  Acceptance Banner  */
        .acceptance-banner {
            margin-top: 24px; padding: 12px 16px; border-radius: 6px;
            background: var(--green-100); color: var(--green-600);
            border-left: 4px solid var(--green-600);
            font-size: 9pt; font-weight: 700;
        }

        /*  Empty State  */
        .pending-block {
            margin-top: 24px; padding: 20px 16px;
            border: 2px dashed var(--gray-200); border-radius: 6px;
            text-align: center;
        }
        .pending-block .pending-text {
            font-size: 10pt; color: var(--gray-400); font-weight: 500;
        }

        @media print {
            .signature-block { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="page">
        <!--  Header  -->
        <div class="header">
            <div class="header-logo">
                {{if .LogoBase64}}
                    <img src="data:{{.LogoMimeType}};base64,{{.LogoBase64}}" alt="Logo">
                {{else}}
                    <span class="org-name-fallback">{{.OrganizationName}}</span>
                {{end}}
            </div>
            <div class="header-title">
                <h1>AKKOORDVERKLARING</h1>
                <div class="quote-number">{{.QuoteNumber}}</div>
            </div>
        </div>

        <!--  URLs / Terms  -->
        {{if .HasURLs}}
        <div class="urls-section">
            <div class="section-title">Algemene Voorwaarden</div>
            {{range .URLs}}
            <div class="url-item">
                <div class="url-checkbox"></div>
                <span class="url-label">{{.Label}}</span>
                <span class="url-href">{{.Href}}</span>
            </div>
            {{end}}
        </div>
        {{end}}

        <!--  Signature  -->
        {{if .HasSignature}}
        <div class="signature-block">
            <div class="sig-title">Handtekening</div>
            <div class="signature-info">
                <span class="sig-name">Geaccepteerd door: {{.SignatureName}}</span>
                <span class="sig-date">Datum: {{.AcceptedAtFormatted}}</span>
            </div>
            {{if .SignatureBase64}}
            <div class="signature-image-row">
                <span class="sig-label">Handtekening:</span>
                <img src="data:image/png;base64,{{.SignatureBase64}}" alt="Handtekening">
            </div>
            {{end}}
        </div>

        <div class="acceptance-banner">
             Offerte geaccepteerd op {{.AcceptedAtFormatted}}
        </div>
        {{else}}
        <div class="pending-block">
            <div class="pending-text">Wacht op akkoord van de klant</div>
        </div>
        {{end}}
    </div>
</body>
</html>
</file>

<file path="internal/quotes/module.go">
// Package quotes provides the quotes (offertes) domain module.
package quotes

import (
	"portal_final_backend/internal/adapters/storage"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/internal/quotes/handler"
	"portal_final_backend/internal/quotes/repository"
	"portal_final_backend/internal/quotes/service"
	"portal_final_backend/platform/events"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module represents the quotes domain module
type Module struct {
	handler       *handler.Handler
	publicHandler *handler.PublicHandler
	service       *service.Service
	repository    *repository.Repository
}

// NewModule creates a new quotes module with all dependencies wired
func NewModule(pool *pgxpool.Pool, eventBus *events.InMemoryBus, val *validator.Validator) *Module {
	repo := repository.New(pool)
	svc := service.New(repo)
	svc.SetEventBus(eventBus)
	h := handler.New(svc, val)
	ph := handler.NewPublicHandler(svc, val)

	return &Module{
		handler:       h,
		publicHandler: ph,
		service:       svc,
		repository:    repo,
	}
}

// Name returns the module name for logging
func (m *Module) Name() string {
	return "quotes"
}

// Service returns the service layer for external use
func (m *Module) Service() *service.Service {
	return m.service
}

// Repository returns the repository for use by adapters (e.g., PDF generation).
func (m *Module) Repository() *repository.Repository {
	return m.repository
}

// SetSSE injects the SSE service so public viewers get real-time quote updates.
func (m *Module) SetSSE(s *sse.Service) {
	m.publicHandler.SetSSE(s)
}

// SetStorageForPDF injects storage service for PDF download endpoints.
func (m *Module) SetStorageForPDF(svc storage.StorageService, bucket string) {
	m.handler.SetStorageForPDF(svc, bucket)
	m.publicHandler.SetStorageForPDF(svc, bucket)
}

// SetAttachmentBucket injects the bucket name for manual quote attachment uploads.
func (m *Module) SetAttachmentBucket(bucket string) {
	m.handler.SetAttachmentBucket(bucket)
}

// SetCatalogBucket injects the bucket name for catalog asset downloads via attachment preview.
func (m *Module) SetCatalogBucket(bucket string) {
	m.handler.SetCatalogBucket(bucket)
}

// SetPDFGenerator injects the on-demand PDF generator for lazy PDF creation in download endpoints.
func (m *Module) SetPDFGenerator(gen handler.PDFOnDemandGenerator) {
	m.handler.SetPDFGenerator(gen)
	m.publicHandler.SetPDFGenerator(gen)
}

// RegisterRoutes registers the module's routes
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	quotes := ctx.Protected.Group("/quotes")
	m.handler.RegisterRoutes(quotes)

	// Public routes  no auth middleware
	publicQuotes := ctx.V1.Group("/public/quotes")
	m.publicHandler.RegisterRoutes(publicQuotes)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/scheduler/client.go">
package scheduler

import (
	"context"
	"crypto/tls"
	"fmt"
	"time"

	"portal_final_backend/platform/config"

	"github.com/hibiken/asynq"
	"github.com/redis/go-redis/v9"
)

type Client struct {
	client *asynq.Client
	queue  string
}

type ReminderScheduler interface {
	ScheduleAppointmentReminder(ctx context.Context, payload AppointmentReminderPayload, runAt time.Time) error
}

func NewClient(cfg config.SchedulerConfig) (*Client, error) {
	redisURL := cfg.GetRedisURL()
	if redisURL == "" {
		return nil, fmt.Errorf("redis url not configured")
	}

	opt, err := redisClientOpt(redisURL, cfg.GetRedisTLSInsecure())
	if err != nil {
		return nil, err
	}

	queue := cfg.GetAsynqQueueName()
	if queue == "" {
		queue = "default"
	}

	return &Client{
		client: asynq.NewClient(opt),
		queue:  queue,
	}, nil
}

func (c *Client) Close() error {
	if c == nil || c.client == nil {
		return nil
	}
	return c.client.Close()
}

func (c *Client) ScheduleAppointmentReminder(ctx context.Context, payload AppointmentReminderPayload, runAt time.Time) error {
	if c == nil || c.client == nil {
		return nil
	}

	task, err := NewAppointmentReminderTask(payload)
	if err != nil {
		return err
	}

	_, err = c.client.EnqueueContext(ctx, task, asynq.ProcessAt(runAt), asynq.Queue(c.queue))
	return err
}

func redisClientOpt(redisURL string, tlsInsecure bool) (asynq.RedisClientOpt, error) {
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		return asynq.RedisClientOpt{}, err
	}

	var tlsConfig *tls.Config
	if opt.TLSConfig != nil {
		clone := opt.TLSConfig.Clone()
		if tlsInsecure {
			clone.InsecureSkipVerify = true
		}
		tlsConfig = clone
	} else if tlsInsecure {
		tlsConfig = &tls.Config{InsecureSkipVerify: true}
	}

	return asynq.RedisClientOpt{
		Addr:      opt.Addr,
		Password:  opt.Password,
		DB:        opt.DB,
		TLSConfig: tlsConfig,
	}, nil
}
</file>

<file path="internal/scheduler/tasks.go">
package scheduler

import (
	"encoding/json"

	"github.com/hibiken/asynq"
)

const TaskAppointmentReminder = "appointments.reminder"

type AppointmentReminderPayload struct {
	AppointmentID  string `json:"appointmentId"`
	OrganizationID string `json:"organizationId"`
}

func NewAppointmentReminderTask(payload AppointmentReminderPayload) (*asynq.Task, error) {
	data, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}
	return asynq.NewTask(TaskAppointmentReminder, data), nil
}

func ParseAppointmentReminderPayload(task *asynq.Task) (AppointmentReminderPayload, error) {
	var payload AppointmentReminderPayload
	if err := json.Unmarshal(task.Payload(), &payload); err != nil {
		return AppointmentReminderPayload{}, err
	}
	return payload, nil
}
</file>

<file path="internal/services/handler/handler.go">
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"

	"portal_final_backend/internal/services/service"
	"portal_final_backend/internal/services/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"
)

// Handler handles HTTP requests for service types.
type Handler struct {
	svc *service.Service
	val *validator.Validator
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
	msgInvalidID        = "invalid service type ID"
)

// New creates a new service types handler.
func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

// List retrieves all service types (admin only).
// GET /api/v1/admin/service-types
func (h *Handler) List(c *gin.Context) {
	var req transport.ListServiceTypesRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListWithFilters(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// ListActive retrieves only active service types (public).
// GET /api/v1/service-types
func (h *Handler) ListActive(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListActive(c.Request.Context(), tenantID)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// GetByID retrieves a service type by ID.
// GET /api/v1/service-types/:id
func (h *Handler) GetByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetByID(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// GetBySlug retrieves a service type by slug.
// GET /api/v1/service-types/slug/:slug
func (h *Handler) GetBySlug(c *gin.Context) {
	slug := c.Param("slug")
	if slug == "" {
		httpkit.Error(c, http.StatusBadRequest, "slug is required", nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetBySlug(c.Request.Context(), tenantID, slug)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// Create creates a new service type.
// POST /api/v1/admin/service-types
func (h *Handler) Create(c *gin.Context) {
	var req transport.CreateServiceTypeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.Create(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.JSON(c, http.StatusCreated, result)
}

// Update updates an existing service type.
// PUT /api/v1/admin/service-types/:id
func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}

	var req transport.UpdateServiceTypeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.Update(c.Request.Context(), tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// Delete removes a service type.
// DELETE /api/v1/admin/service-types/:id
func (h *Handler) Delete(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.Delete(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

// ToggleActive toggles the is_active flag for a service type.
// PATCH /api/v1/admin/service-types/:id/toggle-active
func (h *Handler) ToggleActive(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidID, nil)
		return
	}
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ToggleActive(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}
	httpkit.OK(c, result)
}

func mustGetTenantID(c *gin.Context, identity httpkit.Identity) (uuid.UUID, bool) {
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, "tenant ID is required", nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}
</file>

<file path="internal/services/module.go">
// Package services provides the service types bounded context module.
// This module manages dynamic service categories that can be assigned to RAC_leads.
package services

import (
	"context"

	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/services/handler"
	"portal_final_backend/internal/services/repository"
	"portal_final_backend/internal/services/service"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the services bounded context module implementing http.Module.
type Module struct {
	handler *handler.Handler
	service *service.Service
	repo    repository.Repository
}

// NewModule creates and initializes the services module with all its dependencies.
func NewModule(pool *pgxpool.Pool, val *validator.Validator, log *logger.Logger) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, log)
	h := handler.New(svc, val)

	return &Module{
		handler: h,
		service: svc,
		repo:    repo,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "services"
}

// Service returns the service layer for external use.
func (m *Module) Service() *service.Service {
	return m.service
}

// Repository returns the repository for direct access if needed.
func (m *Module) Repository() repository.Repository {
	return m.repo
}

// RegisterRoutes mounts service type routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// Protected read-only endpoints for active service types (tenant-scoped)
	ctx.Protected.GET("/service-types", m.handler.ListActive)
	ctx.Protected.GET("/service-types/:id", m.handler.GetByID)
	ctx.Protected.GET("/service-types/slug/:slug", m.handler.GetBySlug)

	// Admin-only CRUD endpoints
	adminGroup := ctx.Admin.Group("/service-types")
	adminGroup.GET("", m.handler.List)
	adminGroup.POST("", m.handler.Create)
	adminGroup.GET("/:id", m.handler.GetByID)
	adminGroup.PUT("/:id", m.handler.Update)
	adminGroup.DELETE("/:id", m.handler.Delete)
	adminGroup.PATCH("/:id/toggle-active", m.handler.ToggleActive)
}

// RegisterHandlers subscribes to domain events for seeding tenant defaults.
func (m *Module) RegisterHandlers(bus *events.InMemoryBus) {
	bus.Subscribe(events.OrganizationCreated{}.EventName(), m)
}

// Handle routes events to the appropriate handler method.
func (m *Module) Handle(ctx context.Context, event events.Event) error {
	switch e := event.(type) {
	case events.OrganizationCreated:
		return m.service.SeedDefaults(ctx, e.OrganizationID)
	default:
		return nil
	}
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/services/repository/interface.go">
package repository

import (
	"context"

	"github.com/google/uuid"
)

// ServiceType represents a service category that can be assigned to RAC_leads.
type ServiceType struct {
	ID               uuid.UUID `db:"id"`
	OrganizationID   uuid.UUID `db:"organization_id"`
	Name             string    `db:"name"`
	Slug             string    `db:"slug"`
	Description      *string   `db:"description"`
	IntakeGuidelines *string   `db:"intake_guidelines"`
	Icon             *string   `db:"icon"`
	Color            *string   `db:"color"`
	IsActive         bool      `db:"is_active"`
	CreatedAt        string    `db:"created_at"`
	UpdatedAt        string    `db:"updated_at"`
}

// CreateParams contains parameters for creating a service type.
type CreateParams struct {
	OrganizationID   uuid.UUID
	Name             string
	Slug             string
	Description      *string
	IntakeGuidelines *string
	Icon             *string
	Color            *string
}

// UpdateParams contains parameters for updating a service type.
type UpdateParams struct {
	ID               uuid.UUID
	OrganizationID   uuid.UUID
	Name             *string
	Slug             *string
	Description      *string
	IntakeGuidelines *string
	Icon             *string
	Color            *string
}

// ListParams defines filters for listing service types.
type ListParams struct {
	OrganizationID uuid.UUID
	Search         string
	IsActive       *bool
	Offset         int
	Limit          int
	SortBy         string
	SortOrder      string
}

// ServiceTypeReader provides read operations for service types.
type ServiceTypeReader interface {
	GetByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (ServiceType, error)
	GetBySlug(ctx context.Context, organizationID uuid.UUID, slug string) (ServiceType, error)
	List(ctx context.Context, organizationID uuid.UUID) ([]ServiceType, error)
	ListActive(ctx context.Context, organizationID uuid.UUID) ([]ServiceType, error)
	ListWithFilters(ctx context.Context, params ListParams) ([]ServiceType, int, error)
	Exists(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error)
	HasLeadServices(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error)
}

// ServiceTypeWriter provides write operations for service types.
type ServiceTypeWriter interface {
	Create(ctx context.Context, params CreateParams) (ServiceType, error)
	Update(ctx context.Context, params UpdateParams) (ServiceType, error)
	Delete(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error
	SetActive(ctx context.Context, organizationID uuid.UUID, id uuid.UUID, isActive bool) error
}

// Repository combines all service type repository operations.
type Repository interface {
	ServiceTypeReader
	ServiceTypeWriter
}
</file>

<file path="internal/webhook/handler.go">
package webhook

import (
	"net/http"

	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// Handler handles webhook HTTP requests.
type Handler struct {
	service *Service
	repo    *Repository
	val     *validator.Validator
}

// NewHandler creates a new webhook handler.
func NewHandler(service *Service, repo *Repository, val *validator.Validator) *Handler {
	return &Handler{service: service, repo: repo, val: val}
}

// ---- Form Submission (public, API-key authenticated) ----

// HandleFormSubmission processes an inbound form submission.
// POST /api/v1/webhook/forms
// Authenticated via X-Webhook-API-Key header (set by middleware).
func (h *Handler) HandleFormSubmission(c *gin.Context) {
	// orgID and apiKeyID are set by the API key auth middleware
	orgID, ok := c.Get("webhookOrgID")
	if !ok {
		httpkit.Error(c, http.StatusUnauthorized, "missing organization context", nil)
		return
	}
	apiKeyID, _ := c.Get("webhookKeyID")

	// Parse multipart form (max 32 MB)
	if err := c.Request.ParseMultipartForm(32 << 20); err != nil {
		// Fallback: try regular form data
		if err := c.Request.ParseForm(); err != nil {
			httpkit.Error(c, http.StatusBadRequest, "unable to parse form data", nil)
			return
		}
	}

	// Collect all text fields
	fields := make(map[string]string)
	if c.Request.MultipartForm != nil {
		for key, values := range c.Request.MultipartForm.Value {
			if len(values) > 0 {
				fields[key] = values[0]
			}
		}
	}
	for key, values := range c.Request.PostForm {
		if _, exists := fields[key]; !exists && len(values) > 0 {
			fields[key] = values[0]
		}
	}

	// Collect files
	var files []FormFile
	if c.Request.MultipartForm != nil {
		for fieldName, fileHeaders := range c.Request.MultipartForm.File {
			for _, fh := range fileHeaders {
				f, err := fh.Open()
				if err != nil {
					continue
				}
				files = append(files, FormFile{
					FieldName:   fieldName,
					FileName:    fh.Filename,
					ContentType: fh.Header.Get("Content-Type"),
					Size:        fh.Size,
					Reader:      f,
				})
			}
		}
	}

	// Also support JSON body (for SDK sending JSON)
	if c.ContentType() == "application/json" {
		var jsonBody map[string]interface{}
		if err := c.ShouldBindJSON(&jsonBody); err == nil {
			for key, val := range jsonBody {
				switch v := val.(type) {
				case string:
					fields[key] = v
				case float64:
					fields[key] = c.DefaultQuery(key, "")
					_ = v
				}
			}
		}
	}

	if len(fields) == 0 && len(files) == 0 {
		httpkit.Error(c, http.StatusBadRequest, "no form data received", nil)
		return
	}

	submission := FormSubmission{
		Fields:       fields,
		Files:        files,
		SourceDomain: c.GetHeader("Origin"),
	}
	if keyID, ok := apiKeyID.(uuid.UUID); ok {
		submission.APIKeyID = keyID
	}

	resp, err := h.service.ProcessFormSubmission(c.Request.Context(), submission, orgID.(uuid.UUID))
	if httpkit.HandleError(c, err) {
		return
	}

	c.JSON(http.StatusCreated, resp)
}

// ---- Admin API Key Management (JWT authenticated) ----

// CreateAPIKeyRequest is the request body for creating a new API key.
type CreateAPIKeyRequest struct {
	Name           string   `json:"name" validate:"required,min=1,max=100"`
	AllowedDomains []string `json:"allowedDomains" validate:"max=20,dive,max=200"`
}

// APIKeyResponse is returned when listing or creating API keys.
type APIKeyResponse struct {
	ID             uuid.UUID `json:"id"`
	Name           string    `json:"name"`
	KeyPrefix      string    `json:"keyPrefix"`
	AllowedDomains []string  `json:"allowedDomains"`
	IsActive       bool      `json:"isActive"`
	CreatedAt      string    `json:"createdAt"`
}

// CreateAPIKeyResponse includes the plaintext key (shown only once).
type CreateAPIKeyResponse struct {
	APIKeyResponse
	Key string `json:"key"` // plaintext, shown only once
}

// HandleCreateAPIKey creates a new webhook API key.
// POST /api/v1/admin/webhook/keys
func (h *Handler) HandleCreateAPIKey(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, "no organization context", nil)
		return
	}

	var req CreateAPIKeyRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid request body", err.Error())
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "validation error", err.Error())
		return
	}

	plaintext, hash, prefix, err := GenerateAPIKey()
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate API key", nil)
		return
	}

	domains := req.AllowedDomains
	if domains == nil {
		domains = []string{}
	}

	key, err := h.repo.Create(c.Request.Context(), *tenantID, req.Name, hash, prefix, domains)
	if httpkit.HandleError(c, err) {
		return
	}

	c.JSON(http.StatusCreated, CreateAPIKeyResponse{
		APIKeyResponse: toAPIKeyResponse(key),
		Key:            plaintext,
	})
}

// HandleListAPIKeys lists all webhook API keys for the organization.
// GET /api/v1/admin/webhook/keys
func (h *Handler) HandleListAPIKeys(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, "no organization context", nil)
		return
	}

	keys, err := h.repo.ListByOrganization(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	result := make([]APIKeyResponse, len(keys))
	for i, k := range keys {
		result[i] = toAPIKeyResponse(k)
	}

	httpkit.OK(c, result)
}

// HandleRevokeAPIKey deactivates a webhook API key.
// DELETE /api/v1/admin/webhook/keys/:keyId
func (h *Handler) HandleRevokeAPIKey(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, "no organization context", nil)
		return
	}

	keyID, err := uuid.Parse(c.Param("keyId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid key ID", nil)
		return
	}

	if err := h.repo.Revoke(c.Request.Context(), keyID, *tenantID); err != nil {
		if err == ErrAPIKeyNotFound {
			httpkit.Error(c, http.StatusNotFound, "API key not found", nil)
			return
		}
		httpkit.HandleError(c, err)
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API key revoked"})
}

func toAPIKeyResponse(key APIKey) APIKeyResponse {
	return APIKeyResponse{
		ID:             key.ID,
		Name:           key.Name,
		KeyPrefix:      key.KeyPrefix,
		AllowedDomains: key.AllowedDomains,
		IsActive:       key.IsActive,
		CreatedAt:      key.CreatedAt.Format("2006-01-02T15:04:05Z"),
	}
}
</file>

<file path="internal/webhook/middleware.go">
package webhook

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/gin-gonic/gin"
)

// APIKeyAuthMiddleware validates the X-Webhook-API-Key header
// and sets the organization context on the gin context.
func APIKeyAuthMiddleware(repo *Repository) gin.HandlerFunc {
	return func(c *gin.Context) {
		apiKey := c.GetHeader("X-Webhook-API-Key")
		if apiKey == "" {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing API key"})
			return
		}

		keyHash := HashKey(apiKey)
		key, err := repo.GetByHash(c.Request.Context(), keyHash)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid API key"})
			return
		}

		// Domain validation (if allowed_domains is configured)
		if len(key.AllowedDomains) > 0 {
			// The CORS bypass middleware strips the Origin header and saves
			// it as "webhookOrigin" in the gin context. Fall back to the
			// raw header and Referer for non-browser callers.
			origin := c.GetString("webhookOrigin")
			if origin == "" {
				origin = c.GetHeader("Origin")
			}
			if origin == "" {
				origin = c.GetHeader("Referer")
			}
			if !isDomainAllowed(origin, key.AllowedDomains) {
				c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "domain not allowed"})
				return
			}
		}

		// Set organization context for downstream handlers
		c.Set("webhookOrgID", key.OrganizationID)
		c.Set("webhookKeyID", key.ID)
		c.Next()
	}
}

// isDomainAllowed checks if the origin matches any of the allowed domains.
// Supports exact match and wildcard subdomains (e.g., "*.example.com").
func isDomainAllowed(origin string, allowedDomains []string) bool {
	if origin == "" {
		return false
	}

	parsed, err := url.Parse(origin)
	if err != nil {
		return false
	}
	host := strings.ToLower(parsed.Hostname())

	for _, domain := range allowedDomains {
		domain = strings.ToLower(strings.TrimSpace(domain))
		if domain == "*" {
			return true
		}
		if strings.HasPrefix(domain, "*.") {
			// Wildcard subdomain match
			suffix := domain[1:] // ".example.com"
			if strings.HasSuffix(host, suffix) || host == domain[2:] {
				return true
			}
		} else {
			if host == domain {
				return true
			}
		}
	}
	return false
}
</file>

<file path="internal/webhook/module.go">
// Package webhook provides the webhook/form capture bounded context module.
// This file defines the module that encapsulates all webhook setup and route registration.
package webhook

import (
	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the webhook bounded context module implementing http.Module.
type Module struct {
	handler *Handler
	repo    *Repository
}

// NewModule creates and initializes the webhook module with all its dependencies.
func NewModule(pool *pgxpool.Pool, leadCreator LeadCreator, storageSvc storage.StorageService, storageBucket string, eventBus events.Bus, val *validator.Validator, log *logger.Logger) *Module {
	repo := NewRepository(pool)
	service := NewService(repo, leadCreator, storageSvc, storageBucket, eventBus, log)
	handler := NewHandler(service, repo, val)

	return &Module{
		handler: handler,
		repo:    repo,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "webhook"
}

// RegisterRoutes mounts webhook routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// Public webhook endpoint (API key auth, no JWT)
	webhookGroup := ctx.V1.Group("/webhook")
	webhookGroup.Use(APIKeyAuthMiddleware(m.repo))
	webhookGroup.POST("/forms", m.handler.HandleFormSubmission)

	// Admin API key management (JWT auth + admin role)
	adminGroup := ctx.Admin.Group("/webhook/keys")
	adminGroup.POST("", m.handler.HandleCreateAPIKey)
	adminGroup.GET("", m.handler.HandleListAPIKeys)
	adminGroup.DELETE("/:keyId", m.handler.HandleRevokeAPIKey)

	// SDK serving (public, no auth)
	ctx.V1.GET("/webhook/sdk.js", m.handler.HandleServeSDK)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/webhook/repository.go">
// Package webhook provides the webhook/form capture bounded context.
// It handles API key management and inbound form submissions from external websites.
package webhook

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrAPIKeyNotFound = errors.New("webhook API key not found")

// APIKey represents a webhook API key stored in the database.
type APIKey struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Name           string
	KeyHash        string
	KeyPrefix      string
	AllowedDomains []string
	IsActive       bool
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

// Repository provides data access for webhook API keys.
type Repository struct {
	pool *pgxpool.Pool
}

// NewRepository creates a new webhook repository.
func NewRepository(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

// GenerateAPIKey creates a new random API key and returns the plaintext key and its hash.
// The plaintext key is returned only once; only the hash is stored.
func GenerateAPIKey() (plaintext string, hash string, prefix string, err error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", "", "", err
	}
	plaintext = "whk_" + hex.EncodeToString(bytes)
	h := sha256.Sum256([]byte(plaintext))
	hash = hex.EncodeToString(h[:])
	prefix = plaintext[:12] // "whk_" + 8 hex chars
	return plaintext, hash, prefix, nil
}

// HashKey hashes a plaintext API key for lookup.
func HashKey(plaintext string) string {
	h := sha256.Sum256([]byte(plaintext))
	return hex.EncodeToString(h[:])
}

// Create creates a new API key record.
func (r *Repository) Create(ctx context.Context, orgID uuid.UUID, name string, keyHash string, keyPrefix string, allowedDomains []string) (APIKey, error) {
	var key APIKey
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_webhook_api_keys (organization_id, name, key_hash, key_prefix, allowed_domains)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, organization_id, name, key_hash, key_prefix, allowed_domains, is_active, created_at, updated_at
	`, orgID, name, keyHash, keyPrefix, allowedDomains).Scan(
		&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix,
		&key.AllowedDomains, &key.IsActive, &key.CreatedAt, &key.UpdatedAt,
	)
	return key, err
}

// GetByHash retrieves an active API key by its hash.
func (r *Repository) GetByHash(ctx context.Context, keyHash string) (APIKey, error) {
	var key APIKey
	err := r.pool.QueryRow(ctx, `
		SELECT id, organization_id, name, key_hash, key_prefix, allowed_domains, is_active, created_at, updated_at
		FROM RAC_webhook_api_keys
		WHERE key_hash = $1 AND is_active = true
	`, keyHash).Scan(
		&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix,
		&key.AllowedDomains, &key.IsActive, &key.CreatedAt, &key.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return APIKey{}, ErrAPIKeyNotFound
	}
	return key, err
}

// ListByOrganization returns all API keys for an organization.
func (r *Repository) ListByOrganization(ctx context.Context, orgID uuid.UUID) ([]APIKey, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT id, organization_id, name, key_hash, key_prefix, allowed_domains, is_active, created_at, updated_at
		FROM RAC_webhook_api_keys
		WHERE organization_id = $1
		ORDER BY created_at DESC
	`, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var keys []APIKey
	for rows.Next() {
		var key APIKey
		if err := rows.Scan(
			&key.ID, &key.OrganizationID, &key.Name, &key.KeyHash, &key.KeyPrefix,
			&key.AllowedDomains, &key.IsActive, &key.CreatedAt, &key.UpdatedAt,
		); err != nil {
			return nil, err
		}
		keys = append(keys, key)
	}
	return keys, rows.Err()
}

// Revoke deactivates an API key.
func (r *Repository) Revoke(ctx context.Context, keyID uuid.UUID, orgID uuid.UUID) error {
	tag, err := r.pool.Exec(ctx, `
		UPDATE RAC_webhook_api_keys SET is_active = false, updated_at = now()
		WHERE id = $1 AND organization_id = $2
	`, keyID, orgID)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return ErrAPIKeyNotFound
	}
	return nil
}

// UpdateWebhookLeadData sets webhook-specific columns on a lead (raw_form_data, source domain, is_incomplete).
func (r *Repository) UpdateWebhookLeadData(ctx context.Context, leadID uuid.UUID, orgID uuid.UUID, rawFormData []byte, sourceDomain string, isIncomplete bool) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_leads
		SET raw_form_data = $3, webhook_source_domain = $4, is_incomplete = $5, updated_at = now()
		WHERE id = $1 AND organization_id = $2
	`, leadID, orgID, rawFormData, sourceDomain, isIncomplete)
	return err
}
</file>

<file path="internal/webhook/sdk_handler.go">
package webhook

import (
	_ "embed"
	"net/http"

	"github.com/gin-gonic/gin"
)

//go:embed sdk.js
var sdkJS []byte

// HandleServeSDK serves the form capture JavaScript SDK.
// GET /api/v1/webhook/sdk.js
func (h *Handler) HandleServeSDK(c *gin.Context) {
	c.Header("Content-Type", "application/javascript; charset=utf-8")
	c.Header("Cache-Control", "public, max-age=3600")
	c.Header("Access-Control-Allow-Origin", "*")
	c.Data(http.StatusOK, "application/javascript; charset=utf-8", sdkJS)
}
</file>

<file path="migrations/026_catalog_core.sql">
-- 026_catalog_core.sql
-- Catalog core tables: VAT rates, products, and product-material links.

CREATE TABLE IF NOT EXISTS RAC_catalog_vat_rates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    rate_bps INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_catalog_vat_rates_org_name
    ON RAC_catalog_vat_rates(organization_id, name);

CREATE TABLE IF NOT EXISTS RAC_catalog_products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    vat_rate_id UUID NOT NULL REFERENCES RAC_catalog_vat_rates(id) ON DELETE RESTRICT,
    title TEXT NOT NULL,
    reference TEXT NOT NULL,
    description TEXT,
    price_cents BIGINT NOT NULL DEFAULT 0,
    type TEXT NOT NULL,
    period_count INTEGER,
    period_unit TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_catalog_products_org_id
    ON RAC_catalog_products(organization_id);

CREATE INDEX IF NOT EXISTS idx_catalog_products_vat_rate_id
    ON RAC_catalog_products(vat_rate_id);

CREATE INDEX IF NOT EXISTS idx_catalog_products_type
    ON RAC_catalog_products(type);

CREATE TABLE IF NOT EXISTS RAC_catalog_product_materials (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES RAC_catalog_products(id) ON DELETE CASCADE,
    material_id UUID NOT NULL REFERENCES RAC_catalog_products(id) ON DELETE CASCADE,
    PRIMARY KEY (organization_id, product_id, material_id)
);

CREATE INDEX IF NOT EXISTS idx_catalog_product_materials_product
    ON RAC_catalog_product_materials(product_id);

CREATE INDEX IF NOT EXISTS idx_catalog_product_materials_material
    ON RAC_catalog_product_materials(material_id);
</file>

<file path="migrations/051_quote_preview_tokens.sql">
-- 051_quote_preview_tokens.sql
-- Read-only preview tokens for internal agent preview links

ALTER TABLE RAC_quotes
ADD COLUMN preview_token TEXT UNIQUE,
ADD COLUMN preview_token_expires_at TIMESTAMPTZ;

CREATE INDEX idx_quotes_preview_token ON RAC_quotes(preview_token) WHERE preview_token IS NOT NULL;
</file>

<file path="migrations/052_quotes_created_by.sql">
ALTER TABLE RAC_quotes
  ADD COLUMN IF NOT EXISTS created_by_id UUID REFERENCES RAC_users(id) ON DELETE SET NULL;

CREATE INDEX IF NOT EXISTS idx_quotes_created_by ON RAC_quotes(created_by_id);
</file>

<file path="migrations/053_organization_settings.sql">
-- Organization-level settings for quote defaults (payment terms, validity period).
CREATE TABLE IF NOT EXISTS RAC_organization_settings (
    organization_id UUID PRIMARY KEY REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    quote_payment_days INT NOT NULL DEFAULT 7,
    quote_valid_days   INT NOT NULL DEFAULT 14,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seed a row for every existing organization so queries never return empty.
INSERT INTO RAC_organization_settings (organization_id)
SELECT id FROM RAC_organizations
ON CONFLICT DO NOTHING;
</file>

<file path="migrations/054_quote_attachments.sql">
-- 054_quote_attachments.sql
-- Adds attachment (PDF) and URL (voorwaarden) tracking to quotes.

-- Source enum for attachment origin
CREATE TYPE rac_quote_attachment_source AS ENUM ('catalog', 'manual');

-- Quote attachments (PDF documents)
CREATE TABLE IF NOT EXISTS RAC_quote_attachments (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_id            UUID NOT NULL REFERENCES RAC_quotes(id) ON DELETE CASCADE,
    organization_id     UUID NOT NULL,
    filename            TEXT NOT NULL,
    file_key            TEXT NOT NULL,
    source              rac_quote_attachment_source NOT NULL DEFAULT 'catalog',
    catalog_product_id  UUID,
    enabled             BOOLEAN NOT NULL DEFAULT TRUE,
    sort_order          INT NOT NULL DEFAULT 0,
    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Deduplication: same filename cannot appear twice on the same quote
CREATE UNIQUE INDEX idx_quote_attachments_unique_filename
    ON RAC_quote_attachments (quote_id, filename);

CREATE INDEX idx_quote_attachments_quote_id
    ON RAC_quote_attachments (quote_id);

-- Quote URLs (voorwaarden / terms links)
CREATE TABLE IF NOT EXISTS RAC_quote_urls (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quote_id            UUID NOT NULL REFERENCES RAC_quotes(id) ON DELETE CASCADE,
    organization_id     UUID NOT NULL,
    label               TEXT NOT NULL,
    href                TEXT NOT NULL,
    accepted            BOOLEAN NOT NULL DEFAULT FALSE,
    catalog_product_id  UUID,
    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_quote_urls_quote_id
    ON RAC_quote_urls (quote_id);
</file>

<file path="migrations/055_fix_attachment_unique_index.sql">
-- 055_fix_attachment_unique_index.sql
-- Change dedup key from (quote_id, filename) to (quote_id, file_key).
-- Multiple catalog products can share the same filename (e.g. "productblad.pdf").

DROP INDEX IF EXISTS idx_quote_attachments_unique_filename;

CREATE UNIQUE INDEX idx_quote_attachments_unique_file_key
    ON RAC_quote_attachments (quote_id, file_key);
</file>

<file path="migrations/056_quote_items_catalog_product.sql">
-- 056: Add catalog_product_id to quote items for hybrid AI-drafted quotes
-- Allows linking quote line items back to their source catalog product.
-- NULL means ad-hoc (AI-estimated) item; non-NULL means catalog-linked.

ALTER TABLE RAC_quote_items
    ADD COLUMN catalog_product_id UUID;

-- Partial index on non-null values for efficient filtering
CREATE INDEX idx_quote_items_catalog_product
    ON RAC_quote_items(catalog_product_id)
    WHERE catalog_product_id IS NOT NULL;
</file>

<file path="migrations/057_fix_english_timeline_titles.sql">
-- Fix legacy English timeline titles  Dutch (ILIKE for case-insensitive match)
UPDATE lead_timeline_events SET title = 'Fase bijgewerkt'               WHERE title ILIKE 'Stage Updated';
UPDATE lead_timeline_events SET title = 'Gatekeeper analyse voltooid'   WHERE title ILIKE 'Gatekeeper Analysis Complete';
UPDATE lead_timeline_events SET title = 'Leadscore bijgewerkt'          WHERE title ILIKE 'Lead Score Updated';
UPDATE lead_timeline_events SET title = 'Leadgegevens bijgewerkt'       WHERE title ILIKE 'Lead Data Updated';
UPDATE lead_timeline_events SET title = 'Partnerzoekactie'              WHERE title ILIKE 'Partner search';
UPDATE lead_timeline_events SET title = 'Schatting opgeslagen'          WHERE title ILIKE 'Estimation saved';
UPDATE lead_timeline_events SET title = 'Gesprek geregistreerd'         WHERE title ILIKE 'Call Logged';
UPDATE lead_timeline_events SET title = 'Notitie toegevoegd'            WHERE title ILIKE 'Note Added';
UPDATE lead_timeline_events SET title = 'Handmatige interventie vereist' WHERE title ILIKE 'Manual intervention required';

-- Also fix English summaries on the orchestrator alert events
UPDATE lead_timeline_events
   SET summary = 'Geautomatiseerde verwerking vereist menselijke beoordeling'
 WHERE event_type = 'alert'
   AND summary ILIKE 'Automated processing requires human review';
</file>

<file path="migrations/058_quote_financing_disclaimer.sql">
-- 058: Add "onder voorbehoud van financiering" financing disclaimer flag to quotes.
-- When enabled, the quote proposal shows a financing disclaimer the customer must acknowledge.

ALTER TABLE RAC_quotes
    ADD COLUMN financing_disclaimer BOOLEAN NOT NULL DEFAULT false;
</file>

<file path="migrations/059_partner_offers.sql">
-- Partner Offers: Tracks job offers to vakman partners, pricing, and commitment lifecycle.
-- Supports sequential offer model (one active offer at a time per lead service).

CREATE TYPE offer_status AS ENUM ('pending', 'sent', 'accepted', 'rejected', 'expired');
CREATE TYPE pricing_source AS ENUM ('quote', 'estimate');

CREATE TABLE IF NOT EXISTS RAC_partner_offers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    partner_id UUID NOT NULL REFERENCES RAC_partners(id) ON DELETE CASCADE,
    lead_service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,

    -- Security: unguessable public token for partner-facing URLs
    public_token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,

    -- Economics (immutable snapshot at creation time)
    pricing_source pricing_source NOT NULL,
    customer_price_cents BIGINT NOT NULL CHECK (customer_price_cents >= 0),
    vakman_price_cents BIGINT NOT NULL CHECK (vakman_price_cents >= 0),

    -- Lifecycle
    status offer_status NOT NULL DEFAULT 'pending',

    -- Commitment data (filled on acceptance)
    accepted_at TIMESTAMPTZ,
    rejected_at TIMESTAMPTZ,
    rejection_reason TEXT,
    inspection_availability JSONB,
    job_availability JSONB,

    -- Audit
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Lookup by public token (partner-facing URL)
CREATE INDEX idx_partner_offers_token ON RAC_partner_offers(public_token);

-- List offers for a given lead service
CREATE INDEX idx_partner_offers_service ON RAC_partner_offers(lead_service_id);

-- List offers for a given partner
CREATE INDEX idx_partner_offers_partner ON RAC_partner_offers(partner_id);

-- Background expiration job
CREATE INDEX idx_partner_offers_expiry ON RAC_partner_offers(status, expires_at)
    WHERE status IN ('pending', 'sent');

-- Exclusivity: only ONE accepted offer per lead_service_id
CREATE UNIQUE INDEX idx_partner_offers_exclusive_acceptance
    ON RAC_partner_offers(lead_service_id)
    WHERE status = 'accepted';
</file>

<file path="migrations/060_partner_offers_summary.sql">
-- Add short job summary to partner offers for partner-facing display
ALTER TABLE RAC_partner_offers
  ADD COLUMN IF NOT EXISTS job_summary_short TEXT;
</file>

<file path="migrations/061_pipeline_quote_sent.sql">
-- Add Quote_Sent stage to the pipeline_stage enum
-- This handles the holding state between Estimation and Partner Dispatch
ALTER TYPE pipeline_stage ADD VALUE IF NOT EXISTS 'Quote_Sent' AFTER 'Ready_For_Estimator';
</file>

<file path="migrations/062_photo_analysis_v2.sql">
-- PhotoAnalyzer v2: forensic analysis with measurements, OCR, discrepancies, and product identification.
-- All columns have defaults so existing rows remain valid.

ALTER TABLE RAC_lead_photo_analyses
    ADD COLUMN IF NOT EXISTS measurements              JSONB DEFAULT '[]'::jsonb,
    ADD COLUMN IF NOT EXISTS needs_onsite_measurement  JSONB DEFAULT '[]'::jsonb,
    ADD COLUMN IF NOT EXISTS discrepancies             JSONB DEFAULT '[]'::jsonb,
    ADD COLUMN IF NOT EXISTS extracted_text             JSONB DEFAULT '[]'::jsonb,
    ADD COLUMN IF NOT EXISTS suggested_search_terms     JSONB DEFAULT '[]'::jsonb;

COMMENT ON COLUMN RAC_lead_photo_analyses.measurements IS
    'Array of {description, value, unit, type, confidence, photoRef} measurement objects';
COMMENT ON COLUMN RAC_lead_photo_analyses.needs_onsite_measurement IS
    'Array of strings: items that need physical on-site measurement';
COMMENT ON COLUMN RAC_lead_photo_analyses.discrepancies IS
    'Array of strings: contradictions between user claims and photo evidence';
COMMENT ON COLUMN RAC_lead_photo_analyses.extracted_text IS
    'Array of strings: OCR text from labels, stickers, screens, type plates';
COMMENT ON COLUMN RAC_lead_photo_analyses.suggested_search_terms IS
    'Array of strings: specific product/material names for catalog search';
</file>

<file path="migrations/063_lead_public_token.sql">
ALTER TABLE RAC_leads
    ADD COLUMN IF NOT EXISTS public_token TEXT UNIQUE,
    ADD COLUMN IF NOT EXISTS public_token_expires_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_leads_public_token ON RAC_leads(public_token) WHERE public_token IS NOT NULL;
</file>

<file path="migrations/064_lead_customer_preferences.sql">
ALTER TABLE RAC_lead_services
    ADD COLUMN IF NOT EXISTS customer_preferences JSONB DEFAULT '{}'::jsonb;
</file>

<file path="migrations/065_appointment_requested_status.sql">
-- +goose StatementBegin

ALTER TABLE RAC_appointments
  DROP CONSTRAINT IF EXISTS appointments_status_check;

ALTER TABLE RAC_appointments
  DROP CONSTRAINT IF EXISTS rac_appointments_status_check;

ALTER TABLE RAC_appointments
  ADD CONSTRAINT rac_appointments_status_check
  CHECK (status IN ('scheduled', 'requested', 'completed', 'cancelled', 'no_show'));

-- +goose StatementEnd
</file>

<file path="migrations/066_partner_offers_builder_summary.sql">
-- Add AI-generated builder summary for partner offers (markdown)
ALTER TABLE RAC_partner_offers
  ADD COLUMN IF NOT EXISTS builder_summary TEXT;
</file>

<file path="migrations/067_organization_whatsapp_device.sql">
ALTER TABLE RAC_organization_settings
ADD COLUMN IF NOT EXISTS whatsapp_device_id TEXT;
</file>

<file path="migrations/068_remove_service_type_order.sql">
-- Migration: Remove display_order from RAC_service_types

DROP INDEX IF EXISTS idx_service_types_display_order;

ALTER TABLE RAC_service_types
    DROP COLUMN IF EXISTS display_order;
</file>

<file path="migrations/069_smart_feed_prep.sql">
-- Smart Feed: schema prep for future roadmap features + performance indexes
-- Migration: 069_smart_feed_prep.sql

-- =============================================
-- 1. Performance indexes for clustering window functions
-- =============================================

-- Composite index to support the 15-minute clustering window function
CREATE INDEX IF NOT EXISTS idx_lead_activity_cluster
  ON RAC_lead_activity(organization_id, lead_id, action, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_quote_activity_cluster
  ON RAC_quote_activity(organization_id, event_type, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_timeline_events_cluster
  ON lead_timeline_events(organization_id, lead_id, event_type, created_at DESC);

-- General performance: support the main UNION ALL WHERE clause
CREATE INDEX IF NOT EXISTS idx_lead_activity_org_created
  ON RAC_lead_activity(organization_id, created_at DESC);


-- =============================================
-- 2. Read State  "New" line separator (Future)
-- =============================================

-- Track when each user last viewed the activity feed.
-- Used to inject a "New updates" separator in the feed response.
CREATE TABLE IF NOT EXISTS RAC_feed_read_state (
  user_id UUID NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  last_feed_viewed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  feed_mode TEXT NOT NULL DEFAULT 'all'
    CHECK (feed_mode IN ('all', 'high_signal')),
  PRIMARY KEY (user_id, organization_id)
);


-- =============================================
-- 3. Threaded Comments / Reactions on events (Future)
-- =============================================

-- Allow notes to be threaded as replies to specific feed events.
-- parent_event_type identifies which source table the event came from.
ALTER TABLE RAC_lead_notes
  ADD COLUMN IF NOT EXISTS parent_event_id UUID,
  ADD COLUMN IF NOT EXISTS parent_event_type TEXT CHECK (
    parent_event_type IS NULL OR parent_event_type IN (
      'lead_activity', 'quote_activity', 'timeline_event', 'appointment'
    )
  );

CREATE INDEX IF NOT EXISTS idx_lead_notes_parent_event
  ON RAC_lead_notes(parent_event_id) WHERE parent_event_id IS NOT NULL;


-- =============================================
-- 4. Pinned / Sticky Alert Cards (Future)
-- =============================================

-- Force-pinned alert cards that float to the top of the feed
-- until resolved or dismissed. Supports "manual_intervention" and
-- "urgent_analysis" alert types.
CREATE TABLE IF NOT EXISTS RAC_feed_pinned_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
  alert_type TEXT NOT NULL,
  resolved_at TIMESTAMPTZ,
  dismissed_by UUID REFERENCES RAC_users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_feed_pinned_alerts_org
  ON RAC_feed_pinned_alerts(organization_id) WHERE resolved_at IS NULL;
</file>

<file path="migrations/070_feed_reactions_comments.sql">
-- 070: Feed reactions, comments and @-mentions
-- Adds social interactions to the activity feed.

-- ==============================
-- Reactions table
-- ==============================
CREATE TABLE IF NOT EXISTS RAC_feed_reactions (
  id            UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id      TEXT        NOT NULL,          -- composite key for the feed item
  event_source  TEXT        NOT NULL,          -- category: leads, quotes, appointments, ai
  reaction_type TEXT        NOT NULL CHECK (reaction_type IN ('thumbs-up','heart','party-popper','flame')),
  user_id       UUID        NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  org_id        UUID        NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- one reaction per type per user per event
  UNIQUE (event_id, event_source, reaction_type, user_id)
);

CREATE INDEX IF NOT EXISTS idx_feed_reactions_event
  ON RAC_feed_reactions (event_id, event_source);

CREATE INDEX IF NOT EXISTS idx_feed_reactions_org
  ON RAC_feed_reactions (org_id);

-- ==============================
-- Comments table
-- ==============================
CREATE TABLE IF NOT EXISTS RAC_feed_comments (
  id            UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id      TEXT        NOT NULL,
  event_source  TEXT        NOT NULL,
  user_id       UUID        NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  org_id        UUID        NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  body          TEXT        NOT NULL CHECK (char_length(body) BETWEEN 1 AND 2000),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_feed_comments_event
  ON RAC_feed_comments (event_id, event_source);

CREATE INDEX IF NOT EXISTS idx_feed_comments_org
  ON RAC_feed_comments (org_id);

-- ==============================
-- Comment mentions table (M2M)
-- ==============================
CREATE TABLE IF NOT EXISTS RAC_feed_comment_mentions (
  id            UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id    UUID        NOT NULL REFERENCES RAC_feed_comments(id) ON DELETE CASCADE,
  mentioned_user_id UUID   NOT NULL REFERENCES RAC_users(id) ON DELETE CASCADE,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE (comment_id, mentioned_user_id)
);

CREATE INDEX IF NOT EXISTS idx_feed_comment_mentions_comment
  ON RAC_feed_comment_mentions (comment_id);

CREATE INDEX IF NOT EXISTS idx_feed_comment_mentions_user
  ON RAC_feed_comment_mentions (mentioned_user_id);
</file>

<file path="migrations/071_lead_notes_service_scope.sql">
-- Scope lead notes to individual services.
-- service_id is nullable for backward compatibility with pre-existing notes.

ALTER TABLE RAC_lead_notes
  ADD COLUMN IF NOT EXISTS service_id UUID REFERENCES RAC_lead_services(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_lead_notes_service ON RAC_lead_notes(lead_id, service_id, created_at DESC);
</file>

<file path="migrations/072_webhook_api_keys.sql">
-- Webhook API keys for external form capture
CREATE TABLE IF NOT EXISTS RAC_webhook_api_keys (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
    name            TEXT NOT NULL DEFAULT '',
    key_hash        TEXT NOT NULL,
    key_prefix      TEXT NOT NULL,
    allowed_domains TEXT[] NOT NULL DEFAULT '{}',
    is_active       BOOLEAN NOT NULL DEFAULT true,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_webhook_api_keys_org ON RAC_webhook_api_keys(organization_id);
CREATE INDEX idx_webhook_api_keys_prefix ON RAC_webhook_api_keys(key_prefix);

-- Add webhook-specific columns to RAC_leads
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS raw_form_data JSONB;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS webhook_source_domain TEXT;
ALTER TABLE RAC_leads ADD COLUMN IF NOT EXISTS is_incomplete BOOLEAN NOT NULL DEFAULT false;
</file>

<file path="migrations/073_general_service_type.sql">
-- Migration 073: Make all service types tenant-scoped
-- 1. Drop leftover global unique constraints (migration 024 used wrong names).
-- 2. Copy global (NULL org) service types into every existing org.
-- 3. Seed "Algemeen" for every org.
-- 4. Delete orphan global rows.
-- 5. Make organization_id NOT NULL.

BEGIN;

-- Step 1: Drop global unique constraints that block per-org duplicates.
ALTER TABLE rac_service_types DROP CONSTRAINT IF EXISTS rac_service_types_name_key;
ALTER TABLE rac_service_types DROP CONSTRAINT IF EXISTS rac_service_types_slug_key;

-- Step 2: Copy each global service type into every org that doesn't already have it.
INSERT INTO rac_service_types (id, organization_id, name, slug, description, icon, color, is_active)
SELECT
    gen_random_uuid(),
    o.id,
    g.name,
    g.slug,
    g.description,
    g.icon,
    g.color,
    g.is_active
FROM rac_service_types g
CROSS JOIN rac_organizations o
WHERE g.organization_id IS NULL
  AND NOT EXISTS (
      SELECT 1 FROM rac_service_types existing
      WHERE existing.organization_id = o.id AND existing.slug = g.slug
  );

-- Step 3: Seed "Algemeen" for every org that doesn't already have it.
INSERT INTO rac_service_types (id, organization_id, name, slug, description, icon, color, is_active)
SELECT
    gen_random_uuid(),
    o.id,
    'Algemeen',
    'algemeen',
    'Algemene aanvragen en niet-gecategoriseerde verzoeken',
    'inbox',
    '#9CA3AF',
    true
FROM rac_organizations o
WHERE NOT EXISTS (
    SELECT 1 FROM rac_service_types st
    WHERE st.organization_id = o.id AND st.slug = 'algemeen'
);

-- Step 4: Delete global (NULL org) service types  they are now copied into each org.
DELETE FROM rac_service_types WHERE organization_id IS NULL;

-- Step 5: Make organization_id NOT NULL so no global types can be created.
ALTER TABLE rac_service_types ALTER COLUMN organization_id SET NOT NULL;

COMMIT;
</file>

<file path="migrations/074_google_ads_exports.sql">
-- Google Ads tracking fields and export infrastructure

ALTER TABLE RAC_leads
  ADD COLUMN IF NOT EXISTS gclid TEXT,
  ADD COLUMN IF NOT EXISTS utm_source TEXT,
  ADD COLUMN IF NOT EXISTS utm_medium TEXT,
  ADD COLUMN IF NOT EXISTS utm_campaign TEXT,
  ADD COLUMN IF NOT EXISTS utm_content TEXT,
  ADD COLUMN IF NOT EXISTS utm_term TEXT,
  ADD COLUMN IF NOT EXISTS ad_landing_page TEXT,
  ADD COLUMN IF NOT EXISTS referrer_url TEXT;

CREATE INDEX IF NOT EXISTS idx_leads_gclid ON RAC_leads(gclid) WHERE gclid IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_leads_org_created_at ON RAC_leads(organization_id, created_at DESC);

-- API keys for Google Ads exports
CREATE TABLE IF NOT EXISTS RAC_export_api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  key_hash TEXT NOT NULL UNIQUE,
  key_prefix TEXT NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID REFERENCES RAC_users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_used_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_export_keys_org ON RAC_export_api_keys(organization_id);
CREATE INDEX IF NOT EXISTS idx_export_keys_hash_active ON RAC_export_api_keys(key_hash) WHERE is_active = true;

-- Lead service events for exportable conversion milestones
CREATE TABLE IF NOT EXISTS RAC_lead_service_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
  lead_service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL CHECK (event_type IN ('status_changed', 'pipeline_stage_changed', 'service_created')),
  status TEXT,
  pipeline_stage TEXT,
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_service_events_org_time ON RAC_lead_service_events(organization_id, occurred_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_service_events_service ON RAC_lead_service_events(lead_service_id, occurred_at DESC);

-- Track exported conversions to avoid duplicates
CREATE TABLE IF NOT EXISTS RAC_google_ads_exports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES RAC_organizations(id) ON DELETE CASCADE,
  lead_id UUID NOT NULL REFERENCES RAC_leads(id) ON DELETE CASCADE,
  lead_service_id UUID NOT NULL REFERENCES RAC_lead_services(id) ON DELETE CASCADE,
  conversion_name TEXT NOT NULL,
  conversion_time TIMESTAMPTZ NOT NULL,
  conversion_value NUMERIC(12,2),
  gclid TEXT NOT NULL,
  order_id TEXT NOT NULL,
  exported_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (organization_id, order_id, conversion_name)
);

CREATE INDEX IF NOT EXISTS idx_gads_exports_org_time ON RAC_google_ads_exports(organization_id, exported_at DESC);
</file>

<file path="platform/ai/embeddingapi/client.go">
// Package embeddingapi provides a client for the product embedding API.
package embeddingapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// Client is an HTTP client for the product embedding API.
type Client struct {
	baseURL    string
	apiKey     string
	collection string
	httpClient *http.Client
}

// Config configures the product embedding API client.
type Config struct {
	BaseURL    string
	APIKey     string
	Collection string
	Timeout    time.Duration
}

// NewClient creates a new product embedding API client.
func NewClient(cfg Config) *Client {
	timeout := cfg.Timeout
	if timeout == 0 {
		timeout = 30 * time.Second
	}

	return &Client{
		baseURL:    strings.TrimRight(cfg.BaseURL, "/"),
		apiKey:     cfg.APIKey,
		collection: strings.TrimSpace(cfg.Collection),
		httpClient: &http.Client{Timeout: timeout},
	}
}

// AddDocumentsRequest is the request body for adding documents.
type AddDocumentsRequest struct {
	Documents  []map[string]any `json:"documents"`
	TextFields []string         `json:"text_fields,omitempty"`
	IDField    string           `json:"id_field,omitempty"`
	Collection string           `json:"collection,omitempty"`
}

// AddDocumentsResponse is the response from the add documents endpoint.
type AddDocumentsResponse struct {
	Success        bool     `json:"success"`
	DocumentsAdded int      `json:"documents_added"`
	IDs            []string `json:"ids"`
	Message        string   `json:"message"`
}

// AddDocuments sends documents to the product embedding API.
func (c *Client) AddDocuments(ctx context.Context, req AddDocumentsRequest) (AddDocumentsResponse, error) {
	if len(req.Documents) == 0 {
		return AddDocumentsResponse{}, fmt.Errorf("documents are required")
	}
	if req.Collection == "" {
		req.Collection = c.collection
	}

	bodyBytes, err := json.Marshal(req)
	if err != nil {
		return AddDocumentsResponse{}, fmt.Errorf("failed to marshal add documents request: %w", err)
	}

	url := c.baseURL + "/api/documents"
	request, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(bodyBytes))
	if err != nil {
		return AddDocumentsResponse{}, fmt.Errorf("failed to create add documents request: %w", err)
	}

	request.Header.Set("Content-Type", "application/json")
	if c.apiKey != "" {
		request.Header.Set("Authorization", "Bearer "+c.apiKey)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return AddDocumentsResponse{}, fmt.Errorf("add documents request failed: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {
		body, _ := io.ReadAll(resp.Body)
		return AddDocumentsResponse{}, fmt.Errorf("embedding API returned %d: %s", resp.StatusCode, string(body))
	}

	var result AddDocumentsResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		body, _ := io.ReadAll(resp.Body)
		return AddDocumentsResponse{}, fmt.Errorf("failed to decode add documents response: %w (%s)", err, string(body))
	}

	return result, nil
}
</file>

<file path="platform/ai/embeddings/client.go">
// Package embeddings provides a client for external embedding API services.
package embeddings

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// Client is an HTTP client for embedding API services.
type Client struct {
	baseURL    string
	apiKey     string
	httpClient *http.Client
}

// Config configures the embedding client.
type Config struct {
	BaseURL string
	APIKey  string
	Timeout time.Duration
}

// NewClient creates a new embedding API client.
func NewClient(cfg Config) *Client {
	timeout := cfg.Timeout
	if timeout == 0 {
		timeout = 30 * time.Second
	}

	return &Client{
		baseURL: cfg.BaseURL,
		apiKey:  cfg.APIKey,
		httpClient: &http.Client{
			Timeout: timeout,
		},
	}
}

// embeddingRequest is the request body for the embedding API.
type embeddingRequest struct {
	Text string `json:"text"`
}

// Embed generates an embedding vector for the given text.
// Returns a 1024-dimensional vector for BGE-M3.
func (c *Client) Embed(ctx context.Context, text string) ([]float32, error) {
	reqBody := embeddingRequest{Text: text}
	bodyBytes, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal embedding request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.baseURL, bytes.NewReader(bodyBytes))
	if err != nil {
		return nil, fmt.Errorf("failed to create embedding request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	if c.apiKey != "" {
		req.Header.Set("Authorization", "Bearer "+c.apiKey)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("embedding request failed: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("embedding API returned %d: %s", resp.StatusCode, string(body))
	}

	// Accept both {"vector": [...]} and raw array responses for compatibility.
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read embedding response: %w", err)
	}

	var wrapped struct {
		Vector []float32 `json:"vector"`
	}
	if err := json.Unmarshal(body, &wrapped); err == nil && len(wrapped.Vector) > 0 {
		return wrapped.Vector, nil
	}

	var vector []float32
	if err := json.Unmarshal(body, &vector); err == nil {
		return vector, nil
	}

	return nil, fmt.Errorf("failed to decode embedding response")
}
</file>

<file path="platform/db/migrate.go">
// Package db provides database connection infrastructure.
// This is part of the platform layer and contains no business logic.
package db

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"portal_final_backend/platform/config"

	"github.com/jackc/pgx/v5"
)

// RunMigrations applies all pending .sql migrations from the provided directory.
// It uses a _migrations tracking table, an advisory lock for concurrency safety,
// and SHA-256 checksums to detect drift in already-applied files.
func RunMigrations(ctx context.Context, cfg config.DatabaseConfig, migrationsDir string) error {
	dir, err := resolveMigrationsDir(migrationsDir)
	if err != nil {
		return err
	}
	if dir == "" {
		return nil // empty input  nothing to do
	}

	files, err := collectSQLFiles(dir)
	if err != nil {
		return err
	}
	if len(files) == 0 {
		return nil
	}

	conn, err := pgx.Connect(ctx, cfg.GetDatabaseURL())
	if err != nil {
		return fmt.Errorf("connect for migrations: %w", err)
	}
	defer func() { _ = conn.Close(ctx) }()

	if err := acquireAdvisoryLock(ctx, conn); err != nil {
		return err
	}
	defer releaseAdvisoryLock(ctx, conn)

	if err := ensureTrackingTable(ctx, conn); err != nil {
		return err
	}

	if err := bootstrapExistingDB(ctx, conn, dir, files); err != nil {
		return fmt.Errorf("bootstrap existing db: %w", err)
	}

	applied, err := loadAppliedMigrations(ctx, conn)
	if err != nil {
		return err
	}

	return applyPendingMigrations(ctx, conn, dir, files, applied)
}

// resolveMigrationsDir validates and resolves the migrations directory path.
func resolveMigrationsDir(dir string) (string, error) {
	if strings.TrimSpace(dir) == "" {
		return "", nil
	}

	cleaned := filepath.Clean(dir)
	if !filepath.IsAbs(cleaned) {
		abs, err := filepath.Abs(cleaned)
		if err != nil {
			return "", fmt.Errorf("resolve migrations dir: %w", err)
		}
		cleaned = abs
	}

	stat, err := os.Stat(cleaned)
	if err != nil {
		return "", fmt.Errorf("migrations dir not found: %s", cleaned)
	}
	if !stat.IsDir() {
		return "", fmt.Errorf("migrations dir is not a directory: %s", cleaned)
	}

	return cleaned, nil
}

// collectSQLFiles reads a directory and returns sorted .sql filenames.
func collectSQLFiles(dir string) ([]string, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("read migrations dir: %w", err)
	}

	var files []string
	for _, e := range entries {
		if !e.IsDir() && strings.HasSuffix(e.Name(), ".sql") {
			files = append(files, e.Name())
		}
	}
	sort.Strings(files)
	return files, nil
}

const advisoryLockKey = 1234567890

// acquireAdvisoryLock obtains a PostgreSQL advisory lock for migration safety.
func acquireAdvisoryLock(ctx context.Context, conn *pgx.Conn) error {
	if _, err := conn.Exec(ctx, `SELECT pg_advisory_lock($1)`, advisoryLockKey); err != nil {
		return fmt.Errorf("acquire advisory lock: %w", err)
	}
	return nil
}

// releaseAdvisoryLock releases the PostgreSQL advisory lock.
func releaseAdvisoryLock(ctx context.Context, conn *pgx.Conn) {
	_, _ = conn.Exec(ctx, `SELECT pg_advisory_unlock($1)`, advisoryLockKey)
}

// ensureTrackingTable creates or upgrades the _migrations tracking table.
func ensureTrackingTable(ctx context.Context, conn *pgx.Conn) error {
	if _, err := conn.Exec(ctx, `
		CREATE TABLE IF NOT EXISTS _migrations (
			filename   TEXT PRIMARY KEY,
			checksum   TEXT NOT NULL DEFAULT '',
			applied_at TIMESTAMPTZ NOT NULL DEFAULT now()
		)
	`); err != nil {
		return fmt.Errorf("create _migrations table: %w", err)
	}

	// Add checksum column if upgrading from earlier version of this table.
	_, _ = conn.Exec(ctx, `ALTER TABLE _migrations ADD COLUMN IF NOT EXISTS checksum TEXT NOT NULL DEFAULT ''`)

	return nil
}

// loadAppliedMigrations returns a map of filename  checksum for all applied migrations.
func loadAppliedMigrations(ctx context.Context, conn *pgx.Conn) (map[string]string, error) {
	rows, err := conn.Query(ctx, `SELECT filename, checksum FROM _migrations`)
	if err != nil {
		return nil, fmt.Errorf("query _migrations: %w", err)
	}
	defer rows.Close()

	applied := make(map[string]string)
	for rows.Next() {
		var name, cs string
		if err := rows.Scan(&name, &cs); err != nil {
			return nil, fmt.Errorf("scan _migrations row: %w", err)
		}
		applied[name] = cs
	}
	return applied, nil
}

// applyPendingMigrations applies all migrations not yet tracked in _migrations.
func applyPendingMigrations(ctx context.Context, conn *pgx.Conn, dir string, files []string, applied map[string]string) error {
	for _, f := range files {
		content, err := os.ReadFile(filepath.Join(dir, f))
		if err != nil {
			return fmt.Errorf("read migration %s: %w", f, err)
		}
		cs := sha256sum(content)

		if existingCS, ok := applied[f]; ok {
			if existingCS != "" && existingCS != cs {
				slog.Warn("migration checksum mismatch  file was modified after it was applied",
					"file", f, "expected", existingCS, "actual", cs)
			}
			continue
		}

		if err := applyMigration(ctx, conn, f, string(content), cs); err != nil {
			return err
		}
	}
	return nil
}

// applyMigration runs a single migration file inside a transaction and records it.
func applyMigration(ctx context.Context, conn *pgx.Conn, filename, sql, checksum string) error {
	slog.Info("applying migration", "file", filename)

	tx, err := conn.Begin(ctx)
	if err != nil {
		return fmt.Errorf("begin tx for %s: %w", filename, err)
	}

	if _, err := tx.Exec(ctx, sql); err != nil {
		_ = tx.Rollback(ctx)
		return fmt.Errorf("execute migration %s: %w", filename, err)
	}
	if _, err := tx.Exec(ctx, `INSERT INTO _migrations (filename, checksum) VALUES ($1, $2)`, filename, checksum); err != nil {
		_ = tx.Rollback(ctx)
		return fmt.Errorf("record migration %s: %w", filename, err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("commit migration %s: %w", filename, err)
	}
	return nil
}

// bootstrapExistingDB seeds the _migrations table when switching from another
// migration tool (or manual DDL) to this runner. It only runs the INSERT loop
// when the table has fewer entries than there are files AND the DB already has
// known application tables.
func bootstrapExistingDB(ctx context.Context, conn *pgx.Conn, dir string, files []string) error {
	var count int
	if err := conn.QueryRow(ctx, `SELECT count(*) FROM _migrations`).Scan(&count); err != nil {
		return err
	}
	if count >= len(files) {
		return nil // fully seeded already
	}

	// Only auto-seed if the DB already has application tables.
	var hasExisting bool
	if err := conn.QueryRow(ctx, `
		SELECT EXISTS (
			SELECT 1 FROM information_schema.tables
			WHERE table_schema = 'public'
			  AND table_name IN ('schema_migrations', 'rac_users', 'rac_leads', 'rac_roles')
		)
	`).Scan(&hasExisting); err != nil {
		return err
	}
	if !hasExisting {
		return nil // fresh database  run everything from scratch
	}

	slog.Info("bootstrapping _migrations table from existing database", "files", len(files), "already_tracked", count)

	for _, f := range files {
		content, err := os.ReadFile(filepath.Join(dir, f))
		if err != nil {
			return fmt.Errorf("read %s for checksum: %w", f, err)
		}
		cs := sha256sum(content)
		if _, err := conn.Exec(ctx,
			`INSERT INTO _migrations (filename, checksum) VALUES ($1, $2) ON CONFLICT (filename) DO UPDATE SET checksum = EXCLUDED.checksum WHERE _migrations.checksum = ''`,
			f, cs,
		); err != nil {
			return fmt.Errorf("seed _migrations for %s: %w", f, err)
		}
	}

	return nil
}

func sha256sum(data []byte) string {
	h := sha256.Sum256(data)
	return hex.EncodeToString(h[:])
}
</file>

<file path="platform/httpkit/middleware.go">
// Package httpkit provides HTTP middleware infrastructure.
// This is part of the platform layer and contains no business logic.
package httpkit

import (
	"errors"
	"net/http"
	"strings"
	"sync"
	"time"

	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/time/rate"
)

const (
	// ContextUserIDKey is the gin context key for the authenticated user ID.
	ContextUserIDKey = "userID"
	// ContextRolesKey is the gin context key for the user's roles.
	ContextRolesKey = "roles"
	// ContextTenantIDKey is the gin context key for the tenant (organization) ID.
	ContextTenantIDKey = "tenantID"

	errMissingToken = "missing token"
	errInvalidToken = "invalid token"
)

// RequestLogger logs HTTP requests with timing.
func RequestLogger(log *logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path

		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		clientIP := c.ClientIP()

		log.HTTPRequest(c.Request.Method, path, status, float64(latency.Milliseconds()), clientIP)
	}
}

// SecurityHeaders adds security headers to responses.
func SecurityHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		c.Header("Content-Security-Policy", "default-src 'self'")
		c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()")

		// Only add HSTS in production
		if c.Request.TLS != nil {
			c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}

		c.Next()
	}
}

// IPRateLimiter manages per-IP rate limiters.
type IPRateLimiter struct {
	limiters sync.Map
	rate     rate.Limit
	burst    int
	log      *logger.Logger
}

// NewIPRateLimiter creates a new IP-based rate limiter.
func NewIPRateLimiter(r rate.Limit, burst int, log *logger.Logger) *IPRateLimiter {
	return &IPRateLimiter{
		rate:  r,
		burst: burst,
		log:   log,
	}
}

func (i *IPRateLimiter) getLimiter(ip string) *rate.Limiter {
	limiter, exists := i.limiters.Load(ip)
	if !exists {
		newLimiter := rate.NewLimiter(i.rate, i.burst)
		i.limiters.Store(ip, newLimiter)
		return newLimiter
	}
	return limiter.(*rate.Limiter)
}

// RateLimit returns a middleware that rate limits by IP.
// OPTIONS (CORS preflight) requests are exempt so they don't
// consume rate-limit tokens.
func (i *IPRateLimiter) RateLimit() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Skip rate limiting for CORS preflight requests
		if c.Request.Method == http.MethodOptions {
			c.Next()
			return
		}

		ip := c.ClientIP()
		limiter := i.getLimiter(ip)

		if !limiter.Allow() {
			if i.log != nil {
				i.log.RateLimitExceeded(ip, c.Request.URL.Path)
			}
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"error": "rate limit exceeded",
			})
			return
		}

		c.Next()
	}
}

// AuthRateLimiter is a stricter rate limiter for auth endpoints.
type AuthRateLimiter struct {
	*IPRateLimiter
}

// NewAuthRateLimiter creates a rate limiter for authentication endpoints
// with stricter limits (e.g., 5 requests per minute).
func NewAuthRateLimiter(log *logger.Logger) *AuthRateLimiter {
	return &AuthRateLimiter{
		IPRateLimiter: NewIPRateLimiter(rate.Limit(5.0/60.0), 5, log), // 5 requests per minute, burst of 5
	}
}

// AuthRequired returns middleware that validates JWT access tokens.
// Supports token via Authorization header (Bearer) or query param (for SSE).
func AuthRequired(cfg config.JWTConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		rawToken, ok := extractBearerToken(c.GetHeader("Authorization"))
		if !ok {
			// Fallback to query param for SSE connections
			rawToken = c.Query("token")
			if rawToken == "" {
				abortUnauthorized(c, errMissingToken)
				return
			}
		}

		claims, err := parseAccessClaims(rawToken, cfg)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		userID, err := parseUserID(claims)
		if err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		}

		roles := extractRoles(claims["roles"])
		c.Set(ContextUserIDKey, userID)
		c.Set(ContextRolesKey, roles)

		if tenantID, err := parseTenantID(claims); err != nil {
			abortUnauthorized(c, errInvalidToken)
			return
		} else if tenantID != nil {
			c.Set(ContextTenantIDKey, *tenantID)
		}
		c.Next()
	}
}

// RequireRole returns middleware that checks if the user has the specified role.
func RequireRole(role string) gin.HandlerFunc {
	return func(c *gin.Context) {
		roles, ok := c.Get(ContextRolesKey)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		roleList, ok := roles.([]string)
		if !ok {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
			return
		}

		for _, item := range roleList {
			if item == role {
				c.Next()
				return
			}
		}

		c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "forbidden"})
	}
}

func extractRoles(value interface{}) []string {
	roles := make([]string, 0)
	if value == nil {
		return roles
	}

	switch typed := value.(type) {
	case []string:
		return append(roles, typed...)
	case []interface{}:
		for _, item := range typed {
			if text, ok := item.(string); ok {
				roles = append(roles, text)
			}
		}
	}

	return roles
}

func extractBearerToken(authHeader string) (string, bool) {
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return "", false
	}

	rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
	if rawToken == "" {
		return "", false
	}

	return rawToken, true
}

func parseAccessClaims(rawToken string, cfg config.JWTConfig) (jwt.MapClaims, error) {
	parsed, err := jwt.Parse(rawToken, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("invalid signing method")
		}
		return []byte(cfg.GetJWTAccessSecret()), nil
	})
	if err != nil || !parsed.Valid {
		return nil, errors.New(errInvalidToken)
	}

	claims, ok := parsed.Claims.(jwt.MapClaims)
	if !ok {
		return nil, errors.New(errInvalidToken)
	}

	if tokenType, _ := claims["type"].(string); tokenType != "access" {
		return nil, errors.New(errInvalidToken)
	}

	return claims, nil
}

func parseUserID(claims jwt.MapClaims) (uuid.UUID, error) {
	userIDRaw, _ := claims["sub"].(string)
	return uuid.Parse(userIDRaw)
}

func parseTenantID(claims jwt.MapClaims) (*uuid.UUID, error) {
	value, ok := claims["tenant_id"].(string)
	if !ok || strings.TrimSpace(value) == "" {
		return nil, nil
	}
	parsed, err := uuid.Parse(value)
	if err != nil {
		return nil, err
	}
	return &parsed, nil
}

func abortUnauthorized(c *gin.Context, message string) {
	c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": message})
}
</file>

<file path="start.sh">
#!/bin/sh
set -eu

# Start scheduler in background and forward termination signals.
/app/scheduler &
scheduler_pid=$!

terminate() {
	kill -TERM "$scheduler_pid" 2>/dev/null || true
}

trap terminate INT TERM

exec /app/server
</file>

<file path="internal/adapters/catalog_product_reader.go">
package adapters

import (
	"context"
	"fmt"

	"github.com/google/uuid"

	catrepo "portal_final_backend/internal/catalog/repository"
	"portal_final_backend/internal/leads/ports"
)

// CatalogProductReader adapts the catalog repository for the leads domain.
// It composes GetProductsByIDs, ListProductMaterials and GetVatRateByID to
// return fully-hydrated CatalogProductDetails, satisfying ports.CatalogReader.
type CatalogProductReader struct {
	repo catrepo.Repository
}

// NewCatalogProductReader creates a new catalog reader adapter.
func NewCatalogProductReader(repo catrepo.Repository) *CatalogProductReader {
	return &CatalogProductReader{repo: repo}
}

// GetProductDetails returns enriched product details (including materials and
// resolved VAT rate) for the given IDs. Unknown IDs are silently omitted.
func (a *CatalogProductReader) GetProductDetails(ctx context.Context, orgID uuid.UUID, productIDs []uuid.UUID) ([]ports.CatalogProductDetails, error) {
	if len(productIDs) == 0 {
		return nil, nil
	}

	products, err := a.repo.GetProductsByIDs(ctx, orgID, productIDs)
	if err != nil {
		return nil, fmt.Errorf("catalog adapter: get products: %w", err)
	}

	// Collect unique VAT rate IDs.
	vatIDs := make(map[uuid.UUID]struct{})
	for _, p := range products {
		vatIDs[p.VatRateID] = struct{}{}
	}

	// Batch-fetch VAT rates.
	vatRates := make(map[uuid.UUID]int) // vatRateID  rateBps
	for id := range vatIDs {
		vr, err := a.repo.GetVatRateByID(ctx, orgID, id)
		if err != nil {
			// Non-fatal: default to 0 if VAT rate lookup fails.
			continue
		}
		vatRates[id] = vr.RateBps
	}

	result := make([]ports.CatalogProductDetails, 0, len(products))
	for _, p := range products {
		result = append(result, a.productToDetail(ctx, orgID, p, vatRates))
	}

	return result, nil
}

// productToDetail converts a single catalog product into a CatalogProductDetails,
// enriching it with materials, document/URL assets, and the resolved VAT rate.
func (a *CatalogProductReader) productToDetail(ctx context.Context, orgID uuid.UUID, p catrepo.Product, vatRates map[uuid.UUID]int) ports.CatalogProductDetails {
	detail := ports.CatalogProductDetails{
		ID:             p.ID,
		Title:          p.Title,
		UnitPriceCents: p.UnitPriceCents,
		VatRateBps:     vatRates[p.VatRateID],
		Materials:      a.fetchMaterialNames(ctx, orgID, p.ID),
	}

	setOptional(&detail.Description, p.Description)
	setOptional(&detail.UnitLabel, p.UnitLabel)
	setOptional(&detail.LaborTimeText, p.LaborTimeText)

	detail.Documents = a.fetchDocumentAssets(ctx, orgID, p.ID)
	detail.URLs = a.fetchURLAssets(ctx, orgID, p.ID)

	return detail
}

// setOptional assigns src to dst when src is non-nil.
func setOptional(dst *string, src *string) {
	if src != nil {
		*dst = *src
	}
}

// fetchMaterialNames returns the material titles for a product.
func (a *CatalogProductReader) fetchMaterialNames(ctx context.Context, orgID, productID uuid.UUID) []string {
	materials, err := a.repo.ListProductMaterials(ctx, orgID, productID)
	if err != nil {
		return nil
	}
	names := make([]string, len(materials))
	for i, m := range materials {
		names[i] = m.Title
	}
	return names
}

// fetchDocumentAssets returns catalog document assets (PDFs, specs) for a product.
func (a *CatalogProductReader) fetchDocumentAssets(ctx context.Context, orgID, productID uuid.UUID) []ports.CatalogDocument {
	docType := "document"
	assets, err := a.repo.ListProductAssets(ctx, catrepo.ListProductAssetsParams{
		OrganizationID: orgID,
		ProductID:      productID,
		AssetType:      &docType,
	})
	if err != nil {
		return nil
	}
	var docs []ports.CatalogDocument
	for _, asset := range assets {
		if asset.FileKey != nil && asset.FileName != nil {
			docs = append(docs, ports.CatalogDocument{
				ID:       asset.ID,
				Filename: *asset.FileName,
				FileKey:  *asset.FileKey,
			})
		}
	}
	return docs
}

// fetchURLAssets returns catalog URL assets (terms & conditions, links) for a product.
func (a *CatalogProductReader) fetchURLAssets(ctx context.Context, orgID, productID uuid.UUID) []ports.CatalogURL {
	urlType := "terms_url"
	assets, err := a.repo.ListProductAssets(ctx, catrepo.ListProductAssetsParams{
		OrganizationID: orgID,
		ProductID:      productID,
		AssetType:      &urlType,
	})
	if err != nil {
		return nil
	}
	var urls []ports.CatalogURL
	for _, asset := range assets {
		if asset.URL == nil || *asset.URL == "" {
			continue
		}
		label := "Link"
		if asset.FileName != nil && *asset.FileName != "" {
			label = *asset.FileName
		}
		urls = append(urls, ports.CatalogURL{
			Label: label,
			Href:  *asset.URL,
		})
	}
	return urls
}

// Compile-time check that CatalogProductReader implements ports.CatalogReader.
var _ ports.CatalogReader = (*CatalogProductReader)(nil)
</file>

<file path="internal/adapters/organization_public_viewer.go">
package adapters

import (
	"context"
	"strings"

	identitysvc "portal_final_backend/internal/identity/service"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// OrganizationPublicAdapter exposes organization contact info for the public lead portal.
type OrganizationPublicAdapter struct {
	svc *identitysvc.Service
}

func NewOrganizationPublicAdapter(svc *identitysvc.Service) *OrganizationPublicAdapter {
	return &OrganizationPublicAdapter{svc: svc}
}

func (a *OrganizationPublicAdapter) GetPublicPhone(ctx context.Context, organizationID uuid.UUID) (string, error) {
	org, err := a.svc.GetOrganization(ctx, organizationID)
	if err != nil {
		return "", err
	}
	if org.Phone == nil {
		return "", nil
	}
	return normalizeWhatsAppNL(*org.Phone), nil
}

func normalizeWhatsAppNL(phone string) string {
	trimmed := strings.TrimSpace(phone)
	if trimmed == "" {
		return ""
	}

	digits := make([]rune, 0, len(trimmed))
	for _, ch := range trimmed {
		if ch >= '0' && ch <= '9' {
			digits = append(digits, ch)
		}
	}

	if len(digits) == 0 {
		return ""
	}

	normalized := strings.TrimPrefix(string(digits), "00")
	if strings.HasPrefix(normalized, "0") {
		normalized = "31" + normalized[1:]
	}

	return normalized
}

var _ ports.OrganizationPublicViewer = (*OrganizationPublicAdapter)(nil)
</file>

<file path="internal/adapters/partner_offer_adapter.go">
package adapters

import (
	"context"
	"time"

	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/partners/service"
	"portal_final_backend/internal/partners/transport"

	"github.com/google/uuid"
)

type PartnerOfferAdapter struct {
	service *service.Service
}

func NewPartnerOfferAdapter(s *service.Service) *PartnerOfferAdapter {
	return &PartnerOfferAdapter{service: s}
}

func (a *PartnerOfferAdapter) CreateOffer(ctx context.Context, tenantID uuid.UUID, req ports.CreateOfferParams) (*ports.CreateOfferResult, error) {
	transportReq := transport.CreateOfferRequest{
		PartnerID:          req.PartnerID,
		LeadServiceID:      req.LeadServiceID,
		PricingSource:      req.PricingSource,
		CustomerPriceCents: req.CustomerPriceCents,
		ExpiresInHours:     req.ExpiresInHours,
		JobSummaryShort:    req.JobSummaryShort,
	}

	resp, err := a.service.CreateOffer(ctx, tenantID, transportReq)
	if err != nil {
		return nil, err
	}

	return &ports.CreateOfferResult{
		OfferID:     resp.ID,
		PublicToken: resp.PublicToken,
		ExpiresAt:   resp.ExpiresAt.Format(time.RFC3339),
	}, nil
}
</file>

<file path="internal/adapters/quote_generator.go">
package adapters

import (
	"context"
	"fmt"

	"portal_final_backend/internal/leads"
	quotesvc "portal_final_backend/internal/quotes/service"

	"github.com/google/uuid"
)

// QuoteGeneratorAdapter adapts the leads module's QuoteGenerator agent to the
// quotes service's QuotePromptGenerator interface, following the ACL pattern.
type QuoteGeneratorAdapter struct {
	leadsModule *leads.Module
}

// NewQuoteGeneratorAdapter creates a new QuoteGeneratorAdapter wrapping the leads module.
func NewQuoteGeneratorAdapter(m *leads.Module) *QuoteGeneratorAdapter {
	return &QuoteGeneratorAdapter{leadsModule: m}
}

// GenerateFromPrompt calls the leads module's QuoteGenerator agent and maps the result.
func (a *QuoteGeneratorAdapter) GenerateFromPrompt(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, prompt string, existingQuoteID *uuid.UUID) (*quotesvc.GenerateQuoteResult, error) {
	result, err := a.leadsModule.GenerateQuoteFromPrompt(ctx, leadID, serviceID, tenantID, prompt, existingQuoteID)
	if err != nil {
		return nil, fmt.Errorf("quote generation failed: %w", err)
	}

	return &quotesvc.GenerateQuoteResult{
		QuoteID:     result.QuoteID,
		QuoteNumber: result.QuoteNumber,
		ItemCount:   result.ItemCount,
	}, nil
}

// Compile-time check that QuoteGeneratorAdapter implements QuotePromptGenerator.
var _ quotesvc.QuotePromptGenerator = (*QuoteGeneratorAdapter)(nil)
</file>

<file path="internal/adapters/quotes_contact_reader.go">
package adapters

import (
	"context"
	"fmt"
	"strings"

	authrepo "portal_final_backend/internal/auth/repository"
	identityrepo "portal_final_backend/internal/identity/repository"
	leadsrepo "portal_final_backend/internal/leads/repository"
	quotesvc "portal_final_backend/internal/quotes/service"

	"github.com/google/uuid"
)

// QuotesContactReader adapts the leads, identity, and auth repositories
// to provide contact details needed for quote emails (consumer + organization + agent).
// It implements quotes/service.QuoteContactReader using interface-segregation.
type QuotesContactReader struct {
	leads leadsrepo.LeadReader
	orgs  OrgNameReader
	users AgentUserReader
}

// OrgNameReader is the narrow interface for fetching an organization name.
type OrgNameReader interface {
	GetOrganization(ctx context.Context, organizationID uuid.UUID) (identityrepo.Organization, error)
}

// AgentUserReader is the narrow interface for looking up an agent's email and name by ID.
type AgentUserReader interface {
	GetUserByID(ctx context.Context, userID uuid.UUID) (authrepo.User, error)
}

// NewQuotesContactReader creates a new contact reader adapter.
func NewQuotesContactReader(leads leadsrepo.LeadReader, orgs OrgNameReader, users AgentUserReader) *QuotesContactReader {
	return &QuotesContactReader{leads: leads, orgs: orgs, users: users}
}

// GetQuoteContactData retrieves consumer email, consumer name, organization name,
// and the assigned agent's email and name.
func (a *QuotesContactReader) GetQuoteContactData(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (quotesvc.QuoteContactData, error) {
	lead, err := a.leads.GetByID(ctx, leadID, organizationID)
	if err != nil {
		return quotesvc.QuoteContactData{}, fmt.Errorf("look up lead for quote email: %w", err)
	}

	consumerEmail, consumerName, consumerPhone := extractConsumerContact(lead)

	org, err := a.orgs.GetOrganization(ctx, organizationID)
	if err != nil {
		return quotesvc.QuoteContactData{}, fmt.Errorf("look up organization for quote email: %w", err)
	}

	agentEmail, agentName := a.lookupAgentContact(ctx, lead.AssignedAgentID)

	return quotesvc.QuoteContactData{
		ConsumerEmail:    consumerEmail,
		ConsumerName:     consumerName,
		ConsumerPhone:    consumerPhone,
		OrganizationName: org.Name,
		AgentEmail:       agentEmail,
		AgentName:        agentName,
	}, nil
}

func extractConsumerContact(lead leadsrepo.Lead) (string, string, string) {
	consumerEmail := ""
	if lead.ConsumerEmail != nil {
		consumerEmail = *lead.ConsumerEmail
	}

	consumerName := strings.TrimSpace(lead.ConsumerFirstName + " " + lead.ConsumerLastName)
	if consumerName == "" {
		consumerName = lead.ConsumerFirstName
	}

	return consumerEmail, consumerName, lead.ConsumerPhone
}

func (a *QuotesContactReader) lookupAgentContact(ctx context.Context, agentID *uuid.UUID) (string, string) {
	if agentID == nil || a.users == nil {
		return "", ""
	}

	user, err := a.users.GetUserByID(ctx, *agentID)
	if err != nil {
		return "", ""
	}

	name := buildUserName(user)
	if name == "" {
		name = user.Email
	}

	return user.Email, name
}

func buildUserName(user authrepo.User) string {
	first := ""
	if user.FirstName != nil {
		first = *user.FirstName
	}

	last := ""
	if user.LastName != nil {
		last = *user.LastName
	}

	return strings.TrimSpace(first + " " + last)
}

// Compile-time check that QuotesContactReader implements quotes/service.QuoteContactReader.
var _ quotesvc.QuoteContactReader = (*QuotesContactReader)(nil)
</file>

<file path="internal/appointments/module.go">
// Package RAC_appointments provides the RAC_appointments domain module.
package appointments

import (
	"portal_final_backend/internal/appointments/handler"
	"portal_final_backend/internal/appointments/repository"
	"portal_final_backend/internal/appointments/service"
	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/internal/scheduler"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module represents the RAC_appointments domain module
type Module struct {
	handler *handler.Handler
	Service *service.Service
	sse     *sse.Service
}

// NewModule creates a new RAC_appointments module with all dependencies wired
func NewModule(pool *pgxpool.Pool, val *validator.Validator, leadAssigner service.LeadAssigner, emailSender email.Sender, eventBus events.Bus, reminderScheduler scheduler.ReminderScheduler) *Module {
	repo := repository.New(pool)
	svc := service.New(repo, leadAssigner, emailSender, eventBus, reminderScheduler)
	h := handler.New(svc, val)

	return &Module{
		handler: h,
		Service: svc,
	}
}

// SetSSE sets the SSE service for real-time appointment event broadcasting.
func (m *Module) SetSSE(sseService *sse.Service) {
	m.sse = sseService
	m.Service.SetSSE(sseService)
}

// Name returns the module name for logging
func (m *Module) Name() string {
	return "RAC_appointments"
}

// RegisterRoutes registers the module's routes under /api/RAC_appointments
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	appointments := ctx.Protected.Group("/appointments")
	m.handler.RegisterRoutes(appointments)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/catalog/module.go">
// Package catalog provides the catalog bounded context module.
package catalog

import (
	"context"
	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/catalog/handler"
	"portal_final_backend/internal/catalog/repository"
	"portal_final_backend/internal/catalog/service"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/ai/embeddingapi"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the catalog bounded context module implementing http.Module.
type Module struct {
	handler *handler.Handler
	service *service.Service
	repo    repository.Repository
}

// NewModule creates and initializes the catalog module.
func NewModule(pool *pgxpool.Pool, storageSvc storage.StorageService, bucket string, val *validator.Validator, cfg *config.Config, log *logger.Logger) *Module {
	repo := repository.New(pool)

	var embedClient *embeddingapi.Client
	if cfg.IsCatalogEmbeddingEnabled() {
		embedClient = embeddingapi.NewClient(embeddingapi.Config{
			BaseURL:    cfg.GetCatalogEmbeddingAPIURL(),
			APIKey:     cfg.GetCatalogEmbeddingAPIKey(),
			Collection: cfg.GetCatalogEmbeddingCollection(),
		})
	}

	svc := service.New(repo, storageSvc, bucket, log, embedClient, cfg.GetCatalogEmbeddingCollection())
	h := handler.New(svc, val)

	return &Module{
		handler: h,
		service: svc,
		repo:    repo,
	}
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "catalog"
}

// Service returns the service layer for external use.
func (m *Module) Service() *service.Service {
	return m.service
}

// Repository returns the repository for direct access if needed.
func (m *Module) Repository() repository.Repository {
	return m.repo
}

// RegisterRoutes mounts catalog routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// Protected read-only endpoints
	ctx.Protected.GET("/catalog/vat-rates", m.handler.ListVatRates)
	ctx.Protected.GET("/catalog/vat-rates/:id", m.handler.GetVatRateByID)
	ctx.Protected.GET("/catalog/products", m.handler.ListProducts)
	ctx.Protected.GET("/catalog/products/:id", m.handler.GetProductByID)
	ctx.Protected.GET("/catalog/products/search", m.handler.SearchProductsForAutocomplete)
	ctx.Protected.GET("/catalog/products/:id/materials", m.handler.ListProductMaterials)
	ctx.Protected.GET("/catalog/products/:id/assets", m.handler.ListCatalogAssets)
	ctx.Protected.GET("/catalog/products/:id/assets/:assetId/download", m.handler.GetCatalogAssetDownloadURL)

	// Admin CRUD endpoints
	adminGroup := ctx.Admin.Group("/catalog")
	adminGroup.POST("/vat-rates", m.handler.CreateVatRate)
	adminGroup.PUT("/vat-rates/:id", m.handler.UpdateVatRate)
	adminGroup.DELETE("/vat-rates/:id", m.handler.DeleteVatRate)

	adminGroup.POST("/products", m.handler.CreateProduct)
	adminGroup.PUT("/products/:id", m.handler.UpdateProduct)
	adminGroup.DELETE("/products/:id", m.handler.DeleteProduct)
	adminGroup.POST("/products/:id/materials", m.handler.AddProductMaterials)
	adminGroup.DELETE("/products/:id/materials", m.handler.RemoveProductMaterials)
	adminGroup.POST("/products/:id/assets/presign", m.handler.GetCatalogAssetPresign)
	adminGroup.POST("/products/:id/assets", m.handler.CreateCatalogAsset)
	adminGroup.POST("/products/:id/assets/url", m.handler.CreateCatalogURLAsset)
	adminGroup.DELETE("/products/:id/assets/:assetId", m.handler.DeleteCatalogAsset)
}

// RegisterHandlers subscribes to domain events for seeding tenant defaults.
func (m *Module) RegisterHandlers(bus *events.InMemoryBus) {
	bus.Subscribe(events.OrganizationCreated{}.EventName(), m)
}

// Handle routes events to the appropriate handler method.
func (m *Module) Handle(ctx context.Context, event events.Event) error {
	switch e := event.(type) {
	case events.OrganizationCreated:
		return m.service.SeedDefaultVatRates(ctx, e.OrganizationID)
	default:
		return nil
	}
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="internal/identity/handler/handler.go">
package handler

import (
	"net/http"

	"portal_final_backend/internal/identity/repository"
	"portal_final_backend/internal/identity/service"
	"portal_final_backend/internal/identity/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Handler struct {
	svc *service.Service
	val *validator.Validator
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
	msgTenantNotSet     = "tenant not set"
)

func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("/organizations/me", h.GetOrganization)
	rg.PATCH("/organizations/me", h.UpdateOrganization)
	rg.GET("/organizations/me/settings", h.GetOrganizationSettings)
	rg.PATCH("/organizations/me/settings", h.UpdateOrganizationSettings)
	rg.POST("/organizations/me/whatsapp/register", h.RegisterWhatsApp)
	rg.GET("/organizations/me/whatsapp/qr", h.GetWhatsAppQR)
	rg.GET("/organizations/me/whatsapp/status", h.GetWhatsAppStatus)
	rg.POST("/organizations/me/whatsapp/reconnect", h.ReconnectWhatsApp)
	rg.DELETE("/organizations/me/whatsapp", h.DisconnectWhatsApp)
	rg.POST("/organizations/me/logo/presign", h.PresignLogo)
	rg.POST("/organizations/me/logo", h.SetLogo)
	rg.GET("/organizations/me/logo/download", h.GetLogoDownload)
	rg.DELETE("/organizations/me/logo", h.DeleteLogo)
	rg.POST("/organizations/invites", h.CreateInvite)
	rg.GET("/organizations/invites", h.ListInvites)
	rg.PATCH("/organizations/invites/:inviteID", h.UpdateInvite)
	rg.DELETE("/organizations/invites/:inviteID", h.RevokeInvite)
}

func (h *Handler) CreateInvite(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	var req transport.CreateInviteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	token, expiresAt, err := h.svc.CreateInvite(c.Request.Context(), *tenantID, req.Email, identity.UserID())
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, transport.CreateInviteResponse{
		Token:     token,
		ExpiresAt: expiresAt,
	})
}

func (h *Handler) GetOrganization(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	org, err := h.svc.GetOrganization(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.OrganizationResponse{
		ID:              org.ID.String(),
		Name:            org.Name,
		Email:           org.Email,
		Phone:           org.Phone,
		VatNumber:       org.VatNumber,
		KvkNumber:       org.KvkNumber,
		AddressLine1:    org.AddressLine1,
		AddressLine2:    org.AddressLine2,
		PostalCode:      org.PostalCode,
		City:            org.City,
		Country:         org.Country,
		LogoFileKey:     org.LogoFileKey,
		LogoFileName:    org.LogoFileName,
		LogoContentType: org.LogoContentType,
		LogoSizeBytes:   org.LogoSizeBytes,
	})
}

func (h *Handler) UpdateOrganization(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	var req transport.UpdateOrganizationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	org, err := h.svc.UpdateOrganizationProfile(
		c.Request.Context(),
		*tenantID,
		service.OrganizationProfileUpdate{
			Name:         req.Name,
			Email:        req.Email,
			Phone:        req.Phone,
			VATNumber:    req.VatNumber,
			KVKNumber:    req.KvkNumber,
			AddressLine1: req.AddressLine1,
			AddressLine2: req.AddressLine2,
			PostalCode:   req.PostalCode,
			City:         req.City,
			Country:      req.Country,
		},
	)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.OrganizationResponse{
		ID:              org.ID.String(),
		Name:            org.Name,
		Email:           org.Email,
		Phone:           org.Phone,
		VatNumber:       org.VatNumber,
		KvkNumber:       org.KvkNumber,
		AddressLine1:    org.AddressLine1,
		AddressLine2:    org.AddressLine2,
		PostalCode:      org.PostalCode,
		City:            org.City,
		Country:         org.Country,
		LogoFileKey:     org.LogoFileKey,
		LogoFileName:    org.LogoFileName,
		LogoContentType: org.LogoContentType,
		LogoSizeBytes:   org.LogoSizeBytes,
	})
}

func (h *Handler) ListInvites(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	invites, err := h.svc.ListInvites(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	responses := make([]transport.InviteResponse, 0, len(invites))
	for _, invite := range invites {
		responses = append(responses, mapInviteResponse(invite))
	}

	httpkit.OK(c, transport.ListInvitesResponse{Invites: responses})
}

func (h *Handler) UpdateInvite(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	inviteID, err := uuid.Parse(c.Param("inviteID"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateInviteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	invite, tokenValue, err := h.svc.UpdateInvite(c.Request.Context(), *tenantID, inviteID, req.Email, req.Resend)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.UpdateInviteResponse{
		Invite: mapInviteResponse(invite),
		Token:  tokenValue,
	})
}

func (h *Handler) RevokeInvite(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	inviteID, err := uuid.Parse(c.Param("inviteID"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	invite, err := h.svc.RevokeInvite(c.Request.Context(), *tenantID, inviteID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, mapInviteResponse(invite))
}

func mapInviteResponse(invite repository.Invite) transport.InviteResponse {
	return transport.InviteResponse{
		ID:        invite.ID.String(),
		Email:     invite.Email,
		ExpiresAt: invite.ExpiresAt,
		CreatedAt: invite.CreatedAt,
		UsedAt:    invite.UsedAt,
	}
}

func mapOrgResponse(org repository.Organization) transport.OrganizationResponse {
	return transport.OrganizationResponse{
		ID:              org.ID.String(),
		Name:            org.Name,
		Email:           org.Email,
		Phone:           org.Phone,
		VatNumber:       org.VatNumber,
		KvkNumber:       org.KvkNumber,
		AddressLine1:    org.AddressLine1,
		AddressLine2:    org.AddressLine2,
		PostalCode:      org.PostalCode,
		City:            org.City,
		Country:         org.Country,
		LogoFileKey:     org.LogoFileKey,
		LogoFileName:    org.LogoFileName,
		LogoContentType: org.LogoContentType,
		LogoSizeBytes:   org.LogoSizeBytes,
	}
}

func (h *Handler) GetOrganizationSettings(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	settings, err := h.svc.GetOrganizationSettings(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.OrganizationSettingsResponse{
		QuotePaymentDays: settings.QuotePaymentDays,
		QuoteValidDays:   settings.QuoteValidDays,
		WhatsAppDeviceID: settings.WhatsAppDeviceID,
	})
}

func (h *Handler) UpdateOrganizationSettings(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	var req transport.UpdateOrganizationSettingsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	settings, err := h.svc.UpdateOrganizationSettings(c.Request.Context(), *tenantID, repository.OrganizationSettingsUpdate{
		QuotePaymentDays: req.QuotePaymentDays,
		QuoteValidDays:   req.QuoteValidDays,
	})
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.OrganizationSettingsResponse{
		QuotePaymentDays: settings.QuotePaymentDays,
		QuoteValidDays:   settings.QuoteValidDays,
		WhatsAppDeviceID: settings.WhatsAppDeviceID,
	})
}

func (h *Handler) RegisterWhatsApp(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	deviceID, err := h.svc.RegisterWhatsAppDevice(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"deviceId": deviceID, "status": "registered"})
}

func (h *Handler) GetWhatsAppQR(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	qrBytes, err := h.svc.GetWhatsAppQR(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	c.Data(http.StatusOK, "image/png", qrBytes)
}

func (h *Handler) GetWhatsAppStatus(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	status, err := h.svc.GetWhatsAppStatus(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, transport.WhatsAppStatusResponse{
		State:       status.State,
		Message:     status.Message,
		CanSend:     status.CanSend,
		NeedsReauth: status.NeedsReauth,
	})
}

func (h *Handler) ReconnectWhatsApp(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	if err := h.svc.AttemptReconnect(c.Request.Context(), *tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "reconnection initiated"})
}

func (h *Handler) DisconnectWhatsApp(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	if err := h.svc.DisconnectWhatsAppDevice(c.Request.Context(), *tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"status": "disconnected"})
}

func (h *Handler) PresignLogo(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	var req transport.OrgLogoPresignRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.svc.PresignLogoUpload(c.Request.Context(), *tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) SetLogo(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	var req transport.SetOrgLogoRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	org, err := h.svc.SetLogo(c.Request.Context(), *tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, mapOrgResponse(org))
}

func (h *Handler) GetLogoDownload(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	result, err := h.svc.GetLogoDownloadURL(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) DeleteLogo(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}

	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, msgTenantNotSet, nil)
		return
	}

	org, err := h.svc.DeleteLogo(c.Request.Context(), *tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, mapOrgResponse(org))
}
</file>

<file path="internal/identity/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrNotFound = errors.New("not found")

type DBTX interface {
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
}

type Repository struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

func (r *Repository) getDB(q DBTX) DBTX {
	if q != nil {
		return q
	}
	return r.pool
}

type Organization struct {
	ID              uuid.UUID
	Name            string
	Email           *string
	Phone           *string
	VatNumber       *string
	KvkNumber       *string
	AddressLine1    *string
	AddressLine2    *string
	PostalCode      *string
	City            *string
	Country         *string
	LogoFileKey     *string
	LogoFileName    *string
	LogoContentType *string
	LogoSizeBytes   *int64
	CreatedBy       uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

type OrganizationLogo struct {
	FileKey     string
	FileName    string
	ContentType string
	SizeBytes   int64
}

type OrganizationProfileUpdate struct {
	Name         *string
	Email        *string
	Phone        *string
	VatNumber    *string
	KvkNumber    *string
	AddressLine1 *string
	AddressLine2 *string
	PostalCode   *string
	City         *string
	Country      *string
}

type OrganizationSettings struct {
	OrganizationID   uuid.UUID
	QuotePaymentDays int
	QuoteValidDays   int
	WhatsAppDeviceID *string
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

type OrganizationSettingsUpdate struct {
	QuotePaymentDays *int
	QuoteValidDays   *int
	WhatsAppDeviceID *string
}

type Invite struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	Email          string
	TokenHash      string
	ExpiresAt      time.Time
	CreatedBy      uuid.UUID
	CreatedAt      time.Time
	UsedAt         *time.Time
	UsedBy         *uuid.UUID
}

func (r *Repository) CreateOrganization(ctx context.Context, q DBTX, name string, createdBy uuid.UUID) (Organization, error) {
	var org Organization
	err := r.getDB(q).QueryRow(ctx, `
    INSERT INTO RAC_organizations (name, created_by)
    VALUES ($1, $2)
    RETURNING id, name, created_by, created_at, updated_at
  `, name, createdBy).Scan(&org.ID, &org.Name, &org.CreatedBy, &org.CreatedAt, &org.UpdatedAt)
	return org, err
}

func (r *Repository) GetOrganization(ctx context.Context, organizationID uuid.UUID) (Organization, error) {
	var org Organization
	err := r.pool.QueryRow(ctx, `
    SELECT id, name, email, phone, vat_number, kvk_number, address_line1, address_line2, postal_code, city, country,
      logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
      created_by, created_at, updated_at
    FROM RAC_organizations
    WHERE id = $1
  `, organizationID).Scan(
		&org.ID,
		&org.Name,
		&org.Email,
		&org.Phone,
		&org.VatNumber,
		&org.KvkNumber,
		&org.AddressLine1,
		&org.AddressLine2,
		&org.PostalCode,
		&org.City,
		&org.Country,
		&org.LogoFileKey,
		&org.LogoFileName,
		&org.LogoContentType,
		&org.LogoSizeBytes,
		&org.CreatedBy,
		&org.CreatedAt,
		&org.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Organization{}, ErrNotFound
	}
	return org, err
}

func (r *Repository) UpdateOrganizationProfile(
	ctx context.Context,
	organizationID uuid.UUID,
	update OrganizationProfileUpdate,
) (Organization, error) {
	var org Organization
	err := r.pool.QueryRow(ctx, `
    UPDATE RAC_organizations
    SET
      name = COALESCE($2, name),
      email = COALESCE($3, email),
      phone = COALESCE($4, phone),
      vat_number = COALESCE($5, vat_number),
      kvk_number = COALESCE($6, kvk_number),
      address_line1 = COALESCE($7, address_line1),
      address_line2 = COALESCE($8, address_line2),
      postal_code = COALESCE($9, postal_code),
      city = COALESCE($10, city),
      country = COALESCE($11, country),
      updated_at = now()
    WHERE id = $1
    RETURNING id, name, email, phone, vat_number, kvk_number, address_line1, address_line2, postal_code, city, country,
      logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
      created_by, created_at, updated_at
	`, organizationID, update.Name, update.Email, update.Phone, update.VatNumber, update.KvkNumber, update.AddressLine1, update.AddressLine2, update.PostalCode, update.City, update.Country).Scan(
		&org.ID,
		&org.Name,
		&org.Email,
		&org.Phone,
		&org.VatNumber,
		&org.KvkNumber,
		&org.AddressLine1,
		&org.AddressLine2,
		&org.PostalCode,
		&org.City,
		&org.Country,
		&org.LogoFileKey,
		&org.LogoFileName,
		&org.LogoContentType,
		&org.LogoSizeBytes,
		&org.CreatedBy,
		&org.CreatedAt,
		&org.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Organization{}, ErrNotFound
	}
	return org, err
}

func (r *Repository) UpdateOrganizationLogo(
	ctx context.Context,
	organizationID uuid.UUID,
	logo OrganizationLogo,
) (Organization, error) {
	var org Organization
	err := r.pool.QueryRow(ctx, `
    UPDATE RAC_organizations
    SET
      logo_file_key = $2,
      logo_file_name = $3,
      logo_content_type = $4,
      logo_size_bytes = $5,
      updated_at = now()
    WHERE id = $1
    RETURNING id, name, email, phone, vat_number, kvk_number, address_line1, address_line2, postal_code, city, country,
      logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
      created_by, created_at, updated_at
	`, organizationID, logo.FileKey, logo.FileName, logo.ContentType, logo.SizeBytes).Scan(
		&org.ID,
		&org.Name,
		&org.Email,
		&org.Phone,
		&org.VatNumber,
		&org.KvkNumber,
		&org.AddressLine1,
		&org.AddressLine2,
		&org.PostalCode,
		&org.City,
		&org.Country,
		&org.LogoFileKey,
		&org.LogoFileName,
		&org.LogoContentType,
		&org.LogoSizeBytes,
		&org.CreatedBy,
		&org.CreatedAt,
		&org.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Organization{}, ErrNotFound
	}
	return org, err
}

func (r *Repository) ClearOrganizationLogo(
	ctx context.Context,
	organizationID uuid.UUID,
) (Organization, error) {
	var org Organization
	err := r.pool.QueryRow(ctx, `
    UPDATE RAC_organizations
    SET
      logo_file_key = NULL,
      logo_file_name = NULL,
      logo_content_type = NULL,
      logo_size_bytes = NULL,
      updated_at = now()
    WHERE id = $1
    RETURNING id, name, email, phone, vat_number, kvk_number, address_line1, address_line2, postal_code, city, country,
      logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
      created_by, created_at, updated_at
	`, organizationID).Scan(
		&org.ID,
		&org.Name,
		&org.Email,
		&org.Phone,
		&org.VatNumber,
		&org.KvkNumber,
		&org.AddressLine1,
		&org.AddressLine2,
		&org.PostalCode,
		&org.City,
		&org.Country,
		&org.LogoFileKey,
		&org.LogoFileName,
		&org.LogoContentType,
		&org.LogoSizeBytes,
		&org.CreatedBy,
		&org.CreatedAt,
		&org.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Organization{}, ErrNotFound
	}
	return org, err
}

func (r *Repository) GetOrganizationSettings(ctx context.Context, organizationID uuid.UUID) (OrganizationSettings, error) {
	var s OrganizationSettings
	err := r.pool.QueryRow(ctx, `
    SELECT organization_id, quote_payment_days, quote_valid_days, whatsapp_device_id, created_at, updated_at
    FROM RAC_organization_settings
    WHERE organization_id = $1
  `, organizationID).Scan(
		&s.OrganizationID,
		&s.QuotePaymentDays,
		&s.QuoteValidDays,
		&s.WhatsAppDeviceID,
		&s.CreatedAt,
		&s.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		// Return defaults if no row exists yet
		return OrganizationSettings{
			OrganizationID:   organizationID,
			QuotePaymentDays: 7,
			QuoteValidDays:   14,
			WhatsAppDeviceID: nil,
		}, nil
	}
	return s, err
}

func (r *Repository) UpsertOrganizationSettings(
	ctx context.Context,
	organizationID uuid.UUID,
	update OrganizationSettingsUpdate,
) (OrganizationSettings, error) {
	var s OrganizationSettings
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_organization_settings (organization_id, quote_payment_days, quote_valid_days, whatsapp_device_id)
		VALUES ($1, COALESCE($2, 7), COALESCE($3, 14), NULLIF($4, ''))
		ON CONFLICT (organization_id) DO UPDATE SET
			quote_payment_days = COALESCE($2, RAC_organization_settings.quote_payment_days),
			quote_valid_days   = COALESCE($3, RAC_organization_settings.quote_valid_days),
			whatsapp_device_id = CASE WHEN $4 IS NULL THEN RAC_organization_settings.whatsapp_device_id ELSE NULLIF($4, '') END,
			updated_at         = now()
		RETURNING organization_id, quote_payment_days, quote_valid_days, whatsapp_device_id, created_at, updated_at
	`, organizationID, update.QuotePaymentDays, update.QuoteValidDays, update.WhatsAppDeviceID).Scan(
		&s.OrganizationID,
		&s.QuotePaymentDays,
		&s.QuoteValidDays,
		&s.WhatsAppDeviceID,
		&s.CreatedAt,
		&s.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return OrganizationSettings{}, ErrNotFound
	}
	return s, err
}

func (r *Repository) AddMember(ctx context.Context, q DBTX, organizationID, userID uuid.UUID) error {
	_, err := r.getDB(q).Exec(ctx, `
    INSERT INTO RAC_organization_members (organization_id, user_id)
    VALUES ($1, $2)
  `, organizationID, userID)
	return err
}

func (r *Repository) GetUserOrganizationID(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) {
	var orgID uuid.UUID
	err := r.pool.QueryRow(ctx, `
    SELECT organization_id
    FROM RAC_organization_members
    WHERE user_id = $1
  `, userID).Scan(&orgID)
	if errors.Is(err, pgx.ErrNoRows) {
		return uuid.UUID{}, ErrNotFound
	}
	return orgID, err
}

func (r *Repository) CreateInvite(ctx context.Context, organizationID uuid.UUID, email, tokenHash string, expiresAt time.Time, createdBy uuid.UUID) (Invite, error) {
	var invite Invite
	err := r.pool.QueryRow(ctx, `
    INSERT INTO RAC_organization_invites (organization_id, email, token_hash, expires_at, created_by)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING id, organization_id, email, token_hash, expires_at, created_by, created_at, used_at, used_by
  `, organizationID, email, tokenHash, expiresAt, createdBy).Scan(
		&invite.ID,
		&invite.OrganizationID,
		&invite.Email,
		&invite.TokenHash,
		&invite.ExpiresAt,
		&invite.CreatedBy,
		&invite.CreatedAt,
		&invite.UsedAt,
		&invite.UsedBy,
	)
	return invite, err
}

func (r *Repository) GetInviteByToken(ctx context.Context, tokenHash string) (Invite, error) {
	var invite Invite
	err := r.pool.QueryRow(ctx, `
    SELECT id, organization_id, email, token_hash, expires_at, created_by, created_at, used_at, used_by
    FROM RAC_organization_invites
    WHERE token_hash = $1
  `, tokenHash).Scan(
		&invite.ID,
		&invite.OrganizationID,
		&invite.Email,
		&invite.TokenHash,
		&invite.ExpiresAt,
		&invite.CreatedBy,
		&invite.CreatedAt,
		&invite.UsedAt,
		&invite.UsedBy,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Invite{}, ErrNotFound
	}
	return invite, err
}

func (r *Repository) UseInvite(ctx context.Context, q DBTX, inviteID, usedBy uuid.UUID) error {
	_, err := r.getDB(q).Exec(ctx, `
    UPDATE RAC_organization_invites
    SET used_at = now(), used_by = $2
    WHERE id = $1 AND used_at IS NULL
  `, inviteID, usedBy)
	return err
}

func (r *Repository) ListInvites(ctx context.Context, organizationID uuid.UUID) ([]Invite, error) {
	rows, err := r.pool.Query(ctx, `
    SELECT id, organization_id, email, token_hash, expires_at, created_by, created_at, used_at, used_by
    FROM RAC_organization_invites
    WHERE organization_id = $1
    ORDER BY created_at DESC
  `, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var invites []Invite
	for rows.Next() {
		var invite Invite
		if err := rows.Scan(
			&invite.ID,
			&invite.OrganizationID,
			&invite.Email,
			&invite.TokenHash,
			&invite.ExpiresAt,
			&invite.CreatedBy,
			&invite.CreatedAt,
			&invite.UsedAt,
			&invite.UsedBy,
		); err != nil {
			return nil, err
		}
		invites = append(invites, invite)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return invites, nil
}

func (r *Repository) UpdateInvite(
	ctx context.Context,
	organizationID uuid.UUID,
	inviteID uuid.UUID,
	email *string,
	tokenHash *string,
	expiresAt *time.Time,
) (Invite, error) {
	var invite Invite
	err := r.pool.QueryRow(ctx, `
    UPDATE RAC_organization_invites
    SET
      email = COALESCE($3, email),
      token_hash = COALESCE($4, token_hash),
      expires_at = COALESCE($5, expires_at)
    WHERE id = $1 AND organization_id = $2 AND used_at IS NULL
    RETURNING id, organization_id, email, token_hash, expires_at, created_by, created_at, used_at, used_by
  `, inviteID, organizationID, email, tokenHash, expiresAt).Scan(
		&invite.ID,
		&invite.OrganizationID,
		&invite.Email,
		&invite.TokenHash,
		&invite.ExpiresAt,
		&invite.CreatedBy,
		&invite.CreatedAt,
		&invite.UsedAt,
		&invite.UsedBy,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Invite{}, ErrNotFound
	}
	return invite, err
}

func (r *Repository) RevokeInvite(ctx context.Context, organizationID, inviteID uuid.UUID) (Invite, error) {
	var invite Invite
	err := r.pool.QueryRow(ctx, `
    UPDATE RAC_organization_invites
    SET expires_at = now()
    WHERE id = $1 AND organization_id = $2 AND used_at IS NULL
    RETURNING id, organization_id, email, token_hash, expires_at, created_by, created_at, used_at, used_by
  `, inviteID, organizationID).Scan(
		&invite.ID,
		&invite.OrganizationID,
		&invite.Email,
		&invite.TokenHash,
		&invite.ExpiresAt,
		&invite.CreatedBy,
		&invite.CreatedAt,
		&invite.UsedAt,
		&invite.UsedBy,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Invite{}, ErrNotFound
	}
	return invite, err
}
</file>

<file path="internal/identity/service/service.go">
package service

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/identity/repository"
	"portal_final_backend/internal/identity/transport"
	"portal_final_backend/internal/whatsapp"
	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
)

const (
	inviteTokenBytes     = 32
	inviteTTL            = 72 * time.Hour
	inviteNotFound       = "invite not found"
	organizationNotFound = "organization not found"
)

type Service struct {
	repo       *repository.Repository
	eventBus   events.Bus
	storage    storage.StorageService
	logoBucket string
	whatsapp   *whatsapp.Client
}

func New(repo *repository.Repository, eventBus events.Bus, storageSvc storage.StorageService, logoBucket string, whatsappClient *whatsapp.Client) *Service {
	return &Service{repo: repo, eventBus: eventBus, storage: storageSvc, logoBucket: logoBucket, whatsapp: whatsappClient}
}

func (s *Service) GetUserOrganizationID(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) {
	return s.repo.GetUserOrganizationID(ctx, userID)
}

func (s *Service) CreateOrganizationForUser(ctx context.Context, q repository.DBTX, name string, userID uuid.UUID) (uuid.UUID, error) {
	trimmed := strings.TrimSpace(name)
	if trimmed == "" {
		return uuid.UUID{}, apperr.Validation("organization name is required")
	}

	org, err := s.repo.CreateOrganization(ctx, q, trimmed, userID)
	if err != nil {
		return uuid.UUID{}, err
	}

	if s.eventBus != nil {
		if err := s.eventBus.PublishSync(ctx, events.OrganizationCreated{
			BaseEvent:      events.NewBaseEvent(),
			OrganizationID: org.ID,
			CreatedBy:      userID,
		}); err != nil {
			return uuid.UUID{}, err
		}
	}

	return org.ID, nil
}

func (s *Service) AddMember(ctx context.Context, q repository.DBTX, organizationID, userID uuid.UUID) error {
	return s.repo.AddMember(ctx, q, organizationID, userID)
}

func (s *Service) CreateInvite(ctx context.Context, organizationID uuid.UUID, email string, createdBy uuid.UUID) (string, time.Time, error) {
	rawToken, err := token.GenerateRandomToken(inviteTokenBytes)
	if err != nil {
		return "", time.Time{}, err
	}

	tokenHash := token.HashSHA256(rawToken)
	expiresAt := time.Now().Add(inviteTTL)

	if _, err := s.repo.CreateInvite(ctx, organizationID, email, tokenHash, expiresAt, createdBy); err != nil {
		return "", time.Time{}, err
	}

	// Publish event to send invite email
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err == nil && s.eventBus != nil {
		s.eventBus.Publish(ctx, events.OrganizationInviteCreated{
			BaseEvent:        events.NewBaseEvent(),
			OrganizationID:   organizationID,
			OrganizationName: org.Name,
			Email:            email,
			InviteToken:      rawToken,
		})
	}

	return rawToken, expiresAt, nil
}

func (s *Service) GetOrganization(ctx context.Context, organizationID uuid.UUID) (repository.Organization, error) {
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}
	return org, nil
}

func (s *Service) GetOrganizationSettings(ctx context.Context, organizationID uuid.UUID) (repository.OrganizationSettings, error) {
	return s.repo.GetOrganizationSettings(ctx, organizationID)
}

func (s *Service) UpdateOrganizationSettings(
	ctx context.Context,
	organizationID uuid.UUID,
	update repository.OrganizationSettingsUpdate,
) (repository.OrganizationSettings, error) {
	return s.repo.UpsertOrganizationSettings(ctx, organizationID, update)
}

type WhatsAppStatus struct {
	State       string `json:"state"`
	Message     string `json:"message"`
	CanSend     bool   `json:"canSend"`
	NeedsReauth bool   `json:"needsReauth"`
}

func (s *Service) RegisterWhatsAppDevice(ctx context.Context, organizationID uuid.UUID) (string, error) {
	deviceID := fmt.Sprintf("org_%s", organizationID.String())
	if s.whatsapp == nil {
		return "", apperr.Internal("whatsapp service not configured")
	}
	if err := s.whatsapp.CreateDevice(ctx, deviceID); err != nil {
		return "", apperr.Internal("failed to register device with provider: " + err.Error())
	}

	update := repository.OrganizationSettingsUpdate{
		WhatsAppDeviceID: &deviceID,
	}
	if _, err := s.repo.UpsertOrganizationSettings(ctx, organizationID, update); err != nil {
		return "", err
	}

	return deviceID, nil
}

func (s *Service) GetWhatsAppQR(ctx context.Context, organizationID uuid.UUID) ([]byte, error) {
	settings, err := s.repo.GetOrganizationSettings(ctx, organizationID)
	if err != nil {
		return nil, err
	}
	if settings.WhatsAppDeviceID == nil || *settings.WhatsAppDeviceID == "" {
		return nil, apperr.Validation("no device registered for this organization")
	}
	if s.whatsapp == nil {
		return nil, apperr.Internal("whatsapp service not configured")
	}

	return s.whatsapp.GetLoginQR(ctx, *settings.WhatsAppDeviceID)
}

func (s *Service) DisconnectWhatsAppDevice(ctx context.Context, organizationID uuid.UUID) error {
	settings, err := s.repo.GetOrganizationSettings(ctx, organizationID)
	if err != nil {
		return err
	}

	if settings.WhatsAppDeviceID != nil && *settings.WhatsAppDeviceID != "" && s.whatsapp != nil {
		_ = s.whatsapp.DeleteDevice(ctx, *settings.WhatsAppDeviceID)
	}

	clear := ""
	update := repository.OrganizationSettingsUpdate{
		WhatsAppDeviceID: &clear,
	}
	_, err = s.repo.UpsertOrganizationSettings(ctx, organizationID, update)
	return err
}

func (s *Service) GetWhatsAppStatus(ctx context.Context, organizationID uuid.UUID) (WhatsAppStatus, error) {
	settings, err := s.repo.GetOrganizationSettings(ctx, organizationID)
	if err != nil {
		return WhatsAppStatus{}, err
	}
	if settings.WhatsAppDeviceID == nil || *settings.WhatsAppDeviceID == "" {
		return WhatsAppStatus{State: "UNREGISTERED", Message: "No device linked", CanSend: false}, nil
	}
	if s.whatsapp == nil {
		return WhatsAppStatus{}, apperr.Internal("whatsapp service not configured")
	}

	upstreamStatus, err := s.whatsapp.GetDeviceStatus(ctx, *settings.WhatsAppDeviceID)
	if err != nil {
		if apperr.Is(err, apperr.KindNotFound) {
			return WhatsAppStatus{
				State:       "ERROR",
				Message:     "Device configuration lost upstream. Please register again.",
				CanSend:     false,
				NeedsReauth: true,
			}, nil
		}
		return WhatsAppStatus{}, err
	}

	if upstreamStatus.IsLoggedIn {
		return WhatsAppStatus{State: "CONNECTED", Message: "Online", CanSend: true}, nil
	}

	msg := "Waiting for authentication"
	if upstreamStatus.IsConnected {
		msg = "Connected but not logged in"
	}

	return WhatsAppStatus{
		State:       "DISCONNECTED",
		Message:     msg,
		CanSend:     false,
		NeedsReauth: true,
	}, nil
}

func (s *Service) AttemptReconnect(ctx context.Context, organizationID uuid.UUID) error {
	settings, err := s.repo.GetOrganizationSettings(ctx, organizationID)
	if err != nil {
		return err
	}
	if settings.WhatsAppDeviceID == nil || *settings.WhatsAppDeviceID == "" {
		return apperr.Validation("no device to reconnect")
	}
	if s.whatsapp == nil {
		return apperr.Internal("whatsapp service not configured")
	}

	return s.whatsapp.ReconnectDevice(ctx, *settings.WhatsAppDeviceID)
}

type OrganizationProfileUpdate struct {
	Name         *string
	Email        *string
	Phone        *string
	VATNumber    *string
	KVKNumber    *string
	AddressLine1 *string
	AddressLine2 *string
	PostalCode   *string
	City         *string
	Country      *string
}

func (s *Service) UpdateOrganizationProfile(
	ctx context.Context,
	organizationID uuid.UUID,
	update OrganizationProfileUpdate,
) (repository.Organization, error) {
	update = normalizeOrganizationProfileUpdate(update)

	if update.Name != nil && *update.Name == "" {
		return repository.Organization{}, apperr.Validation("organization name is required")
	}
	if update.VATNumber != nil && !isValidNLVAT(*update.VATNumber) {
		return repository.Organization{}, apperr.Validation("invalid VAT number")
	}
	if update.KVKNumber != nil && !isValidKVK(*update.KVKNumber) {
		return repository.Organization{}, apperr.Validation("invalid KVK number")
	}

	org, err := s.repo.UpdateOrganizationProfile(
		ctx,
		organizationID,
		repository.OrganizationProfileUpdate{
			Name:         update.Name,
			Email:        update.Email,
			Phone:        update.Phone,
			VatNumber:    update.VATNumber,
			KvkNumber:    update.KVKNumber,
			AddressLine1: update.AddressLine1,
			AddressLine2: update.AddressLine2,
			PostalCode:   update.PostalCode,
			City:         update.City,
			Country:      update.Country,
		},
	)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}

	return org, nil
}

func normalizeOrganizationProfileUpdate(update OrganizationProfileUpdate) OrganizationProfileUpdate {
	update.Name = normalizeOptional(update.Name)
	update.Email = normalizeOptional(update.Email)
	update.Phone = normalizeOptional(update.Phone)
	update.VATNumber = normalizeOptional(update.VATNumber)
	update.KVKNumber = normalizeOptional(update.KVKNumber)
	update.AddressLine1 = normalizeOptional(update.AddressLine1)
	update.AddressLine2 = normalizeOptional(update.AddressLine2)
	update.PostalCode = normalizeOptional(update.PostalCode)
	update.City = normalizeOptional(update.City)
	update.Country = normalizeOptional(update.Country)
	return update
}

func normalizeOptional(value *string) *string {
	if value == nil {
		return nil
	}
	trimmed := strings.TrimSpace(*value)
	if trimmed == "" {
		return nil
	}
	return &trimmed
}

var nlVATPattern = regexp.MustCompile(`^NL[0-9]{9}B[0-9]{2}$`)
var kvkPattern = regexp.MustCompile(`^[0-9]{8}$`)

func isValidNLVAT(value string) bool {
	return nlVATPattern.MatchString(strings.ToUpper(strings.TrimSpace(value)))
}

func isValidKVK(value string) bool {
	return kvkPattern.MatchString(strings.TrimSpace(value))
}

func (s *Service) ResolveInvite(ctx context.Context, rawToken string) (repository.Invite, error) {
	tokenHash := token.HashSHA256(rawToken)
	invite, err := s.repo.GetInviteByToken(ctx, tokenHash)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Invite{}, apperr.NotFound(inviteNotFound)
		}
		return repository.Invite{}, err
	}

	if invite.UsedAt != nil {
		return repository.Invite{}, apperr.Conflict("invite already used")
	}

	if time.Now().After(invite.ExpiresAt) {
		return repository.Invite{}, apperr.Forbidden("invite expired")
	}

	return invite, nil
}

func (s *Service) UseInvite(ctx context.Context, q repository.DBTX, inviteID, userID uuid.UUID) error {
	return s.repo.UseInvite(ctx, q, inviteID, userID)
}

func (s *Service) ListInvites(ctx context.Context, organizationID uuid.UUID) ([]repository.Invite, error) {
	return s.repo.ListInvites(ctx, organizationID)
}

func (s *Service) UpdateInvite(
	ctx context.Context,
	organizationID uuid.UUID,
	inviteID uuid.UUID,
	email *string,
	resend bool,
) (repository.Invite, *string, error) {
	email = normalizeOptional(email)

	if email == nil && !resend {
		return repository.Invite{}, nil, apperr.Validation("no updates provided")
	}

	resendData, err := buildInviteResendData(resend)
	if err != nil {
		return repository.Invite{}, nil, err
	}

	invite, err := s.repo.UpdateInvite(ctx, organizationID, inviteID, email, resendData.tokenHash, resendData.expiresAt)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Invite{}, nil, apperr.NotFound(inviteNotFound)
		}
		return repository.Invite{}, nil, err
	}

	// Publish event to send invite email when resending
	if resend && resendData.tokenValue != nil && s.eventBus != nil {
		s.publishInviteResend(ctx, organizationID, invite.Email, *resendData.tokenValue)
	}

	return invite, resendData.tokenValue, nil
}

type inviteResendData struct {
	tokenValue *string
	tokenHash  *string
	expiresAt  *time.Time
}

func buildInviteResendData(resend bool) (inviteResendData, error) {
	if !resend {
		return inviteResendData{}, nil
	}

	rawToken, err := token.GenerateRandomToken(inviteTokenBytes)
	if err != nil {
		return inviteResendData{}, err
	}

	hash := token.HashSHA256(rawToken)
	value := rawToken
	freshExpires := time.Now().Add(inviteTTL)

	return inviteResendData{
		tokenValue: &value,
		tokenHash:  &hash,
		expiresAt:  &freshExpires,
	}, nil
}

func (s *Service) publishInviteResend(
	ctx context.Context,
	organizationID uuid.UUID,
	email string,
	tokenValue string,
) {
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err != nil {
		return
	}

	s.eventBus.Publish(ctx, events.OrganizationInviteCreated{
		BaseEvent:        events.NewBaseEvent(),
		OrganizationID:   organizationID,
		OrganizationName: org.Name,
		Email:            email,
		InviteToken:      tokenValue,
	})
}

func (s *Service) RevokeInvite(ctx context.Context, organizationID, inviteID uuid.UUID) (repository.Invite, error) {
	invite, err := s.repo.RevokeInvite(ctx, organizationID, inviteID)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Invite{}, apperr.NotFound(inviteNotFound)
		}
		return repository.Invite{}, err
	}

	return invite, nil
}

// PresignLogoUpload generates a presigned URL for uploading an organization logo.
func (s *Service) PresignLogoUpload(ctx context.Context, organizationID uuid.UUID, req transport.OrgLogoPresignRequest) (transport.OrgLogoPresignResponse, error) {
	if !storage.IsImageContentType(req.ContentType) {
		return transport.OrgLogoPresignResponse{}, apperr.Validation("logo must be an image")
	}

	presigned, err := s.storage.GenerateUploadURL(
		ctx,
		s.logoBucket,
		logoFolder(organizationID),
		req.FileName,
		req.ContentType,
		req.SizeBytes,
	)
	if err != nil {
		return transport.OrgLogoPresignResponse{}, err
	}

	return transport.OrgLogoPresignResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	}, nil
}

// SetLogo stores logo metadata after the client has uploaded the file to MinIO.
func (s *Service) SetLogo(ctx context.Context, organizationID uuid.UUID, req transport.SetOrgLogoRequest) (repository.Organization, error) {
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}

	if !storage.IsImageContentType(req.ContentType) {
		return repository.Organization{}, apperr.Validation("logo must be an image")
	}
	if err := s.storage.ValidateContentType(req.ContentType); err != nil {
		return repository.Organization{}, err
	}
	if err := s.storage.ValidateFileSize(req.SizeBytes); err != nil {
		return repository.Organization{}, err
	}
	if !strings.HasPrefix(req.FileKey, logoFolder(organizationID)+"/") {
		return repository.Organization{}, apperr.Validation("invalid logo file key")
	}

	// Delete old logo if it was a different file
	if org.LogoFileKey != nil && *org.LogoFileKey != req.FileKey {
		_ = s.storage.DeleteObject(ctx, s.logoBucket, *org.LogoFileKey)
	}

	updated, err := s.repo.UpdateOrganizationLogo(ctx, organizationID, repository.OrganizationLogo{
		FileKey:     req.FileKey,
		FileName:    req.FileName,
		ContentType: req.ContentType,
		SizeBytes:   req.SizeBytes,
	})
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}

	return updated, nil
}

// GetLogoDownloadURL generates a presigned download URL for the organization logo.
func (s *Service) GetLogoDownloadURL(ctx context.Context, organizationID uuid.UUID) (transport.OrgLogoDownloadResponse, error) {
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err != nil {
		if err == repository.ErrNotFound {
			return transport.OrgLogoDownloadResponse{}, apperr.NotFound(organizationNotFound)
		}
		return transport.OrgLogoDownloadResponse{}, err
	}

	if org.LogoFileKey == nil || *org.LogoFileKey == "" {
		return transport.OrgLogoDownloadResponse{}, apperr.NotFound("logo not found")
	}

	presigned, err := s.storage.GenerateDownloadURL(ctx, s.logoBucket, *org.LogoFileKey)
	if err != nil {
		return transport.OrgLogoDownloadResponse{}, err
	}

	return transport.OrgLogoDownloadResponse{
		DownloadURL: presigned.URL,
		ExpiresAt:   presigned.ExpiresAt.Unix(),
	}, nil
}

// DeleteLogo removes the organization logo from storage and clears the metadata.
func (s *Service) DeleteLogo(ctx context.Context, organizationID uuid.UUID) (repository.Organization, error) {
	org, err := s.repo.GetOrganization(ctx, organizationID)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}

	if org.LogoFileKey != nil && *org.LogoFileKey != "" {
		_ = s.storage.DeleteObject(ctx, s.logoBucket, *org.LogoFileKey)
	}

	updated, err := s.repo.ClearOrganizationLogo(ctx, organizationID)
	if err != nil {
		if err == repository.ErrNotFound {
			return repository.Organization{}, apperr.NotFound(organizationNotFound)
		}
		return repository.Organization{}, err
	}

	return updated, nil
}

func logoFolder(organizationID uuid.UUID) string {
	return "organizations/" + organizationID.String()
}
</file>

<file path="internal/identity/transport/dto.go">
package transport

import "time"

type CreateInviteRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type CreateInviteResponse struct {
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expiresAt"`
}

type InviteResponse struct {
	ID        string     `json:"id"`
	Email     string     `json:"email"`
	ExpiresAt time.Time  `json:"expiresAt"`
	CreatedAt time.Time  `json:"createdAt"`
	UsedAt    *time.Time `json:"usedAt,omitempty"`
}

type ListInvitesResponse struct {
	Invites []InviteResponse `json:"invites"`
}

type UpdateInviteRequest struct {
	Email  *string `json:"email" validate:"omitempty,email"`
	Resend bool    `json:"resend"`
}

type UpdateInviteResponse struct {
	Invite InviteResponse `json:"invite"`
	Token  *string        `json:"token,omitempty"`
}

type UpdateOrganizationRequest struct {
	Name         *string `json:"name" validate:"omitempty,max=120"`
	Email        *string `json:"email" validate:"omitempty,email"`
	Phone        *string `json:"phone" validate:"omitempty,max=50"`
	VatNumber    *string `json:"vatNumber" validate:"omitempty,max=20"`
	KvkNumber    *string `json:"kvkNumber" validate:"omitempty,max=20"`
	AddressLine1 *string `json:"addressLine1" validate:"omitempty,max=200"`
	AddressLine2 *string `json:"addressLine2" validate:"omitempty,max=200"`
	PostalCode   *string `json:"postalCode" validate:"omitempty,max=20"`
	City         *string `json:"city" validate:"omitempty,max=120"`
	Country      *string `json:"country" validate:"omitempty,max=120"`
}

type OrganizationResponse struct {
	ID              string  `json:"id"`
	Name            string  `json:"name"`
	Email           *string `json:"email,omitempty"`
	Phone           *string `json:"phone,omitempty"`
	VatNumber       *string `json:"vatNumber,omitempty"`
	KvkNumber       *string `json:"kvkNumber,omitempty"`
	AddressLine1    *string `json:"addressLine1,omitempty"`
	AddressLine2    *string `json:"addressLine2,omitempty"`
	PostalCode      *string `json:"postalCode,omitempty"`
	City            *string `json:"city,omitempty"`
	Country         *string `json:"country,omitempty"`
	LogoFileKey     *string `json:"logoFileKey,omitempty"`
	LogoFileName    *string `json:"logoFileName,omitempty"`
	LogoContentType *string `json:"logoContentType,omitempty"`
	LogoSizeBytes   *int64  `json:"logoSizeBytes,omitempty"`
}

// OrgLogoPresignRequest is the request for a presigned organization logo upload URL.
type OrgLogoPresignRequest struct {
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// OrgLogoPresignResponse returns a presigned logo upload URL.
type OrgLogoPresignResponse struct {
	UploadURL string `json:"uploadUrl"`
	FileKey   string `json:"fileKey"`
	ExpiresAt int64  `json:"expiresAt"`
}

// SetOrgLogoRequest stores logo metadata after upload.
type SetOrgLogoRequest struct {
	FileKey     string `json:"fileKey" validate:"required,min=1,max=500"`
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=100"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// OrgLogoDownloadResponse returns a presigned download URL.
type OrgLogoDownloadResponse struct {
	DownloadURL string `json:"downloadUrl"`
	ExpiresAt   int64  `json:"expiresAt"`
}

// OrganizationSettingsResponse returns the organization's quote defaults.
type OrganizationSettingsResponse struct {
	QuotePaymentDays int     `json:"quotePaymentDays"`
	QuoteValidDays   int     `json:"quoteValidDays"`
	WhatsAppDeviceID *string `json:"whatsAppDeviceId,omitempty"`
}

// UpdateOrganizationSettingsRequest updates quote default settings.
type UpdateOrganizationSettingsRequest struct {
	QuotePaymentDays *int `json:"quotePaymentDays" validate:"omitempty,min=1,max=365"`
	QuoteValidDays   *int `json:"quoteValidDays" validate:"omitempty,min=1,max=365"`
}

// WhatsAppStatusResponse describes the current WhatsApp device state for an organization.
type WhatsAppStatusResponse struct {
	State       string `json:"state"`
	Message     string `json:"message"`
	CanSend     bool   `json:"canSend"`
	NeedsReauth bool   `json:"needsReauth"`
}
</file>

<file path="internal/leads/agent/call_logger.go">
package agent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/adk/tool/functiontool"
	"google.golang.org/genai"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/moonshot"
	"portal_final_backend/platform/apperr"
)

// Error messages
const (
	errMsgMissingContext       = "Missing context"
	errMsgBookingNotConfigured = "Appointment booking not configured"
	errBookerNotConfigured     = "booker not configured"
)

// Date/time layout used for short human-readable timestamps
const dateTimeShortLayout = "2006-01-02 15:04"

// Sentinel errors
var (
	errMissingContext = errors.New("missing context")
)

// CallLogResult represents the result of processing a call summary
type CallLogResult struct {
	NoteCreated                   bool       `json:"noteCreated"`
	NoteBody                      string     `json:"noteBody,omitempty"`
	AuthorEmail                   string     `json:"authorEmail,omitempty"`
	CallOutcome                   *string    `json:"callOutcome,omitempty"`
	StatusUpdated                 *string    `json:"statusUpdated,omitempty"`
	PipelineStageUpdated          *string    `json:"pipelineStageUpdated,omitempty"`
	AppointmentBooked             *time.Time `json:"appointmentBooked,omitempty"`
	AppointmentRescheduled        *time.Time `json:"appointmentRescheduled,omitempty"`
	AppointmentRescheduleFallback bool       `json:"appointmentRescheduleFallback,omitempty"`
	AppointmentCancelled          bool       `json:"appointmentCancelled,omitempty"`
	Message                       string     `json:"message"`
}

// CallLogger processes post-call summaries into structured actions
type CallLogger struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	repo           repository.LeadsRepository
	booker         ports.AppointmentBooker
	toolDeps       *CallLoggerToolDeps
	runMu          sync.Mutex
}

// SetAppointmentBooker sets the appointment booker after initialization.
// This is needed to break circular dependencies during module initialization.
func (c *CallLogger) SetAppointmentBooker(booker ports.AppointmentBooker) {
	c.booker = booker
	c.toolDeps.Booker = booker
}

// CallLoggerToolDeps contains the dependencies needed by CallLogger tools
type CallLoggerToolDeps struct {
	Repo     repository.LeadsRepository
	Booker   ports.AppointmentBooker
	EventBus events.Bus
	mu       sync.RWMutex

	// Context for the current run
	tenantID  *uuid.UUID
	userID    *uuid.UUID
	leadID    *uuid.UUID
	serviceID *uuid.UUID

	// Track results during the run
	result CallLogResult

	// Drafted note content (persisted after the run finishes)
	noteDraftBody string
	noteDrafted   bool
}

func (d *CallLoggerToolDeps) SetContext(tenantID, userID, leadID, serviceID uuid.UUID) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.tenantID = &tenantID
	d.userID = &userID
	d.leadID = &leadID
	d.serviceID = &serviceID
	d.result = CallLogResult{} // Reset result
	d.noteDraftBody = ""
	d.noteDrafted = false
}

func (d *CallLoggerToolDeps) GetContext() (tenantID, userID, leadID, serviceID uuid.UUID, ok bool) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	if d.tenantID == nil || d.userID == nil || d.leadID == nil || d.serviceID == nil {
		return uuid.UUID{}, uuid.UUID{}, uuid.UUID{}, uuid.UUID{}, false
	}
	return *d.tenantID, *d.userID, *d.leadID, *d.serviceID, true
}

func (d *CallLoggerToolDeps) MarkNoteCreated() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.NoteCreated = true
}

func (d *CallLoggerToolDeps) SetNoteDraft(body string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.noteDraftBody = body
	d.noteDrafted = true
}

func (d *CallLoggerToolDeps) GetNoteDraft() (string, bool) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.noteDraftBody, d.noteDrafted
}

func (d *CallLoggerToolDeps) SetNoteDetails(body, authorEmail string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.NoteBody = body
	d.result.AuthorEmail = authorEmail
}

func (d *CallLoggerToolDeps) MarkStatusUpdated(status string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.StatusUpdated = &status
}

func (d *CallLoggerToolDeps) MarkAppointmentBooked(startTime time.Time) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.AppointmentBooked = &startTime
}

func (d *CallLoggerToolDeps) MarkAppointmentRescheduled(startTime time.Time) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.AppointmentRescheduled = &startTime
}

func (d *CallLoggerToolDeps) MarkRescheduleFallback() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.AppointmentRescheduleFallback = true
}

func (d *CallLoggerToolDeps) MarkAppointmentCancelled() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.AppointmentCancelled = true
}

func (d *CallLoggerToolDeps) SetCallOutcome(outcome string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.CallOutcome = &outcome
}

func (d *CallLoggerToolDeps) MarkPipelineStageUpdated(stage string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result.PipelineStageUpdated = &stage
}

func (d *CallLoggerToolDeps) GetResult() CallLogResult {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.result
}

// NewCallLogger creates a new CallLogger agent
func NewCallLogger(apiKey string, repo repository.LeadsRepository, booker ports.AppointmentBooker, eventBus events.Bus) (*CallLogger, error) {
	// Use kimi-k2.5 with thinking disabled for reliable tool calling
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          apiKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	logger := &CallLogger{
		repo:           repo,
		booker:         booker,
		appName:        "call_logger",
		sessionService: session.InMemoryService(),
		toolDeps: &CallLoggerToolDeps{
			Repo:     repo,
			Booker:   booker,
			EventBus: eventBus,
		},
	}

	// Build tools
	tools, err := buildCallLoggerTools(logger.toolDeps)
	if err != nil {
		return nil, fmt.Errorf("failed to build call logger tools: %w", err)
	}

	// Create the ADK agent
	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "CallLogger",
		Model:       kimi,
		Description: "Post-call processing assistant that converts natural language call summaries into structured database updates (Notes, Status changes, Appointments).",
		Instruction: getCallLoggerSystemPrompt(),
		Tools:       tools,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create call logger agent: %w", err)
	}

	// Create the runner
	r, err := runner.New(runner.Config{
		AppName:        logger.appName,
		Agent:          adkAgent,
		SessionService: logger.sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create call logger runner: %w", err)
	}

	logger.agent = adkAgent
	logger.runner = r

	return logger, nil
}

// resolveExistingAppointment checks whether the lead already has a booked visit
// and returns a human-readable timestamp or "None".
func (c *CallLogger) resolveExistingAppointment(ctx context.Context, tenantID, serviceID, userID uuid.UUID) string {
	if c.booker == nil {
		return "None"
	}

	visit, err := c.booker.GetLeadVisitByService(ctx, tenantID, serviceID, userID)
	if err == nil && visit != nil {
		return visit.StartTime.Format(dateTimeShortLayout)
	}
	if err != nil && !apperr.Is(err, apperr.KindNotFound) {
		log.Printf("CallLogger warning: failed to check existing appointment: %v", err)
	}
	return "None"
}

// executeAgentRun creates an ephemeral session, runs the agent, and returns the
// concatenated text output.
func (c *CallLogger) executeAgentRun(ctx context.Context, userIDStr, sessionID, promptText string) (string, error) {
	_, err := c.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   c.appName,
		UserID:    userIDStr,
		SessionID: sessionID,
	})
	if err != nil {
		return "", fmt.Errorf("failed to create session: %w", err)
	}
	defer func() {
		if deleteErr := c.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   c.appName,
			UserID:    userIDStr,
			SessionID: sessionID,
		}); deleteErr != nil {
			log.Printf("warning: failed to delete call logger session: %v", deleteErr)
		}
	}()

	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			{Text: promptText},
		},
	}

	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	var outputText string
	for event, err := range c.runner.Run(ctx, userIDStr, sessionID, userMessage, runConfig) {
		if err != nil {
			return "", fmt.Errorf("call logger run failed: %w", err)
		}
		if event.Content != nil {
			for _, part := range event.Content.Parts {
				outputText += part.Text
			}
		}
	}

	return outputText, nil
}

// ProcessSummary is the main entry point for processing a call summary
func (c *CallLogger) ProcessSummary(ctx context.Context, leadID, serviceID, userID, tenantID uuid.UUID, summary string) (*CallLogResult, error) {
	c.runMu.Lock()
	defer c.runMu.Unlock()

	// Set context for tools
	c.toolDeps.SetContext(tenantID, userID, leadID, serviceID)

	existingAppointment := c.resolveExistingAppointment(ctx, tenantID, serviceID, userID)

	// Construct the prompt with context
	promptText := fmt.Sprintf(`Analysis Context:
- Current Time: %s
- Lead ID: %s
- Service ID: %s
- Agent User ID: %s
- Existing Appointment: %s

The agent provided this post-call summary:
"%s"

Task:
1. Analyze the summary to determine the call outcome and any appointment changes.
2. ALWAYS save a clean, professional Dutch call note.
	- Draft the note, then run it through 'NormalizeCallNote'.
	- Save the normalized version using 'SaveNote'.
	- Write a short, readable note (no raw input block).
	- If the input is sparse, infer structure (do NOT invent facts).
	- Use 24-hour time format (e.g., 09:00).
	- Preferred structure:
	  "Afspraak: ..."
	  "Werkzaamheden: ..."
	  "Materiaal: ..."
	  "Locatie: ..." (if provided)
	  "Vragen: ..." (if any)
3. If an appointment was scheduled (e.g., "booked next tuesday at 9", "scheduled for friday 2pm"):
   - Calculate the exact date based on Current Time
   - Use 'ScheduleVisit' to book the appointment
   - Assume 1 hour duration unless specified otherwise
4. If an existing appointment must be rescheduled and a new time is provided:
   - Use 'RescheduleVisit' with the new start/end time
	- Only reschedule if Existing Appointment is not "None"; otherwise schedule a new appointment and write "Nieuwe afspraak ingepland"
5. If the appointment is cancelled:
   - Use 'CancelVisit'
6. Set a call outcome using 'SetCallOutcome' (short label, e.g., Scheduled, Attempted_Contact, Bad_Lead, Needs_Rescheduling).
7. Update the status using 'UpdateStatus' if the outcome implies a status change:
   - "booked", "scheduled", "appointment set"  Scheduled
   - "not interested", "no need", "declined"  Bad_Lead
   - "voicemail", "no answer", "callback"  Attempted_Contact
   - "completed survey", "finished inspection"  Surveyed
   - "needs to reschedule", "postponed"  Needs_Rescheduling
8. Update the pipeline stage with 'UpdatePipelineStage' if the summary explicitly indicates a stage change.

Execute the appropriate tools now.`,
		time.Now().Format(time.RFC3339),
		leadID.String(),
		serviceID.String(),
		userID.String(),
		existingAppointment,
		summary,
	)

	sessionID := uuid.New().String()
	userIDStr := userID.String()

	outputText, err := c.executeAgentRun(ctx, userIDStr, sessionID, promptText)
	if err != nil {
		return nil, err
	}

	log.Printf("CallLogger finished. Output: %s", outputText)

	if err := c.persistDraftedNote(ctx); err != nil {
		return nil, err
	}

	// Get the result and build message
	result := c.toolDeps.GetResult()
	result.Message = buildResultMessage(result)

	return &result, nil
}

func (c *CallLogger) persistDraftedNote(ctx context.Context) error {
	body, ok := c.toolDeps.GetNoteDraft()
	if !ok {
		return nil
	}

	result := c.toolDeps.GetResult()
	finalBody := body
	if result.AppointmentRescheduleFallback && result.AppointmentBooked != nil {
		finalBody = appendRescheduleFallbackNote(finalBody, *result.AppointmentBooked)
	}

	tenantID, userID, leadID, _, ok := c.toolDeps.GetContext()
	if !ok {
		return errMissingContext
	}

	note, err := c.repo.CreateLeadNote(ctx, repository.CreateLeadNoteParams{
		LeadID:         leadID,
		OrganizationID: tenantID,
		AuthorID:       userID,
		Type:           "call",
		Body:           finalBody,
	})
	if err != nil {
		return err
	}

	c.toolDeps.MarkNoteCreated()
	c.toolDeps.SetNoteDetails(finalBody, note.AuthorEmail)
	return nil
}

// buildResultMessage constructs a human-readable message from the call log result
func buildResultMessage(result CallLogResult) string {
	var messages []string
	if result.NoteCreated {
		messages = append(messages, "Note saved")
	}
	if result.CallOutcome != nil {
		messages = append(messages, fmt.Sprintf("Call outcome set to %s", *result.CallOutcome))
	}
	if result.StatusUpdated != nil {
		messages = append(messages, fmt.Sprintf("Status updated to %s", *result.StatusUpdated))
	}
	if result.PipelineStageUpdated != nil {
		messages = append(messages, fmt.Sprintf("Pipeline stage updated to %s", *result.PipelineStageUpdated))
	}
	if result.AppointmentBooked != nil {
		messages = append(messages, fmt.Sprintf("Appointment booked for %s", result.AppointmentBooked.Format(dateTimeShortLayout)))
	}
	if result.AppointmentRescheduled != nil {
		messages = append(messages, fmt.Sprintf("Appointment rescheduled for %s", result.AppointmentRescheduled.Format(dateTimeShortLayout)))
	}
	if result.AppointmentCancelled {
		messages = append(messages, "Appointment cancelled")
	}
	if len(messages) == 0 {
		return "No actions taken"
	}
	return strings.Join(messages, ". ")
}

func getCallLoggerSystemPrompt() string {
	return `You are a Post-Call Processing Assistant for a home services sales team.

Your job is to read a rough summary of a sales/qualification call and execute the necessary database updates using the available tools.

IMPORTANT RULES:
1. Draft a clean, professional Dutch note and pass it through NormalizeCallNote.
	- Do NOT include the raw input text.
	- Structure when possible (Afspraak, Werkzaamheden, Materiaal, Locatie, Vragen).
	- Do NOT invent details that were not stated.
2. ALWAYS call SaveNote with the normalized note.
3. Parse dates relative to the Current Time provided in the context:
   - "next Tuesday" = the coming Tuesday from Current Time
   - "tomorrow" = Current Time + 1 day
   - "this Friday" = the Friday of the current week
   - "on the 15th" = the 15th of the current or next month
4. Default appointment duration is 1 hour unless explicitly stated.
5. Set a call outcome using SetCallOutcome (short label like Scheduled, Attempted_Contact, Bad_Lead, Needs_Rescheduling).
6. If the context says Existing Appointment is None, do NOT say "verplaatst". Schedule a new appointment and write "Nieuwe afspraak ingepland" in the note.
7. Status mapping:
   - Appointment scheduled/booked  "Scheduled"
   - No answer/voicemail/try again  "Attempted_Contact"  
   - Not interested/declined/bad fit  "Bad_Lead"
   - Survey/inspection completed  "Surveyed"
   - Needs to reschedule/postponed  "Needs_Rescheduling"
8. When booking RAC_appointments, also update status to "Scheduled".
9. Use 24-hour time format (e.g., 09:00, 14:30).
10. Do NOT make up information. Only act on what is explicitly stated in the summary.
11. Email confirmation behavior for RAC_appointments:
   - By default, sendConfirmationEmail should be TRUE (send email)
   - Only set sendConfirmationEmail to FALSE if the call notes explicitly mention:
     - "no email", "don't send email", "skip email", "no confirmation email"
     - "they'll confirm differently", "will contact them separately"
   - If unclear, default to TRUE to send confirmation

Available tools:
- NormalizeCallNote: Cleans and formats a call note draft (use before SaveNote)
- SaveNote: Saves the call note (ALWAYS use this)
- SetCallOutcome: Stores a short outcome label for the call
- UpdateStatus: Updates the lead service status
- UpdatePipelineStage: Updates the pipeline stage when explicitly indicated
- ScheduleVisit: Books an inspection/visit appointment (includes sendConfirmationEmail option)
- RescheduleVisit: Reschedules an existing appointment
- CancelVisit: Cancels the existing appointment
`
}

// Tool input/output types for CallLogger

type SaveNoteInput struct {
	Body string `json:"body"` // The note text to save
}

type SaveNoteOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type NormalizeCallNoteInput struct {
	Body string `json:"body"` // Draft note to normalize
}

type NormalizeCallNoteOutput struct {
	Body string `json:"body"`
}

type SetCallOutcomeInput struct {
	Outcome string `json:"outcome"` // Short outcome label
	Notes   string `json:"notes,omitempty"`
}

type SetCallOutcomeOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type UpdateStatusInput struct {
	Status string `json:"status"` // New status: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling, Closed
}

type UpdateStatusOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type ScheduleVisitInput struct {
	StartTime             string `json:"startTime"`             // ISO 8601 format (e.g., "2026-02-10T09:00:00Z")
	EndTime               string `json:"endTime"`               // ISO 8601 format (e.g., "2026-02-10T10:00:00Z")
	Title                 string `json:"title"`                 // Appointment title (e.g., "Inspection visit")
	SendConfirmationEmail *bool  `json:"sendConfirmationEmail"` // Whether to send email to lead (default: true)
}

type ScheduleVisitOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type RescheduleVisitInput struct {
	StartTime   string `json:"startTime"` // ISO 8601 format (e.g., "2026-02-10T09:00:00Z")
	EndTime     string `json:"endTime"`   // ISO 8601 format (e.g., "2026-02-10T10:00:00Z")
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
}

type RescheduleVisitOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type CancelVisitInput struct {
	Reason string `json:"reason,omitempty"`
}

type CancelVisitOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func buildCallLoggerTools(deps *CallLoggerToolDeps) ([]tool.Tool, error) {
	normalizeCallNoteTool, err := buildNormalizeCallNoteTool(deps)
	if err != nil {
		return nil, err
	}

	saveNoteTool, err := buildSaveNoteTool(deps)
	if err != nil {
		return nil, err
	}

	setCallOutcomeTool, err := buildSetCallOutcomeTool(deps)
	if err != nil {
		return nil, err
	}

	updateStatusTool, err := buildUpdateStatusTool(deps)
	if err != nil {
		return nil, err
	}

	updatePipelineStageTool, err := buildCallLoggerUpdatePipelineStageTool(deps)
	if err != nil {
		return nil, err
	}

	scheduleVisitTool, err := buildScheduleVisitTool(deps)
	if err != nil {
		return nil, err
	}

	rescheduleVisitTool, err := buildRescheduleVisitTool(deps)
	if err != nil {
		return nil, err
	}

	cancelVisitTool, err := buildCancelVisitTool(deps)
	if err != nil {
		return nil, err
	}

	return []tool.Tool{
		normalizeCallNoteTool,
		saveNoteTool,
		setCallOutcomeTool,
		updateStatusTool,
		updatePipelineStageTool,
		scheduleVisitTool,
		rescheduleVisitTool,
		cancelVisitTool,
	}, nil
}

func buildSaveNoteTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "SaveNote",
		Description: "Saves the call summary as a note on the lead. ALWAYS call this tool to record the call outcome.",
	}, func(ctx tool.Context, input SaveNoteInput) (SaveNoteOutput, error) {
		if _, _, _, _, ok := deps.GetContext(); !ok {
			return SaveNoteOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
		}

		deps.SetNoteDraft(input.Body)
		return SaveNoteOutput{Success: true, Message: "Note drafted"}, nil
	})
}

func normalizeCallNoteBody(body string) string {
	trimmed := strings.TrimSpace(body)
	if trimmed == "" {
		return ""
	}

	lines := strings.Split(trimmed, "\n")
	cleaned := make([]string, 0, len(lines))
	lastBlank := false
	for _, line := range lines {
		plain := strings.TrimSpace(line)
		lower := strings.ToLower(plain)
		if strings.Contains(lower, "originele input") {
			continue
		}
		if plain == "" {
			if lastBlank {
				continue
			}
			lastBlank = true
			cleaned = append(cleaned, "")
			continue
		}
		lastBlank = false
		cleaned = append(cleaned, strings.TrimRight(line, " \t"))
	}

	return strings.TrimSpace(strings.Join(cleaned, "\n"))
}

func appendRescheduleFallbackNote(body string, startTime time.Time) string {
	lower := strings.ToLower(body)
	if strings.Contains(lower, "geen bestaande afspraak") || strings.Contains(lower, "nieuwe afspraak") {
		return body
	}

	correction := fmt.Sprintf("Let op: er was geen bestaande afspraak. Nieuwe afspraak ingepland op %s.", startTime.Format(dateTimeShortLayout))
	trimmed := strings.TrimSpace(body)
	if trimmed == "" {
		return correction
	}
	return strings.TrimRight(body, "\n") + "\n\n" + correction
}

func buildNormalizeCallNoteTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	_ = deps
	return functiontool.New(functiontool.Config{
		Name:        "NormalizeCallNote",
		Description: "Cleans and normalizes a drafted call note. Use before SaveNote.",
	}, func(ctx tool.Context, input NormalizeCallNoteInput) (NormalizeCallNoteOutput, error) {
		normalized := normalizeCallNoteBody(input.Body)
		return NormalizeCallNoteOutput{Body: normalized}, nil
	})
}

func buildSetCallOutcomeTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "SetCallOutcome",
		Description: "Stores a short call outcome label on the timeline.",
	}, func(ctx tool.Context, input SetCallOutcomeInput) (SetCallOutcomeOutput, error) {
		tenantID, userID, leadID, serviceID, ok := deps.GetContext()
		if !ok {
			return SetCallOutcomeOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
		}

		outcome := strings.TrimSpace(input.Outcome)
		if outcome == "" {
			return SetCallOutcomeOutput{Success: false, Message: "Missing outcome"}, fmt.Errorf("missing outcome")
		}

		actorName := userID.String()
		summary := outcome
		if strings.TrimSpace(input.Notes) != "" {
			summary = fmt.Sprintf("%s - %s", outcome, strings.TrimSpace(input.Notes))
		}

		_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
			LeadID:         leadID,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      "User",
			ActorName:      actorName,
			EventType:      "call_outcome",
			Title:          "Belresultaat",
			Summary:        &summary,
			Metadata: map[string]any{
				"outcome": outcome,
				"notes":   strings.TrimSpace(input.Notes),
			},
		})

		deps.SetCallOutcome(outcome)
		return SetCallOutcomeOutput{Success: true, Message: "Call outcome set"}, nil
	})
}

// validLeadStatuses defines the allowed status values for RAC_leads
var validLeadStatuses = map[string]bool{
	"New":                true,
	"Attempted_Contact":  true,
	"Scheduled":          true,
	"Surveyed":           true,
	"Bad_Lead":           true,
	"Needs_Rescheduling": true,
	"Closed":             true,
}

func buildUpdateStatusTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "UpdateStatus",
		Description: "Updates the status of the lead service. Valid statuses: New, Attempted_Contact, Scheduled, Surveyed, Bad_Lead, Needs_Rescheduling, Closed",
	}, func(ctx tool.Context, input UpdateStatusInput) (UpdateStatusOutput, error) {
		tenantID, _, _, serviceID, ok := deps.GetContext()
		if !ok {
			return UpdateStatusOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
		}

		if !validLeadStatuses[input.Status] {
			return UpdateStatusOutput{Success: false, Message: "Invalid status"}, fmt.Errorf("invalid status: %s", input.Status)
		}

		_, err := deps.Repo.UpdateServiceStatus(context.Background(), serviceID, tenantID, input.Status)
		if err != nil {
			return UpdateStatusOutput{Success: false, Message: err.Error()}, err
		}

		deps.MarkStatusUpdated(input.Status)
		return UpdateStatusOutput{Success: true, Message: fmt.Sprintf("Status updated to %s", input.Status)}, nil
	})
}

func buildScheduleVisitTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "ScheduleVisit",
		Description: "Books an inspection/visit appointment for the lead. Provide start and end times in ISO 8601 format. Set sendConfirmationEmail to false if the call notes mention not sending email; otherwise it defaults to true.",
	}, func(ctx tool.Context, input ScheduleVisitInput) (ScheduleVisitOutput, error) {
		return executeScheduleVisit(deps, input)
	})
}

func buildRescheduleVisitTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "RescheduleVisit",
		Description: "Reschedules an existing lead visit appointment. Provide start and end times in ISO 8601 format.",
	}, func(ctx tool.Context, input RescheduleVisitInput) (RescheduleVisitOutput, error) {
		return executeRescheduleVisit(deps, input)
	})
}

func buildCancelVisitTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "CancelVisit",
		Description: "Cancels the existing lead visit appointment.",
	}, func(ctx tool.Context, input CancelVisitInput) (CancelVisitOutput, error) {
		return executeCancelVisit(deps, input)
	})
}

func executeScheduleVisit(deps *CallLoggerToolDeps, input ScheduleVisitInput) (ScheduleVisitOutput, error) {
	tenantID, userID, leadID, serviceID, ok := deps.GetContext()
	if !ok {
		return ScheduleVisitOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
	}

	if deps.Booker == nil {
		return ScheduleVisitOutput{Success: false, Message: errMsgBookingNotConfigured}, errors.New(errBookerNotConfigured)
	}

	startTime, err := time.Parse(time.RFC3339, input.StartTime)
	if err != nil {
		return ScheduleVisitOutput{Success: false, Message: "Invalid start time format"}, err
	}

	endTime, err := time.Parse(time.RFC3339, input.EndTime)
	if err != nil {
		return ScheduleVisitOutput{Success: false, Message: "Invalid end time format"}, err
	}

	title := input.Title
	if title == "" {
		title = "Lead visit"
	}

	// Default to sending confirmation email if not specified
	sendEmail := true
	if input.SendConfirmationEmail != nil {
		sendEmail = *input.SendConfirmationEmail
	}

	err = deps.Booker.BookLeadVisit(context.Background(), ports.BookVisitParams{
		TenantID:              tenantID,
		UserID:                userID,
		LeadID:                leadID,
		LeadServiceID:         serviceID,
		StartTime:             startTime,
		EndTime:               endTime,
		Title:                 title,
		Description:           "Scheduled via Call Logger",
		SendConfirmationEmail: sendEmail,
	})
	if err != nil {
		return ScheduleVisitOutput{Success: false, Message: err.Error()}, err
	}

	deps.MarkAppointmentBooked(startTime)
	return ScheduleVisitOutput{Success: true, Message: "Appointment booked"}, nil
}

func buildCallLoggerUpdatePipelineStageTool(deps *CallLoggerToolDeps) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "UpdatePipelineStage",
		Description: "Updates the pipeline stage for the lead service and records a timeline event.",
	}, func(ctx tool.Context, input UpdatePipelineStageInput) (UpdatePipelineStageOutput, error) {
		if !validPipelineStages[input.Stage] {
			return UpdatePipelineStageOutput{Success: false, Message: "Invalid pipeline stage"}, fmt.Errorf("invalid pipeline stage: %s", input.Stage)
		}

		tenantID, userID, leadID, serviceID, ok := deps.GetContext()
		if !ok {
			return UpdatePipelineStageOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
		}

		svc, err := deps.Repo.GetLeadServiceByID(ctx, serviceID, tenantID)
		if err != nil {
			return UpdatePipelineStageOutput{Success: false, Message: "Lead service not found"}, err
		}
		oldStage := svc.PipelineStage

		_, err = deps.Repo.UpdatePipelineStage(ctx, serviceID, tenantID, input.Stage)
		if err != nil {
			return UpdatePipelineStageOutput{Success: false, Message: "Failed to update pipeline stage"}, err
		}

		reason := strings.TrimSpace(input.Reason)
		var summary *string
		if reason != "" {
			summary = &reason
		}

		actorName := userID.String()
		_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
			LeadID:         leadID,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      "User",
			ActorName:      actorName,
			EventType:      "stage_change",
			Title:          "Fase bijgewerkt",
			Summary:        summary,
			Metadata: map[string]any{
				"oldStage": oldStage,
				"newStage": input.Stage,
			},
		})

		if deps.EventBus != nil {
			deps.EventBus.Publish(ctx, events.PipelineStageChanged{
				BaseEvent:     events.NewBaseEvent(),
				LeadID:        leadID,
				LeadServiceID: serviceID,
				TenantID:      tenantID,
				OldStage:      oldStage,
				NewStage:      input.Stage,
			})
		}

		deps.MarkPipelineStageUpdated(input.Stage)
		return UpdatePipelineStageOutput{Success: true, Message: "Pipeline stage updated"}, nil
	})
}

func executeRescheduleVisit(deps *CallLoggerToolDeps, input RescheduleVisitInput) (RescheduleVisitOutput, error) {
	tenantID, userID, _, serviceID, ok := deps.GetContext()
	if !ok {
		return RescheduleVisitOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
	}

	if deps.Booker == nil {
		return RescheduleVisitOutput{Success: false, Message: errMsgBookingNotConfigured}, errors.New(errBookerNotConfigured)
	}

	if _, err := deps.Booker.GetLeadVisitByService(context.Background(), tenantID, serviceID, userID); err != nil {
		if apperr.Is(err, apperr.KindNotFound) {
			deps.MarkRescheduleFallback()
			scheduled, scheduleErr := executeScheduleVisit(deps, ScheduleVisitInput{
				StartTime: input.StartTime,
				EndTime:   input.EndTime,
				Title:     input.Title,
			})
			if scheduleErr != nil {
				return RescheduleVisitOutput{Success: false, Message: scheduled.Message}, scheduleErr
			}
			return RescheduleVisitOutput{Success: true, Message: "Appointment scheduled"}, nil
		}
		return RescheduleVisitOutput{Success: false, Message: err.Error()}, err
	}

	startTime, err := time.Parse(time.RFC3339, input.StartTime)
	if err != nil {
		return RescheduleVisitOutput{Success: false, Message: "Invalid start time format"}, err
	}

	endTime, err := time.Parse(time.RFC3339, input.EndTime)
	if err != nil {
		return RescheduleVisitOutput{Success: false, Message: "Invalid end time format"}, err
	}

	var title *string
	if strings.TrimSpace(input.Title) != "" {
		value := strings.TrimSpace(input.Title)
		title = &value
	}

	var description *string
	if strings.TrimSpace(input.Description) != "" {
		value := strings.TrimSpace(input.Description)
		description = &value
	}

	err = deps.Booker.RescheduleLeadVisit(context.Background(), ports.RescheduleVisitParams{
		TenantID:      tenantID,
		UserID:        userID,
		LeadServiceID: serviceID,
		StartTime:     startTime,
		EndTime:       endTime,
		Title:         title,
		Description:   description,
	})
	if err != nil {
		return RescheduleVisitOutput{Success: false, Message: err.Error()}, err
	}

	deps.MarkAppointmentRescheduled(startTime)
	return RescheduleVisitOutput{Success: true, Message: "Appointment rescheduled"}, nil
}

func executeCancelVisit(deps *CallLoggerToolDeps, input CancelVisitInput) (CancelVisitOutput, error) {
	_ = input
	tenantID, userID, _, serviceID, ok := deps.GetContext()
	if !ok {
		return CancelVisitOutput{Success: false, Message: errMsgMissingContext}, errMissingContext
	}

	if deps.Booker == nil {
		return CancelVisitOutput{Success: false, Message: errMsgBookingNotConfigured}, errors.New(errBookerNotConfigured)
	}

	err := deps.Booker.CancelLeadVisit(context.Background(), ports.CancelVisitParams{
		TenantID:      tenantID,
		UserID:        userID,
		LeadServiceID: serviceID,
	})
	if err != nil {
		return CancelVisitOutput{Success: false, Message: err.Error()}, err
	}

	deps.MarkAppointmentCancelled()
	return CancelVisitOutput{Success: true, Message: "Appointment cancelled"}, nil
}
</file>

<file path="internal/leads/agent/photo_analyzer.go">
package agent

import (
	"context"
	"fmt"
	"log"
	"strings"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/adk/tool/functiontool"
	"google.golang.org/genai"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/moonshot"
)

// Measurement represents a single measurement extracted from photo analysis
type Measurement struct {
	Description string  `json:"description"`
	Value       float64 `json:"value"`
	Unit        string  `json:"unit"`
	Type        string  `json:"type"`       // dimension, area, count, volume
	Confidence  string  `json:"confidence"` // High, Medium, Low
	PhotoRef    string  `json:"photoRef,omitempty"`
}

// PhotoAnalysis represents the result of analyzing photos for a lead service
type PhotoAnalysis struct {
	ID                     uuid.UUID     `json:"id"`
	LeadID                 uuid.UUID     `json:"leadId"`
	ServiceID              uuid.UUID     `json:"serviceId"`
	Summary                string        `json:"summary"`
	Observations           []string      `json:"observations"`
	ScopeAssessment        string        `json:"scopeAssessment"`
	CostIndicators         string        `json:"costIndicators"`
	SafetyConcerns         []string      `json:"safetyConcerns,omitempty"`
	AdditionalInfo         []string      `json:"additionalInfo,omitempty"`
	Measurements           []Measurement `json:"measurements,omitempty"`
	NeedsOnsiteMeasurement []string      `json:"needsOnsiteMeasurement,omitempty"`
	Discrepancies          []string      `json:"discrepancies,omitempty"`
	ExtractedText          []string      `json:"extractedText,omitempty"`
	SuggestedSearchTerms   []string      `json:"suggestedSearchTerms,omitempty"`
	PhotoCount             int           `json:"photoCount"`
	ConfidenceLevel        string        `json:"confidenceLevel"` // High, Medium, Low
}

// PhotoAnalyzerDeps contains dependencies for the photo analyzer
type PhotoAnalyzerDeps struct {
	Repo     repository.LeadsRepository
	mu       sync.RWMutex
	tenantID *uuid.UUID
	// Result storage - set after analysis
	result                  *PhotoAnalysis
	needsOnsiteMeasurements []string // Accumulated by FlagOnsiteMeasurement tool
}

func (d *PhotoAnalyzerDeps) SetTenantID(id uuid.UUID) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.tenantID = &id
}

func (d *PhotoAnalyzerDeps) GetTenantID() (uuid.UUID, bool) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	if d.tenantID == nil {
		return uuid.UUID{}, false
	}
	return *d.tenantID, true
}

func (d *PhotoAnalyzerDeps) SetResult(r *PhotoAnalysis) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result = r
}

func (d *PhotoAnalyzerDeps) GetResult() *PhotoAnalysis {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.result
}

func (d *PhotoAnalyzerDeps) AddOnsiteFlag(reason string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.needsOnsiteMeasurements = append(d.needsOnsiteMeasurements, reason)
}

func (d *PhotoAnalyzerDeps) GetOnsiteFlags() []string {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.needsOnsiteMeasurements
}

func (d *PhotoAnalyzerDeps) ResetAccumulators() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.result = nil
	d.needsOnsiteMeasurements = nil
}

// PhotoAnalyzer provides AI-powered photo analysis for lead services
type PhotoAnalyzer struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	deps           *PhotoAnalyzerDeps
	runMu          sync.Mutex
}

// NewPhotoAnalyzer creates a new photo analyzer agent
func NewPhotoAnalyzer(apiKey string, repo repository.LeadsRepository) (*PhotoAnalyzer, error) {
	// Use kimi-k2.5 with thinking disabled for multimodal analysis
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          apiKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	deps := &PhotoAnalyzerDeps{
		Repo: repo,
	}

	analyzer := &PhotoAnalyzer{
		appName: "photo_analyzer",
		deps:    deps,
	}

	tools, err := buildPhotoAnalyzerTools(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build photo analyzer tools: %w", err)
	}

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "PhotoAnalyzer",
		Model:       kimi,
		Description: "Expert AI agent specialized in analyzing photos of home repair and service situations",
		Instruction: getPhotoAnalyzerPrompt(),
		Tools:       tools,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create photo analyzer agent: %w", err)
	}

	sessionService := session.InMemoryService()

	r, err := runner.New(runner.Config{
		AppName:        analyzer.appName,
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create photo analyzer runner: %w", err)
	}

	analyzer.agent = adkAgent
	analyzer.runner = r
	analyzer.sessionService = sessionService

	return analyzer, nil
}

// AnalyzePhotos analyzes a set of photos for a lead service.
func (pa *PhotoAnalyzer) AnalyzePhotos(ctx context.Context, req PhotoAnalysisRequest) (*PhotoAnalysis, error) {
	pa.runMu.Lock()
	defer pa.runMu.Unlock()

	if len(req.Images) == 0 {
		return nil, fmt.Errorf("no images provided")
	}

	pa.deps.SetTenantID(req.TenantID)
	pa.deps.ResetAccumulators() // Clear previous result and onsite flags

	userContent := buildUserContent(req)
	userID, sessionID, err := pa.createSession(ctx, req.LeadID, req.ServiceID)
	if err != nil {
		return nil, err
	}
	defer pa.cleanupSession(ctx, userID, sessionID)

	output, err := pa.runAnalysis(ctx, userID, sessionID, userContent)
	if err != nil {
		return nil, err
	}
	log.Printf("Photo analysis completed for lead %s service %s. Output: %s", req.LeadID, req.ServiceID, output)

	result, err := pa.getOrRetryResult(ctx, userID, sessionID, output)
	if err != nil {
		return nil, err
	}

	pa.mergeOnsiteFlags(result)
	return result, nil
}

// PhotoAnalysisRequest contains analysis parameters for photo analysis.
// Images should be raw image data with MIME types.
type PhotoAnalysisRequest struct {
	LeadID             uuid.UUID
	ServiceID          uuid.UUID
	TenantID           uuid.UUID
	Images             []ImageData
	ContextInfo        string
	ServiceType        string
	IntakeRequirements string
}

func buildUserContent(req PhotoAnalysisRequest) *genai.Content {
	parts := make([]*genai.Part, 0, len(req.Images)+1)
	for _, img := range req.Images {
		parts = append(parts, &genai.Part{
			InlineData: &genai.Blob{
				MIMEType: img.MIMEType,
				Data:     img.Data,
			},
		})
	}

	prompt := buildPhotoAnalysisPrompt(req.LeadID, req.ServiceID, len(req.Images), req.ContextInfo, req.ServiceType, req.IntakeRequirements)
	parts = append(parts, genai.NewPartFromText(prompt))

	return &genai.Content{
		Role:  "user",
		Parts: parts,
	}
}

func (pa *PhotoAnalyzer) createSession(ctx context.Context, leadID, serviceID uuid.UUID) (string, string, error) {
	userID := fmt.Sprintf("photo-analyzer-%s-%s", leadID, serviceID)
	sessionID := uuid.New().String()

	_, err := pa.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   pa.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return "", "", fmt.Errorf("failed to create session: %w", err)
	}

	return userID, sessionID, nil
}

func (pa *PhotoAnalyzer) cleanupSession(ctx context.Context, userID, sessionID string) {
	if deleteErr := pa.sessionService.Delete(ctx, &session.DeleteRequest{
		AppName:   pa.appName,
		UserID:    userID,
		SessionID: sessionID,
	}); deleteErr != nil {
		log.Printf("warning: failed to delete session: %v", deleteErr)
	}
}

func (pa *PhotoAnalyzer) runAnalysis(ctx context.Context, userID, sessionID string, userContent *genai.Content) (string, error) {
	var output string
	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	for event, err := range pa.runner.Run(ctx, userID, sessionID, userContent, runConfig) {
		if err != nil {
			return "", fmt.Errorf("photo analysis failed: %w", err)
		}
		output += collectContentText(event.Content)
	}

	return output, nil
}

func (pa *PhotoAnalyzer) getOrRetryResult(ctx context.Context, userID, sessionID string, output string) (*PhotoAnalysis, error) {
	result := pa.deps.GetResult()
	if result != nil {
		return result, nil
	}

	retryOutput, err := pa.retryForResult(ctx, userID, sessionID, output)
	if err != nil {
		return nil, err
	}
	_ = retryOutput

	result = pa.deps.GetResult()
	if result == nil {
		return nil, fmt.Errorf("AI did not save photo analysis")
	}

	return result, nil
}

func (pa *PhotoAnalyzer) retryForResult(ctx context.Context, userID, sessionID string, output string) (string, error) {
	retryContent := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			genai.NewPartFromText("toolYou MUST call the SavePhotoAnalysis tool now with your complete analysis."),
		},
	}

	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	for event, err := range pa.runner.Run(ctx, userID, sessionID, retryContent, runConfig) {
		if err != nil {
			return output, fmt.Errorf("photo analysis retry failed: %w", err)
		}
		output += collectContentText(event.Content)
	}

	return output, nil
}

func collectContentText(content *genai.Content) string {
	if content == nil {
		return ""
	}

	var output string
	for _, part := range content.Parts {
		output += part.Text
	}

	return output
}

func (pa *PhotoAnalyzer) mergeOnsiteFlags(result *PhotoAnalysis) {
	if flags := pa.deps.GetOnsiteFlags(); len(flags) > 0 {
		result.NeedsOnsiteMeasurement = append(result.NeedsOnsiteMeasurement, flags...)
	}
}

// ImageData represents an image to analyze
type ImageData struct {
	MIMEType string // e.g., "image/jpeg", "image/png"
	Data     []byte // Raw image bytes
	Filename string // Original filename (optional)
}

// SavePhotoAnalysisInput contains the input parameters for the SavePhotoAnalysis tool
type SavePhotoAnalysisInput struct {
	LeadID               string             `json:"leadId" description:"The UUID of the lead"`
	ServiceID            string             `json:"serviceId" description:"The UUID of the lead service"`
	Summary              string             `json:"summary" description:"A concise 2-3 sentence summary of what the photos show"`
	Observations         []string           `json:"observations" description:"List of specific observations from the photos"`
	ScopeAssessment      string             `json:"scopeAssessment" description:"Assessment of work scope: Small, Medium, Large, or Unclear"`
	CostIndicators       string             `json:"costIndicators" description:"Factors visible that may affect pricing"`
	SafetyConcerns       []string           `json:"safetyConcerns" description:"Any safety issues visible in the photos"`
	AdditionalInfo       []string           `json:"additionalInfo" description:"Additional info or questions to ask the consumer"`
	ConfidenceLevel      string             `json:"confidenceLevel" description:"Analysis confidence: High, Medium, or Low"`
	Measurements         []MeasurementInput `json:"measurements,omitempty" description:"Measurements extracted or estimated from the photos"`
	Discrepancies        []string           `json:"discrepancies,omitempty" description:"Discrepancies between consumer claims and visible evidence"`
	ExtractedText        []string           `json:"extractedText,omitempty" description:"Text, labels, model numbers, or serial numbers read from photos"`
	SuggestedSearchTerms []string           `json:"suggestedSearchTerms,omitempty" description:"Product/material search terms for the Estimator to look up"`
}

// MeasurementInput represents a single measurement from the AI tool
type MeasurementInput struct {
	Description string  `json:"description" description:"What was measured, e.g. 'window width'"`
	Value       float64 `json:"value" description:"Numeric value of the measurement"`
	Unit        string  `json:"unit" description:"Unit of measurement: m, m2, m3, cm, mm, stuks"`
	Type        string  `json:"type" description:"Measurement type: dimension, area, count, or volume"`
	Confidence  string  `json:"confidence" description:"Confidence in measurement: High, Medium, or Low"`
	PhotoRef    string  `json:"photoRef,omitempty" description:"Which photo this was measured from, e.g. 'photo 1'"`
}

// FlagOnsiteMeasurementInput is the input for the FlagOnsiteMeasurement tool
type FlagOnsiteMeasurementInput struct {
	Reason string `json:"reason" description:"Why an on-site measurement is needed, e.g. 'ceiling height not visible from photo angle'"`
}

// SavePhotoAnalysisOutput is the result of saving the photo analysis
type SavePhotoAnalysisOutput struct {
	Success bool   `json:"success"`
	ID      string `json:"id"`
	Message string `json:"message"`
}

func buildPhotoAnalyzerTools(deps *PhotoAnalyzerDeps) ([]tool.Tool, error) {
	savePhotoAnalysis, err := functiontool.New(functiontool.Config{
		Name:        "SavePhotoAnalysis",
		Description: "Save the analysis of photos for a lead service. Call this after analyzing all photos. Include measurements, discrepancies, extracted text, and suggested search terms.",
	}, func(ctx tool.Context, args SavePhotoAnalysisInput) (SavePhotoAnalysisOutput, error) {
		leadID, err := uuid.Parse(args.LeadID)
		if err != nil {
			return SavePhotoAnalysisOutput{Success: false, Message: "Invalid leadId"}, err
		}

		serviceID, err := uuid.Parse(args.ServiceID)
		if err != nil {
			return SavePhotoAnalysisOutput{Success: false, Message: "Invalid serviceId"}, err
		}

		// Normalize confidence level
		confidence := normalizeConfidenceLevel(args.ConfidenceLevel)
		// Normalize scope assessment
		scope := normalizeScopeAssessment(args.ScopeAssessment)

		// Convert measurement inputs to measurements
		measurements := make([]Measurement, 0, len(args.Measurements))
		for _, m := range args.Measurements {
			measurements = append(measurements, Measurement{
				Description: m.Description,
				Value:       m.Value,
				Unit:        m.Unit,
				Type:        normalizeMeasurementType(m.Type),
				Confidence:  normalizeConfidenceLevel(m.Confidence),
				PhotoRef:    m.PhotoRef,
			})
		}

		result := &PhotoAnalysis{
			ID:                   uuid.New(),
			LeadID:               leadID,
			ServiceID:            serviceID,
			Summary:              args.Summary,
			Observations:         args.Observations,
			ScopeAssessment:      scope,
			CostIndicators:       args.CostIndicators,
			SafetyConcerns:       args.SafetyConcerns,
			AdditionalInfo:       args.AdditionalInfo,
			ConfidenceLevel:      confidence,
			Measurements:         measurements,
			Discrepancies:        args.Discrepancies,
			ExtractedText:        args.ExtractedText,
			SuggestedSearchTerms: args.SuggestedSearchTerms,
		}

		deps.SetResult(result)

		log.Printf("Photo analysis saved for lead %s service %s (measurements=%d, discrepancies=%d, extractedText=%d, searchTerms=%d)",
			leadID, serviceID, len(measurements), len(args.Discrepancies), len(args.ExtractedText), len(args.SuggestedSearchTerms))

		return SavePhotoAnalysisOutput{
			Success: true,
			ID:      result.ID.String(),
			Message: "Photo analysis saved successfully",
		}, nil
	})
	if err != nil {
		return nil, err
	}

	// Calculator for exact arithmetic (reuse the shared handler from tools.go)
	calculator, err := createCalculatorTool()
	if err != nil {
		return nil, err
	}

	// FlagOnsiteMeasurement accumulates reasons why on-site measurement is needed
	flagOnsite, err := functiontool.New(functiontool.Config{
		Name:        "FlagOnsiteMeasurement",
		Description: "Flag that a specific measurement cannot be determined from photos alone and requires on-site measurement. Call this for EACH measurement that needs on-site verification.",
	}, func(ctx tool.Context, args FlagOnsiteMeasurementInput) (map[string]any, error) {
		if args.Reason == "" {
			return map[string]any{"success": false, "message": "reason is required"}, nil
		}
		deps.AddOnsiteFlag(args.Reason)
		log.Printf("Flagged on-site measurement needed: %s", args.Reason)
		return map[string]any{"success": true, "message": "On-site flag recorded"}, nil
	})
	if err != nil {
		return nil, err
	}

	return []tool.Tool{savePhotoAnalysis, calculator, flagOnsite}, nil
}

func normalizeConfidenceLevel(level string) string {
	switch level {
	case "High", "HIGH", "high", "Hoog", "hoog":
		return "High"
	case "Low", "LOW", "low", "Laag", "laag":
		return "Low"
	default:
		return "Medium"
	}
}

func normalizeScopeAssessment(scope string) string {
	// Normalize various AI responses to allowed values
	switch scope {
	case "Small", "SMALL", "small", "Klein", "klein", "Minor", "minor":
		return "Small"
	case "Medium", "MEDIUM", "medium", "Gemiddeld", "gemiddeld", "Moderate", "moderate":
		return "Medium"
	case "Large", "LARGE", "large", "Groot", "groot", "Major", "major", "Extensive", "extensive":
		return "Large"
	case "Unclear", "UNCLEAR", "unclear", "Onduidelijk", "onduidelijk", "Unknown", "unknown":
		return "Unclear"
	default:
		// If not recognized, default to Unclear
		return "Unclear"
	}
}

func normalizeMeasurementType(t string) string {
	switch strings.ToLower(strings.TrimSpace(t)) {
	case "dimension", "length", "width", "height", "depth", "lengte", "breedte", "hoogte":
		return "dimension"
	case "area", "oppervlakte", "m2":
		return "area"
	case "count", "aantal", "stuks", "quantity":
		return "count"
	case "volume", "inhoud", "m3":
		return "volume"
	default:
		return "dimension"
	}
}

func buildPhotoAnalysisPrompt(leadID, serviceID uuid.UUID, photoCount int, contextInfo string, serviceType string, intakeRequirements string) string {
	prompt := fmt.Sprintf(`Analyseer de %d foto('s) voor deze thuisdienst aanvraag.

Lead ID: %s
Service ID: %s
`, photoCount, leadID.String(), serviceID.String())

	if serviceType != "" {
		prompt += fmt.Sprintf(`
## DIENSTTYPE: %s
Pas je analyse aan voor dit specifieke vakgebied. Gebruik je vakkennis over '%s' om:
- Specifieke materialen, componenten en systemen te herkennen
- Relevante Nederlandse bouwstandaarden en -normen toe te passen (NEN, KOMO, BRL, etc.)
- Typische afmetingen in te schatten op basis van standaardmaten voor dit type werk
- Productzoektermen te suggereren die de Schatter kan gebruiken om materialen te vinden
`, serviceType, serviceType)
	}

	if intakeRequirements != "" {
		prompt += fmt.Sprintf(`
## INTAKE-EISEN (HARDE EISEN)
Controleer voor elk van deze eisen of ze zichtbaar zijn op de foto's:
%s

Noteer in je observaties welke eisen je kunt bevestigen of weerleggen op basis van de foto's.
Voeg tegenstrijdigheden toe aan discrepancies als claims niet overeenkomen met wat je ziet.
`, intakeRequirements)
	}

	if contextInfo != "" {
		prompt += fmt.Sprintf(`
## Context van de aanvraag (CLAIMS VAN CONSUMENT):
%s

BELANGRIJK: Vergelijk deze claims kritisch met wat je daadwerkelijk op de foto's ziet.
Als een claim niet klopt met de visuele bewijzen, voeg het toe aan discrepancies.
`, contextInfo)
	}

	prompt += `
## Analyseer elke foto zorgvuldig en voer uit:

### 1. VISUELE OBSERVATIES
- Welk specifiek probleem of situatie wordt getoond
- De geschatte omvang en complexiteit van het benodigde werk
- Factoren die prijs of tijdlijn kunnen benvloeden
- Veiligheidszorgen die aangepakt moeten worden

### 2. METINGEN (CRUCIAAL)
Schat afmetingen, oppervlaktes en aantallen uit elke foto:
- Gebruik referentie-objecten (deuren ~2.1m, stopcontacten ~30cm, standaard tegels, etc.)
- Gebruik de Calculator tool voor berekeningen (oppervlakte = lengte  breedte)
- Noteer elke meting met type (dimension/area/count/volume), waarde, eenheid en confidence
- Als een meting niet betrouwbaar uit de foto te halen is, roep FlagOnsiteMeasurement aan

### 3. TEKST EXTRACTIE (OCR)
Lees alle zichtbare tekst op foto's:
- Merknamen, modelnummers, serienummers
- Energielabels, typeplaten, CE-markeringen
- Afmetingen op verpakkingen of producten
- Waarschuwingsteksten

### 4. FEITCONTROLE (DISCREPANCIES)
Als er context/claims van de consument zijn meegegeven:
- Vergelijk elke claim met visuele bewijzen
- Noteer tegenstrijdigheden (bijv. "consument meldt lekkage maar geen vochtsporen zichtbaar")
- Dit helpt de Gatekeeper claims te valideren

### 5. PRODUCTZOEKTERMEN
Stel zoektermen voor die de Schatter kan gebruiken om materialen te vinden:
- Specifieke productnamen, materiaalsoorten
- Nederlandse en Engelse termen
- Merken en modellen als zichtbaar

## VERPLICHT
Na je analyse MOET je de SavePhotoAnalysis tool aanroepen met je complete bevindingen.
Gebruik de Calculator voor alle berekeningen. Gebruik FlagOnsiteMeasurement voor metingen die ter plaatse nodig zijn.`

	return prompt
}

func getPhotoAnalyzerPrompt() string {
	return `Je bent een forensisch foto-analist voor een Nederlandse thuisdiensten-marktplaats. Je combineert scherp visueel waarnemingsvermogen met diepgaande vakkennis om alles uit foto's te halen wat relevant is voor prijsschatting en kwaliteitsbeoordeling.

## Kerncompetenties
- **Meten**: Schat afmetingen, oppervlaktes en aantallen door referentie-objecten te gebruiken (deurhoogte ~2.1m, standaard stopcontact ~8cm breed, dakpannen ~33cm, etc.)
- **OCR**: Lees alle zichtbare tekst - merknamen, modelnummers, typeplaten, energielabels, CE-markeringen
- **Feitcontrole**: Vergelijk consumentclaims kritisch met visuele bewijzen en rapporteer tegenstrijdigheden
- **Productherkenning**: Identificeer specifieke producten, materialen en systemen voor downstream prijsschatting

## Meetrichtlijnen
- Gebruik bekende referentie-objecten om schaal af te leiden
- Gebruik de Calculator tool voor ALLE berekeningen (oppervlakte, volumes, aantallen)
- Geef confidence levels: High (referentie-object duidelijk zichtbaar), Medium (geschat), Low (onzeker)
- Als een meting echt niet uit de foto te halen is: roep FlagOnsiteMeasurement aan met uitleg

## Analysediepte per Vakgebied
Je past je analyse automatisch aan op basis van het meegegeven diensttype:
- **Loodgieter**: Leidingdiameters, koppelstukken, waterschade-omvang, keteltype/leeftijd, cv-druk
- **Elektricien**: Groepsoorten, kabeldiameters, schakelmateriaal, groepenkast-capaciteit, aardingsstatus
- **Timmerman**: Houtsoort, profielafmetingen, kozijnmaten, glassoort, scharniertypes
- **Dakdekker**: Dakpantype, hellingshoek, nok/goot-details, dakoppervlakte, isolatie
- **Schilder**: Verfsoort, ondergrond, oppervlakte, hechtingsstatus, lagen-opbouw
- Een diensttype dat niet in deze lijst staat? Gebruik je algemene bouwkundige kennis.

## Nederlandse Bouwstandaarden (Latente Kennis)
Je kent de standaardmaten die in Nederland gangbaar zijn:
- Binnendeur: 2015830mm, buitendeur: 2315930mm
- Verdiepingshoogte: ~2.60m (woningbouw), ~3.50m (utiliteit)
- Standaard tegelformaten: 2020, 3030, 6060 cm
- Standaard kozijnen: draai-kiep, vast glas, schuifpui
- Dakpannen: ~14.5 stuks per m
- Leidingdiameters: 15mm (warm/koud), 22mm (cv), 32mm (afvoer)
Deze kennis gebruik je automatisch bij het inschatten van maten.

## Veiligheidszorgen
Markeer altijd:
- Blootliggende bedrading of elektrische gevaren
- Waterschade nabij elektriciteit
- Constructieve zorgen (scheuren, doorbuiging)
- Schimmel of waterschade
- Gas-gerelateerde problemen
- Asbest-era materialen (gebouwen van voor 1994)

## Verplichte Actie
Na het analyseren MOET je de SavePhotoAnalysis tool aanroepen met alle bevindingen.
Gebruik Calculator voor berekeningen. Gebruik FlagOnsiteMeasurement waar nodig.
Beschrijf niet alleen wat je ziet - sla de gestructureerde analyse op via de tools.`
}
</file>

<file path="internal/leads/handler/attachments.go">
package handler

import (
	"fmt"
	"net/http"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// AttachmentsHandler handles HTTP requests for lead service attachments.
type AttachmentsHandler struct {
	repo     repository.LeadsRepository
	eventBus events.Bus
	storage  storage.StorageService
	bucket   string
	val      *validator.Validator
}

// NewAttachmentsHandler creates a new attachments handler.
func NewAttachmentsHandler(repo repository.LeadsRepository, eventBus events.Bus, storageSvc storage.StorageService, bucket string, val *validator.Validator) *AttachmentsHandler {
	return &AttachmentsHandler{repo: repo, eventBus: eventBus, storage: storageSvc, bucket: bucket, val: val}
}

// RegisterRoutes adds attachment routes to a service-specific router group.
// Expected route: /RAC_leads/:id/services/:serviceId/attachments
func (h *AttachmentsHandler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.POST("/presign", h.GetPresignedUploadURL)
	rg.POST("", h.CreateAttachment)
	rg.GET("", h.ListAttachments)
	rg.GET("/:attachmentId", h.GetAttachment)
	rg.GET("/:attachmentId/download", h.GetDownloadURL)
	rg.DELETE("/:attachmentId", h.DeleteAttachment)
}

// GetPresignedUploadURL generates a presigned URL for uploading a file to MinIO.
func (h *AttachmentsHandler) GetPresignedUploadURL(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.PresignedUploadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	// Validate content type
	if err := h.storage.ValidateContentType(req.ContentType); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "file type not allowed", nil)
		return
	}

	// Validate file size
	if err := h.storage.ValidateFileSize(req.SizeBytes); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	// Build folder path: {org_id}/{lead_id}/{service_id}
	folder := fmt.Sprintf("%s/%s/%s", tenantID.String(), leadID.String(), serviceID.String())

	// Generate presigned URL
	presigned, err := h.storage.GenerateUploadURL(c.Request.Context(), h.bucket, folder, req.FileName, req.ContentType, req.SizeBytes)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate upload URL", nil)
		return
	}

	httpkit.OK(c, transport.PresignedUploadResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	})
}

// CreateAttachment records a file attachment after successful upload to MinIO.
func (h *AttachmentsHandler) CreateAttachment(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CreateAttachmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	uploaderID := identity.UserID()
	att, err := h.repo.CreateAttachment(c.Request.Context(), repository.CreateAttachmentParams{
		LeadServiceID:  serviceID,
		OrganizationID: tenantID,
		FileKey:        req.FileKey,
		FileName:       req.FileName,
		ContentType:    req.ContentType,
		SizeBytes:      req.SizeBytes,
		UploadedBy:     &uploaderID,
	})
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to create attachment record", nil)
		return
	}

	if h.eventBus != nil {
		if svc, svcErr := h.repo.GetLeadServiceByID(c.Request.Context(), serviceID, tenantID); svcErr == nil {
			h.eventBus.Publish(c.Request.Context(), events.AttachmentUploaded{
				BaseEvent:     events.NewBaseEvent(),
				LeadID:        svc.LeadID,
				LeadServiceID: serviceID,
				TenantID:      tenantID,
				AttachmentID:  att.ID,
				FileName:      req.FileName,
				ContentType:   req.ContentType,
			})
		}
	}

	httpkit.JSON(c, http.StatusCreated, toAttachmentResponse(att, nil))
}

// ListAttachments returns all attachments for a lead service.
func (h *AttachmentsHandler) ListAttachments(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	attachments, err := h.repo.ListAttachmentsByService(c.Request.Context(), serviceID, tenantID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to list attachments", nil)
		return
	}

	items := make([]transport.AttachmentResponse, len(attachments))
	for i, att := range attachments {
		items[i] = toAttachmentResponse(att, nil)
	}

	httpkit.OK(c, transport.AttachmentListResponse{Items: items})
}

// GetAttachment returns a single attachment by ID.
func (h *AttachmentsHandler) GetAttachment(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	attachmentID, err := uuid.Parse(c.Param("attachmentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	att, err := h.repo.GetAttachmentByID(c.Request.Context(), attachmentID, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, toAttachmentResponse(att, nil))
}

// GetDownloadURL generates a presigned URL for downloading a file.
func (h *AttachmentsHandler) GetDownloadURL(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	attachmentID, err := uuid.Parse(c.Param("attachmentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	att, err := h.repo.GetAttachmentByID(c.Request.Context(), attachmentID, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	presigned, err := h.storage.GenerateDownloadURL(c.Request.Context(), h.bucket, att.FileKey)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate download URL", nil)
		return
	}

	httpkit.OK(c, transport.PresignedDownloadResponse{
		DownloadURL: presigned.URL,
		ExpiresAt:   presigned.ExpiresAt.Unix(),
	})
}

// DeleteAttachment removes an attachment record and the file from MinIO.
func (h *AttachmentsHandler) DeleteAttachment(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	attachmentID, err := uuid.Parse(c.Param("attachmentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	// Get attachment to find file key for deletion
	att, err := h.repo.GetAttachmentByID(c.Request.Context(), attachmentID, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	// Delete from MinIO
	if err := h.storage.DeleteObject(c.Request.Context(), h.bucket, att.FileKey); err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to delete file from storage", nil)
		return
	}

	// Delete record from database
	if err := h.repo.DeleteAttachment(c.Request.Context(), attachmentID, tenantID); err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to delete attachment record", nil)
		return
	}

	httpkit.OK(c, gin.H{"message": "attachment deleted"})
}

// toAttachmentResponse converts a repository attachment to a transport response.
func toAttachmentResponse(att repository.Attachment, downloadURL *string) transport.AttachmentResponse {
	var contentType string
	if att.ContentType != nil {
		contentType = *att.ContentType
	}
	var sizeBytes int64
	if att.SizeBytes != nil {
		sizeBytes = *att.SizeBytes
	}

	return transport.AttachmentResponse{
		ID:          att.ID,
		FileKey:     att.FileKey,
		FileName:    att.FileName,
		ContentType: contentType,
		SizeBytes:   sizeBytes,
		UploadedBy:  att.UploadedBy,
		CreatedAt:   att.CreatedAt,
		DownloadURL: downloadURL,
	}
}
</file>

<file path="internal/leads/ports/catalog.go">
// Package ports defines the interfaces that the RAC_leads domain requires from
// external systems. These interfaces form the Anti-Corruption Layer (ACL),
// ensuring the RAC_leads domain only knows about the data it needs, formatted
// the way it wants.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// CatalogDocument represents a product document attachment the leads domain
// needs when auto-attaching files to AI-drafted quotes.
type CatalogDocument struct {
	ID       uuid.UUID
	Filename string
	FileKey  string
}

// CatalogURL represents a product URL (e.g. terms & conditions link) the leads
// domain needs when auto-attaching URLs to AI-drafted quotes.
type CatalogURL struct {
	Label string
	Href  string
}

// CatalogProductDetails holds the product information the leads/agent needs for
// quote drafting. Materials are pre-resolved to simple description strings so
// the agent never touches the catalog domain directly.
type CatalogProductDetails struct {
	ID             uuid.UUID
	Title          string
	Description    string
	UnitPriceCents int64
	UnitLabel      string
	LaborTimeText  string
	VatRateBps     int
	Materials      []string          // human-readable material names
	Documents      []CatalogDocument // product document assets (PDFs, specs)
	URLs           []CatalogURL      // product URL assets (terms, links)
}

// CatalogReader is the ACL interface through which the leads domain can look up
// catalog product details (including materials). The adapter composes existing
// catalog repository methods under the hood.
type CatalogReader interface {
	// GetProductDetails returns enriched product details for the given IDs.
	// Unknown IDs are silently omitted from the result slice.
	GetProductDetails(ctx context.Context, orgID uuid.UUID, productIDs []uuid.UUID) ([]CatalogProductDetails, error)
}
</file>

<file path="internal/leads/ports/partners.go">
package ports

import (
	"context"

	"github.com/google/uuid"
)

type CreateOfferParams struct {
	PartnerID          uuid.UUID
	LeadServiceID      uuid.UUID
	PricingSource      string // "quote" or "estimate"
	CustomerPriceCents int64
	ExpiresInHours     int
	JobSummaryShort    string
}

type CreateOfferResult struct {
	OfferID     uuid.UUID
	PublicToken string
	ExpiresAt   string
}

// PartnerOfferCreator defines the capability to create job offers for partners.
type PartnerOfferCreator interface {
	CreateOffer(ctx context.Context, tenantID uuid.UUID, req CreateOfferParams) (*CreateOfferResult, error)
}
</file>

<file path="internal/leads/repository/lead_services.go">
package repository

import (
	"context"
	"encoding/json"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var ErrServiceNotFound = errors.New("lead service not found")
var ErrServiceTypeNotFound = errors.New("service type not found")

type LeadService struct {
	ID                  uuid.UUID
	LeadID              uuid.UUID
	OrganizationID      uuid.UUID
	ServiceType         string
	Status              string
	PipelineStage       string
	ConsumerNote        *string
	Source              *string
	CustomerPreferences json.RawMessage
	CreatedAt           time.Time
	UpdatedAt           time.Time
}

type CreateLeadServiceParams struct {
	LeadID         uuid.UUID
	OrganizationID uuid.UUID
	ServiceType    string
	ConsumerNote   *string
	Source         *string
}

func (r *Repository) CreateLeadService(ctx context.Context, params CreateLeadServiceParams) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		WITH inserted AS (
			INSERT INTO RAC_lead_services (lead_id, organization_id, service_type_id, status, consumer_note, source)
			VALUES (
				$1,
				$2,
				(SELECT id FROM RAC_service_types WHERE (name = $3 OR slug = $3) AND organization_id = $2 LIMIT 1),
				'New',
				$4,
				$5
			)
			RETURNING *
		), event AS (
			INSERT INTO RAC_lead_service_events (organization_id, lead_id, lead_service_id, event_type, status, pipeline_stage, occurred_at)
			SELECT organization_id, lead_id, id, 'service_created', status, pipeline_stage, created_at
			FROM inserted
		)
		SELECT i.id, i.lead_id, i.organization_id, st.name AS service_type, i.status, i.pipeline_stage, i.consumer_note, i.source,
			i.customer_preferences, i.created_at, i.updated_at
		FROM inserted i
		JOIN RAC_service_types st ON st.id = i.service_type_id AND st.organization_id = i.organization_id
	`, params.LeadID, params.OrganizationID, params.ServiceType, params.ConsumerNote, params.Source).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	return svc, err
}

func (r *Repository) GetLeadServiceByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		SELECT ls.id, ls.lead_id, ls.organization_id, st.name AS service_type, ls.status, ls.pipeline_stage, ls.consumer_note, ls.source,
			ls.customer_preferences, ls.created_at, ls.updated_at
		FROM RAC_lead_services ls
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		WHERE ls.id = $1 AND ls.organization_id = $2
	`, id, organizationID).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) ListLeadServices(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]LeadService, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT ls.id, ls.lead_id, ls.organization_id, st.name AS service_type, ls.status, ls.pipeline_stage, ls.consumer_note, ls.source,
			ls.customer_preferences, ls.created_at, ls.updated_at
		FROM RAC_lead_services ls
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		WHERE ls.lead_id = $1 AND ls.organization_id = $2
		ORDER BY ls.created_at DESC
	`, leadID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	services := make([]LeadService, 0)
	for rows.Next() {
		var svc LeadService
		if err := rows.Scan(
			&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
			&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
		); err != nil {
			return nil, err
		}
		services = append(services, svc)
	}
	return services, rows.Err()
}

// GetCurrentLeadService returns the most recent non-terminal (not Closed, not Bad_Lead, not Surveyed) service,
// or falls back to the most recent service if all are terminal.
func (r *Repository) GetCurrentLeadService(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (LeadService, error) {
	var svc LeadService
	// Try to find an active (non-terminal) service first
	err := r.pool.QueryRow(ctx, `
		SELECT ls.id, ls.lead_id, ls.organization_id, st.name AS service_type, ls.status, ls.pipeline_stage, ls.consumer_note, ls.source,
			ls.customer_preferences, ls.created_at, ls.updated_at
		FROM RAC_lead_services ls
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		WHERE ls.lead_id = $1 AND ls.organization_id = $2 AND ls.status NOT IN ('Closed', 'Bad_Lead', 'Surveyed')
		ORDER BY ls.created_at DESC
		LIMIT 1
	`, leadID, organizationID).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		// Fallback to most recent service of any status
		err = r.pool.QueryRow(ctx, `
			SELECT ls.id, ls.lead_id, ls.organization_id, st.name AS service_type, ls.status, ls.pipeline_stage, ls.consumer_note, ls.source,
				ls.customer_preferences, ls.created_at, ls.updated_at
			FROM RAC_lead_services ls
			JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
			WHERE ls.lead_id = $1 AND ls.organization_id = $2
			ORDER BY ls.created_at DESC
			LIMIT 1
		`, leadID, organizationID).Scan(
			&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
			&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
		)
	}
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

type UpdateLeadServiceParams struct {
	Status *string
}

func (r *Repository) UpdateLeadService(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadServiceParams) (LeadService, error) {
	if params.Status == nil {
		return r.GetLeadServiceByID(ctx, id, organizationID)
	}

	query := `
		WITH updated AS (
			UPDATE RAC_lead_services SET status = $3, updated_at = now()
			WHERE id = $1 AND organization_id = $2
			RETURNING *
		), event AS (
			INSERT INTO RAC_lead_service_events (organization_id, lead_id, lead_service_id, event_type, status, pipeline_stage, occurred_at)
			SELECT organization_id, lead_id, id, 'status_changed', status, pipeline_stage, updated_at
			FROM updated
		)
		SELECT u.id, u.lead_id, u.organization_id, st.name AS service_type, u.status, u.pipeline_stage, u.consumer_note, u.source,
			u.customer_preferences, u.created_at, u.updated_at
		FROM updated u
		JOIN RAC_service_types st ON st.id = u.service_type_id AND st.organization_id = u.organization_id
	`

	var svc LeadService
	err := r.pool.QueryRow(ctx, query, id, organizationID, *params.Status).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

// UpdateLeadServiceType updates the service type for a lead service using an active service type name/slug.
func (r *Repository) UpdateLeadServiceType(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, serviceType string) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		WITH target AS (
			SELECT id FROM RAC_service_types
			WHERE (name = $3 OR slug = $3)
				AND organization_id = $2
				AND is_active = true
			LIMIT 1
		), updated AS (
			UPDATE RAC_lead_services
			SET service_type_id = (SELECT id FROM target), updated_at = now()
			WHERE id = $1 AND organization_id = $2 AND EXISTS (SELECT 1 FROM target)
			RETURNING *
		)
		SELECT u.id, u.lead_id, u.organization_id, st.name AS service_type, u.status, u.pipeline_stage, u.consumer_note, u.source,
			u.customer_preferences, u.created_at, u.updated_at
		FROM updated u
		JOIN RAC_service_types st ON st.id = u.service_type_id AND st.organization_id = u.organization_id
	`, id, organizationID, serviceType).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceTypeNotFound
	}
	return svc, err
}

func (r *Repository) UpdateServiceStatus(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, status string) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		WITH updated AS (
			UPDATE RAC_lead_services SET status = $3, updated_at = now()
			WHERE id = $1 AND organization_id = $2
			RETURNING *
		), event AS (
			INSERT INTO RAC_lead_service_events (organization_id, lead_id, lead_service_id, event_type, status, pipeline_stage, occurred_at)
			SELECT organization_id, lead_id, id, 'status_changed', status, pipeline_stage, updated_at
			FROM updated
		)
		SELECT u.id, u.lead_id, u.organization_id, st.name AS service_type, u.status, u.pipeline_stage, u.consumer_note, u.source,
			u.customer_preferences, u.created_at, u.updated_at
		FROM updated u
		JOIN RAC_service_types st ON st.id = u.service_type_id AND st.organization_id = u.organization_id
	`, id, organizationID, status).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

func (r *Repository) UpdatePipelineStage(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, stage string) (LeadService, error) {
	var svc LeadService
	err := r.pool.QueryRow(ctx, `
		WITH updated AS (
			UPDATE RAC_lead_services SET pipeline_stage = $3, updated_at = now()
			WHERE id = $1 AND organization_id = $2
			RETURNING *
		), event AS (
			INSERT INTO RAC_lead_service_events (organization_id, lead_id, lead_service_id, event_type, status, pipeline_stage, occurred_at)
			SELECT organization_id, lead_id, id, 'pipeline_stage_changed', status, pipeline_stage, updated_at
			FROM updated
		)
		SELECT u.id, u.lead_id, u.organization_id, st.name AS service_type, u.status, u.pipeline_stage, u.consumer_note, u.source,
			u.customer_preferences, u.created_at, u.updated_at
		FROM updated u
		JOIN RAC_service_types st ON st.id = u.service_type_id AND st.organization_id = u.organization_id
	`, id, organizationID, stage).Scan(
		&svc.ID, &svc.LeadID, &svc.OrganizationID, &svc.ServiceType, &svc.Status, &svc.PipelineStage, &svc.ConsumerNote, &svc.Source,
		&svc.CustomerPreferences, &svc.CreatedAt, &svc.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return LeadService{}, ErrServiceNotFound
	}
	return svc, err
}

// CloseAllActiveServices marks all non-terminal services for a lead as Closed
func (r *Repository) CloseAllActiveServices(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		WITH updated AS (
			UPDATE RAC_lead_services 
			SET status = 'Closed', updated_at = now()
			WHERE lead_id = $1 AND organization_id = $2 AND status NOT IN ('Closed', 'Bad_Lead', 'Surveyed')
			RETURNING id, lead_id, organization_id, status, pipeline_stage, updated_at
		)
		INSERT INTO RAC_lead_service_events (organization_id, lead_id, lead_service_id, event_type, status, pipeline_stage, occurred_at)
		SELECT organization_id, lead_id, id, 'status_changed', status, pipeline_stage, updated_at
		FROM updated
	`, leadID, organizationID)
	return err
}

func (r *Repository) UpdateServicePreferences(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID, prefs []byte) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_lead_services
		SET customer_preferences = $3, updated_at = now()
		WHERE id = $1 AND organization_id = $2
	`, serviceID, organizationID, prefs)
	return err
}
</file>

<file path="internal/partners/handler/handler.go">
package handler

import (
	"net/http"

	"portal_final_backend/internal/partners/service"
	"portal_final_backend/internal/partners/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

// Handler handles HTTP requests for partners.
type Handler struct {
	svc *service.Service
	val *validator.Validator
}

// New creates a new partners handler.
func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

// RegisterRoutes registers partner routes.
func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("", h.List)
	rg.POST("", h.Create)
	rg.GET("/:id", h.GetByID)
	rg.PUT("/:id", h.Update)
	rg.DELETE("/:id", h.Delete)

	rg.POST("/:id/logo/presign", h.PresignLogo)
	rg.POST("/:id/logo", h.SetLogo)
	rg.GET("/:id/logo/download", h.GetLogoDownload)
	rg.DELETE("/:id/logo", h.DeleteLogo)

	rg.GET("/:id/leads", h.ListLeads)
	rg.POST("/:id/leads", h.LinkLead)
	rg.DELETE("/:id/leads/:leadId", h.UnlinkLead)

	rg.GET("/:id/invites", h.ListInvites)
	rg.POST("/:id/invites", h.CreateInvite)
	rg.DELETE("/:id/invites/:inviteId", h.RevokeInvite)

	rg.GET("/:id/offers", h.ListPartnerOffers)

	// Offer routes (authenticated / admin)
	rg.POST("/offers", h.CreateOffer)
	rg.GET("/services/:serviceId/offers", h.ListServiceOffers)
	rg.GET("/offers/:offerId/preview", h.PreviewOffer)
}

func (h *Handler) List(c *gin.Context) {
	var req transport.ListPartnersRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.List(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) Create(c *gin.Context) {
	var req transport.CreatePartnerRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.Create(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

func (h *Handler) GetByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetByID(c.Request.Context(), tenantID, id)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdatePartnerRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.Update(c.Request.Context(), tenantID, id, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) Delete(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.Delete(c.Request.Context(), tenantID, id); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "partner deleted"})
}

func (h *Handler) PresignLogo(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.PartnerLogoPresignRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.PresignLogoUpload(c.Request.Context(), tenantID, partnerID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) SetLogo(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.SetPartnerLogoRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.SetLogo(c.Request.Context(), tenantID, partnerID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) GetLogoDownload(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetLogoDownloadURL(c.Request.Context(), tenantID, partnerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) DeleteLogo(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.DeleteLogo(c.Request.Context(), tenantID, partnerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) ListLeads(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListLeads(c.Request.Context(), tenantID, partnerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) LinkLead(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.LinkLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.LinkLead(c.Request.Context(), tenantID, partnerID, req.LeadID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, gin.H{"message": "lead linked"})
}

func (h *Handler) UnlinkLead(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	leadID, err := uuid.Parse(c.Param("leadId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.svc.UnlinkLead(c.Request.Context(), tenantID, partnerID, leadID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "lead unlinked"})
}

func (h *Handler) CreateInvite(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CreatePartnerInviteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.CreateInvite(c.Request.Context(), tenantID, partnerID, identity.UserID(), req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

func (h *Handler) ListInvites(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListInvites(c.Request.Context(), tenantID, partnerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) RevokeInvite(c *gin.Context) {
	inviteID, err := uuid.Parse(c.Param("inviteId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.RevokeInvite(c.Request.Context(), tenantID, inviteID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) CreateOffer(c *gin.Context) {
	var req transport.CreateOfferRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.CreateOffer(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

func (h *Handler) PreviewOffer(c *gin.Context) {
	offerID, err := uuid.Parse(c.Param("offerId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.GetOfferPreview(c.Request.Context(), tenantID, offerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) ListPartnerOffers(c *gin.Context) {
	partnerID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListOffersByPartner(c.Request.Context(), tenantID, partnerID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) ListServiceOffers(c *gin.Context) {
	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.svc.ListOffersForService(c.Request.Context(), tenantID, serviceID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func mustGetTenantID(c *gin.Context, identity httpkit.Identity) (uuid.UUID, bool) {
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, "tenant ID is required", nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}
</file>

<file path="internal/partners/service/service.go">
package service

import (
	"context"
	"regexp"
	"strings"
	"time"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/partners/repository"
	"portal_final_backend/internal/partners/transport"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/phone"
	"portal_final_backend/platform/sanitize"

	"github.com/google/uuid"
)

const (
	inviteTokenBytes = 32
	inviteTTL        = 72 * time.Hour
)

// Service provides business logic for partners.
type Service struct {
	repo             *repository.Repository
	eventBus         events.Bus
	storage          storage.StorageService
	logoBucket       string
	summaryGenerator OfferSummaryGenerator
}

// New creates a new partners service.
func New(repo *repository.Repository, eventBus events.Bus, storageSvc storage.StorageService, logoBucket string) *Service {
	return &Service{repo: repo, eventBus: eventBus, storage: storageSvc, logoBucket: logoBucket}
}

func (s *Service) Create(ctx context.Context, tenantID uuid.UUID, req transport.CreatePartnerRequest) (transport.PartnerResponse, error) {
	if err := s.ensureServiceTypeIDsValid(ctx, tenantID, req.ServiceTypeIDs); err != nil {
		return transport.PartnerResponse{}, err
	}

	partner := repository.Partner{
		ID:             uuid.New(),
		OrganizationID: tenantID,
		BusinessName:   sanitize.Text(req.BusinessName),
		KVKNumber:      strings.TrimSpace(req.KVKNumber),
		VATNumber:      strings.TrimSpace(req.VATNumber),
		AddressLine1:   sanitize.Text(req.AddressLine1),
		AddressLine2:   normalizeOptional(req.AddressLine2),
		HouseNumber:    normalizeOptional(req.HouseNumber),
		PostalCode:     strings.TrimSpace(req.PostalCode),
		City:           sanitize.Text(req.City),
		Country:        sanitize.Text(req.Country),
		Latitude:       req.Latitude,
		Longitude:      req.Longitude,
		ContactName:    sanitize.Text(req.ContactName),
		ContactEmail:   normalizeEmail(req.ContactEmail),
		ContactPhone:   phone.NormalizeE164(req.ContactPhone),
		CreatedAt:      time.Now(),
		UpdatedAt:      time.Now(),
	}

	if err := validatePartnerNumbers(partner.KVKNumber, partner.VATNumber); err != nil {
		return transport.PartnerResponse{}, err
	}

	created, err := s.repo.Create(ctx, partner)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	if len(req.ServiceTypeIDs) > 0 {
		if err := s.repo.ReplaceServiceTypes(ctx, created.ID, req.ServiceTypeIDs); err != nil {
			return transport.PartnerResponse{}, err
		}
	}

	return mapPartnerResponse(created, req.ServiceTypeIDs), nil
}

func (s *Service) SetOfferSummaryGenerator(generator OfferSummaryGenerator) {
	s.summaryGenerator = generator
}

func (s *Service) GetByID(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.PartnerResponse, error) {
	partner, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}
	serviceTypeIDs, err := s.repo.ListServiceTypeIDs(ctx, tenantID, id)
	if err != nil {
		return transport.PartnerResponse{}, err
	}
	return mapPartnerResponse(partner, serviceTypeIDs), nil
}

func (s *Service) Update(ctx context.Context, tenantID uuid.UUID, id uuid.UUID, req transport.UpdatePartnerRequest) (transport.PartnerResponse, error) {
	if req.ServiceTypeIDs != nil {
		if err := s.ensureServiceTypeIDsValid(ctx, tenantID, *req.ServiceTypeIDs); err != nil {
			return transport.PartnerResponse{}, err
		}
	}

	update := repository.PartnerUpdate{
		ID:             id,
		OrganizationID: tenantID,
		BusinessName:   normalizeOptionalString(req.BusinessName, sanitize.Text),
		KVKNumber:      normalizeOptionalString(req.KVKNumber, strings.TrimSpace),
		VATNumber:      normalizeOptionalString(req.VATNumber, strings.TrimSpace),
		AddressLine1:   normalizeOptionalString(req.AddressLine1, sanitize.Text),
		AddressLine2:   normalizeOptionalString(req.AddressLine2, sanitize.Text),
		HouseNumber:    normalizeOptionalString(req.HouseNumber, strings.TrimSpace),
		PostalCode:     normalizeOptionalString(req.PostalCode, strings.TrimSpace),
		City:           normalizeOptionalString(req.City, sanitize.Text),
		Country:        normalizeOptionalString(req.Country, sanitize.Text),
		Latitude:       req.Latitude,
		Longitude:      req.Longitude,
		ContactName:    normalizeOptionalString(req.ContactName, sanitize.Text),
		ContactEmail:   normalizeOptionalString(req.ContactEmail, normalizeEmail),
		ContactPhone:   normalizeOptionalString(req.ContactPhone, phone.NormalizeE164),
	}

	if err := validatePartnerNumbersUpdate(update); err != nil {
		return transport.PartnerResponse{}, err
	}

	updated, err := s.repo.Update(ctx, update)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	serviceTypeIDs, err := s.resolveServiceTypeIDs(ctx, tenantID, id, req.ServiceTypeIDs)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	return mapPartnerResponse(updated, serviceTypeIDs), nil
}

func (s *Service) Delete(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) error {
	return s.repo.Delete(ctx, id, tenantID)
}

func (s *Service) List(ctx context.Context, tenantID uuid.UUID, req transport.ListPartnersRequest) (transport.ListPartnersResponse, error) {
	result, err := s.repo.List(ctx, repository.ListParams{
		OrganizationID: tenantID,
		Search:         req.Search,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
		Page:           req.Page,
		PageSize:       req.PageSize,
	})
	if err != nil {
		return transport.ListPartnersResponse{}, err
	}

	items := make([]transport.PartnerResponse, 0, len(result.Items))
	for _, partner := range result.Items {
		items = append(items, mapPartnerResponse(partner, nil))
	}

	return transport.ListPartnersResponse{
		Items:      items,
		Total:      result.Total,
		Page:       result.Page,
		PageSize:   result.PageSize,
		TotalPages: result.TotalPages,
	}, nil
}

func (s *Service) PresignLogoUpload(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, req transport.PartnerLogoPresignRequest) (transport.PartnerLogoPresignResponse, error) {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return transport.PartnerLogoPresignResponse{}, err
	}
	if !storage.IsImageContentType(req.ContentType) {
		return transport.PartnerLogoPresignResponse{}, apperr.Validation("logo must be an image")
	}

	presigned, err := s.storage.GenerateUploadURL(
		ctx,
		s.logoBucket,
		logoFolder(tenantID, partnerID),
		req.FileName,
		req.ContentType,
		req.SizeBytes,
	)
	if err != nil {
		return transport.PartnerLogoPresignResponse{}, err
	}

	return transport.PartnerLogoPresignResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	}, nil
}

func (s *Service) SetLogo(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, req transport.SetPartnerLogoRequest) (transport.PartnerResponse, error) {
	partner, err := s.repo.GetByID(ctx, partnerID, tenantID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}
	if !storage.IsImageContentType(req.ContentType) {
		return transport.PartnerResponse{}, apperr.Validation("logo must be an image")
	}
	if err := s.storage.ValidateContentType(req.ContentType); err != nil {
		return transport.PartnerResponse{}, err
	}
	if err := s.storage.ValidateFileSize(req.SizeBytes); err != nil {
		return transport.PartnerResponse{}, err
	}
	if !strings.HasPrefix(req.FileKey, logoFolder(tenantID, partnerID)+"/") {
		return transport.PartnerResponse{}, apperr.Validation("invalid logo file key")
	}

	if partner.LogoFileKey != nil && *partner.LogoFileKey != req.FileKey {
		_ = s.storage.DeleteObject(ctx, s.logoBucket, *partner.LogoFileKey)
	}

	updated, err := s.repo.UpdateLogo(ctx, tenantID, partnerID, repository.PartnerLogo{
		FileKey:     req.FileKey,
		FileName:    req.FileName,
		ContentType: req.ContentType,
		SizeBytes:   req.SizeBytes,
	})
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	serviceTypeIDs, err := s.repo.ListServiceTypeIDs(ctx, tenantID, partnerID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	return mapPartnerResponse(updated, serviceTypeIDs), nil
}

func (s *Service) GetLogoDownloadURL(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) (transport.PartnerLogoDownloadResponse, error) {
	partner, err := s.repo.GetByID(ctx, partnerID, tenantID)
	if err != nil {
		return transport.PartnerLogoDownloadResponse{}, err
	}
	if partner.LogoFileKey == nil || *partner.LogoFileKey == "" {
		return transport.PartnerLogoDownloadResponse{}, apperr.NotFound("logo not found")
	}

	presigned, err := s.storage.GenerateDownloadURL(ctx, s.logoBucket, *partner.LogoFileKey)
	if err != nil {
		return transport.PartnerLogoDownloadResponse{}, err
	}

	return transport.PartnerLogoDownloadResponse{
		DownloadURL: presigned.URL,
		ExpiresAt:   presigned.ExpiresAt.Unix(),
	}, nil
}

func (s *Service) DeleteLogo(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) (transport.PartnerResponse, error) {
	partner, err := s.repo.GetByID(ctx, partnerID, tenantID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}
	if partner.LogoFileKey != nil && *partner.LogoFileKey != "" {
		_ = s.storage.DeleteObject(ctx, s.logoBucket, *partner.LogoFileKey)
	}

	updated, err := s.repo.ClearLogo(ctx, tenantID, partnerID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	serviceTypeIDs, err := s.repo.ListServiceTypeIDs(ctx, tenantID, partnerID)
	if err != nil {
		return transport.PartnerResponse{}, err
	}

	return mapPartnerResponse(updated, serviceTypeIDs), nil
}

func (s *Service) LinkLead(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, leadID uuid.UUID) error {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return err
	}
	if err := s.ensureLeadExists(ctx, tenantID, leadID); err != nil {
		return err
	}
	return s.repo.LinkLead(ctx, tenantID, partnerID, leadID)
}

func (s *Service) UnlinkLead(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, leadID uuid.UUID) error {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return err
	}
	return s.repo.UnlinkLead(ctx, tenantID, partnerID, leadID)
}

func (s *Service) ListLeads(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) ([]transport.PartnerLeadResponse, error) {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return nil, err
	}

	items, err := s.repo.ListLeads(ctx, tenantID, partnerID)
	if err != nil {
		return nil, err
	}

	resp := make([]transport.PartnerLeadResponse, 0, len(items))
	for _, lead := range items {
		resp = append(resp, transport.PartnerLeadResponse{
			ID:        lead.ID,
			FirstName: lead.FirstName,
			LastName:  lead.LastName,
			Phone:     lead.Phone,
			Address:   formatAddress(lead.Street, lead.HouseNumber, lead.City),
		})
	}

	return resp, nil
}

func (s *Service) CreateInvite(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, createdBy uuid.UUID, req transport.CreatePartnerInviteRequest) (transport.CreatePartnerInviteResponse, error) {
	partner, err := s.repo.GetByID(ctx, partnerID, tenantID)
	if err != nil {
		return transport.CreatePartnerInviteResponse{}, err
	}

	if req.LeadID != nil {
		if err := s.ensureLeadExists(ctx, tenantID, *req.LeadID); err != nil {
			return transport.CreatePartnerInviteResponse{}, err
		}
	}
	if req.LeadServiceID != nil {
		if err := s.ensureLeadServiceExists(ctx, tenantID, *req.LeadServiceID); err != nil {
			return transport.CreatePartnerInviteResponse{}, err
		}
	}

	rawToken, err := token.GenerateRandomToken(inviteTokenBytes)
	if err != nil {
		return transport.CreatePartnerInviteResponse{}, err
	}

	expiresAt := time.Now().Add(inviteTTL)
	invite := repository.PartnerInvite{
		ID:             uuid.New(),
		OrganizationID: tenantID,
		PartnerID:      partnerID,
		Email:          normalizeEmail(req.Email),
		TokenHash:      token.HashSHA256(rawToken),
		ExpiresAt:      expiresAt,
		CreatedBy:      createdBy,
		CreatedAt:      time.Now(),
		LeadID:         req.LeadID,
		LeadServiceID:  req.LeadServiceID,
	}

	if _, err := s.repo.CreateInvite(ctx, invite); err != nil {
		return transport.CreatePartnerInviteResponse{}, err
	}

	if s.eventBus != nil {
		organizationName, _ := s.repo.GetOrganizationName(ctx, tenantID)
		s.eventBus.Publish(ctx, events.PartnerInviteCreated{
			BaseEvent:        events.NewBaseEvent(),
			OrganizationID:   tenantID,
			OrganizationName: organizationName,
			PartnerID:        partnerID,
			PartnerName:      partner.BusinessName,
			Email:            invite.Email,
			InviteToken:      rawToken,
			LeadID:           req.LeadID,
			LeadServiceID:    req.LeadServiceID,
		})
	}

	return transport.CreatePartnerInviteResponse{Token: rawToken, ExpiresAt: expiresAt}, nil
}

func (s *Service) ListInvites(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) (transport.ListPartnerInvitesResponse, error) {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return transport.ListPartnerInvitesResponse{}, err
	}

	items, err := s.repo.ListInvites(ctx, tenantID, partnerID)
	if err != nil {
		return transport.ListPartnerInvitesResponse{}, err
	}

	resp := make([]transport.PartnerInviteResponse, 0, len(items))
	for _, invite := range items {
		resp = append(resp, transport.PartnerInviteResponse{
			ID:            invite.ID,
			Email:         invite.Email,
			LeadID:        invite.LeadID,
			LeadServiceID: invite.LeadServiceID,
			ExpiresAt:     invite.ExpiresAt,
			CreatedAt:     invite.CreatedAt,
			UsedAt:        invite.UsedAt,
		})
	}

	return transport.ListPartnerInvitesResponse{Invites: resp}, nil
}

func (s *Service) RevokeInvite(ctx context.Context, tenantID uuid.UUID, inviteID uuid.UUID) (transport.PartnerInviteResponse, error) {
	invite, err := s.repo.RevokeInvite(ctx, tenantID, inviteID)
	if err != nil {
		return transport.PartnerInviteResponse{}, err
	}

	return transport.PartnerInviteResponse{
		ID:            invite.ID,
		Email:         invite.Email,
		LeadID:        invite.LeadID,
		LeadServiceID: invite.LeadServiceID,
		ExpiresAt:     invite.ExpiresAt,
		CreatedAt:     invite.CreatedAt,
		UsedAt:        invite.UsedAt,
	}, nil
}

func (s *Service) ensurePartnerExists(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) error {
	exists, err := s.repo.Exists(ctx, partnerID, tenantID)
	if err != nil {
		return err
	}
	if !exists {
		return apperr.NotFound("partner not found")
	}
	return nil
}

func (s *Service) ensureServiceTypeIDsValid(ctx context.Context, tenantID uuid.UUID, ids []uuid.UUID) error {
	if len(ids) == 0 {
		return nil
	}
	return s.repo.ValidateServiceTypeIDs(ctx, tenantID, ids)
}

func (s *Service) ensureLeadExists(ctx context.Context, tenantID uuid.UUID, leadID uuid.UUID) error {
	exists, err := s.repo.LeadExists(ctx, leadID, tenantID)
	if err != nil {
		return err
	}
	if !exists {
		return apperr.NotFound("lead not found")
	}
	return nil
}

func (s *Service) ensureLeadServiceExists(ctx context.Context, tenantID uuid.UUID, leadServiceID uuid.UUID) error {
	exists, err := s.repo.LeadServiceExists(ctx, leadServiceID, tenantID)
	if err != nil {
		return err
	}
	if !exists {
		return apperr.NotFound("lead service not found")
	}
	return nil
}

func (s *Service) resolveServiceTypeIDs(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID, ids *[]uuid.UUID) ([]uuid.UUID, error) {
	if ids != nil {
		if err := s.repo.ReplaceServiceTypes(ctx, partnerID, *ids); err != nil {
			return nil, err
		}
		return *ids, nil
	}
	return s.repo.ListServiceTypeIDs(ctx, tenantID, partnerID)
}

func mapPartnerResponse(partner repository.Partner, serviceTypeIDs []uuid.UUID) transport.PartnerResponse {
	return transport.PartnerResponse{
		ID:              partner.ID,
		BusinessName:    partner.BusinessName,
		KVKNumber:       partner.KVKNumber,
		VATNumber:       partner.VATNumber,
		AddressLine1:    partner.AddressLine1,
		AddressLine2:    partner.AddressLine2,
		HouseNumber:     partner.HouseNumber,
		PostalCode:      partner.PostalCode,
		City:            partner.City,
		Country:         partner.Country,
		Latitude:        partner.Latitude,
		Longitude:       partner.Longitude,
		ContactName:     partner.ContactName,
		ContactEmail:    partner.ContactEmail,
		ContactPhone:    partner.ContactPhone,
		LogoFileKey:     partner.LogoFileKey,
		LogoFileName:    partner.LogoFileName,
		LogoContentType: partner.LogoContentType,
		LogoSizeBytes:   partner.LogoSizeBytes,
		ServiceTypeIDs:  serviceTypeIDs,
		CreatedAt:       partner.CreatedAt,
		UpdatedAt:       partner.UpdatedAt,
	}
}

func logoFolder(tenantID uuid.UUID, partnerID uuid.UUID) string {
	return "partners/" + tenantID.String() + "/" + partnerID.String()
}

func formatAddress(street string, houseNumber string, city string) string {
	parts := strings.TrimSpace(strings.Join([]string{street, houseNumber}, " "))
	if city == "" {
		return parts
	}
	if parts == "" {
		return city
	}
	return parts + ", " + city
}

func normalizeEmail(value string) string {
	return strings.ToLower(strings.TrimSpace(value))
}

func normalizeOptional(value string) *string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return nil
	}
	clean := sanitize.Text(trimmed)
	if clean == "" {
		return nil
	}
	return &clean
}

func normalizeOptionalString(value *string, normalize func(string) string) *string {
	if value == nil {
		return nil
	}
	trimmed := strings.TrimSpace(*value)
	if trimmed == "" {
		return nil
	}
	normalized := normalize(trimmed)
	if normalized == "" {
		return nil
	}
	return &normalized
}

func validatePartnerNumbersUpdate(update repository.PartnerUpdate) error {
	if update.KVKNumber == nil && update.VATNumber == nil {
		return nil
	}
	kvk := ""
	vat := ""
	if update.KVKNumber != nil {
		kvk = *update.KVKNumber
	}
	if update.VATNumber != nil {
		vat = *update.VATNumber
	}
	return validatePartnerNumbers(kvk, vat)
}

var nlVATPattern = regexp.MustCompile(`^NL[0-9]{9}B[0-9]{2}$`)
var kvkPattern = regexp.MustCompile(`^[0-9]{8}$`)

func validatePartnerNumbers(kvk string, vat string) error {
	if kvk != "" && !kvkPattern.MatchString(strings.TrimSpace(kvk)) {
		return apperr.Validation("invalid KVK number")
	}
	if vat != "" && !nlVATPattern.MatchString(strings.ToUpper(strings.TrimSpace(vat))) {
		return apperr.Validation("invalid VAT number")
	}
	return nil
}
</file>

<file path="internal/pdf/generator.go">
// Package pdf generates quote PDFs using Gotenberg (HTMLPDF via Chromium).
// The cover page uses an industrial "construction proposal" design with the
// Barlow font; the detail page contains all quote data, line-items, totals,
// legal terms, and the signature block.
package pdf

import (
	"bytes"
	"context"
	"embed"
	"encoding/base64"
	"fmt"
	"html/template"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"portal_final_backend/internal/quotes/transport"
)

const (
	dateFormatDMY     = "02-01-2006"
	dateTimeFormatDMY = "02-01-2006 15:04"
)

//go:embed templates/*.html
var templateFS embed.FS

//  Package-level Gotenberg client 

var gotenbergClient *GotenbergClient

// Init initialises the Gotenberg client. Must be called before GenerateQuotePDF.
func Init(gotenbergURL, username, password string) {
	if gotenbergURL != "" {
		gotenbergClient = NewGotenbergClient(gotenbergURL, username, password)
	}
}

//  Data structs 

// QuotePDFData holds all data needed to generate a quote PDF.
type QuotePDFData struct {
	// Quote
	QuoteNumber string
	Status      string
	PricingMode string
	ValidUntil  *time.Time
	CreatedAt   time.Time
	Notes       *string

	// Organization
	OrganizationName string
	OrgEmail         string
	OrgPhone         string
	OrgVatNumber     string
	OrgKvkNumber     string
	OrgAddressLine1  string
	OrgAddressLine2  string
	OrgPostalCode    string
	OrgCity          string
	OrgCountry       string
	OrgLogo          []byte // raw image bytes (PNG or JPEG)

	// Customer
	CustomerName string

	// Signature (populated when accepted)
	SignatureName  *string
	SignatureImage []byte // raw PNG bytes of the drawn signature
	AcceptedAt     *time.Time

	// Line items & totals
	Items          []transport.PublicQuoteItemResponse
	SubtotalCents  int64
	DiscountAmount int64
	TaxTotalCents  int64
	TotalCents     int64
	VatBreakdown   []transport.VatBreakdown

	// Organization settings for PDF terms
	PaymentDays    int
	QuoteValidDays int

	// Document attachments: pre-downloaded PDF bytes to merge after the content page.
	AttachmentPDFs []AttachmentPDFEntry

	// URLs for the signature/acceptance page (terms & conditions links).
	URLs []QuoteURLEntry
}

// AttachmentPDFEntry holds a pre-downloaded PDF to be appended to the quote document.
type AttachmentPDFEntry struct {
	Filename string
	PDFBytes []byte
}

// QuoteURLEntry holds a terms & conditions URL for display on the signature page.
type QuoteURLEntry struct {
	Label string
	Href  string
}

//  Template view models 

type coverViewModel struct {
	LogoBase64          string
	LogoMimeType        string
	OrganizationName    string
	CustomerName        string
	QuoteNumber         string
	QuoteSequenceNumber string
	CreatedAtFormatted  string
	ValidUntilFormatted string
	OrgAddressLine1     string
	OrgPostalCode       string
	OrgCity             string
	OrgPhone            string
	OrgEmail            string
}

type quoteViewModel struct {
	LogoBase64          string
	LogoMimeType        string
	OrganizationName    string
	CustomerName        string
	QuoteNumber         string
	CreatedAtFormatted  string
	ValidUntilFormatted string
	Status              string
	StatusLabel         string
	StatusClass         string
	OrgAddressLine1     string
	OrgAddressLine2     string
	OrgPostalCode       string
	OrgCity             string
	OrgEmail            string
	OrgPhone            string
	OrgKvkNumber        string
	OrgVatNumber        string
	AcceptedAtFormatted string
	Items               []itemViewModel
	SubtotalFormatted   string
	HasDiscount         bool
	DiscountFormatted   string
	VatBreakdown        []vatLineViewModel
	TotalFormatted      string
	Notes               string
	PaymentDays         int
	QuoteValidDays      int
}

type itemViewModel struct {
	Description        string
	Quantity           string
	UnitPriceFormatted string
	VatPctFormatted    string
	LineTotalFormatted string
	IsOptional         bool
	IsSelected         bool
}

type vatLineViewModel struct {
	PctFormatted    string
	AmountFormatted string
}

type footerViewModel struct {
	FooterText string
}

type signatureViewModel struct {
	LogoBase64          string
	LogoMimeType        string
	OrganizationName    string
	QuoteNumber         string
	HasSignature        bool
	SignatureName       string
	SignatureBase64     string
	AcceptedAtFormatted string
	HasURLs             bool
	URLs                []urlViewModel
}

type urlViewModel struct {
	Label string
	Href  string
}

//  Public API 

// GenerateQuotePDF creates a professional multi-page PDF document.
// Page 1 = cover page (industrial Barlow design).
// Page 2+ = quote details with line items, totals, legal terms.
// Attachments = any enabled PDF documents from the catalog or uploaded manually.
// Final page = signature/acceptance page with URL checkboxes and signature block.
func GenerateQuotePDF(data QuotePDFData) ([]byte, error) {
	if gotenbergClient == nil {
		return nil, fmt.Errorf("gotenberg client not initialized  call pdf.Init first")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 45*time.Second)
	defer cancel()

	//  Build view models 
	logoB64, logoMime := encodeLogoBase64(data.OrgLogo)

	cover := buildCoverVM(data, logoB64, logoMime)
	quote := buildQuoteVM(data, logoB64, logoMime)
	footer := buildFooterVM(data)

	//  Render HTML templates 
	coverHTML, err := renderTemplate("templates/cover.html", cover)
	if err != nil {
		return nil, fmt.Errorf("render cover template: %w", err)
	}

	quoteHTML, err := renderTemplate("templates/quote.html", quote)
	if err != nil {
		return nil, fmt.Errorf("render quote template: %w", err)
	}

	footerHTML, err := renderTemplate("templates/footer.html", footer)
	if err != nil {
		return nil, fmt.Errorf("render footer template: %w", err)
	}

	//  Convert cover HTML  PDF (full-bleed, no footer) 
	coverPDF, err := gotenbergClient.ConvertHTML(ctx, coverHTML, CoverPageOpts())
	if err != nil {
		return nil, fmt.Errorf("convert cover to PDF: %w", err)
	}

	//  Convert quote HTML  PDF (with margins + footer) 
	contentOpts := DefaultContentOpts()
	contentOpts.FooterHTML = footerHTML
	contentPDF, err := gotenbergClient.ConvertHTML(ctx, quoteHTML, contentOpts)
	if err != nil {
		return nil, fmt.Errorf("convert content to PDF: %w", err)
	}

	//  Build merge map: cover  content  attachments  signature 
	mergeMap := map[string][]byte{
		"01_cover.pdf":   coverPDF,
		"02_content.pdf": contentPDF,
	}

	// Add enabled attachment PDFs with zero-padded sort keys
	addAttachmentPDFs(mergeMap, data.AttachmentPDFs)

	// Generate signature/acceptance page if needed (signature OR URLs)
	if err := addSignaturePageIfNeeded(mergeMap, data, logoB64, logoMime, contentOpts); err != nil {
		return nil, err
	}

	//  Merge all PDFs into one document 
	merged, err := gotenbergClient.MergePDFs(ctx, mergeMap)
	if err != nil {
		return nil, fmt.Errorf("merge PDFs: %w", err)
	}

	return merged, nil
}

func addAttachmentPDFs(mergeMap map[string][]byte, attachments []AttachmentPDFEntry) {
	for i, att := range attachments {
		if len(att.PDFBytes) > 0 {
			key := fmt.Sprintf("03_attachment_%03d.pdf", i)
			mergeMap[key] = att.PDFBytes
		}
	}
}

func addSignaturePageIfNeeded(mergeMap map[string][]byte, data QuotePDFData, logoB64, logoMime string, opts ConvertOpts) error {
	needsPage := (data.SignatureName != nil && data.AcceptedAt != nil) || len(data.URLs) > 0
	if !needsPage {
		return nil
	}

	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	sigVM := buildSignatureVM(data, logoB64, logoMime)
	sigHTML, err := renderTemplate("templates/signature.html", sigVM)
	if err != nil {
		return fmt.Errorf("render signature template: %w", err)
	}
	sigPDF, err := gotenbergClient.ConvertHTML(ctx, sigHTML, opts)
	if err != nil {
		return fmt.Errorf("convert signature to PDF: %w", err)
	}
	mergeMap["04_signature.pdf"] = sigPDF
	return nil
}

//  View model builders 

func buildCoverVM(data QuotePDFData, logoB64, logoMime string) coverViewModel {
	vm := coverViewModel{
		LogoBase64:         logoB64,
		LogoMimeType:       logoMime,
		OrganizationName:   data.OrganizationName,
		CustomerName:       data.CustomerName,
		QuoteNumber:        data.QuoteNumber,
		CreatedAtFormatted: data.CreatedAt.Format(dateFormatDMY),
		OrgAddressLine1:    data.OrgAddressLine1,
		OrgPostalCode:      data.OrgPostalCode,
		OrgCity:            data.OrgCity,
		OrgPhone:           data.OrgPhone,
		OrgEmail:           data.OrgEmail,
	}
	if data.ValidUntil != nil {
		vm.ValidUntilFormatted = data.ValidUntil.Format(dateFormatDMY)
	}
	vm.QuoteSequenceNumber = extractSequenceNumber(data.QuoteNumber)
	return vm
}

func buildQuoteVM(data QuotePDFData, logoB64, logoMime string) quoteViewModel {
	vm := quoteViewModel{
		LogoBase64:         logoB64,
		LogoMimeType:       logoMime,
		OrganizationName:   data.OrganizationName,
		CustomerName:       data.CustomerName,
		QuoteNumber:        data.QuoteNumber,
		CreatedAtFormatted: data.CreatedAt.Format(dateFormatDMY),
		Status:             data.Status,
		StatusLabel:        translateStatus(data.Status),
		StatusClass:        statusCSSClass(data.Status),
		OrgAddressLine1:    data.OrgAddressLine1,
		OrgAddressLine2:    data.OrgAddressLine2,
		OrgPostalCode:      data.OrgPostalCode,
		OrgCity:            data.OrgCity,
		OrgEmail:           data.OrgEmail,
		OrgPhone:           data.OrgPhone,
		OrgKvkNumber:       data.OrgKvkNumber,
		OrgVatNumber:       data.OrgVatNumber,
		SubtotalFormatted:  formatCurrency(data.SubtotalCents),
		HasDiscount:        data.DiscountAmount > 0,
		DiscountFormatted:  formatCurrency(data.DiscountAmount),
		TotalFormatted:     formatCurrency(data.TotalCents),
	}
	if data.ValidUntil != nil {
		vm.ValidUntilFormatted = data.ValidUntil.Format(dateFormatDMY)
	}
	if data.AcceptedAt != nil {
		vm.AcceptedAtFormatted = data.AcceptedAt.Format(dateTimeFormatDMY)
	}
	if data.Notes != nil && *data.Notes != "" {
		vm.Notes = *data.Notes
	}

	// Items
	vm.Items = make([]itemViewModel, len(data.Items))
	for i, it := range data.Items {
		vm.Items[i] = itemViewModel{
			Description:        it.Description,
			Quantity:           it.Quantity,
			UnitPriceFormatted: formatCurrency(it.UnitPriceCents),
			VatPctFormatted:    fmt.Sprintf("%.0f%%", float64(it.TaxRateBps)/100.0),
			LineTotalFormatted: formatCurrency(it.LineTotalCents),
			IsOptional:         it.IsOptional,
			IsSelected:         it.IsSelected,
		}
	}

	// VAT breakdown
	vm.VatBreakdown = make([]vatLineViewModel, len(data.VatBreakdown))
	for i, vat := range data.VatBreakdown {
		vm.VatBreakdown[i] = vatLineViewModel{
			PctFormatted:    fmt.Sprintf("%.0f%%", float64(vat.RateBps)/100.0),
			AmountFormatted: formatCurrency(vat.AmountCents),
		}
	}

	// Organization settings  use defaults if not provided
	vm.PaymentDays = data.PaymentDays
	if vm.PaymentDays <= 0 {
		vm.PaymentDays = 7
	}
	vm.QuoteValidDays = data.QuoteValidDays
	if vm.QuoteValidDays <= 0 {
		vm.QuoteValidDays = 14
	}

	return vm
}

func buildSignatureVM(data QuotePDFData, logoB64, logoMime string) signatureViewModel {
	vm := signatureViewModel{
		LogoBase64:       logoB64,
		LogoMimeType:     logoMime,
		OrganizationName: data.OrganizationName,
		QuoteNumber:      data.QuoteNumber,
		HasURLs:          len(data.URLs) > 0,
	}

	if data.AcceptedAt != nil {
		vm.AcceptedAtFormatted = data.AcceptedAt.Format(dateTimeFormatDMY)
	}

	if data.SignatureName != nil && data.AcceptedAt != nil {
		vm.HasSignature = true
		vm.SignatureName = *data.SignatureName
		if len(data.SignatureImage) > 0 {
			vm.SignatureBase64 = base64.StdEncoding.EncodeToString(data.SignatureImage)
		}
	}

	vm.URLs = make([]urlViewModel, len(data.URLs))
	for i, u := range data.URLs {
		vm.URLs[i] = urlViewModel(u)
	}

	return vm
}

func buildFooterVM(data QuotePDFData) footerViewModel {
	parts := []string{data.OrganizationName}
	if data.OrgKvkNumber != "" {
		parts = append(parts, "KVK: "+data.OrgKvkNumber)
	}
	if data.OrgVatNumber != "" {
		parts = append(parts, "BTW: "+data.OrgVatNumber)
	}
	if data.OrgPhone != "" {
		parts = append(parts, "Tel: "+data.OrgPhone)
	}
	if data.OrgEmail != "" {
		parts = append(parts, data.OrgEmail)
	}
	return footerViewModel{
		FooterText: strings.Join(parts, "    "),
	}
}

//  Template rendering 

func renderTemplate(name string, data any) ([]byte, error) {
	raw, err := templateFS.ReadFile(name)
	if err != nil {
		return nil, fmt.Errorf("read embedded template %s: %w", name, err)
	}

	tmpl, err := template.New(name).Parse(string(raw))
	if err != nil {
		return nil, fmt.Errorf("parse template %s: %w", name, err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("execute template %s: %w", name, err)
	}
	return buf.Bytes(), nil
}

//  Helpers 

func encodeLogoBase64(logo []byte) (string, string) {
	if len(logo) == 0 {
		return "", ""
	}
	mime := http.DetectContentType(logo)
	// Normalise to common image types
	switch {
	case strings.Contains(mime, "jpeg"):
		mime = "image/jpeg"
	case strings.Contains(mime, "png"):
		mime = "image/png"
	case strings.Contains(mime, "gif"):
		mime = "image/gif"
	case strings.Contains(mime, "svg"):
		mime = "image/svg+xml"
	default:
		mime = "image/png"
	}
	return base64.StdEncoding.EncodeToString(logo), mime
}

var seqNumberRe = regexp.MustCompile(`(\d+)$`)

// extractSequenceNumber pulls the trailing numeric part from a quote number.
// e.g. "OFF-2026-0042"  "42", "Q-001"  "01"
func extractSequenceNumber(qn string) string {
	m := seqNumberRe.FindString(qn)
	if m == "" {
		return "01"
	}
	// Strip leading zeroes for display, but keep at least two digits
	n, err := strconv.Atoi(m)
	if err != nil {
		return m
	}
	return fmt.Sprintf("%02d", n)
}

func statusCSSClass(status string) string {
	switch status {
	case "Accepted":
		return "status-accepted"
	case "Rejected":
		return "status-rejected"
	case "Sent":
		return "status-sent"
	default:
		return "status-default"
	}
}

func translateStatus(status string) string {
	switch status {
	case "Draft":
		return "Concept"
	case "Sent":
		return "Verzonden"
	case "Accepted":
		return "Geaccepteerd"
	case "Rejected":
		return "Afgewezen"
	case "Expired":
		return "Verlopen"
	default:
		return status
	}
}

func formatCurrency(cents int64) string {
	return fmt.Sprintf(" %.2f", float64(cents)/100.0)
}
</file>

<file path="internal/scheduler/worker.go">
package scheduler

import (
	"context"
	"fmt"
	"strings"

	"portal_final_backend/internal/appointments/repository"
	"portal_final_backend/internal/events"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
	"github.com/hibiken/asynq"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Worker struct {
	server *asynq.Server
	mux    *asynq.ServeMux
	repo   *repository.Repository
	bus    events.Bus
	log    *logger.Logger
}

func NewWorker(cfg config.SchedulerConfig, pool *pgxpool.Pool, bus events.Bus, log *logger.Logger) (*Worker, error) {
	redisURL := cfg.GetRedisURL()
	if redisURL == "" {
		return nil, fmt.Errorf("redis url not configured")
	}

	opt, err := redisClientOpt(redisURL, cfg.GetRedisTLSInsecure())
	if err != nil {
		return nil, err
	}

	queue := cfg.GetAsynqQueueName()
	if queue == "" {
		queue = "default"
	}

	concurrency := cfg.GetAsynqConcurrency()
	if concurrency < 1 {
		concurrency = 10
	}

	server := asynq.NewServer(opt, asynq.Config{
		Concurrency: concurrency,
		Queues: map[string]int{
			queue: 1,
		},
	})

	mux := asynq.NewServeMux()
	w := &Worker{
		server: server,
		mux:    mux,
		repo:   repository.New(pool),
		bus:    bus,
		log:    log,
	}

	mux.HandleFunc(TaskAppointmentReminder, w.handleAppointmentReminder)

	return w, nil
}

func (w *Worker) Run(ctx context.Context) {
	if w == nil || w.server == nil {
		return
	}

	go func() {
		<-ctx.Done()
		w.server.Shutdown()
	}()

	if err := w.server.Run(w.mux); err != nil {
		w.log.Error("scheduler worker stopped", "error", err)
	}
}

func (w *Worker) handleAppointmentReminder(ctx context.Context, task *asynq.Task) error {
	payload, err := ParseAppointmentReminderPayload(task)
	if err != nil {
		return err
	}

	apptID, err := uuid.Parse(payload.AppointmentID)
	if err != nil {
		return err
	}

	orgID, err := uuid.Parse(payload.OrganizationID)
	if err != nil {
		return err
	}

	appt, err := w.repo.GetByID(ctx, apptID, orgID)
	if err != nil {
		return err
	}

	if appt.Status != "scheduled" || appt.Type != "lead_visit" {
		return nil
	}

	if appt.LeadID == nil {
		return nil
	}

	leadInfo, err := w.repo.GetLeadInfo(ctx, *appt.LeadID, orgID)
	if err != nil {
		return err
	}
	if leadInfo == nil || leadInfo.Phone == "" {
		return nil
	}

	consumerName := strings.TrimSpace(fmt.Sprintf("%s %s", leadInfo.FirstName, leadInfo.LastName))
	if consumerName == "" {
		consumerName = "klant"
	}

	if w.bus == nil {
		return nil
	}

	w.bus.Publish(ctx, events.AppointmentReminderDue{
		BaseEvent:      events.NewBaseEvent(),
		AppointmentID:  appt.ID,
		OrganizationID: appt.OrganizationID,
		LeadID:         appt.LeadID,
		LeadServiceID:  appt.LeadServiceID,
		UserID:         appt.UserID,
		Type:           appt.Type,
		Title:          appt.Title,
		StartTime:      appt.StartTime,
		EndTime:        appt.EndTime,
		ConsumerName:   consumerName,
		ConsumerPhone:  leadInfo.Phone,
		Location:       getOptionalString(appt.Location),
	})

	return nil
}

func getOptionalString(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}
</file>

<file path="internal/services/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"

	"portal_final_backend/platform/apperr"
)

const serviceTypeNotFoundMessage = "service type not found"

// Repo implements the Repository interface with PostgreSQL.
type Repo struct {
	pool *pgxpool.Pool
}

// New creates a new service types repository.
func New(pool *pgxpool.Pool) *Repo {
	return &Repo{pool: pool}
}

// Compile-time check that Repo implements Repository.
var _ Repository = (*Repo)(nil)

// GetByID retrieves a service type by its ID.
func (r *Repo) GetByID(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (ServiceType, error) {
	query := `
		SELECT id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at
		FROM RAC_service_types
		WHERE id = $1 AND organization_id = $2`

	var st ServiceType
	var createdAt, updatedAt time.Time

	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&st.ID, &st.OrganizationID, &st.Name, &st.Slug, &st.Description, &st.IntakeGuidelines, &st.Icon, &st.Color,
		&st.IsActive, &createdAt, &updatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return ServiceType{}, apperr.NotFound(serviceTypeNotFoundMessage)
		}
		return ServiceType{}, fmt.Errorf("get service type by id: %w", err)
	}

	st.CreatedAt = createdAt.Format(time.RFC3339)
	st.UpdatedAt = updatedAt.Format(time.RFC3339)

	return st, nil
}

// GetBySlug retrieves a service type by its slug.
func (r *Repo) GetBySlug(ctx context.Context, organizationID uuid.UUID, slug string) (ServiceType, error) {
	query := `
		SELECT id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at
		FROM RAC_service_types
		WHERE slug = $1 AND organization_id = $2`

	var st ServiceType
	var createdAt, updatedAt time.Time

	err := r.pool.QueryRow(ctx, query, slug, organizationID).Scan(
		&st.ID, &st.OrganizationID, &st.Name, &st.Slug, &st.Description, &st.IntakeGuidelines, &st.Icon, &st.Color,
		&st.IsActive, &createdAt, &updatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return ServiceType{}, apperr.NotFound(serviceTypeNotFoundMessage)
		}
		return ServiceType{}, fmt.Errorf("get service type by slug: %w", err)
	}

	st.CreatedAt = createdAt.Format(time.RFC3339)
	st.UpdatedAt = updatedAt.Format(time.RFC3339)

	return st, nil
}

// List retrieves all service types ordered by name.
func (r *Repo) List(ctx context.Context, organizationID uuid.UUID) ([]ServiceType, error) {
	query := `
		SELECT id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at
		FROM RAC_service_types
		WHERE organization_id = $1
		ORDER BY name ASC`

	rows, err := r.pool.Query(ctx, query, organizationID)
	if err != nil {
		return nil, fmt.Errorf("list service types: %w", err)
	}
	defer rows.Close()

	return scanServiceTypes(rows)
}

// ListActive retrieves only active service types ordered by name.
func (r *Repo) ListActive(ctx context.Context, organizationID uuid.UUID) ([]ServiceType, error) {
	query := `
		SELECT id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at
		FROM RAC_service_types
		WHERE organization_id = $1 AND is_active = true
		ORDER BY name ASC`

	rows, err := r.pool.Query(ctx, query, organizationID)
	if err != nil {
		return nil, fmt.Errorf("list active service types: %w", err)
	}
	defer rows.Close()

	return scanServiceTypes(rows)
}

// ListWithFilters retrieves service types with search, active filter, pagination, and sorting.
func (r *Repo) ListWithFilters(ctx context.Context, params ListParams) ([]ServiceType, int, error) {
	var searchParam interface{}
	if params.Search != "" {
		searchParam = "%" + params.Search + "%"
	}
	var isActiveParam interface{}
	if params.IsActive != nil {
		isActiveParam = *params.IsActive
	}

	sortBy := "name"
	if params.SortBy != "" {
		switch params.SortBy {
		case "name", "slug", "isActive", "createdAt", "updatedAt":
			sortBy = params.SortBy
		default:
			return nil, 0, apperr.BadRequest("invalid sort field")
		}
	}

	sortOrder := "asc"
	if params.SortOrder != "" {
		switch params.SortOrder {
		case "asc", "desc":
			sortOrder = params.SortOrder
		default:
			return nil, 0, apperr.BadRequest("invalid sort order")
		}
	}

	args := []interface{}{params.OrganizationID, searchParam, isActiveParam}

	countQuery := `
		SELECT COUNT(*)
		FROM RAC_service_types
		WHERE organization_id = $1
			AND ($2::text IS NULL OR name ILIKE $2 OR slug ILIKE $2)
			AND ($3::boolean IS NULL OR is_active = $3)
	`

	var total int
	if err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("count service types: %w", err)
	}

	query := `
		SELECT id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at
		FROM RAC_service_types
		WHERE organization_id = $1
			AND ($2::text IS NULL OR name ILIKE $2 OR slug ILIKE $2)
			AND ($3::boolean IS NULL OR is_active = $3)
		ORDER BY
			CASE WHEN $4 = 'name' AND $5 = 'asc' THEN name END ASC,
			CASE WHEN $4 = 'name' AND $5 = 'desc' THEN name END DESC,
			CASE WHEN $4 = 'slug' AND $5 = 'asc' THEN slug END ASC,
			CASE WHEN $4 = 'slug' AND $5 = 'desc' THEN slug END DESC,
			CASE WHEN $4 = 'isActive' AND $5 = 'asc' THEN is_active END ASC,
			CASE WHEN $4 = 'isActive' AND $5 = 'desc' THEN is_active END DESC,
			CASE WHEN $4 = 'createdAt' AND $5 = 'asc' THEN created_at END ASC,
			CASE WHEN $4 = 'createdAt' AND $5 = 'desc' THEN created_at END DESC,
			CASE WHEN $4 = 'updatedAt' AND $5 = 'asc' THEN updated_at END ASC,
			CASE WHEN $4 = 'updatedAt' AND $5 = 'desc' THEN updated_at END DESC,
			name ASC
		LIMIT $6 OFFSET $7
	`

	args = append(args, sortBy, sortOrder, params.Limit, params.Offset)
	rows, err := r.pool.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("list service types: %w", err)
	}
	defer rows.Close()

	items, err := scanServiceTypes(rows)
	if err != nil {
		return nil, 0, err
	}

	return items, total, nil
}

// Exists checks if a service type exists by ID.
func (r *Repo) Exists(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM RAC_service_types WHERE id = $1 AND organization_id = $2)`

	var exists bool
	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("check service type exists: %w", err)
	}

	return exists, nil
}

// HasLeadServices checks if a service type is referenced by RAC_lead_services.
func (r *Repo) HasLeadServices(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM RAC_lead_services WHERE service_type_id = $1 AND organization_id = $2)`

	var exists bool
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check service type lead services: %w", err)
	}

	return exists, nil
}

// Create creates a new service type.
func (r *Repo) Create(ctx context.Context, params CreateParams) (ServiceType, error) {
	query := `
		INSERT INTO RAC_service_types (organization_id, name, slug, description, intake_guidelines, icon, color)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at`

	var st ServiceType
	var createdAt, updatedAt time.Time

	err := r.pool.QueryRow(ctx, query,
		params.OrganizationID, params.Name, params.Slug, params.Description, params.IntakeGuidelines, params.Icon, params.Color,
	).Scan(
		&st.ID, &st.OrganizationID, &st.Name, &st.Slug, &st.Description, &st.IntakeGuidelines, &st.Icon, &st.Color,
		&st.IsActive, &createdAt, &updatedAt,
	)
	if err != nil {
		return ServiceType{}, fmt.Errorf("create service type: %w", err)
	}

	st.CreatedAt = createdAt.Format(time.RFC3339)
	st.UpdatedAt = updatedAt.Format(time.RFC3339)

	return st, nil
}

// Update updates an existing service type.
func (r *Repo) Update(ctx context.Context, params UpdateParams) (ServiceType, error) {
	// Build dynamic update query
	query := `
		UPDATE RAC_service_types SET
			name = COALESCE($2, name),
			slug = COALESCE($3, slug),
			description = COALESCE($4, description),
			intake_guidelines = COALESCE($5, intake_guidelines),
			icon = COALESCE($6, icon),
			color = COALESCE($7, color),
			updated_at = now()
		WHERE id = $1 AND organization_id = $8
		RETURNING id, organization_id, name, slug, description, intake_guidelines, icon, color, is_active, created_at, updated_at`

	var st ServiceType
	var createdAt, updatedAt time.Time

	err := r.pool.QueryRow(ctx, query,
		params.ID, params.Name, params.Slug, params.Description, params.IntakeGuidelines, params.Icon, params.Color, params.OrganizationID,
	).Scan(
		&st.ID, &st.OrganizationID, &st.Name, &st.Slug, &st.Description, &st.IntakeGuidelines, &st.Icon, &st.Color,
		&st.IsActive, &createdAt, &updatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return ServiceType{}, apperr.NotFound(serviceTypeNotFoundMessage)
		}
		return ServiceType{}, fmt.Errorf("update service type: %w", err)
	}

	st.CreatedAt = createdAt.Format(time.RFC3339)
	st.UpdatedAt = updatedAt.Format(time.RFC3339)

	return st, nil
}

// Delete removes a service type by ID (hard delete).
// Use SetActive(false) for soft delete.
func (r *Repo) Delete(ctx context.Context, organizationID uuid.UUID, id uuid.UUID) error {
	query := `DELETE FROM RAC_service_types WHERE id = $1 AND organization_id = $2`

	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("delete service type: %w", err)
	}

	if result.RowsAffected() == 0 {
		return apperr.NotFound(serviceTypeNotFoundMessage)
	}

	return nil
}

// SetActive sets the is_active flag for a service type.
func (r *Repo) SetActive(ctx context.Context, organizationID uuid.UUID, id uuid.UUID, isActive bool) error {
	query := `UPDATE RAC_service_types SET is_active = $3, updated_at = now() WHERE id = $1 AND organization_id = $2`

	result, err := r.pool.Exec(ctx, query, id, organizationID, isActive)
	if err != nil {
		return fmt.Errorf("set service type active: %w", err)
	}

	if result.RowsAffected() == 0 {
		return apperr.NotFound(serviceTypeNotFoundMessage)
	}

	return nil
}

// scanServiceTypes is a helper to scan multiple rows into ServiceType slice.
func scanServiceTypes(rows pgx.Rows) ([]ServiceType, error) {
	var results []ServiceType

	for rows.Next() {
		var st ServiceType
		var createdAt, updatedAt time.Time

		err := rows.Scan(
			&st.ID, &st.OrganizationID, &st.Name, &st.Slug, &st.Description, &st.IntakeGuidelines, &st.Icon, &st.Color,
			&st.IsActive, &createdAt, &updatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("scan service type: %w", err)
		}

		st.CreatedAt = createdAt.Format(time.RFC3339)
		st.UpdatedAt = updatedAt.Format(time.RFC3339)

		results = append(results, st)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate service types: %w", err)
	}

	return results, nil
}
</file>

<file path="internal/services/transport/dto.go">
package transport

import "github.com/google/uuid"

// CreateServiceTypeRequest contains data for creating a new service type.
type CreateServiceTypeRequest struct {
	Name             string  `json:"name" validate:"required,min=1,max=100"`
	Description      *string `json:"description,omitempty" validate:"omitempty,max=500"`
	IntakeGuidelines *string `json:"intakeGuidelines,omitempty" validate:"omitempty,max=10000"`
	Icon             *string `json:"icon,omitempty" validate:"omitempty,max=50"`
	Color            *string `json:"color,omitempty" validate:"omitempty,max=20"`
}

// UpdateServiceTypeRequest contains data for updating an existing service type.
type UpdateServiceTypeRequest struct {
	Name             *string `json:"name,omitempty" validate:"omitempty,min=1,max=100"`
	Description      *string `json:"description,omitempty" validate:"omitempty,max=500"`
	IntakeGuidelines *string `json:"intakeGuidelines,omitempty" validate:"omitempty,max=10000"`
	Icon             *string `json:"icon,omitempty" validate:"omitempty,max=50"`
	Color            *string `json:"color,omitempty" validate:"omitempty,max=20"`
}

// ListServiceTypesRequest defines query params for admin listing.
type ListServiceTypesRequest struct {
	Search    string `form:"search" validate:"max=100"`
	IsActive  *bool  `form:"isActive" validate:"omitempty"`
	Page      int    `form:"page" validate:"min=1"`
	PageSize  int    `form:"pageSize" validate:"min=1,max=100"`
	SortBy    string `form:"sortBy" validate:"omitempty,oneof=name slug isActive createdAt updatedAt"`
	SortOrder string `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
}

// ServiceTypeResponse represents a service type in API responses.
type ServiceTypeResponse struct {
	ID               uuid.UUID `json:"id"`
	Name             string    `json:"name"`
	Slug             string    `json:"slug"`
	Description      *string   `json:"description,omitempty"`
	IntakeGuidelines *string   `json:"intakeGuidelines,omitempty"`
	Icon             *string   `json:"icon,omitempty"`
	Color            *string   `json:"color,omitempty"`
	IsActive         bool      `json:"isActive"`
	CreatedAt        string    `json:"createdAt"`
	UpdatedAt        string    `json:"updatedAt"`
}

// ServiceTypeListResponse wraps a list of service types.
type ServiceTypeListResponse struct {
	Items      []ServiceTypeResponse `json:"items"`
	Total      int                   `json:"total"`
	Page       int                   `json:"page"`
	PageSize   int                   `json:"pageSize"`
	TotalPages int                   `json:"totalPages"`
}

// DeleteServiceTypeResponse indicates whether a service type was deleted or deactivated.
type DeleteServiceTypeResponse struct {
	Status string `json:"status"`
}
</file>

<file path="internal/webhook/extractor.go">
package webhook

import (
	"regexp"
	"strings"
)

// ExtractedFields holds the fields extracted from raw form data via best-effort pattern matching.
type ExtractedFields struct {
	FirstName     string
	LastName      string
	Email         string
	Phone         string
	Street        string
	HouseNumber   string
	ZipCode       string
	City          string
	Message       string
	ServiceType   string // Matched against known service type slugs/keywords
	GCLID         string
	UTMSource     string
	UTMMedium     string
	UTMCampaign   string
	UTMContent    string
	UTMTerm       string
	AdLandingPage string
	ReferrerURL   string
}

// IsIncomplete returns true if minimum required fields (name + at least one contact method) are missing.
func (e ExtractedFields) IsIncomplete() bool {
	hasName := e.FirstName != "" || e.LastName != ""
	hasContact := e.Phone != "" || e.Email != ""
	return !hasName || !hasContact
}

// ExtractFields performs best-effort field extraction from a flat string map of form data.
// It uses label matching to identify common fields across any form.
func ExtractFields(data map[string]string) ExtractedFields {
	var result ExtractedFields

	for key, value := range data {
		value = strings.TrimSpace(value)
		if value == "" {
			continue
		}
		k := strings.ToLower(strings.TrimSpace(key))
		applyExtractedField(&result, k, value)
	}

	// If we got a full name but no separate first/last, and first name looks like "first last"
	if result.FirstName != "" && result.LastName == "" && strings.Contains(result.FirstName, " ") {
		parts := strings.SplitN(result.FirstName, " ", 2)
		result.FirstName = parts[0]
		result.LastName = parts[1]
	}

	return result
}

func applyExtractedField(result *ExtractedFields, key, value string) {
	switch {
	case matchesAny(key, firstNamePatterns):
		result.FirstName = value
	case matchesAny(key, lastNamePatterns):
		result.LastName = value
	case matchesAny(key, fullNamePatterns):
		parts := strings.SplitN(value, " ", 2)
		result.FirstName = parts[0]
		if len(parts) > 1 {
			result.LastName = parts[1]
		}
	case matchesAny(key, emailPatterns):
		if emailRegex.MatchString(value) {
			result.Email = value
		}
	case matchesAny(key, phonePatterns):
		result.Phone = normalizePhone(value)
	case matchesAny(key, streetPatterns):
		result.Street = value
	case matchesAny(key, houseNumberPatterns):
		result.HouseNumber = value
	case matchesAny(key, zipCodePatterns):
		result.ZipCode = normalizeZipCode(value)
	case matchesAny(key, cityPatterns):
		result.City = value
	case matchesAny(key, messagePatterns):
		result.Message = value
	case matchesAny(key, addressPatterns):
		parseFullAddress(value, result)
	case matchesAny(key, serviceTypePatterns):
		if st := matchServiceType(value); st != "" {
			result.ServiceType = st
		}
	case matchesAny(key, gclidPatterns):
		result.GCLID = value
	case matchesAny(key, utmSourcePatterns):
		result.UTMSource = value
	case matchesAny(key, utmMediumPatterns):
		result.UTMMedium = value
	case matchesAny(key, utmCampaignPatterns):
		result.UTMCampaign = value
	case matchesAny(key, utmContentPatterns):
		result.UTMContent = value
	case matchesAny(key, utmTermPatterns):
		result.UTMTerm = value
	case matchesAny(key, landingPagePatterns):
		result.AdLandingPage = value
	case matchesAny(key, referrerPatterns):
		result.ReferrerURL = value
	}
}

// Field label patterns (Dutch + English)
var (
	firstNamePatterns   = []string{"first_name", "firstname", "first name", "voornaam", "given_name", "givenname", "fname"}
	lastNamePatterns    = []string{"last_name", "lastname", "last name", "achternaam", "family_name", "familyname", "surname", "lname"}
	fullNamePatterns    = []string{"name", "naam", "full_name", "fullname", "your_name", "your name"}
	emailPatterns       = []string{"email", "e-mail", "e_mail", "emailaddress", "email_address", "mail"}
	phonePatterns       = []string{"phone", "telefoon", "tel", "telephone", "phonenumber", "phone_number", "telefoonnummer", "mobile", "mobiel", "gsm"}
	streetPatterns      = []string{"street", "straat", "straatnaam", "street_name", "streetname"}
	houseNumberPatterns = []string{"house_number", "housenumber", "huisnummer", "house number", "nr", "number", "nummer"}
	zipCodePatterns     = []string{"zip", "zipcode", "zip_code", "postcode", "postal_code", "postalcode", "zip code", "postal code"}
	cityPatterns        = []string{"city", "stad", "woonplaats", "plaats", "town", "gemeente", "location", "locatie"}
	messagePatterns     = []string{"message", "bericht", "opmerking", "opmerkingen", "comment", "comments", "notes", "description", "toelichting", "vraag", "question"}
	addressPatterns     = []string{"address", "adres", "full_address", "fulladdress"}
	serviceTypePatterns = []string{"service", "dienst", "project_type", "projecttype", "service_type", "servicetype", "type", "werkzaamheden", "soort", "category", "categorie", "product"}
	gclidPatterns       = []string{"gclid", "google_click_id", "googleclickid"}
	utmSourcePatterns   = []string{"utm_source", "utmsource"}
	utmMediumPatterns   = []string{"utm_medium", "utmmedium"}
	utmCampaignPatterns = []string{"utm_campaign", "utmcampaign"}
	utmContentPatterns  = []string{"utm_content", "utmcontent"}
	utmTermPatterns     = []string{"utm_term", "utmterm"}
	landingPagePatterns = []string{"ad_landing_page", "landing_page", "landingpage"}
	referrerPatterns    = []string{"referrer", "referrer_url", "referrerurl"}
)

var (
	emailRegex   = regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
	dutchZipRe   = regexp.MustCompile(`(\d{4})\s*([A-Za-z]{2})`)
	dutchPhoneRe = regexp.MustCompile(`^(?:\+31|0031|0)\s*[-.\s]?(\d[\d\s\-\.]{7,})$`)
)

func matchesAny(label string, patterns []string) bool {
	// Normalize: strip spaces, dashes, underscores for fuzzy matching
	normalized := strings.NewReplacer("-", "", "_", "", " ", "").Replace(label)
	for _, p := range patterns {
		pNormalized := strings.NewReplacer("-", "", "_", "", " ", "").Replace(p)
		if normalized == pNormalized {
			return true
		}
	}
	return false
}

func normalizePhone(value string) string {
	// Remove common formatting characters
	cleaned := strings.Map(func(r rune) rune {
		if (r >= '0' && r <= '9') || r == '+' {
			return r
		}
		return -1
	}, value)

	// Dutch number normalization: 06...  +316...
	if strings.HasPrefix(cleaned, "06") && len(cleaned) == 10 {
		return "+31" + cleaned[1:]
	}
	if strings.HasPrefix(cleaned, "0031") {
		return "+" + cleaned[2:]
	}
	if strings.HasPrefix(cleaned, "0") && len(cleaned) == 10 {
		return "+31" + cleaned[1:]
	}

	return cleaned
}

func normalizeZipCode(value string) string {
	value = strings.TrimSpace(value)
	m := dutchZipRe.FindStringSubmatch(value)
	if len(m) == 3 {
		return m[1] + " " + strings.ToUpper(m[2])
	}
	return value
}

func parseFullAddress(value string, result *ExtractedFields) {
	parts := strings.SplitN(value, ",", 2)
	streetPart := strings.TrimSpace(parts[0])

	parseStreetPart(streetPart, result)
	if len(parts) == 2 {
		parseZipCityPart(strings.TrimSpace(parts[1]), result)
	}
}

func parseStreetPart(streetPart string, result *ExtractedFields) {
	words := strings.Fields(streetPart)
	if len(words) < 2 {
		if result.Street == "" {
			result.Street = streetPart
		}
		return
	}

	last := words[len(words)-1]
	if len(last) > 0 && last[0] >= '0' && last[0] <= '9' {
		if result.Street == "" {
			result.Street = strings.Join(words[:len(words)-1], " ")
		}
		if result.HouseNumber == "" {
			result.HouseNumber = last
		}
		return
	}

	if result.Street == "" {
		result.Street = streetPart
	}
}

func parseZipCityPart(value string, result *ExtractedFields) {
	m := dutchZipRe.FindStringSubmatchIndex(value)
	if m != nil {
		if result.ZipCode == "" {
			result.ZipCode = normalizeZipCode(value[m[0]:m[1]])
		}
		after := strings.TrimSpace(value[m[1]:])
		if result.City == "" && after != "" {
			result.City = after
		}
		return
	}

	if result.City == "" {
		result.City = value
	}
}

// serviceTypeKeywords maps Dutch + English keywords found in form values
// to the slugs used in RAC_service_types. Order matters: first match wins.
var serviceTypeKeywords = []struct {
	slug     string
	keywords []string
}{
	{"windows", []string{"kozijn", "kozijnen", "raam", "ramen", "window", "windows", "glas", "glaswerk", "deur", "deuren", "door", "doors", "beglazing", "dubbel glas", "hr++", "triple glas"}},
	{"insulation", []string{"isolatie", "isoleren", "insulation", "spouwmuur", "vloerisolatie", "dakisolatie", "muurisolatie", "cavity wall", "floor insulation", "roof insulation"}},
	{"solar", []string{"solar", "zonnepaneel", "zonnepanelen", "zonne-energie", "pv", "zonneboiler", "solar panel"}},
	{"hvac", []string{"hvac", "warmtepomp", "heat pump", "airco", "airconditioning", "verwarming", "heating", "ventilatie", "ventilation", "cv", "cv-ketel", "boiler"}},
	{"plumbing", []string{"loodgieter", "plumbing", "sanitair", "afvoer", "drain", "waterleiding", "badkamer", "bathroom", "kraan", "toilet"}},
	{"electrical", []string{"elektra", "electrical", "electrician", "bedrading", "wiring", "meterkast", "laadpaal", "charging station", "ev charger"}},
	{"carpentry", []string{"timmerwerk", "timmerman", "carpentry", "carpenter", "hout", "wood", "vloer", "floor", "parket", "laminaat", "trap", "stairs"}},
	{"handyman", []string{"klusjesman", "handyman", "klussen", "reparatie", "repair", "onderhoud", "maintenance"}},
}

// matchServiceType maps a form field value to a known service type slug
// using keyword matching. Returns empty string if no match.
func matchServiceType(value string) string {
	v := strings.ToLower(strings.TrimSpace(value))
	if v == "" {
		return ""
	}
	for _, st := range serviceTypeKeywords {
		for _, kw := range st.keywords {
			if strings.Contains(v, kw) {
				return st.slug
			}
		}
	}
	return ""
}
</file>

<file path="internal/webhook/sdk.js">
/**
 * RAC Form Capture SDK
 * 
 * Automatically captures form submissions and sends them to your lead management system.
 * 
 * Usage:
 *   <script src="https://your-api.com/api/v1/webhook/sdk.js" data-api-key="whk_..." async></script>
 * 
 * Options (data attributes on the script tag):
 *   data-api-key      (required) Your webhook API key
 *   data-endpoint     (optional) Custom API endpoint URL (defaults to script origin)
 *   data-selector     (optional) CSS selector for forms to capture (defaults to all forms)
 *   data-success-url  (optional) Redirect URL after successful submission
 *   data-tracking-ttl (optional) Tracking TTL in days (default: 90)
 * 
 * Manual capture (for JS-rendered forms):
 *   window.RACFormCapture.submit({ name: "John", email: "john@example.com" })
 */
(function () {
  'use strict';

  // Find our script tag to read config
  var scripts = document.querySelectorAll('script[data-api-key]');
  var scriptTag = scripts[scripts.length - 1];
  if (!scriptTag) {
    console.warn('[RAC] No script tag with data-api-key found');
    return;
  }

  var config = {
    apiKey: scriptTag.getAttribute('data-api-key'),
    endpoint: scriptTag.getAttribute('data-endpoint') || getScriptOrigin(scriptTag),
    selector: scriptTag.getAttribute('data-selector') || null,
    successUrl: scriptTag.getAttribute('data-success-url') || null,
    trackingTTL: parseInt(scriptTag.getAttribute('data-tracking-ttl') || '90', 10)
  };

  if (!config.apiKey) {
    console.warn('[RAC] data-api-key is required');
    return;
  }

  function getScriptOrigin(tag) {
    try {
      var url = new URL(tag.src);
      return url.origin + '/api/v1/webhook/forms';
    } catch (e) {
      return '/api/v1/webhook/forms';
    }
  }

  var STORAGE_KEY = 'rac_tracking_data';

  function captureTrackingParams() {
    try {
      var params = new URLSearchParams(window.location.search);
      var trackingData = loadTrackingData() || {};
      var hasUpdates = false;

      var gclid = params.get('gclid');
      if (gclid) {
        trackingData.gclid = gclid;
        hasUpdates = true;
      }

      var utmParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term'];
      utmParams.forEach(function (param) {
        var value = params.get(param);
        if (value) {
          trackingData[param] = value;
          hasUpdates = true;
        }
      });

      if (gclid || !trackingData.ad_landing_page) {
        trackingData.ad_landing_page = window.location.href;
        hasUpdates = true;
      }

      if (!trackingData.referrer_url && document.referrer) {
        trackingData.referrer_url = document.referrer;
        hasUpdates = true;
      }

      if (hasUpdates) {
        var expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + config.trackingTTL);
        trackingData.expiry = expiryDate.toISOString();

        localStorage.setItem(STORAGE_KEY, JSON.stringify(trackingData));
      }
    } catch (e) {
      console.warn('[RAC] Failed to capture tracking params:', e && e.message ? e.message : e);
    }
  }

  function loadTrackingData() {
    try {
      var stored = localStorage.getItem(STORAGE_KEY);
      if (!stored) return null;

      var data = JSON.parse(stored);
      if (data && data.expiry) {
        var expiry = new Date(data.expiry);
        if (expiry < new Date()) {
          localStorage.removeItem(STORAGE_KEY);
          return null;
        }
      }

      if (data && data.expiry) {
        delete data.expiry;
      }
      return data;
    } catch (e) {
      return null;
    }
  }

  function appendTrackingData(data) {
    var trackingData = loadTrackingData();
    if (!trackingData) return data;

    if (data instanceof FormData) {
      Object.keys(trackingData).forEach(function (key) {
        if (!data.has(key)) {
          data.append(key, trackingData[key]);
        }
      });
    } else {
      Object.keys(trackingData).forEach(function (key) {
        if (!(key in data)) {
          data[key] = trackingData[key];
        }
      });
    }

    return data;
  }

  /**
   * Submit form data to the webhook endpoint.
   * @param {Object|FormData} data - Key-value pairs or FormData object
   * @param {Object} [options] - Optional overrides
   * @returns {Promise<Object>} Response from the API
   */
  function submit(data, options) {
    options = options || {};
    var url = options.endpoint || config.endpoint;
    var apiKey = options.apiKey || config.apiKey;

    data = appendTrackingData(data);

    var body;
    var headers = {
      'X-Webhook-API-Key': apiKey
    };

    if (data instanceof FormData) {
      body = data;
      // Don't set Content-Type  browser will set multipart/form-data with boundary
    } else {
      body = JSON.stringify(data);
      headers['Content-Type'] = 'application/json';
    }

    return fetch(url, {
      method: 'POST',
      headers: headers,
      body: body,
      mode: 'cors'
    }).then(function (response) {
      if (!response.ok) {
        return response.json().then(function (err) {
          throw new Error(err.error || 'Form submission failed');
        });
      }
      return response.json();
    });
  }

  /**
   * Auto-capture form submissions
   */
  function attachFormListeners() {
    var selector = config.selector || 'form';
    var forms = document.querySelectorAll(selector);

    forms.forEach(function (form) {
      // Skip forms that are already captured or explicitly excluded
      if (form.hasAttribute('data-rac-ignore') || form.hasAttribute('data-rac-attached')) {
        return;
      }
      form.setAttribute('data-rac-attached', 'true');

      form.addEventListener('submit', function (e) {
        e.preventDefault();

        var formData = new FormData(form);

        // Show loading state
        var submitBtn = form.querySelector('[type="submit"]');
        var originalText = '';
        if (submitBtn) {
          originalText = submitBtn.textContent;
          submitBtn.textContent = 'Verzenden...';
          submitBtn.disabled = true;
        }

        submit(formData)
          .then(function (response) {
            // Success
            if (config.successUrl) {
              window.location.href = config.successUrl;
            } else {
              // Dispatch custom event for app-level handling
              form.dispatchEvent(new CustomEvent('rac:success', {
                detail: response,
                bubbles: true
              }));

              // Default: show simple success message
              if (!form.hasAttribute('data-rac-no-message')) {
                showMessage(form, 'Bedankt! Uw aanvraag is ontvangen.', 'success');
              }
              form.reset();
            }
          })
          .catch(function (error) {
            form.dispatchEvent(new CustomEvent('rac:error', {
              detail: { error: error.message },
              bubbles: true
            }));

            if (!form.hasAttribute('data-rac-no-message')) {
              showMessage(form, 'Er is iets misgegaan. Probeer het opnieuw.', 'error');
            }
          })
          .finally(function () {
            if (submitBtn) {
              submitBtn.textContent = originalText;
              submitBtn.disabled = false;
            }
          });
      });
    });
  }

  function showMessage(form, text, type) {
    // Remove previous message
    var existing = form.querySelector('.rac-message');
    if (existing) existing.remove();

    var msg = document.createElement('div');
    msg.className = 'rac-message rac-message--' + type;
    msg.textContent = text;
    msg.style.cssText = 'padding:12px;margin:8px 0;border-radius:6px;font-size:14px;' +
      (type === 'success'
        ? 'background:#d4edda;color:#155724;border:1px solid #c3e6cb;'
        : 'background:#f8d7da;color:#721c24;border:1px solid #f5c6cb;');
    form.appendChild(msg);

    setTimeout(function () { msg.remove(); }, 5000);
  }

  // Expose public API
  window.RACFormCapture = {
    submit: submit,
    refresh: attachFormListeners,
    getTrackingData: loadTrackingData,
    clearTrackingData: function () {
      localStorage.removeItem(STORAGE_KEY);
    }
  };

  captureTrackingParams();

  // Auto-attach when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachFormListeners);
  } else {
    attachFormListeners();
  }

  // Re-attach on dynamic content (MutationObserver for SPAs)
  if (typeof MutationObserver !== 'undefined') {
    var observer = new MutationObserver(function (mutations) {
      var hasNewForms = mutations.some(function (m) {
        return Array.from(m.addedNodes).some(function (n) {
          return n.nodeType === 1 && (n.tagName === 'FORM' || n.querySelector && n.querySelector('form'));
        });
      });
      if (hasNewForms) {
        attachFormListeners();
      }
    });
    observer.observe(document.body || document.documentElement, {
      childList: true,
      subtree: true
    });
  }
})();
</file>

<file path="platform/qdrant/client.go">
// Package qdrant provides a REST client for Qdrant vector database.
package qdrant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// Client is an HTTP client for Qdrant vector database.
type Client struct {
	baseURL    string
	apiKey     string
	collection string
	httpClient *http.Client
}

// Config configures the Qdrant client.
type Config struct {
	BaseURL    string
	APIKey     string
	Collection string
	Timeout    time.Duration
}

// NewClient creates a new Qdrant client.
func NewClient(cfg Config) *Client {
	timeout := cfg.Timeout
	if timeout == 0 {
		timeout = 30 * time.Second
	}

	return &Client{
		baseURL:    cfg.BaseURL,
		apiKey:     cfg.APIKey,
		collection: cfg.Collection,
		httpClient: &http.Client{
			Timeout: timeout,
		},
	}
}

// SearchRequest is the request body for a vector search.
type SearchRequest struct {
	Vector         []float32 `json:"vector"`
	Limit          int       `json:"limit"`
	WithPayload    bool      `json:"with_payload"`
	ScoreThreshold *float64  `json:"score_threshold,omitempty"` // Minimum similarity score (Qdrant filters server-side)
}

// SearchResult is a single search result from Qdrant.
type SearchResult struct {
	ID      interface{}            `json:"id"`
	Score   float64                `json:"score"`
	Payload map[string]interface{} `json:"payload"`
}

// SearchResponse is the response from a search query.
type SearchResponse struct {
	Result []SearchResult `json:"result"`
	Status interface{}    `json:"status"`
	Time   float64        `json:"time"`
}

// SearchWithThreshold performs a vector similarity search with a minimum score threshold.
func (c *Client) SearchWithThreshold(ctx context.Context, vector []float32, limit int, scoreThreshold float64) ([]SearchResult, error) {
	return c.searchInternal(ctx, vector, limit, &scoreThreshold)
}

// Search performs a vector similarity search in the configured collection.
func (c *Client) Search(ctx context.Context, vector []float32, limit int) ([]SearchResult, error) {
	return c.searchInternal(ctx, vector, limit, nil)
}

func (c *Client) searchInternal(ctx context.Context, vector []float32, limit int, scoreThreshold *float64) ([]SearchResult, error) {
	if limit <= 0 {
		limit = 5
	}

	reqBody := SearchRequest{
		Vector:         vector,
		Limit:          limit,
		WithPayload:    true,
		ScoreThreshold: scoreThreshold,
	}

	bodyBytes, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal search request: %w", err)
	}

	url := fmt.Sprintf("%s/collections/%s/points/search", c.baseURL, c.collection)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(bodyBytes))
	if err != nil {
		return nil, fmt.Errorf("failed to create search request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	if c.apiKey != "" {
		req.Header.Set("api-key", c.apiKey)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("search request failed: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("qdrant returned %d: %s", resp.StatusCode, string(body))
	}

	var searchResp SearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&searchResp); err != nil {
		return nil, fmt.Errorf("failed to decode search response: %w", err)
	}

	return searchResp.Result, nil
}
</file>

<file path="Dockerfile">
# Build stage
FROM golang:1.24.12-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -trimpath -ldflags="-s -w" -o /app/bin/server ./cmd/api
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -trimpath -ldflags="-s -w" -o /app/bin/scheduler ./cmd/scheduler

# Runtime stage
FROM alpine:3.20

RUN addgroup -S app && adduser -S app -G app && apk add --no-cache ca-certificates curl

WORKDIR /app
COPY --from=builder /app/bin/server /app/server
COPY --from=builder /app/bin/scheduler /app/scheduler
COPY --from=builder /app/migrations /app/migrations
COPY start.sh /app/start.sh

RUN chmod +x /app/start.sh
COPY healthcheck.sh /app/healthcheck.sh

RUN chmod +x /app/healthcheck.sh

ENV HTTP_ADDR=:8080
ENV SERVICE_ROLE=api
EXPOSE 8080

USER app

HEALTHCHECK --interval=30s --timeout=5s --start-period=20s --retries=3 CMD ["/app/healthcheck.sh"]

ENTRYPOINT ["/app/start.sh"]
</file>

<file path="internal/adapters/appointment_public_slots_adapter.go">
package adapters

import (
	"context"
	"fmt"
	"sort"
	"time"

	"portal_final_backend/internal/appointments/service"
	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/internal/leads/ports"

	"github.com/google/uuid"
)

// AppointmentSlotAdapter exposes appointment availability and booking for the public lead portal.
type AppointmentSlotAdapter struct {
	svc *service.Service
}

func NewAppointmentSlotAdapter(svc *service.Service) *AppointmentSlotAdapter {
	return &AppointmentSlotAdapter{svc: svc}
}

func (a *AppointmentSlotAdapter) HasAvailabilityRules(ctx context.Context, organizationID uuid.UUID) (bool, error) {
	userIDs, err := a.svc.ListAvailabilityRuleUserIDs(ctx, organizationID)
	if err != nil {
		return false, err
	}
	return len(userIDs) > 0, nil
}

func (a *AppointmentSlotAdapter) GetAvailableSlots(ctx context.Context, organizationID uuid.UUID, startDate string, endDate string, slotDuration int) (*ports.PublicAvailableSlotsResponse, error) {
	userIDs, err := a.svc.ListAvailabilityRuleUserIDs(ctx, organizationID)
	if err != nil {
		return nil, err
	}
	if len(userIDs) == 0 {
		return &ports.PublicAvailableSlotsResponse{Days: []ports.PublicDaySlots{}}, nil
	}

	dayMap, err := a.collectAvailableSlots(ctx, organizationID, userIDs, startDate, endDate, slotDuration)
	if err != nil {
		return nil, err
	}

	return &ports.PublicAvailableSlotsResponse{Days: a.buildPublicDaySlots(dayMap)}, nil
}

func (a *AppointmentSlotAdapter) CreateRequestedAppointment(ctx context.Context, userID uuid.UUID, organizationID uuid.UUID, leadID uuid.UUID, leadServiceID uuid.UUID, startTime time.Time, endTime time.Time) (*ports.PublicAppointmentSummary, error) {
	allowed, err := a.isAllowedToBook(ctx, organizationID, userID)
	if err != nil {
		return nil, err
	}
	if !allowed {
		return nil, fmt.Errorf("user not available for booking")
	}

	sendEmail := false
	appt, err := a.svc.Create(ctx, userID, true, organizationID, transport.CreateAppointmentRequest{
		LeadID:                &leadID,
		LeadServiceID:         &leadServiceID,
		Type:                  transport.AppointmentTypeLeadVisit,
		Title:                 "Offerte inspectie",
		StartTime:             startTime,
		EndTime:               endTime,
		AllDay:                false,
		SendConfirmationEmail: &sendEmail,
	})
	if err != nil {
		return nil, err
	}

	_, err = a.svc.UpdateStatus(ctx, appt.ID, userID, true, organizationID, transport.UpdateAppointmentStatusRequest{
		Status: transport.AppointmentStatusRequested,
	})
	if err != nil {
		return nil, err
	}

	return a.toPublicAppointmentSummary(appt), nil
}

func (a *AppointmentSlotAdapter) isAllowedToBook(ctx context.Context, organizationID uuid.UUID, userID uuid.UUID) (bool, error) {
	userIDs, err := a.svc.ListAvailabilityRuleUserIDs(ctx, organizationID)
	if err != nil {
		return false, err
	}
	for _, id := range userIDs {
		if id == userID {
			return true, nil
		}
	}
	return false, nil
}

func (a *AppointmentSlotAdapter) toPublicAppointmentSummary(appt *transport.AppointmentResponse) *ports.PublicAppointmentSummary {
	return &ports.PublicAppointmentSummary{
		ID:        appt.ID,
		StartTime: appt.StartTime,
		EndTime:   appt.EndTime,
		Title:     appt.Title,
		Status:    string(appt.Status),
	}
}

func (a *AppointmentSlotAdapter) collectAvailableSlots(
	ctx context.Context,
	organizationID uuid.UUID,
	userIDs []uuid.UUID,
	startDate string,
	endDate string,
	slotDuration int,
) (map[string][]ports.PublicTimeSlot, error) {
	dayMap := make(map[string][]ports.PublicTimeSlot)
	seen := make(map[string]struct{})
	for _, userID := range userIDs {
		resp, err := a.svc.GetAvailableSlots(ctx, userID, true, organizationID, transport.GetAvailableSlotsRequest{
			StartDate:    startDate,
			EndDate:      endDate,
			SlotDuration: slotDuration,
		})
		if err != nil {
			return nil, err
		}
		for _, day := range resp.Days {
			for _, slot := range day.Slots {
				key := fmt.Sprintf("%s|%s|%s", day.Date, slot.StartTime.Format(time.RFC3339), slot.EndTime.Format(time.RFC3339))
				if _, exists := seen[key]; exists {
					continue
				}
				seen[key] = struct{}{}
				dayMap[day.Date] = append(dayMap[day.Date], ports.PublicTimeSlot{
					UserID:    userID,
					StartTime: slot.StartTime,
					EndTime:   slot.EndTime,
				})
			}
		}
	}

	return dayMap, nil
}

func (a *AppointmentSlotAdapter) buildPublicDaySlots(dayMap map[string][]ports.PublicTimeSlot) []ports.PublicDaySlots {
	keys := make([]string, 0, len(dayMap))
	for date := range dayMap {
		keys = append(keys, date)
	}
	sort.Strings(keys)

	result := make([]ports.PublicDaySlots, 0, len(keys))
	for _, date := range keys {
		slots := dayMap[date]
		sort.Slice(slots, func(i, j int) bool { return slots[i].StartTime.Before(slots[j].StartTime) })
		result = append(result, ports.PublicDaySlots{Date: date, Slots: slots})
	}

	return result
}

var _ ports.AppointmentSlotProvider = (*AppointmentSlotAdapter)(nil)
</file>

<file path="internal/adapters/public_viewers.go">
package adapters

import (
	"context"

	"portal_final_backend/internal/appointments/service"
	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/internal/leads/ports"
	quotesvc "portal_final_backend/internal/quotes/service"

	"github.com/google/uuid"
)

// QuotePublicAdapter exposes quote data for the public lead portal.
type QuotePublicAdapter struct {
	svc *quotesvc.Service
}

func NewQuotePublicAdapter(svc *quotesvc.Service) *QuotePublicAdapter {
	return &QuotePublicAdapter{svc: svc}
}

func (a *QuotePublicAdapter) GetActiveQuote(ctx context.Context, leadID, orgID uuid.UUID) (*ports.PublicQuoteSummary, error) {
	quote, err := a.svc.GetLatestNonDraftByLead(ctx, leadID, orgID)
	if err != nil || quote == nil {
		return nil, err
	}

	publicToken := ""
	if quote.PublicToken != nil {
		publicToken = *quote.PublicToken
	}

	return &ports.PublicQuoteSummary{
		ID:          quote.ID,
		QuoteNumber: quote.QuoteNumber,
		Status:      quote.Status,
		PublicToken: publicToken,
		TotalCents:  quote.TotalCents,
		PDFFileKey:  quote.PDFFileKey,
	}, nil
}

// AppointmentPublicAdapter exposes appointment data for the public lead portal.
type AppointmentPublicAdapter struct {
	svc *service.Service
}

func NewAppointmentPublicAdapter(svc *service.Service) *AppointmentPublicAdapter {
	return &AppointmentPublicAdapter{svc: svc}
}

func (a *AppointmentPublicAdapter) GetUpcomingVisit(ctx context.Context, leadID, orgID uuid.UUID) (*ports.PublicAppointmentSummary, error) {
	appt, err := a.svc.GetNextScheduledVisit(ctx, leadID, orgID)
	if err != nil || appt == nil {
		return nil, err
	}

	return &ports.PublicAppointmentSummary{
		ID:        appt.ID,
		StartTime: appt.StartTime,
		EndTime:   appt.EndTime,
		Title:     appt.Title,
		Status:    appt.Status,
	}, nil
}

func (a *AppointmentPublicAdapter) GetPendingVisit(ctx context.Context, leadID, orgID uuid.UUID) (*ports.PublicAppointmentSummary, error) {
	appt, err := a.svc.GetNextRequestedVisit(ctx, leadID, orgID)
	if err != nil || appt == nil {
		return nil, err
	}

	return &ports.PublicAppointmentSummary{
		ID:        appt.ID,
		StartTime: appt.StartTime,
		EndTime:   appt.EndTime,
		Title:     appt.Title,
		Status:    appt.Status,
	}, nil
}

func (a *AppointmentPublicAdapter) ListVisits(ctx context.Context, leadID, orgID uuid.UUID) ([]ports.PublicAppointmentSummary, error) {
	visits, err := a.svc.ListLeadVisitsByStatus(ctx, leadID, orgID, []transport.AppointmentStatus{
		transport.AppointmentStatusRequested,
		transport.AppointmentStatusScheduled,
	})
	if err != nil {
		return nil, err
	}

	items := make([]ports.PublicAppointmentSummary, 0, len(visits))
	for _, appt := range visits {
		items = append(items, ports.PublicAppointmentSummary{
			ID:        appt.ID,
			StartTime: appt.StartTime,
			EndTime:   appt.EndTime,
			Title:     appt.Title,
			Status:    appt.Status,
		})
	}

	return items, nil
}

var _ ports.QuotePublicViewer = (*QuotePublicAdapter)(nil)
var _ ports.AppointmentPublicViewer = (*AppointmentPublicAdapter)(nil)
</file>

<file path="internal/adapters/quote_acceptance_processor.go">
package adapters

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"log/slog"
	"strings"

	"portal_final_backend/internal/adapters/storage"
	identityrepo "portal_final_backend/internal/identity/repository"
	"portal_final_backend/internal/notification"
	"portal_final_backend/internal/pdf"
	"portal_final_backend/internal/quotes/repository"
	"portal_final_backend/internal/quotes/service"
	"portal_final_backend/internal/quotes/transport"

	"github.com/google/uuid"
)

// QuoteDataReader is the narrow interface the acceptance processor uses
// to read quote data and persist the PDF file key.
type QuoteDataReader interface {
	GetByID(ctx context.Context, id uuid.UUID, orgID uuid.UUID) (*repository.Quote, error)
	GetItemsByQuoteID(ctx context.Context, quoteID uuid.UUID, orgID uuid.UUID) ([]repository.QuoteItem, error)
	GetAttachmentsByQuoteID(ctx context.Context, quoteID uuid.UUID, orgID uuid.UUID) ([]repository.QuoteAttachment, error)
	GetURLsByQuoteID(ctx context.Context, quoteID uuid.UUID, orgID uuid.UUID) ([]repository.QuoteURL, error)
	SetPDFFileKey(ctx context.Context, quoteID uuid.UUID, fileKey string) error
}

// QuotePDFBucketConfig is the narrow config interface for the PDF bucket name.
type QuotePDFBucketConfig interface {
	GetMinioBucketQuotePDFs() string
	GetMinioBucketOrganizationLogos() string
	GetMinioBucketCatalogAssets() string
	GetMinioBucketQuoteAttachments() string
}

// QuoteOrgReader is the narrow interface for fetching organization profile data.
type QuoteOrgReader interface {
	GetOrganization(ctx context.Context, organizationID uuid.UUID) (identityrepo.Organization, error)
}

// QuoteAcceptanceProcessor implements notification.QuoteAcceptanceProcessor.
// It generates the quote PDF, uploads it to MinIO, and persists the file key.
type QuoteAcceptanceProcessor struct {
	repo           QuoteDataReader
	orgReader      QuoteOrgReader
	contactReader  service.QuoteContactReader
	storage        storage.StorageService
	cfg            QuotePDFBucketConfig
	settingsReader OrgSettingsReaderRepo
}

// NewQuoteAcceptanceProcessor creates a new processor adapter.
func NewQuoteAcceptanceProcessor(repo QuoteDataReader, orgReader QuoteOrgReader, contactReader service.QuoteContactReader, storageSvc storage.StorageService, cfg QuotePDFBucketConfig, settingsReader OrgSettingsReaderRepo) *QuoteAcceptanceProcessor {
	return &QuoteAcceptanceProcessor{
		repo:           repo,
		orgReader:      orgReader,
		contactReader:  contactReader,
		storage:        storageSvc,
		cfg:            cfg,
		settingsReader: settingsReader,
	}
}

// GenerateAndStorePDF builds the quote PDF, uploads it to storage,
// and persists the file key on the quote record.
func (p *QuoteAcceptanceProcessor) GenerateAndStorePDF(
	ctx context.Context,
	quoteID, organizationID uuid.UUID,
	orgName, customerName, signatureName string,
) (string, []byte, error) {
	// 1. Fetch quote and items
	quote, err := p.repo.GetByID(ctx, quoteID, organizationID)
	if err != nil {
		return "", nil, fmt.Errorf("fetch quote for PDF: %w", err)
	}

	items, err := p.repo.GetItemsByQuoteID(ctx, quoteID, organizationID)
	if err != nil {
		return "", nil, fmt.Errorf("fetch quote items for PDF: %w", err)
	}

	// 2. Fetch full organization profile
	org, orgErr := p.orgReader.GetOrganization(ctx, organizationID)

	// 3. Calculate totals + VAT breakdown using the service calculator
	calc := service.CalculateQuote(buildCalcRequest(items, quote))

	// 4. Build PDF data
	bc := pdfBuildContext{
		org:            org,
		orgErr:         orgErr,
		organizationID: organizationID,
		orgName:        orgName,
		customerName:   customerName,
		signatureName:  signatureName,
	}
	pdfData := p.buildPDFData(ctx, quote, items, calc, bc)

	// 5. Generate PDF bytes
	pdfBytes, err := pdf.GenerateQuotePDF(pdfData)
	if err != nil {
		return "", nil, fmt.Errorf("generate PDF: %w", err)
	}

	// 6. Upload and persist
	return p.uploadAndPersist(ctx, pdfBytes, quoteID, organizationID, quote.QuoteNumber)
}

// buildCalcRequest converts repository items + quote into a calculation request.
func buildCalcRequest(items []repository.QuoteItem, quote *repository.Quote) transport.QuoteCalculationRequest {
	itemReqs := make([]transport.QuoteItemRequest, len(items))
	for i, it := range items {
		itemReqs[i] = transport.QuoteItemRequest{
			Description:    it.Description,
			Quantity:       it.Quantity,
			UnitPriceCents: it.UnitPriceCents,
			TaxRateBps:     it.TaxRateBps,
			IsOptional:     it.IsOptional,
			IsSelected:     it.IsSelected,
		}
	}
	return transport.QuoteCalculationRequest{
		Items:         itemReqs,
		PricingMode:   quote.PricingMode,
		DiscountType:  quote.DiscountType,
		DiscountValue: quote.DiscountValue,
	}
}

// pdfBuildContext groups ancillary data needed to build the PDF model.
type pdfBuildContext struct {
	org            identityrepo.Organization
	orgErr         error
	organizationID uuid.UUID
	orgName        string
	customerName   string
	signatureName  string
}

// buildPDFData assembles the full QuotePDFData struct from all gathered data.
func (p *QuoteAcceptanceProcessor) buildPDFData(
	ctx context.Context,
	quote *repository.Quote,
	items []repository.QuoteItem,
	calc transport.QuoteCalculationResponse,
	bc pdfBuildContext,
) pdf.QuotePDFData {
	pdfItems := buildPDFItems(items, quote.PricingMode)

	var signatureImageBytes []byte
	if quote.SignatureData != nil && *quote.SignatureData != "" {
		signatureImageBytes = decodeSignatureDataURL(*quote.SignatureData)
	}

	logoBytes := p.downloadOrgLogo(ctx, bc.org, bc.orgErr, bc.organizationID)

	data := pdf.QuotePDFData{
		QuoteNumber:      quote.QuoteNumber,
		OrganizationName: bc.orgName,
		CustomerName:     bc.customerName,
		Status:           quote.Status,
		PricingMode:      quote.PricingMode,
		ValidUntil:       quote.ValidUntil,
		CreatedAt:        quote.CreatedAt,
		Notes:            quote.Notes,
		SignatureName:    &bc.signatureName,
		SignatureImage:   signatureImageBytes,
		AcceptedAt:       quote.AcceptedAt,
		Items:            pdfItems,
		SubtotalCents:    calc.SubtotalCents,
		DiscountAmount:   calc.DiscountAmountCents,
		TaxTotalCents:    calc.VatTotalCents,
		TotalCents:       calc.TotalCents,
		VatBreakdown:     calc.VatBreakdown,
		OrgLogo:          logoBytes,
		PaymentDays:      7,
		QuoteValidDays:   14,
	}

	if p.settingsReader != nil {
		settings, settingsErr := p.settingsReader.GetOrganizationSettings(ctx, bc.organizationID)
		if settingsErr == nil {
			data.PaymentDays = settings.QuotePaymentDays
			data.QuoteValidDays = settings.QuoteValidDays
		}
	}

	if bc.orgErr == nil {
		data.OrgEmail = derefStr(bc.org.Email)
		data.OrgPhone = derefStr(bc.org.Phone)
		data.OrgVatNumber = derefStr(bc.org.VatNumber)
		data.OrgKvkNumber = derefStr(bc.org.KvkNumber)
		data.OrgAddressLine1 = derefStr(bc.org.AddressLine1)
		data.OrgAddressLine2 = derefStr(bc.org.AddressLine2)
		data.OrgPostalCode = derefStr(bc.org.PostalCode)
		data.OrgCity = derefStr(bc.org.City)
		data.OrgCountry = derefStr(bc.org.Country)
	}

	// Load document attachments and download enabled PDFs from MinIO
	data.AttachmentPDFs = p.downloadEnabledAttachments(ctx, quote.ID, quote.OrganizationID)
	data.URLs = p.loadURLEntries(ctx, quote.ID, quote.OrganizationID)

	return data
}

// downloadOrgLogo fetches the organization logo from storage, returning nil on any failure.
func (p *QuoteAcceptanceProcessor) downloadOrgLogo(
	ctx context.Context,
	org identityrepo.Organization,
	orgErr error,
	organizationID uuid.UUID,
) []byte {
	if orgErr != nil {
		slog.Warn("could not fetch organization for logo", "error", orgErr)
		return nil
	}
	if org.LogoFileKey == nil || *org.LogoFileKey == "" {
		slog.Info("organization has no logo file key", "orgID", organizationID)
		return nil
	}

	logoBucket := p.cfg.GetMinioBucketOrganizationLogos()
	slog.Info("downloading org logo", "bucket", logoBucket, "key", *org.LogoFileKey)

	logoReader, dlErr := p.storage.DownloadFile(ctx, logoBucket, *org.LogoFileKey)
	if dlErr != nil {
		slog.Warn("logo download failed", "bucket", logoBucket, "key", *org.LogoFileKey, "error", dlErr)
		return nil
	}
	defer func() { _ = logoReader.Close() }()

	data, readErr := io.ReadAll(logoReader)
	if readErr != nil {
		slog.Warn("failed to read logo bytes", "key", *org.LogoFileKey, "error", readErr)
		return nil
	}
	if len(data) == 0 {
		slog.Warn("logo file is empty", "key", *org.LogoFileKey)
		return nil
	}

	slog.Info("logo loaded", "key", *org.LogoFileKey, "bytes", len(data))
	return data
}

// downloadEnabledAttachments fetches all enabled attachment PDFs from MinIO.
// Catalog-sourced attachments are read from the catalog-assets bucket;
// manually uploaded attachments are read from the quote-attachments bucket.
func (p *QuoteAcceptanceProcessor) downloadEnabledAttachments(ctx context.Context, quoteID, orgID uuid.UUID) []pdf.AttachmentPDFEntry {
	attachments, err := p.repo.GetAttachmentsByQuoteID(ctx, quoteID, orgID)
	if err != nil {
		slog.Warn("failed to load quote attachments", "quoteID", quoteID, "error", err)
		return nil
	}

	catalogBucket := p.cfg.GetMinioBucketCatalogAssets()
	manualBucket := p.cfg.GetMinioBucketQuoteAttachments()

	var result []pdf.AttachmentPDFEntry
	for _, att := range attachments {
		if !att.Enabled || att.FileKey == "" {
			continue
		}

		bucket := catalogBucket
		if att.Source == "manual" {
			bucket = manualBucket
		}

		reader, dlErr := p.storage.DownloadFile(ctx, bucket, att.FileKey)
		if dlErr != nil {
			slog.Warn("failed to download attachment PDF", "fileKey", att.FileKey, "error", dlErr)
			continue
		}
		data, readErr := io.ReadAll(reader)
		_ = reader.Close()
		if readErr != nil || len(data) == 0 {
			slog.Warn("empty or unreadable attachment PDF", "fileKey", att.FileKey)
			continue
		}

		result = append(result, pdf.AttachmentPDFEntry{
			Filename: att.Filename,
			PDFBytes: data,
		})
	}
	return result
}

// loadURLEntries converts stored quote URLs into PDF URL entries.
func (p *QuoteAcceptanceProcessor) loadURLEntries(ctx context.Context, quoteID, orgID uuid.UUID) []pdf.QuoteURLEntry {
	urls, err := p.repo.GetURLsByQuoteID(ctx, quoteID, orgID)
	if err != nil {
		slog.Warn("failed to load quote URLs", "quoteID", quoteID, "error", err)
		return nil
	}

	result := make([]pdf.QuoteURLEntry, len(urls))
	for i, u := range urls {
		result[i] = pdf.QuoteURLEntry{Label: u.Label, Href: u.Href}
	}
	return result
}

// uploadAndPersist uploads the PDF to MinIO and persists the file key on the quote record.
func (p *QuoteAcceptanceProcessor) uploadAndPersist(
	ctx context.Context,
	pdfBytes []byte,
	quoteID, organizationID uuid.UUID,
	quoteNumber string,
) (string, []byte, error) {
	bucket := p.cfg.GetMinioBucketQuotePDFs()
	folder := organizationID.String()
	fileName := fmt.Sprintf("%s.pdf", quoteNumber)
	reader := bytes.NewReader(pdfBytes)

	fileKey, err := p.storage.UploadFile(ctx, bucket, folder, fileName, "application/pdf", reader, int64(len(pdfBytes)))
	if err != nil {
		return "", nil, fmt.Errorf("upload PDF to storage: %w", err)
	}

	if err := p.repo.SetPDFFileKey(ctx, quoteID, fileKey); err != nil {
		return "", nil, fmt.Errorf("persist PDF file key: %w", err)
	}

	return fileKey, pdfBytes, nil
}

// derefStr safely dereferences a *string, returning "" if nil.
func derefStr(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

// buildPDFItems converts repository QuoteItems into transport PublicQuoteItemResponse
// suitable for the PDF generator, including per-line tax calculations.
func buildPDFItems(items []repository.QuoteItem, pricingMode string) []transport.PublicQuoteItemResponse {
	if pricingMode == "" {
		pricingMode = "exclusive"
	}

	result := make([]transport.PublicQuoteItemResponse, len(items))
	for i, it := range items {
		qty := parseQtyNumeric(it.Quantity)
		unitPrice := float64(it.UnitPriceCents)
		taxRateBps := it.TaxRateBps

		netUnitPrice := unitPrice
		if pricingMode == "inclusive" && taxRateBps > 0 {
			netUnitPrice = unitPrice / (1.0 + float64(taxRateBps)/10000.0)
		}

		lineSubtotal := qty * netUnitPrice
		lineVat := lineSubtotal * (float64(taxRateBps) / 10000.0)

		result[i] = transport.PublicQuoteItemResponse{
			ID:                  it.ID,
			Description:         it.Description,
			Quantity:            it.Quantity,
			UnitPriceCents:      it.UnitPriceCents,
			TaxRateBps:          it.TaxRateBps,
			IsOptional:          it.IsOptional,
			IsSelected:          it.IsSelected,
			SortOrder:           it.SortOrder,
			TotalBeforeTaxCents: roundC(lineSubtotal),
			TotalTaxCents:       roundC(lineVat),
			LineTotalCents:      roundC(lineSubtotal + lineVat),
		}
	}
	return result
}

// parseQtyNumeric parses a quantity string to a float64, defaulting to 1.
func parseQtyNumeric(q string) float64 {
	var f float64
	if _, err := fmt.Sscanf(q, "%f", &f); err != nil || f <= 0 {
		return 1
	}
	return f
}

// roundC rounds a float64 to the nearest cent.
func roundC(f float64) int64 {
	if f < 0 {
		return int64(f - 0.5)
	}
	return int64(f + 0.5)
}

// Compile-time check.
var _ notification.QuoteAcceptanceProcessor = (*QuoteAcceptanceProcessor)(nil)

// RegeneratePDF generates and stores the quote PDF on demand, looking up all
// required metadata (org name, customer name, signature name) from the database.
// This is used for lazy/on-demand PDF generation in download endpoints.
func (p *QuoteAcceptanceProcessor) RegeneratePDF(
	ctx context.Context,
	quoteID, organizationID uuid.UUID,
) (string, []byte, error) {
	// Fetch quote to get LeadID & SignatureName
	quote, err := p.repo.GetByID(ctx, quoteID, organizationID)
	if err != nil {
		return "", nil, fmt.Errorf("fetch quote for PDF regeneration: %w", err)
	}

	signatureName := ""
	if quote.SignatureName != nil {
		signatureName = *quote.SignatureName
	}

	// Resolve org name and customer name from the lead contact data
	orgName := ""
	customerName := signatureName // fallback to signature name
	if p.contactReader != nil {
		contactData, contactErr := p.contactReader.GetQuoteContactData(ctx, quote.LeadID, organizationID)
		if contactErr == nil {
			orgName = contactData.OrganizationName
			if contactData.ConsumerName != "" {
				customerName = contactData.ConsumerName
			}
		}
	}

	// Fallback: get org name from org reader if contact reader didn't provide it
	if orgName == "" {
		org, orgErr := p.orgReader.GetOrganization(ctx, organizationID)
		if orgErr == nil {
			orgName = org.Name
		}
	}

	return p.GenerateAndStorePDF(ctx, quoteID, organizationID, orgName, customerName, signatureName)
}

// decodeSignatureDataURL strips the "data:image/png;base64," prefix from
// a data URL and decodes the remaining base64 payload into raw PNG bytes.
// Returns nil if decoding fails (non-fatal  the PDF just won't have the image).
func decodeSignatureDataURL(dataURL string) []byte {
	// Strip the data URL prefix if present, e.g. "data:image/png;base64,iVBOR..."
	b64 := dataURL
	if idx := strings.Index(dataURL, ","); idx >= 0 {
		b64 = dataURL[idx+1:]
	}
	raw, err := base64.StdEncoding.DecodeString(b64)
	if err != nil {
		return nil
	}
	return raw
}
</file>

<file path="internal/adapters/quotes_draft_writer.go">
package adapters

import (
	"context"
	"fmt"

	"portal_final_backend/internal/leads/ports"
	quotesvc "portal_final_backend/internal/quotes/service"
)

// QuotesDraftWriter adapts the quotes service for the leads domain.
// It implements ports.QuoteDrafter by delegating to quotesvc.Service.DraftQuote.
type QuotesDraftWriter struct {
	svc *quotesvc.Service
}

// NewQuotesDraftWriter creates a new quote drafter adapter.
func NewQuotesDraftWriter(svc *quotesvc.Service) *QuotesDraftWriter {
	return &QuotesDraftWriter{svc: svc}
}

// DraftQuote translates the leads-domain DraftQuoteParams to the quotes-domain
// DraftQuoteParams and delegates to the quotes service.
func (a *QuotesDraftWriter) DraftQuote(ctx context.Context, params ports.DraftQuoteParams) (*ports.DraftQuoteResult, error) {
	svcItems := make([]quotesvc.DraftQuoteItemParams, len(params.Items))
	for i, it := range params.Items {
		svcItems[i] = quotesvc.DraftQuoteItemParams{
			Description:      it.Description,
			Quantity:         it.Quantity,
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			CatalogProductID: it.CatalogProductID,
		}
	}

	svcAttachments := make([]quotesvc.DraftQuoteAttachmentParams, len(params.Attachments))
	for i, att := range params.Attachments {
		svcAttachments[i] = quotesvc.DraftQuoteAttachmentParams{
			Filename:         att.Filename,
			FileKey:          att.FileKey,
			Source:           att.Source,
			CatalogProductID: att.CatalogProductID,
		}
	}

	svcURLs := make([]quotesvc.DraftQuoteURLParams, len(params.URLs))
	for i, u := range params.URLs {
		svcURLs[i] = quotesvc.DraftQuoteURLParams{
			Label:            u.Label,
			Href:             u.Href,
			CatalogProductID: u.CatalogProductID,
		}
	}

	result, err := a.svc.DraftQuote(ctx, quotesvc.DraftQuoteParams{
		QuoteID:        params.QuoteID,
		LeadID:         params.LeadID,
		LeadServiceID:  params.LeadServiceID,
		OrganizationID: params.OrganizationID,
		CreatedByID:    params.CreatedByID,
		Notes:          params.Notes,
		Items:          svcItems,
		Attachments:    svcAttachments,
		URLs:           svcURLs,
	})
	if err != nil {
		return nil, fmt.Errorf("quotes draft adapter: %w", err)
	}

	return &ports.DraftQuoteResult{
		QuoteID:     result.QuoteID,
		QuoteNumber: result.QuoteNumber,
		ItemCount:   result.ItemCount,
	}, nil
}

// Compile-time check that QuotesDraftWriter implements ports.QuoteDrafter.
var _ ports.QuoteDrafter = (*QuotesDraftWriter)(nil)
</file>

<file path="internal/appointments/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Appointment represents the appointment database model
type Appointment struct {
	ID             uuid.UUID  `db:"id"`
	OrganizationID uuid.UUID  `db:"organization_id"`
	UserID         uuid.UUID  `db:"user_id"`
	LeadID         *uuid.UUID `db:"lead_id"`
	LeadServiceID  *uuid.UUID `db:"lead_service_id"`
	Type           string     `db:"type"`
	Title          string     `db:"title"`
	Description    *string    `db:"description"`
	Location       *string    `db:"location"`
	MeetingLink    *string    `db:"meeting_link"`
	StartTime      time.Time  `db:"start_time"`
	EndTime        time.Time  `db:"end_time"`
	Status         string     `db:"status"`
	AllDay         bool       `db:"all_day"`
	CreatedAt      time.Time  `db:"created_at"`
	UpdatedAt      time.Time  `db:"updated_at"`
}

// LeadInfo represents basic lead information for embedding in appointment responses
type LeadInfo struct {
	ID          uuid.UUID `db:"id"`
	FirstName   string    `db:"first_name"`
	LastName    string    `db:"last_name"`
	Phone       string    `db:"phone"`
	Street      string    `db:"street"`
	HouseNumber string    `db:"house_number"`
	City        string    `db:"city"`
}

// Repository provides database operations for RAC_appointments
type Repository struct {
	pool *pgxpool.Pool
}

const appointmentNotFoundMsg = "appointment not found"

// New creates a new RAC_appointments repository
func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

// Create inserts a new appointment
func (r *Repository) Create(ctx context.Context, appt *Appointment) error {
	query := `
		INSERT INTO RAC_appointments (
			id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
			location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
		)`

	_, err := r.pool.Exec(ctx, query,
		appt.ID, appt.OrganizationID, appt.UserID, appt.LeadID, appt.LeadServiceID, appt.Type,
		appt.Title, appt.Description, appt.Location, appt.MeetingLink, appt.StartTime,
		appt.EndTime, appt.Status, appt.AllDay, appt.CreatedAt, appt.UpdatedAt,
	)
	if err != nil {
		return fmt.Errorf("failed to create appointment: %w", err)
	}

	return nil
}

// GetByID retrieves an appointment by its ID
func (r *Repository) GetByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (*Appointment, error) {
	var appt Appointment
	query := `SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
		location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments WHERE id = $1 AND organization_id = $2`

	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
		&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
		&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound(appointmentNotFoundMsg)
		}
		return nil, fmt.Errorf("failed to get appointment: %w", err)
	}

	return &appt, nil
}

// GetByLeadServiceID retrieves an appointment by lead service ID (for sync)
func (r *Repository) GetByLeadServiceID(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) (*Appointment, error) {
	var appt Appointment
	query := `SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
		location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments WHERE lead_service_id = $1 AND organization_id = $2 AND status != 'cancelled' ORDER BY created_at DESC LIMIT 1`

	err := r.pool.QueryRow(ctx, query, leadServiceID, organizationID).Scan(
		&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
		&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
		&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil // Not found is acceptable
		}
		return nil, fmt.Errorf("failed to get appointment by lead service: %w", err)
	}

	return &appt, nil
}

// GetNextScheduledVisit returns the next upcoming scheduled lead visit for a lead.
func (r *Repository) GetNextScheduledVisit(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*Appointment, error) {
	var appt Appointment
	queryUpcoming := `
		SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
			location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments
		WHERE lead_id = $1
			AND organization_id = $2
			AND type = 'lead_visit'
			AND status = 'scheduled'
			AND start_time > now()
		ORDER BY start_time ASC
		LIMIT 1
	`

	err := r.pool.QueryRow(ctx, queryUpcoming, leadID, organizationID).Scan(
		&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
		&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
		&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
	)
	if err != nil {
		if !errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("failed to get next scheduled visit: %w", err)
		}
		queryLatest := `
			SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
				location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
			FROM RAC_appointments
			WHERE lead_id = $1
				AND organization_id = $2
				AND type = 'lead_visit'
				AND status = 'scheduled'
			ORDER BY start_time DESC
			LIMIT 1
		`

		err = r.pool.QueryRow(ctx, queryLatest, leadID, organizationID).Scan(
			&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
			&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
			&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
		)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return nil, nil
			}
			return nil, fmt.Errorf("failed to get latest scheduled visit: %w", err)
		}
	}

	return &appt, nil
}

// GetNextRequestedVisit returns the next upcoming requested lead visit for a lead.
func (r *Repository) GetNextRequestedVisit(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*Appointment, error) {
	var appt Appointment
	query := `
		SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
			location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments
		WHERE lead_id = $1
			AND organization_id = $2
			AND type = 'lead_visit'
			AND status = 'requested'
		ORDER BY start_time ASC
		LIMIT 1
	`

	err := r.pool.QueryRow(ctx, query, leadID, organizationID).Scan(
		&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
		&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
		&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get requested appointment: %w", err)
	}

	return &appt, nil
}

// ListLeadVisitsByStatus returns lead visit appointments matching the provided statuses.
func (r *Repository) ListLeadVisitsByStatus(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID, statuses []string) ([]Appointment, error) {
	if len(statuses) == 0 {
		return []Appointment{}, nil
	}

	query := `
		SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
			location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments
		WHERE lead_id = $1
			AND organization_id = $2
			AND type = 'lead_visit'
			AND status = ANY($3)
		ORDER BY start_time ASC
	`

	rows, err := r.pool.Query(ctx, query, leadID, organizationID, statuses)
	if err != nil {
		return nil, fmt.Errorf("failed to list lead visits: %w", err)
	}
	defer rows.Close()

	items := make([]Appointment, 0)
	for rows.Next() {
		var appt Appointment
		if err := rows.Scan(
			&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
			&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
			&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan lead visit: %w", err)
		}
		items = append(items, appt)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate lead visits: %w", err)
	}

	return items, nil
}

// Update updates an existing appointment
func (r *Repository) Update(ctx context.Context, appt *Appointment) error {
	query := `
		UPDATE RAC_appointments SET
			title = $2,
			description = $3,
			location = $4,
			meeting_link = $5,
			start_time = $6,
			end_time = $7,
			all_day = $8,
			updated_at = $9
		WHERE id = $1 AND organization_id = $10`

	result, err := r.pool.Exec(ctx, query,
		appt.ID, appt.Title, appt.Description, appt.Location, appt.MeetingLink,
		appt.StartTime, appt.EndTime, appt.AllDay, appt.UpdatedAt, appt.OrganizationID,
	)
	if err != nil {
		return fmt.Errorf("failed to update appointment: %w", err)
	}

	if result.RowsAffected() == 0 {
		return apperr.NotFound(appointmentNotFoundMsg)
	}

	return nil
}

// UpdateStatus updates the status of an appointment
func (r *Repository) UpdateStatus(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, status string) error {
	query := `UPDATE RAC_appointments SET status = $3, updated_at = $4 WHERE id = $1 AND organization_id = $2`

	result, err := r.pool.Exec(ctx, query, id, organizationID, status, time.Now())
	if err != nil {
		return fmt.Errorf("failed to update appointment status: %w", err)
	}

	if result.RowsAffected() == 0 {
		return apperr.NotFound(appointmentNotFoundMsg)
	}

	return nil
}

// Delete removes an appointment
func (r *Repository) Delete(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	query := `DELETE FROM RAC_appointments WHERE id = $1 AND organization_id = $2`

	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("failed to delete appointment: %w", err)
	}

	if result.RowsAffected() == 0 {
		return apperr.NotFound(appointmentNotFoundMsg)
	}

	return nil
}

// ListParams contains parameters for listing RAC_appointments
type ListParams struct {
	OrganizationID uuid.UUID
	UserID         *uuid.UUID
	LeadID         *uuid.UUID
	Type           *string
	Status         *string
	StartFrom      *time.Time
	StartTo        *time.Time
	Search         string
	SortBy         string
	SortOrder      string
	Page           int
	PageSize       int
}

// ListResult contains the result of listing RAC_appointments
type ListResult struct {
	Items      []Appointment
	Total      int
	Page       int
	PageSize   int
	TotalPages int
}

// List retrieves RAC_appointments with optional filtering
func (r *Repository) List(ctx context.Context, params ListParams) (*ListResult, error) {
	filters := appointmentListFilters{
		userID:    optionalParam(params.UserID),
		leadID:    optionalParam(params.LeadID),
		typeValue: optionalParam(params.Type),
		status:    optionalParam(params.Status),
		startFrom: optionalParam(params.StartFrom),
		startTo:   optionalParam(params.StartTo),
		search:    optionalSearchParam(params.Search),
	}

	sortBy, err := resolveAppointmentSortBy(params.SortBy)
	if err != nil {
		return nil, err
	}

	sortOrder, err := resolveAppointmentSortOrder(params.SortOrder)
	if err != nil {
		return nil, err
	}

	baseQuery := `
		FROM RAC_appointments
		WHERE organization_id = $1
			AND ($2::uuid IS NULL OR user_id = $2)
			AND ($3::uuid IS NULL OR lead_id = $3)
			AND ($4::text IS NULL OR type = $4)
			AND ($5::text IS NULL OR status = $5)
			AND ($6::timestamptz IS NULL OR start_time >= $6)
			AND ($7::timestamptz IS NULL OR start_time <= $7)
			AND ($8::text IS NULL OR title ILIKE $8 OR location ILIKE $8 OR meeting_link ILIKE $8)
	`
	args := []interface{}{
		params.OrganizationID,
		filters.userID,
		filters.leadID,
		filters.typeValue,
		filters.status,
		filters.startFrom,
		filters.startTo,
		filters.search,
	}

	var total int
	countQuery := "SELECT COUNT(*) " + baseQuery
	if err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, fmt.Errorf("failed to count RAC_appointments: %w", err)
	}

	totalPages := (total + params.PageSize - 1) / params.PageSize
	offset := (params.Page - 1) * params.PageSize

	selectQuery := `SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
		location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		` + baseQuery + `
		ORDER BY
			CASE WHEN $9 = 'title' AND $10 = 'asc' THEN title END ASC,
			CASE WHEN $9 = 'title' AND $10 = 'desc' THEN title END DESC,
			CASE WHEN $9 = 'type' AND $10 = 'asc' THEN type END ASC,
			CASE WHEN $9 = 'type' AND $10 = 'desc' THEN type END DESC,
			CASE WHEN $9 = 'status' AND $10 = 'asc' THEN status END ASC,
			CASE WHEN $9 = 'status' AND $10 = 'desc' THEN status END DESC,
			CASE WHEN $9 = 'startTime' AND $10 = 'asc' THEN start_time END ASC,
			CASE WHEN $9 = 'startTime' AND $10 = 'desc' THEN start_time END DESC,
			CASE WHEN $9 = 'endTime' AND $10 = 'asc' THEN end_time END ASC,
			CASE WHEN $9 = 'endTime' AND $10 = 'desc' THEN end_time END DESC,
			CASE WHEN $9 = 'createdAt' AND $10 = 'asc' THEN created_at END ASC,
			CASE WHEN $9 = 'createdAt' AND $10 = 'desc' THEN created_at END DESC,
			start_time ASC
		LIMIT $11 OFFSET $12`

	args = append(args, sortBy, sortOrder, params.PageSize, offset)

	rows, err := r.pool.Query(ctx, selectQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list RAC_appointments: %w", err)
	}
	defer rows.Close()

	var items []Appointment
	for rows.Next() {
		var appt Appointment
		if err := rows.Scan(
			&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
			&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
			&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan appointment: %w", err)
		}
		items = append(items, appt)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate RAC_appointments: %w", err)
	}

	return &ListResult{
		Items:      items,
		Total:      total,
		Page:       params.Page,
		PageSize:   params.PageSize,
		TotalPages: totalPages,
	}, nil
}

type appointmentListFilters struct {
	userID    interface{}
	leadID    interface{}
	typeValue interface{}
	status    interface{}
	startFrom interface{}
	startTo   interface{}
	search    interface{}
}

func optionalParam[T any](value *T) interface{} {
	if value == nil {
		return nil
	}
	return *value
}

func optionalSearchParam(value string) interface{} {
	if value == "" {
		return nil
	}
	return "%" + value + "%"
}

func resolveAppointmentSortBy(sortBy string) (string, error) {
	if sortBy == "" {
		return "startTime", nil
	}
	switch sortBy {
	case "title", "type", "status", "startTime", "endTime", "createdAt":
		return sortBy, nil
	default:
		return "", apperr.BadRequest("invalid sort field")
	}
}

func resolveAppointmentSortOrder(sortOrder string) (string, error) {
	if sortOrder == "" {
		return "asc", nil
	}
	switch sortOrder {
	case "asc", "desc":
		return sortOrder, nil
	default:
		return "", apperr.BadRequest("invalid sort order")
	}
}

// GetLeadInfo retrieves basic lead information for embedding in appointment responses
func (r *Repository) GetLeadInfo(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*LeadInfo, error) {
	var info LeadInfo
	query := `SELECT id, consumer_first_name, consumer_last_name, consumer_phone, address_street, address_house_number, address_city 
		FROM RAC_leads WHERE id = $1 AND organization_id = $2`

	err := r.pool.QueryRow(ctx, query, leadID, organizationID).Scan(
		&info.ID, &info.FirstName, &info.LastName, &info.Phone,
		&info.Street, &info.HouseNumber, &info.City,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get lead info: %w", err)
	}

	return &info, nil
}

// GetLeadEmail retrieves the email for a lead
func (r *Repository) GetLeadEmail(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (string, error) {
	var email string
	query := `SELECT COALESCE(consumer_email, '') FROM RAC_leads WHERE id = $1 AND organization_id = $2`

	err := r.pool.QueryRow(ctx, query, leadID, organizationID).Scan(&email)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return "", nil
		}
		return "", fmt.Errorf("failed to get lead email: %w", err)
	}

	return email, nil
}

// GetLeadInfoBatch retrieves lead info for multiple lead IDs
func (r *Repository) GetLeadInfoBatch(ctx context.Context, leadIDs []uuid.UUID, organizationID uuid.UUID) (map[uuid.UUID]*LeadInfo, error) {
	if len(leadIDs) == 0 {
		return make(map[uuid.UUID]*LeadInfo), nil
	}

	query := `SELECT id, consumer_first_name, consumer_last_name, consumer_phone, address_street, address_house_number, address_city 
		FROM RAC_leads WHERE id = ANY($1) AND organization_id = $2`

	rows, err := r.pool.Query(ctx, query, leadIDs, organizationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get lead info batch: %w", err)
	}
	defer rows.Close()

	result := make(map[uuid.UUID]*LeadInfo)
	for rows.Next() {
		var info LeadInfo
		if err := rows.Scan(
			&info.ID, &info.FirstName, &info.LastName, &info.Phone,
			&info.Street, &info.HouseNumber, &info.City,
		); err != nil {
			return nil, fmt.Errorf("failed to scan lead info: %w", err)
		}
		result[info.ID] = &info
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate RAC_leads: %w", err)
	}

	return result, nil
}

// ListForDateRange retrieves all RAC_appointments for a user within a date range (for slots computation)
// Uses proper overlap detection: an appointment overlaps if it starts before the window ends AND ends after the window starts
func (r *Repository) ListForDateRange(ctx context.Context, organizationID uuid.UUID, userID uuid.UUID, startDate, endDate time.Time) ([]Appointment, error) {
	query := `SELECT id, organization_id, user_id, lead_id, lead_service_id, type, title, description,
		location, meeting_link, start_time, end_time, status, all_day, created_at, updated_at
		FROM RAC_appointments 
		WHERE organization_id = $1 AND user_id = $2 
		AND start_time < $4 AND end_time > $3
		AND status = 'scheduled'
		ORDER BY start_time ASC`

	rows, err := r.pool.Query(ctx, query, organizationID, userID, startDate, endDate)
	if err != nil {
		return nil, fmt.Errorf("failed to list RAC_appointments for date range: %w", err)
	}
	defer rows.Close()

	var items []Appointment
	for rows.Next() {
		var appt Appointment
		if err := rows.Scan(
			&appt.ID, &appt.OrganizationID, &appt.UserID, &appt.LeadID, &appt.LeadServiceID, &appt.Type,
			&appt.Title, &appt.Description, &appt.Location, &appt.MeetingLink, &appt.StartTime,
			&appt.EndTime, &appt.Status, &appt.AllDay, &appt.CreatedAt, &appt.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan appointment: %w", err)
		}
		items = append(items, appt)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate RAC_appointments: %w", err)
	}

	return items, nil
}

// ToResponse converts an Appointment to AppointmentResponse
func (a *Appointment) ToResponse(leadInfo *transport.AppointmentLeadInfo) transport.AppointmentResponse {
	resp := transport.AppointmentResponse{
		ID:            a.ID,
		UserID:        a.UserID,
		LeadID:        a.LeadID,
		LeadServiceID: a.LeadServiceID,
		Type:          transport.AppointmentType(a.Type),
		Title:         a.Title,
		Description:   a.Description,
		Location:      a.Location,
		MeetingLink:   a.MeetingLink,
		StartTime:     a.StartTime,
		EndTime:       a.EndTime,
		Status:        transport.AppointmentStatus(a.Status),
		AllDay:        a.AllDay,
		CreatedAt:     a.CreatedAt,
		UpdatedAt:     a.UpdatedAt,
		Lead:          leadInfo,
	}
	return resp
}
</file>

<file path="internal/catalog/transport/dto.go">
package transport

import "github.com/google/uuid"

// VAT Rates

type CreateVatRateRequest struct {
	Name    string `json:"name" validate:"required,min=1,max=100"`
	RateBps *int   `json:"rateBps" validate:"required,min=0,max=10000"`
}

type UpdateVatRateRequest struct {
	Name    *string `json:"name,omitempty" validate:"omitempty,min=1,max=100"`
	RateBps *int    `json:"rateBps,omitempty" validate:"omitempty,min=0,max=10000"`
}

type ListVatRatesRequest struct {
	Search    string `form:"search" validate:"max=100"`
	Page      int    `form:"page" validate:"omitempty,min=1"`
	PageSize  int    `form:"pageSize" validate:"omitempty,min=1,max=100"`
	SortBy    string `form:"sortBy" validate:"omitempty,oneof=name rateBps createdAt updatedAt"`
	SortOrder string `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
}

type VatRateResponse struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	RateBps   int       `json:"rateBps"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
}

type VatRateListResponse struct {
	Items      []VatRateResponse `json:"items"`
	Total      int               `json:"total"`
	Page       int               `json:"page"`
	PageSize   int               `json:"pageSize"`
	TotalPages int               `json:"totalPages"`
}

// Products

type CreateProductRequest struct {
	Title          string    `json:"title" validate:"required,min=1,max=200"`
	Reference      string    `json:"reference" validate:"required,min=1,max=100"`
	Description    *string   `json:"description,omitempty" validate:"omitempty,max=1000"`
	PriceCents     int64     `json:"priceCents" validate:"min=0"`
	UnitPriceCents int64     `json:"unitPriceCents,omitempty" validate:"min=0"`
	UnitLabel      *string   `json:"unitLabel,omitempty" validate:"omitempty,max=50"`
	LaborTimeText  *string   `json:"laborTimeText,omitempty" validate:"omitempty,max=100"`
	VatRateID      uuid.UUID `json:"vatRateId" validate:"required"`
	Type           string    `json:"type" validate:"required,oneof=digital_service service product material"`
	PeriodCount    *int      `json:"periodCount,omitempty" validate:"omitempty,min=1"`
	PeriodUnit     *string   `json:"periodUnit,omitempty" validate:"omitempty,oneof=day week month quarter year"`
}

type UpdateProductRequest struct {
	Title          *string    `json:"title,omitempty" validate:"omitempty,min=1,max=200"`
	Reference      *string    `json:"reference,omitempty" validate:"omitempty,min=1,max=100"`
	Description    *string    `json:"description,omitempty" validate:"omitempty,max=1000"`
	PriceCents     *int64     `json:"priceCents,omitempty" validate:"omitempty,min=0"`
	UnitPriceCents *int64     `json:"unitPriceCents,omitempty" validate:"omitempty,min=0"`
	UnitLabel      *string    `json:"unitLabel,omitempty" validate:"omitempty,max=50"`
	LaborTimeText  *string    `json:"laborTimeText,omitempty" validate:"omitempty,max=100"`
	VatRateID      *uuid.UUID `json:"vatRateId,omitempty" validate:"omitempty"`
	Type           *string    `json:"type,omitempty" validate:"omitempty,oneof=digital_service service product material"`
	PeriodCount    *int       `json:"periodCount,omitempty" validate:"omitempty,min=1"`
	PeriodUnit     *string    `json:"periodUnit,omitempty" validate:"omitempty,oneof=day week month quarter year"`
}

type ListProductsRequest struct {
	Search        string `form:"search" validate:"max=100"`
	Title         string `form:"title" validate:"omitempty,max=200"`
	Reference     string `form:"reference" validate:"omitempty,max=100"`
	Type          string `form:"type" validate:"omitempty,oneof=digital_service service product material"`
	VatRateID     string `form:"vatRateId" validate:"omitempty"`
	CreatedAtFrom string `form:"createdAtFrom" validate:"omitempty,max=50"`
	CreatedAtTo   string `form:"createdAtTo" validate:"omitempty,max=50"`
	UpdatedAtFrom string `form:"updatedAtFrom" validate:"omitempty,max=50"`
	UpdatedAtTo   string `form:"updatedAtTo" validate:"omitempty,max=50"`
	Page          int    `form:"page" validate:"omitempty,min=1"`
	PageSize      int    `form:"pageSize" validate:"omitempty,min=1,max=100"`
	SortBy        string `form:"sortBy" validate:"omitempty,oneof=title reference priceCents type vatRateId createdAt updatedAt"`
	SortOrder     string `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
}

type ProductResponse struct {
	ID             uuid.UUID `json:"id"`
	VatRateID      uuid.UUID `json:"vatRateId"`
	Title          string    `json:"title"`
	Reference      string    `json:"reference"`
	Description    *string   `json:"description,omitempty"`
	PriceCents     int64     `json:"priceCents"`
	UnitPriceCents int64     `json:"unitPriceCents"`
	UnitLabel      *string   `json:"unitLabel,omitempty"`
	LaborTimeText  *string   `json:"laborTimeText,omitempty"`
	Type           string    `json:"type"`
	PeriodCount    *int      `json:"periodCount,omitempty"`
	PeriodUnit     *string   `json:"periodUnit,omitempty"`
	CreatedAt      string    `json:"createdAt"`
	UpdatedAt      string    `json:"updatedAt"`
}

type ProductListResponse struct {
	Items      []ProductResponse `json:"items"`
	Total      int               `json:"total"`
	Page       int               `json:"page"`
	PageSize   int               `json:"pageSize"`
	TotalPages int               `json:"totalPages"`
}

// Assets

type PresignCatalogAssetRequest struct {
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=255"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
	AssetType   string `json:"assetType" validate:"required,oneof=image document"`
}

type PresignedUploadResponse struct {
	UploadURL string `json:"uploadUrl"`
	FileKey   string `json:"fileKey"`
	ExpiresAt int64  `json:"expiresAt"`
}

type CreateCatalogAssetRequest struct {
	AssetType   string `json:"assetType" validate:"required,oneof=image document"`
	FileKey     string `json:"fileKey" validate:"required,min=1"`
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,min=1,max=255"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

type CreateCatalogURLAssetRequest struct {
	AssetType string  `json:"assetType" validate:"required,oneof=terms_url"`
	URL       string  `json:"url" validate:"required,url,max=2048"`
	Label     *string `json:"label,omitempty" validate:"omitempty,max=255"`
}

type CatalogAssetResponse struct {
	ID          uuid.UUID `json:"id"`
	ProductID   uuid.UUID `json:"productId"`
	AssetType   string    `json:"assetType"`
	FileKey     *string   `json:"fileKey,omitempty"`
	FileName    *string   `json:"fileName,omitempty"`
	ContentType *string   `json:"contentType,omitempty"`
	SizeBytes   *int64    `json:"sizeBytes,omitempty"`
	URL         *string   `json:"url,omitempty"`
	CreatedAt   string    `json:"createdAt"`
}

type CatalogAssetListResponse struct {
	Items []CatalogAssetResponse `json:"items"`
}

type PresignedDownloadResponse struct {
	DownloadURL string `json:"downloadUrl"`
	ExpiresAt   *int64 `json:"expiresAt,omitempty"`
}

//  Autocomplete Search 

type AutocompleteSearchRequest struct {
	Query string `form:"q" validate:"required,min=1,max=200"`
	Limit int    `form:"limit" validate:"omitempty,min=1,max=20"`
}

type AutocompleteDocumentResponse struct {
	ID       uuid.UUID `json:"id"`
	Filename string    `json:"filename"`
	FileKey  string    `json:"fileKey"`
}

type AutocompleteURLResponse struct {
	Label string `json:"label"`
	Href  string `json:"href"`
}

type AutocompleteItemResponse struct {
	ID             uuid.UUID                      `json:"id"`
	Title          string                         `json:"title"`
	Description    *string                        `json:"description,omitempty"`
	PriceCents     int64                          `json:"priceCents"`
	UnitPriceCents int64                          `json:"unitPriceCents"`
	UnitLabel      *string                        `json:"unitLabel,omitempty"`
	VatRateID      uuid.UUID                      `json:"vatRateId"`
	VatRateBps     int                            `json:"vatRateBps"`
	Documents      []AutocompleteDocumentResponse `json:"documents"`
	URLs           []AutocompleteURLResponse      `json:"urls"`
}

// Materials

type ProductMaterialsRequest struct {
	MaterialIDs []uuid.UUID `json:"materialIds" validate:"required,min=1,dive,required"`
}
</file>

<file path="internal/email/brevo.go">
package email

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"portal_final_backend/platform/config"
)

// Attachment represents a file attachment for an email.
type Attachment struct {
	Content  []byte // raw file bytes (will be base64-encoded for Brevo)
	FileName string // e.g. "offerte-Q-00042.pdf"
	MIMEType string // e.g. "application/pdf"
}

type Sender interface {
	SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error
	SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error
	SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error
	SendOrganizationInviteEmail(ctx context.Context, toEmail, organizationName, inviteURL string) error
	SendPartnerInviteEmail(ctx context.Context, toEmail, organizationName, partnerName, inviteURL string) error
	SendQuoteProposalEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber, proposalURL string) error
	SendQuoteAcceptedEmail(ctx context.Context, toEmail, agentName, quoteNumber, consumerName string, totalCents int64) error
	SendQuoteAcceptedThankYouEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber string, attachments ...Attachment) error
	SendPartnerOfferAcceptedEmail(ctx context.Context, toEmail, partnerName, offerID string) error
	SendPartnerOfferAcceptedConfirmationEmail(ctx context.Context, toEmail, partnerName string) error
	SendPartnerOfferRejectedEmail(ctx context.Context, toEmail, partnerName, offerID, reason string) error
}

type NoopSender struct{}

func (NoopSender) SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error {
	return nil
}

func (NoopSender) SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error {
	return nil
}

func (NoopSender) SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error {
	return nil
}

func (NoopSender) SendOrganizationInviteEmail(ctx context.Context, toEmail, organizationName, inviteURL string) error {
	return nil
}

func (NoopSender) SendPartnerInviteEmail(ctx context.Context, toEmail, organizationName, partnerName, inviteURL string) error {
	return nil
}

func (NoopSender) SendQuoteProposalEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber, proposalURL string) error {
	return nil
}

func (NoopSender) SendQuoteAcceptedEmail(ctx context.Context, toEmail, agentName, quoteNumber, consumerName string, totalCents int64) error {
	return nil
}

func (NoopSender) SendQuoteAcceptedThankYouEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber string, attachments ...Attachment) error {
	return nil
}

func (NoopSender) SendPartnerOfferAcceptedEmail(ctx context.Context, toEmail, partnerName, offerID string) error {
	return nil
}

func (NoopSender) SendPartnerOfferAcceptedConfirmationEmail(ctx context.Context, toEmail, partnerName string) error {
	return nil
}

func (NoopSender) SendPartnerOfferRejectedEmail(ctx context.Context, toEmail, partnerName, offerID, reason string) error {
	return nil
}

type BrevoSender struct {
	apiKey    string
	fromName  string
	fromEmail string
	client    *http.Client
}

const inviteTitle = "U bent uitgenodigd"

type brevoAttachment struct {
	Content string `json:"content"` // base64-encoded file content
	Name    string `json:"name"`
}

type brevoEmailRequest struct {
	Sender struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	} `json:"sender"`
	To []struct {
		Email string `json:"email"`
	} `json:"to"`
	Subject     string            `json:"subject"`
	HTMLContent string            `json:"htmlContent"`
	Attachment  []brevoAttachment `json:"attachment,omitempty"`
}

func NewSender(cfg config.EmailConfig) (Sender, error) {
	if !cfg.GetEmailEnabled() {
		return NoopSender{}, nil
	}

	client := &http.Client{Timeout: 10 * time.Second}
	return &BrevoSender{
		apiKey:    cfg.GetBrevoAPIKey(),
		fromName:  cfg.GetEmailFromName(),
		fromEmail: cfg.GetEmailFromAddress(),
		client:    client,
	}, nil
}

func (b *BrevoSender) SendVerificationEmail(ctx context.Context, toEmail, verifyURL string) error {
	subject := subjectVerification
	content, err := renderEmailTemplate("verification.html", verificationEmailData{
		baseEmailData: baseEmailData{
			Title:    "Bevestig uw e-mailadres",
			Heading:  "Bevestig uw e-mailadres",
			CTALabel: "E-mailadres verifiren",
			CTAURL:   verifyURL,
		},
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendPasswordResetEmail(ctx context.Context, toEmail, resetURL string) error {
	subject := subjectPasswordReset
	content, err := renderEmailTemplate("password_reset.html", passwordResetEmailData{
		baseEmailData: baseEmailData{
			Title:    "Wachtwoord opnieuw instellen",
			Heading:  "Wachtwoord opnieuw instellen",
			CTALabel: "Wachtwoord resetten",
			CTAURL:   resetURL,
		},
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendVisitInviteEmail(ctx context.Context, toEmail, consumerName, scheduledDate, address string) error {
	subject := subjectVisitInvite
	content, err := renderEmailTemplate("visit_invite.html", visitInviteEmailData{
		baseEmailData: baseEmailData{
			Title:   "Bezoek ingepland",
			Heading: "Bezoek ingepland",
		},
		ConsumerName:  consumerName,
		ScheduledDate: scheduledDate,
		Address:       address,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendOrganizationInviteEmail(ctx context.Context, toEmail, organizationName, inviteURL string) error {
	subject := fmt.Sprintf(subjectOrganizationInviteFmt, organizationName)
	content, err := renderEmailTemplate("organization_invite.html", organizationInviteEmailData{
		baseEmailData: baseEmailData{
			Title:    inviteTitle,
			Heading:  inviteTitle,
			CTALabel: "Uitnodiging accepteren",
			CTAURL:   inviteURL,
		},
		OrganizationName: organizationName,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendPartnerInviteEmail(ctx context.Context, toEmail, organizationName, partnerName, inviteURL string) error {
	subject := fmt.Sprintf(subjectPartnerInviteFmt, organizationName)
	content, err := renderEmailTemplate("partner_invite.html", partnerInviteEmailData{
		baseEmailData: baseEmailData{
			Title:    inviteTitle,
			Heading:  inviteTitle,
			CTALabel: "Uitnodiging bekijken",
			CTAURL:   inviteURL,
		},
		OrganizationName: organizationName,
		PartnerName:      partnerName,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendQuoteProposalEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber, proposalURL string) error {
	subject := fmt.Sprintf(subjectQuoteProposalFmt, quoteNumber, organizationName)
	content, err := renderEmailTemplate("quote_proposal.html", quoteProposalEmailData{
		baseEmailData: baseEmailData{
			Title:    "Uw offerte is klaar",
			Heading:  "Uw offerte is klaar",
			CTALabel: "Bekijk offerte",
			CTAURL:   proposalURL,
		},
		ConsumerName:     consumerName,
		OrganizationName: organizationName,
		QuoteNumber:      quoteNumber,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendQuoteAcceptedEmail(ctx context.Context, toEmail, agentName, quoteNumber, consumerName string, totalCents int64) error {
	subject := fmt.Sprintf(subjectQuoteAcceptedFmt, quoteNumber)
	content, err := renderEmailTemplate("quote_accepted.html", quoteAcceptedEmailData{
		baseEmailData: baseEmailData{
			Title:   "Offerte geaccepteerd",
			Heading: "Offerte geaccepteerd",
		},
		AgentName:      agentName,
		QuoteNumber:    quoteNumber,
		ConsumerName:   consumerName,
		TotalFormatted: formatCurrencyEUR(totalCents),
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendQuoteAcceptedThankYouEmail(ctx context.Context, toEmail, consumerName, organizationName, quoteNumber string, attachments ...Attachment) error {
	subject := fmt.Sprintf(subjectQuoteAcceptedThankYouFmt, quoteNumber)
	content, err := renderEmailTemplate("quote_thank_you.html", quoteAcceptedThankYouEmailData{
		baseEmailData: baseEmailData{
			Title:   "Bedankt voor uw akkoord",
			Heading: "Bedankt voor uw akkoord",
		},
		ConsumerName:     consumerName,
		OrganizationName: organizationName,
		QuoteNumber:      quoteNumber,
		HasAttachments:   len(attachments) > 0,
	})
	if err != nil {
		return err
	}
	return b.sendWithAttachments(ctx, toEmail, subject, content, attachments...)
}

func (b *BrevoSender) SendPartnerOfferAcceptedEmail(ctx context.Context, toEmail, partnerName, offerID string) error {
	subject := fmt.Sprintf(subjectPartnerOfferAcceptedFmt, partnerName)
	content, err := renderEmailTemplate("partner_offer_accepted.html", partnerOfferAcceptedEmailData{
		baseEmailData: baseEmailData{
			Title:   "Werkaanbod geaccepteerd",
			Heading: "Werkaanbod geaccepteerd",
		},
		PartnerName: partnerName,
		OfferID:     offerID,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendPartnerOfferAcceptedConfirmationEmail(ctx context.Context, toEmail, partnerName string) error {
	subject := subjectPartnerOfferAcceptedConfirmation
	content, err := renderEmailTemplate("partner_offer_confirmation.html", partnerOfferAcceptedConfirmationEmailData{
		baseEmailData: baseEmailData{
			Title:   "Acceptatie bevestigd",
			Heading: "Acceptatie bevestigd",
		},
		PartnerName: partnerName,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) SendPartnerOfferRejectedEmail(ctx context.Context, toEmail, partnerName, offerID, reason string) error {
	subject := fmt.Sprintf(subjectPartnerOfferRejectedFmt, partnerName)
	content, err := renderEmailTemplate("partner_offer_rejected.html", partnerOfferRejectedEmailData{
		baseEmailData: baseEmailData{
			Title:   "Werkaanbod afgewezen",
			Heading: "Werkaanbod afgewezen",
		},
		PartnerName: partnerName,
		OfferID:     offerID,
		Reason:      reason,
	})
	if err != nil {
		return err
	}
	return b.send(ctx, toEmail, subject, content)
}

func (b *BrevoSender) send(ctx context.Context, toEmail, subject, htmlContent string) error {
	return b.sendWithAttachments(ctx, toEmail, subject, htmlContent)
}

func (b *BrevoSender) sendWithAttachments(ctx context.Context, toEmail, subject, htmlContent string, attachments ...Attachment) error {
	payload := brevoEmailRequest{
		Subject:     subject,
		HTMLContent: htmlContent,
	}
	payload.Sender.Name = b.fromName
	payload.Sender.Email = b.fromEmail
	payload.To = []struct {
		Email string `json:"email"`
	}{{Email: toEmail}}

	for _, att := range attachments {
		payload.Attachment = append(payload.Attachment, brevoAttachment{
			Content: base64.StdEncoding.EncodeToString(att.Content),
			Name:    att.FileName,
		})
	}

	body, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, "https://api.brevo.com/v3/smtp/email", bytes.NewReader(body))
	if err != nil {
		return err
	}
	req.Header.Set("api-key", b.apiKey)
	req.Header.Set("content-type", "application/json")
	req.Header.Set("accept", "application/json")

	resp, err := b.client.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("brevo send failed: status %d: %s", resp.StatusCode, string(data))
	}

	return nil
}
</file>

<file path="internal/http/router/router.go">
package router

import (
	"context"
	"net/http"
	"strings"
	"time"

	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"golang.org/x/time/rate"
)

// New creates a new Gin router with all middleware and module routes registered.
// The App struct contains all pre-initialized modules from the composition root (main.go).
// This keeps the router focused solely on HTTP concerns: middleware, routing, and CORS.
func New(app *apphttp.App) *gin.Engine {
	cfg := app.Config
	log := app.Logger

	engine := gin.New()
	engine.Use(gin.Recovery())

	engine.Use(webhookCorsBypass())
	engine.Use(cors.New(buildCorsConfig(cfg)))

	// Security headers
	engine.Use(httpkit.SecurityHeaders())

	// Request logging
	engine.Use(httpkit.RequestLogger(log))

	// Global rate limiter (100 requests per second, burst of 200)
	globalLimiter := httpkit.NewIPRateLimiter(rate.Limit(100), 200, log)
	engine.Use(globalLimiter.RateLimit())

	registerHealthRoute(engine, app)

	// Set up route groups
	v1 := engine.Group("/api/v1")
	protected := v1.Group("")
	protected.Use(httpkit.AuthRequired(cfg))
	admin := v1.Group("/admin")
	admin.Use(httpkit.AuthRequired(cfg), httpkit.RequireRole("admin"))

	// Router context provides shared dependencies to modules
	routerCtx := &apphttp.RouterContext{
		Engine:          engine,
		V1:              v1,
		Protected:       protected,
		Admin:           admin,
		Config:          cfg,
		AuthMiddleware:  httpkit.AuthRequired(cfg),
		AuthRateLimiter: httpkit.NewAuthRateLimiter(log),
	}

	// Register all HTTP modules (already initialized by composition root)
	for _, mod := range app.Modules {
		log.Info("registering module routes", "module", mod.Name())
		mod.RegisterRoutes(routerCtx)
	}

	return engine
}

func webhookCorsBypass() gin.HandlerFunc {
	return func(c *gin.Context) {
		if strings.HasPrefix(c.Request.URL.Path, "/api/v1/webhook/") {
			origin := c.GetHeader("Origin")
			if origin != "" {
				c.Header("Access-Control-Allow-Origin", origin)
				c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
				c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, X-Webhook-API-Key")
				c.Header("Access-Control-Max-Age", "43200")
				c.Set("webhookOrigin", origin)
				c.Request.Header.Del("Origin")
			}
			if c.Request.Method == "OPTIONS" {
				c.AbortWithStatus(http.StatusNoContent)
				return
			}
		}
		c.Next()
	}
}

func buildCorsConfig(cfg config.HTTPConfig) cors.Config {
	corsConfig := cors.Config{
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization", "Accept", "X-Webhook-API-Key", "X-Export-API-Key"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: cfg.GetCORSAllowCreds(),
		MaxAge:           12 * time.Hour,
	}
	if cfg.GetCORSAllowAll() {
		corsConfig.AllowAllOrigins = true
		return corsConfig
	}
	corsConfig.AllowOrigins = cfg.GetCORSOrigins()
	return corsConfig
}

func registerHealthRoute(engine *gin.Engine, app *apphttp.App) {
	engine.GET("/api/health", func(c *gin.Context) {
		if app.Health != nil {
			timeoutCtx, cancel := context.WithTimeout(c.Request.Context(), 2*time.Second)
			defer cancel()
			if err := app.Health.Ping(timeoutCtx); err != nil {
				c.JSON(http.StatusServiceUnavailable, gin.H{"status": "unhealthy"})
				return
			}
		}
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})
}
</file>

<file path="internal/leads/agent/dispatcher.go">
package agent

import (
	"context"
	"fmt"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/genai"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/moonshot"
)

// Dispatcher finds partner matches and advances pipeline stage.
type Dispatcher struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	repo           repository.LeadsRepository
	toolDeps       *ToolDependencies
	runMu          sync.Mutex
}

// NewDispatcher creates a Dispatcher agent.
func NewDispatcher(apiKey string, repo repository.LeadsRepository, eventBus events.Bus) (*Dispatcher, error) {
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          apiKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	deps := &ToolDependencies{
		Repo:     repo,
		EventBus: eventBus,
	}

	findPartnersTool, err := createFindMatchingPartnersTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build FindMatchingPartners tool: %w", err)
	}

	updateStageTool, err := createUpdatePipelineStageTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build UpdatePipelineStage tool: %w", err)
	}

	createOfferTool, err := createCreatePartnerOfferTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build CreatePartnerOffer tool: %w", err)
	}

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "Dispatcher",
		Model:       kimi,
		Description: "Fulfillment manager that finds partner matches and advances the pipeline.",
		Instruction: "You are the Fulfillment Manager.",
		Tools:       []tool.Tool{findPartnersTool, createOfferTool, updateStageTool},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create dispatcher agent: %w", err)
	}

	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "dispatcher",
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create dispatcher runner: %w", err)
	}

	return &Dispatcher{
		agent:          adkAgent,
		runner:         r,
		sessionService: sessionService,
		appName:        "dispatcher",
		repo:           repo,
		toolDeps:       deps,
	}, nil
}

// SetOfferCreator injects the partner offer creator after module initialization.
func (d *Dispatcher) SetOfferCreator(creator ports.PartnerOfferCreator) {
	d.toolDeps.mu.Lock()
	defer d.toolDeps.mu.Unlock()
	d.toolDeps.OfferCreator = creator
}

// Run executes partner matching for a lead service.
func (d *Dispatcher) Run(ctx context.Context, leadID, serviceID, tenantID uuid.UUID) error {
	d.runMu.Lock()
	defer d.runMu.Unlock()

	d.toolDeps.SetTenantID(tenantID)
	d.toolDeps.SetLeadContext(leadID, serviceID)
	d.toolDeps.SetActor("AI", "Dispatcher")
	d.toolDeps.ResetToolCallTracking()

	lead, err := d.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return err
	}
	service, err := d.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		return err
	}

	excludedIDs, err := d.repo.GetInvitedPartnerIDs(ctx, serviceID)
	if err != nil {
		fmt.Printf("Dispatcher warning: failed to fetch exclusions: %v\n", err)
		excludedIDs = []uuid.UUID{}
	}

	promptText := buildDispatcherPrompt(lead, service, 25, excludedIDs)
	if err := d.runWithPrompt(ctx, promptText, leadID); err != nil {
		return err
	}

	if !d.toolDeps.WasStageUpdateCalled() {
		fmt.Printf("Dispatcher warning: no stage update recorded for lead=%s service=%s\n", leadID, serviceID)
	}
	if d.toolDeps.LastStageUpdated() == "Partner_Matching" && !d.toolDeps.WasOfferCreated() {
		fmt.Printf("Dispatcher warning: Partner_Matching without offer for lead=%s service=%s\n", leadID, serviceID)
	}

	return nil
}

func (d *Dispatcher) runWithPrompt(ctx context.Context, promptText string, leadID uuid.UUID) error {
	sessionID := uuid.New().String()
	userID := "dispatcher-" + leadID.String()

	_, err := d.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   d.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return fmt.Errorf("failed to create dispatcher session: %w", err)
	}
	defer func() {
		_ = d.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   d.appName,
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	userMessage := &genai.Content{
		Role:  "user",
		Parts: []*genai.Part{{Text: promptText}},
	}

	runConfig := agent.RunConfig{StreamingMode: agent.StreamingModeNone}
	for event := range d.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		_ = event
	}

	return nil
}
</file>

<file path="internal/leads/agent/quote_generator.go">
package agent

import (
	"context"
	"fmt"
	"log"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/genai"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/embeddings"
	"portal_final_backend/platform/ai/moonshot"
	"portal_final_backend/platform/qdrant"
)

// GenerateResult is the return value from a prompt-based quote generation.
type GenerateResult struct {
	QuoteID     uuid.UUID
	QuoteNumber string
	ItemCount   int
}

// QuoteGenerator is a dedicated mini-agent that generates draft quotes from a
// user prompt. It has only SearchProductMaterials + DraftQuote tools, ensuring
// exact parity with the estimator's searchhydratedraft pipeline without
// triggering SaveEstimation or UpdatePipelineStage.
type QuoteGenerator struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	repo           repository.LeadsRepository
	toolDeps       *ToolDependencies
	runMu          sync.Mutex
}

// QuoteGeneratorConfig holds configuration for creating a QuoteGenerator.
type QuoteGeneratorConfig struct {
	APIKey              string
	Repo                repository.LeadsRepository
	EventBus            events.Bus
	EmbeddingClient     *embeddings.Client
	QdrantClient        *qdrant.Client
	CatalogQdrantClient *qdrant.Client
	CatalogReader       ports.CatalogReader
	QuoteDrafter        ports.QuoteDrafter
}

// NewQuoteGenerator creates a QuoteGenerator agent with only product search and
// quote drafting capabilities.
func NewQuoteGenerator(cfg QuoteGeneratorConfig) (*QuoteGenerator, error) {
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          cfg.APIKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	deps := &ToolDependencies{
		Repo:                cfg.Repo,
		EventBus:            cfg.EventBus,
		EmbeddingClient:     cfg.EmbeddingClient,
		QdrantClient:        cfg.QdrantClient,
		CatalogQdrantClient: cfg.CatalogQdrantClient,
		CatalogReader:       cfg.CatalogReader,
		QuoteDrafter:        cfg.QuoteDrafter,
	}

	var tools []tool.Tool

	// Calculator is always available for exact arithmetic.
	calculatorTool, err := createCalculatorTool()
	if err != nil {
		return nil, fmt.Errorf("failed to build Calculator tool: %w", err)
	}
	tools = append(tools, calculatorTool)

	// DraftQuote is always registered (gracefully errors if drafter is nil).
	draftQuoteTool, err := createDraftQuoteTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build DraftQuote tool: %w", err)
	}
	tools = append(tools, draftQuoteTool)

	// Add product search tool if configured.
	if deps.IsProductSearchEnabled() {
		searchTool, err := createSearchProductMaterialsTool(deps)
		if err != nil {
			return nil, fmt.Errorf("failed to build SearchProductMaterials tool: %w", err)
		}
		tools = append(tools, searchTool)
		log.Printf("QuoteGenerator: product search enabled")
	} else {
		log.Printf("QuoteGenerator: product search disabled")
	}

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "QuoteGenerator",
		Model:       kimi,
		Description: "Generates draft quotes from a user prompt using catalog search.",
		Instruction: "You are a Quote Generator. Search for products and create draft quotes.",
		Tools:       tools,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create quote generator agent: %w", err)
	}

	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "quote-generator",
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create quote generator runner: %w", err)
	}

	return &QuoteGenerator{
		agent:          adkAgent,
		runner:         r,
		sessionService: sessionService,
		appName:        "quote-generator",
		repo:           cfg.Repo,
		toolDeps:       deps,
	}, nil
}

// SetCatalogReader injects the catalog reader (set after construction to break circular deps).
func (g *QuoteGenerator) SetCatalogReader(cr ports.CatalogReader) {
	g.toolDeps.CatalogReader = cr
}

// SetQuoteDrafter injects the quote drafter (set after construction to break circular deps).
func (g *QuoteGenerator) SetQuoteDrafter(qd ports.QuoteDrafter) {
	g.toolDeps.QuoteDrafter = qd
}

// Generate runs the quote generator agent with the user's prompt and lead context.
// If existingQuoteID is non-nil, the DraftQuote tool will update the existing quote.
// It returns the generated draft quote result or an error.
func (g *QuoteGenerator) Generate(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, userPrompt string, existingQuoteID *uuid.UUID) (*GenerateResult, error) {
	g.runMu.Lock()
	defer g.runMu.Unlock()

	g.toolDeps.SetTenantID(tenantID)
	g.toolDeps.SetLeadContext(leadID, serviceID)
	g.toolDeps.SetActor("AI", "Quote Generator")
	g.toolDeps.ResetToolCallTracking()
	g.toolDeps.SetExistingQuoteID(existingQuoteID)

	lead, err := g.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return nil, fmt.Errorf("quote generator: load lead: %w", err)
	}
	service, err := g.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		return nil, fmt.Errorf("quote generator: load service: %w", err)
	}

	notes, err := g.repo.ListNotesByService(ctx, leadID, serviceID, tenantID)
	if err != nil {
		log.Printf("QuoteGenerator: notes fetch failed: %v", err)
		notes = nil
	}

	promptText := buildQuoteGeneratePrompt(lead, service, notes, userPrompt)

	sessionID := uuid.New().String()
	userID := "quote-gen-" + leadID.String()

	_, err = g.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   g.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return nil, fmt.Errorf("quote generator: create session: %w", err)
	}
	defer func() {
		_ = g.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   g.appName,
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	userMessage := &genai.Content{
		Role:  "user",
		Parts: []*genai.Part{{Text: promptText}},
	}

	runConfig := agent.RunConfig{StreamingMode: agent.StreamingModeNone}
	for event := range g.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		_ = event
	}

	result := g.toolDeps.GetLastDraftResult()
	if result == nil {
		return nil, fmt.Errorf("quote generator: agent did not produce a draft quote")
	}

	return &GenerateResult{
		QuoteID:     result.QuoteID,
		QuoteNumber: result.QuoteNumber,
		ItemCount:   result.ItemCount,
	}, nil
}
</file>

<file path="internal/leads/handler/notes.go">
package handler

import (
	"net/http"
	"strings"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/notes"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// NotesHandler handles HTTP requests for lead notes.
// This is separate from the main Handler to allow independent wiring.
type NotesHandler struct {
	svc      *notes.Service
	repo     repository.LeadsRepository
	eventBus events.Bus
	val      *validator.Validator
}

// NewNotesHandler creates a new notes handler.
func NewNotesHandler(svc *notes.Service, repo repository.LeadsRepository, eventBus events.Bus, val *validator.Validator) *NotesHandler {
	return &NotesHandler{svc: svc, repo: repo, eventBus: eventBus, val: val}
}

func (h *NotesHandler) ListNotes(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	notesList, err := h.svc.List(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, notesList)
}

func (h *NotesHandler) AddNote(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.CreateLeadNoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	created, err := h.svc.Add(c.Request.Context(), id, identity.UserID(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	// Determine service ID for timeline event and data change notification.
	// Prefer the service ID from the request; fall back to GetCurrentLeadService.
	var serviceID uuid.UUID
	var hasServiceID bool
	if req.ServiceID != nil && *req.ServiceID != "" {
		if parsed, parseErr := uuid.Parse(*req.ServiceID); parseErr == nil {
			serviceID = parsed
			hasServiceID = true
		}
	}
	if !hasServiceID {
		serviceID, hasServiceID = h.getCurrentServiceID(c, id, tenantID)
	}

	if hasServiceID {
		_, _ = h.repo.CreateTimelineEvent(c.Request.Context(), repository.CreateTimelineEventParams{
			LeadID:         id,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      "User",
			ActorName:      created.AuthorEmail,
			EventType:      "note",
			Title:          "Notitie toegevoegd",
			Summary:        toSummaryPointer(created.Body, 400),
			Metadata: map[string]any{
				"noteId":   created.ID,
				"noteType": created.Type,
			},
		})

		h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
			BaseEvent:     events.NewBaseEvent(),
			LeadID:        id,
			LeadServiceID: serviceID,
			TenantID:      tenantID,
			Source:        "note",
		})
	}

	httpkit.JSON(c, http.StatusCreated, created)
}

func (h *NotesHandler) getCurrentServiceID(c *gin.Context, leadID, tenantID uuid.UUID) (uuid.UUID, bool) {
	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), leadID, tenantID)
	if err != nil {
		return uuid.UUID{}, false
	}
	return svc.ID, true
}

func toSummaryPointer(text string, maxLen int) *string {
	trimmed := strings.TrimSpace(text)
	if trimmed == "" {
		return nil
	}
	if len(trimmed) > maxLen {
		trimmed = trimmed[:maxLen] + "..."
	}
	return &trimmed
}
</file>

<file path="internal/leads/management/feed_enrichment.go">
// Package management  feed enrichment logic for the Smart Activity Feed.
// Adds sentiment analysis, aggregation formatting, suggested actions, and metadata pass-through.
package management

import (
	"encoding/json"
	"fmt"

	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
)

// enrichFeedItem enriches a mapped ActivityFeedItem with sentiment, grouped titles,
// suggested actions, and parsed metadata from the raw DB entry.
func enrichFeedItem(item *transport.ActivityFeedItem, entry *repository.ActivityFeedEntry) {
	item.GroupCount = entry.GroupCount
	item.ActorName = entry.ActorName

	// --- Sentiment ---
	item.Sentiment = mapSentiment(entry.EventType)

	// --- Aggregation: pluralise title when grouped ---
	if entry.GroupCount > 1 {
		if plural := pluralTitle(entry.EventType, entry.GroupCount); plural != "" {
			item.Title = plural
		}
	}

	// --- Suggested Action (CTA) ---
	action, link := suggestedAction(entry.EventType, entry.EntityID.String())
	item.SuggestedAction = action
	item.ActionLink = link

	// --- Metadata pass-through ---
	if len(entry.RawMetadata) > 0 {
		var meta map[string]any
		if err := json.Unmarshal(entry.RawMetadata, &meta); err == nil && len(meta) > 0 {
			item.Metadata = meta
		}
	}

	// --- Inject serviceId into metadata for AI events (needed for attachment URLs) ---
	if entry.ServiceID != nil {
		if item.Metadata == nil {
			item.Metadata = make(map[string]any)
		}
		item.Metadata["serviceId"] = entry.ServiceID.String()
	}
}

// mapSentiment returns the sentiment label for a given event type.
func mapSentiment(eventType string) string {
	switch eventType {
	// Positive
	case "quote_accepted", "partner_offer_accepted":
		return "positive"
	// Negative
	case "quote_rejected", "partner_offer_rejected", "lead_lost":
		return "negative"
	// Urgent
	case "manual_intervention", "gatekeeper_rejected":
		return "urgent"
	// Info
	case "appointment_scheduled", "appointment_created", "appointment_updated",
		"appointment_upcoming", "lead_created", "lead_assigned":
		return "info"
	// Neutral  default bucket for notes, calls, generic events
	default:
		return "neutral"
	}
}

// pluralTitle returns a Dutch plural title for grouped events.
// Returns empty string if no specific plural mapping exists.
func pluralTitle(eventType string, count int) string {
	switch eventType {
	case "note_added":
		return fmt.Sprintf("%d notities toegevoegd", count)
	case "call_logged":
		return fmt.Sprintf("%d gesprekken gelogd", count)
	case "attachment_uploaded":
		return fmt.Sprintf("%d foto's geupload", count)
	case "lead_viewed":
		return fmt.Sprintf("%d leads bekeken", count)
	case "lead_updated":
		return fmt.Sprintf("%d leads bijgewerkt", count)
	case "lead_created":
		return fmt.Sprintf("%d nieuwe leads aangemaakt", count)
	case "quote_sent":
		return fmt.Sprintf("%d offertes verzonden", count)
	case "quote_viewed":
		return fmt.Sprintf("%d offertes bekeken", count)
	case "quote_accepted":
		return fmt.Sprintf("%d offertes geaccepteerd", count)
	case "quote_rejected":
		return fmt.Sprintf("%d offertes afgewezen", count)
	case "appointment_created":
		return fmt.Sprintf("%d afspraken aangemaakt", count)
	case "appointment_updated":
		return fmt.Sprintf("%d afspraken bijgewerkt", count)
	case "analysis_complete":
		return fmt.Sprintf("%d analyses voltooid", count)
	case "photo_analysis_complete", "photo_analysis_completed":
		return fmt.Sprintf("%d foto-analyses voltooid", count)
	case "status_change":
		return fmt.Sprintf("%d statuswijzigingen", count)
	default:
		return ""
	}
}

// suggestedAction returns a CTA label and deep link for event types that benefit from
// an immediate follow-up action.
func suggestedAction(eventType string, entityID string) (label string, link string) {
	switch eventType {
	case "quote_viewed":
		return "Bel klant", fmt.Sprintf("leads/%s/call", entityID)
	case "manual_intervention":
		return "Triage bekijken", fmt.Sprintf("leads/%s/triage", entityID)
	case "gatekeeper_rejected":
		return "Triage bekijken", fmt.Sprintf("leads/%s/triage", entityID)
	case "partner_offer_rejected":
		return "Nieuwe partner zoeken", fmt.Sprintf("leads/%s/dispatch", entityID)
	case "appointment_created":
		return "Bekijk agenda", fmt.Sprintf("appointments/%s", entityID)
	case "quote_accepted":
		return "Bekijk offerte", fmt.Sprintf("offertes/%s", entityID)
	case "lead_created":
		return "Bekijk lead", fmt.Sprintf("leads/%s", entityID)
	default:
		return "", ""
	}
}
</file>

<file path="internal/leads/ports/quotes.go">
// Package ports defines the interfaces that the RAC_leads domain requires from
// external systems. These interfaces form the Anti-Corruption Layer (ACL),
// ensuring the RAC_leads domain only knows about the data it needs, formatted
// the way it wants.
package ports

import (
	"context"

	"github.com/google/uuid"
)

// DraftQuoteItem represents a single line item for the AI-drafted quote.
type DraftQuoteItem struct {
	Description      string
	Quantity         string // e.g. "3", "1"
	UnitPriceCents   int64
	TaxRateBps       int
	IsOptional       bool
	CatalogProductID *uuid.UUID // nil for ad-hoc items
}

// DraftQuoteAttachment represents a catalog document to auto-attach to the AI-drafted quote.
type DraftQuoteAttachment struct {
	Filename         string
	FileKey          string
	Source           string     // "catalog"
	CatalogProductID *uuid.UUID // originating product
}

// DraftQuoteURL represents a catalog URL to auto-attach to the AI-drafted quote.
type DraftQuoteURL struct {
	Label            string
	Href             string
	CatalogProductID *uuid.UUID // originating product
}

// DraftQuoteParams contains everything the leads agent needs to create a draft quote.
type DraftQuoteParams struct {
	QuoteID        *uuid.UUID // If set, update the existing quote instead of creating a new one
	LeadID         uuid.UUID
	LeadServiceID  uuid.UUID
	OrganizationID uuid.UUID
	CreatedByID    uuid.UUID // system/agent user ID
	Notes          string
	Items          []DraftQuoteItem
	Attachments    []DraftQuoteAttachment
	URLs           []DraftQuoteURL
}

// DraftQuoteResult is the minimal response the leads domain needs after a quote
// is successfully drafted.
type DraftQuoteResult struct {
	QuoteID     uuid.UUID
	QuoteNumber string
	ItemCount   int
}

// QuoteDrafter is the ACL interface through which the leads agent can draft
// quotes in the quotes domain. The adapter delegates to the quotes service.
type QuoteDrafter interface {
	// DraftQuote creates a new draft quote and emits the appropriate timeline event.
	DraftQuote(ctx context.Context, params DraftQuoteParams) (*DraftQuoteResult, error)
}
</file>

<file path="internal/notification/sse/service.go">
// Package sse provides Server-Sent Events support for real-time notifications.
package sse

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// EventType represents different types of SSE events
type EventType string

const (
	EventAnalysisComplete      EventType = "analysis_complete"
	EventPhotoAnalysisComplete EventType = "photo_analysis_complete"
	EventLeadUpdated           EventType = "lead_updated"

	// Lead/customer activity events (pushed to org members)
	EventLeadPreferencesUpdated   EventType = "lead_preferences_updated"
	EventLeadAttachmentUploaded   EventType = "lead_attachment_uploaded"
	EventLeadAttachmentDeleted    EventType = "lead_attachment_deleted"
	EventLeadInfoAdded            EventType = "lead_info_added"
	EventLeadAppointmentRequested EventType = "lead_appointment_requested"
	EventLeadStatusChanged        EventType = "lead_status_changed"

	// Quote events (pushed to agents watching a quote)
	EventQuoteSent        EventType = "quote_sent"
	EventQuoteViewed      EventType = "quote_viewed"
	EventQuoteItemToggled EventType = "quote_item_toggled"
	EventQuoteAnnotated   EventType = "quote_annotated"
	EventQuoteAccepted    EventType = "quote_accepted"
	EventQuoteRejected    EventType = "quote_rejected"

	// Appointment events (pushed to org members)
	EventAppointmentCreated       EventType = "appointment_created"
	EventAppointmentUpdated       EventType = "appointment_updated"
	EventAppointmentStatusChanged EventType = "appointment_status_changed"

	// Pipeline events (pushed to org members for dashboard alerts)
	EventManualIntervention EventType = "manual_intervention"
)

// Event represents an SSE event payload
type Event struct {
	Type      EventType   `json:"type"`
	LeadID    uuid.UUID   `json:"leadId,omitempty"`
	ServiceID uuid.UUID   `json:"serviceId,omitempty"`
	Message   string      `json:"message,omitempty"`
	Data      interface{} `json:"data,omitempty"`
}

// client represents a connected SSE client
type client struct {
	userID uuid.UUID
	orgID  uuid.UUID
	events chan Event
}

// quoteClient represents a public (unauthenticated) SSE viewer on a quote page.
type quoteClient struct {
	quoteID uuid.UUID
	events  chan Event
}

// leadClient represents a public (unauthenticated) SSE viewer on a lead tracking page.
type leadClient struct {
	leadID uuid.UUID
	events chan Event
}

// Service manages SSE connections and event broadcasting
type Service struct {
	mu           sync.RWMutex
	clients      map[uuid.UUID][]*client      // userID -> clients
	orgMap       map[uuid.UUID][]uuid.UUID    // orgID -> userIDs
	quoteClients map[uuid.UUID][]*quoteClient // quoteID -> public viewers
	leadClients  map[uuid.UUID][]*leadClient  // leadID -> public viewers
}

// New creates a new SSE service
func New() *Service {
	return &Service{
		clients:      make(map[uuid.UUID][]*client),
		orgMap:       make(map[uuid.UUID][]uuid.UUID),
		quoteClients: make(map[uuid.UUID][]*quoteClient),
		leadClients:  make(map[uuid.UUID][]*leadClient),
	}
}

// addClient registers a new client connection
func (s *Service) addClient(c *client) {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.clients[c.userID] = append(s.clients[c.userID], c)

	// Track org membership
	if c.orgID != uuid.Nil {
		s.orgMap[c.orgID] = append(s.orgMap[c.orgID], c.userID)
	}
}

// removeClient unregisters a client connection
func (s *Service) removeClient(c *client) {
	s.mu.Lock()
	defer s.mu.Unlock()

	clients := s.clients[c.userID]
	for i, cl := range clients {
		if cl == c {
			s.clients[c.userID] = append(clients[:i], clients[i+1:]...)
			break
		}
	}
	if len(s.clients[c.userID]) == 0 {
		delete(s.clients, c.userID)
	}

	close(c.events)
}

// Publish sends an event to a specific user
func (s *Service) Publish(userID uuid.UUID, event Event) {
	s.mu.RLock()
	clients := s.clients[userID]
	s.mu.RUnlock()

	for _, c := range clients {
		select {
		case c.events <- event:
		default:
			log.Printf("SSE: Event buffer full for user %s", userID)
		}
	}

	log.Printf("SSE: Published event %s to user %s (%d clients)", event.Type, userID, len(clients))
}

// PublishToOrganization broadcasts an event to all org members
func (s *Service) PublishToOrganization(orgID uuid.UUID, event Event) {
	s.mu.RLock()
	userIDs := make([]uuid.UUID, len(s.orgMap[orgID]))
	copy(userIDs, s.orgMap[orgID])
	s.mu.RUnlock()

	// Deduplicate and send
	seen := make(map[uuid.UUID]bool)
	for _, userID := range userIDs {
		if seen[userID] {
			continue
		}
		seen[userID] = true
		s.Publish(userID, event)
	}

	log.Printf("SSE: Published event %s to org %s (%d RAC_users)", event.Type, orgID, len(seen))
}

// PublishQuoteEvent is a convenience wrapper that broadcasts a quote-related
// event to every connected agent in the organisation AND to any public viewers.
func (s *Service) PublishQuoteEvent(orgID uuid.UUID, eventType EventType, quoteID uuid.UUID, data interface{}) {
	evt := Event{
		Type: eventType,
		Data: map[string]interface{}{
			"quoteId": quoteID,
			"payload": data,
		},
	}
	s.PublishToOrganization(orgID, evt)
	s.PublishToQuote(quoteID, evt)
}

// PublishToQuote sends an event to all public viewers of a quote.
func (s *Service) PublishToQuote(quoteID uuid.UUID, event Event) {
	s.mu.RLock()
	viewers := make([]*quoteClient, len(s.quoteClients[quoteID]))
	copy(viewers, s.quoteClients[quoteID])
	s.mu.RUnlock()

	for _, v := range viewers {
		select {
		case v.events <- event:
		default:
			log.Printf("SSE: Quote event buffer full for quote %s", quoteID)
		}
	}

	if len(viewers) > 0 {
		log.Printf("SSE: Published event %s to quote %s (%d public viewers)", event.Type, quoteID, len(viewers))
	}
}

// PublishToLead sends an event to all public viewers of a lead tracking page.
func (s *Service) PublishToLead(leadID uuid.UUID, event Event) {
	s.mu.RLock()
	viewers := make([]*leadClient, len(s.leadClients[leadID]))
	copy(viewers, s.leadClients[leadID])
	s.mu.RUnlock()

	for _, v := range viewers {
		select {
		case v.events <- event:
		default:
			log.Printf("SSE: Lead event buffer full for lead %s", leadID)
		}
	}

	if len(viewers) > 0 {
		log.Printf("SSE: Published event %s to lead %s (%d public viewers)", event.Type, leadID, len(viewers))
	}
}

// setSSEHeaders configures the standard SSE response headers.
func setSSEHeaders(c *gin.Context) {
	c.Writer.Header().Set("Content-Type", "text/event-stream")
	c.Writer.Header().Set("Cache-Control", "no-cache")
	c.Writer.Header().Set("Connection", "keep-alive")
	c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	c.Writer.Header().Set("X-Accel-Buffering", "no")
}

// deregisterQuoteClient removes a public viewer for a quote.
func (s *Service) deregisterQuoteClient(quoteID uuid.UUID, qc *quoteClient) {
	s.mu.Lock()
	defer s.mu.Unlock()

	viewers := s.quoteClients[quoteID]
	for i, v := range viewers {
		if v == qc {
			s.quoteClients[quoteID] = append(viewers[:i], viewers[i+1:]...)
			break
		}
	}
	if len(s.quoteClients[quoteID]) == 0 {
		delete(s.quoteClients, quoteID)
	}
	close(qc.events)
}

// deregisterLeadClient removes a public viewer for a lead.
func (s *Service) deregisterLeadClient(leadID uuid.UUID, lc *leadClient) {
	s.mu.Lock()
	defer s.mu.Unlock()

	viewers := s.leadClients[leadID]
	for i, v := range viewers {
		if v == lc {
			s.leadClients[leadID] = append(viewers[:i], viewers[i+1:]...)
			break
		}
	}
	if len(s.leadClients[leadID]) == 0 {
		delete(s.leadClients, leadID)
	}
	close(lc.events)
}

// streamEvents writes SSE events from the channel until the client disconnects or
// the channel is closed. It is used by both the authenticated and public handlers.
func streamEvents(c *gin.Context, events <-chan Event, disconnectLog string) {
	clientGone := c.Request.Context().Done()
	for {
		select {
		case <-clientGone:
			log.Print(disconnectLog)
			return
		case event, ok := <-events:
			if !ok {
				return
			}
			data, _ := json.Marshal(event)
			c.SSEvent(string(event.Type), string(data))
			c.Writer.Flush()
		}
	}
}

// PublicQuoteHandler returns a Gin handler for unauthenticated SSE connections
// on a specific quote (used by the public proposal page).
func (s *Service) PublicQuoteHandler(resolveQuoteID func(token string) (uuid.UUID, error)) gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.Param("token")
		if token == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
			return
		}

		quoteID, err := resolveQuoteID(token)
		if err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "quote not found"})
			return
		}

		setSSEHeaders(c)

		qc := &quoteClient{
			quoteID: quoteID,
			events:  make(chan Event, 32),
		}

		// Register
		s.mu.Lock()
		s.quoteClients[quoteID] = append(s.quoteClients[quoteID], qc)
		s.mu.Unlock()

		// Deregister on disconnect
		defer s.deregisterQuoteClient(quoteID, qc)

		// Connected signal
		c.SSEvent("connected", gin.H{"quoteId": quoteID})
		c.Writer.Flush()

		log.Printf("SSE: Public viewer connected for quote %s", quoteID)

		streamEvents(c, qc.events, fmt.Sprintf("SSE: Public viewer disconnected for quote %s", quoteID))
	}
}

// PublicLeadHandler returns a Gin handler for unauthenticated SSE connections
// on a specific lead (used by the public lead tracking page).
func (s *Service) PublicLeadHandler(resolveLeadID func(token string) (uuid.UUID, error)) gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.Param("token")
		if token == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
			return
		}

		leadID, err := resolveLeadID(token)
		if err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "lead not found"})
			return
		}

		setSSEHeaders(c)

		lc := &leadClient{
			leadID: leadID,
			events: make(chan Event, 32),
		}

		// Register
		s.mu.Lock()
		s.leadClients[leadID] = append(s.leadClients[leadID], lc)
		s.mu.Unlock()

		// Deregister on disconnect
		defer s.deregisterLeadClient(leadID, lc)

		// Connected signal
		c.SSEvent("connected", gin.H{"leadId": leadID})
		c.Writer.Flush()

		log.Printf("SSE: Public viewer connected for lead %s", leadID)

		streamEvents(c, lc.events, fmt.Sprintf("SSE: Public viewer disconnected for lead %s", leadID))
	}
}

// Handler returns a Gin handler for SSE connections
func (s *Service) Handler(getUserID func(*gin.Context) (uuid.UUID, bool), getOrgID func(*gin.Context) (uuid.UUID, bool)) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID, ok := getUserID(c)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
			return
		}

		orgID, _ := getOrgID(c)

		setSSEHeaders(c)

		// Create client
		cl := &client{
			userID: userID,
			orgID:  orgID,
			events: make(chan Event, 32),
		}
		s.addClient(cl)
		defer s.removeClient(cl)

		// Send connection event
		c.SSEvent("connected", gin.H{"userId": userID, "orgId": orgID})
		c.Writer.Flush()

		log.Printf("SSE: Client connected - user %s, org %s", userID, orgID)

		streamEvents(c, cl.events, fmt.Sprintf("SSE: Client disconnected - user %s", userID))
	}
}

// Close shuts down the SSE service
func (s *Service) Close() {
	s.mu.Lock()
	defer s.mu.Unlock()

	for _, clients := range s.clients {
		for _, c := range clients {
			close(c.events)
		}
	}
	for _, viewers := range s.quoteClients {
		for _, v := range viewers {
			close(v.events)
		}
	}
	for _, viewers := range s.leadClients {
		for _, v := range viewers {
			close(v.events)
		}
	}
	s.clients = make(map[uuid.UUID][]*client)
	s.orgMap = make(map[uuid.UUID][]uuid.UUID)
	s.quoteClients = make(map[uuid.UUID][]*quoteClient)
	s.leadClients = make(map[uuid.UUID][]*leadClient)
}
</file>

<file path="internal/partners/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

const partnerNotFoundMsg = "partner not found"
const partnerInviteNotFoundMsg = "partner invite not found"
const replacePartnerServiceTypesErr = "replace partner service types: %w"

// Repository provides database operations for partners.
type Repository struct {
	pool *pgxpool.Pool
}

// New creates a new partners repository.
func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

type Partner struct {
	ID              uuid.UUID
	OrganizationID  uuid.UUID
	BusinessName    string
	KVKNumber       string
	VATNumber       string
	AddressLine1    string
	AddressLine2    *string
	HouseNumber     *string
	PostalCode      string
	City            string
	Country         string
	Latitude        *float64
	Longitude       *float64
	ContactName     string
	ContactEmail    string
	ContactPhone    string
	LogoFileKey     *string
	LogoFileName    *string
	LogoContentType *string
	LogoSizeBytes   *int64
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

type PartnerUpdate struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	BusinessName   *string
	KVKNumber      *string
	VATNumber      *string
	AddressLine1   *string
	AddressLine2   *string
	HouseNumber    *string
	PostalCode     *string
	City           *string
	Country        *string
	Latitude       *float64
	Longitude      *float64
	ContactName    *string
	ContactEmail   *string
	ContactPhone   *string
}

type PartnerLogo struct {
	FileKey     string
	FileName    string
	ContentType string
	SizeBytes   int64
}

type ListParams struct {
	OrganizationID uuid.UUID
	Search         string
	SortBy         string
	SortOrder      string
	Page           int
	PageSize       int
}

type ListResult struct {
	Items      []Partner
	Total      int
	Page       int
	PageSize   int
	TotalPages int
}

type PartnerLead struct {
	ID          uuid.UUID
	FirstName   string
	LastName    string
	Phone       string
	Street      string
	HouseNumber string
	City        string
}

type PartnerInvite struct {
	ID             uuid.UUID
	OrganizationID uuid.UUID
	PartnerID      uuid.UUID
	Email          string
	TokenHash      string
	ExpiresAt      time.Time
	CreatedBy      uuid.UUID
	CreatedAt      time.Time
	UsedAt         *time.Time
	UsedBy         *uuid.UUID
	LeadID         *uuid.UUID
	LeadServiceID  *uuid.UUID
}

func (r *Repository) Create(ctx context.Context, partner Partner) (Partner, error) {
	query := `
		INSERT INTO RAC_partners (
			id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5,
			$6, $7, $8, $9, $10, $11,
			$12, $13,
			$14, $15, $16, $17, $18
		)
	`

	_, err := r.pool.Exec(ctx, query,
		partner.ID,
		partner.OrganizationID,
		partner.BusinessName,
		partner.KVKNumber,
		partner.VATNumber,
		partner.AddressLine1,
		partner.AddressLine2,
		partner.HouseNumber,
		partner.PostalCode,
		partner.City,
		partner.Country,
		partner.Latitude,
		partner.Longitude,
		partner.ContactName,
		partner.ContactEmail,
		partner.ContactPhone,
		partner.CreatedAt,
		partner.UpdatedAt,
	)
	if err != nil {
		return Partner{}, fmt.Errorf("create partner: %w", err)
	}

	return partner, nil
}

func (r *Repository) GetByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Partner, error) {
	query := `
		SELECT id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone,
			logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
			created_at, updated_at
		FROM RAC_partners
		WHERE id = $1 AND organization_id = $2
	`

	var partner Partner
	err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(
		&partner.ID,
		&partner.OrganizationID,
		&partner.BusinessName,
		&partner.KVKNumber,
		&partner.VATNumber,
		&partner.AddressLine1,
		&partner.AddressLine2,
		&partner.HouseNumber,
		&partner.PostalCode,
		&partner.City,
		&partner.Country,
		&partner.Latitude,
		&partner.Longitude,
		&partner.ContactName,
		&partner.ContactEmail,
		&partner.ContactPhone,
		&partner.LogoFileKey,
		&partner.LogoFileName,
		&partner.LogoContentType,
		&partner.LogoSizeBytes,
		&partner.CreatedAt,
		&partner.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Partner{}, apperr.NotFound(partnerNotFoundMsg)
		}
		return Partner{}, fmt.Errorf("get partner: %w", err)
	}

	return partner, nil
}

func (r *Repository) Update(ctx context.Context, update PartnerUpdate) (Partner, error) {
	query := `
		UPDATE RAC_partners
		SET
			business_name = COALESCE($3, business_name),
			kvk_number = COALESCE($4, kvk_number),
			vat_number = COALESCE($5, vat_number),
			address_line1 = COALESCE($6, address_line1),
			address_line2 = COALESCE($7, address_line2),
			house_number = COALESCE($8, house_number),
			postal_code = COALESCE($9, postal_code),
			city = COALESCE($10, city),
			country = COALESCE($11, country),
			latitude = COALESCE($12, latitude),
			longitude = COALESCE($13, longitude),
			contact_name = COALESCE($14, contact_name),
			contact_email = COALESCE($15, contact_email),
			contact_phone = COALESCE($16, contact_phone),
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone,
			logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
			created_at, updated_at
	`

	var partner Partner
	err := r.pool.QueryRow(ctx, query,
		update.ID,
		update.OrganizationID,
		update.BusinessName,
		update.KVKNumber,
		update.VATNumber,
		update.AddressLine1,
		update.AddressLine2,
		update.HouseNumber,
		update.PostalCode,
		update.City,
		update.Country,
		update.Latitude,
		update.Longitude,
		update.ContactName,
		update.ContactEmail,
		update.ContactPhone,
	).Scan(
		&partner.ID,
		&partner.OrganizationID,
		&partner.BusinessName,
		&partner.KVKNumber,
		&partner.VATNumber,
		&partner.AddressLine1,
		&partner.AddressLine2,
		&partner.HouseNumber,
		&partner.PostalCode,
		&partner.City,
		&partner.Country,
		&partner.Latitude,
		&partner.Longitude,
		&partner.ContactName,
		&partner.ContactEmail,
		&partner.ContactPhone,
		&partner.LogoFileKey,
		&partner.LogoFileName,
		&partner.LogoContentType,
		&partner.LogoSizeBytes,
		&partner.CreatedAt,
		&partner.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Partner{}, apperr.NotFound(partnerNotFoundMsg)
		}
		return Partner{}, fmt.Errorf("update partner: %w", err)
	}

	return partner, nil
}

func (r *Repository) Delete(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	query := `DELETE FROM RAC_partners WHERE id = $1 AND organization_id = $2`

	result, err := r.pool.Exec(ctx, query, id, organizationID)
	if err != nil {
		return fmt.Errorf("delete partner: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(partnerNotFoundMsg)
	}
	return nil
}

func (r *Repository) List(ctx context.Context, params ListParams) (ListResult, error) {
	searchParam := optionalSearch(params.Search)

	sortBy, err := resolveSortBy(params.SortBy)
	if err != nil {
		return ListResult{}, err
	}
	orderBy, err := resolveSortOrder(params.SortOrder)
	if err != nil {
		return ListResult{}, err
	}

	baseQuery := `
		FROM RAC_partners
		WHERE organization_id = $1
			AND ($2::text IS NULL OR business_name ILIKE $2 OR contact_name ILIKE $2 OR contact_email ILIKE $2 OR kvk_number ILIKE $2 OR vat_number ILIKE $2)
	`
	args := []interface{}{params.OrganizationID, searchParam}

	var total int
	countQuery := "SELECT COUNT(*) " + baseQuery
	if err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total); err != nil {
		return ListResult{}, fmt.Errorf("count partners: %w", err)
	}

	page := params.Page
	pageSize := params.PageSize
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}
	offset := (page - 1) * pageSize
	pageTotal := 0
	if pageSize > 0 {
		pageTotal = (total + pageSize - 1) / pageSize
	}

	selectQuery := `
		SELECT id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone,
			logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
			created_at, updated_at
		` + baseQuery + `
		ORDER BY
			CASE WHEN $3 = 'businessName' AND $4 = 'asc' THEN business_name END ASC,
			CASE WHEN $3 = 'businessName' AND $4 = 'desc' THEN business_name END DESC,
			CASE WHEN $3 = 'contactName' AND $4 = 'asc' THEN contact_name END ASC,
			CASE WHEN $3 = 'contactName' AND $4 = 'desc' THEN contact_name END DESC,
			CASE WHEN $3 = 'createdAt' AND $4 = 'asc' THEN created_at END ASC,
			CASE WHEN $3 = 'createdAt' AND $4 = 'desc' THEN created_at END DESC,
			CASE WHEN $3 = 'updatedAt' AND $4 = 'asc' THEN updated_at END ASC,
			CASE WHEN $3 = 'updatedAt' AND $4 = 'desc' THEN updated_at END DESC,
			business_name ASC
		LIMIT $5 OFFSET $6
	`

	args = append(args, sortBy, orderBy, pageSize, offset)
	rows, err := r.pool.Query(ctx, selectQuery, args...)
	if err != nil {
		return ListResult{}, fmt.Errorf("list partners: %w", err)
	}
	defer rows.Close()

	items := make([]Partner, 0)
	for rows.Next() {
		var partner Partner
		if err := rows.Scan(
			&partner.ID,
			&partner.OrganizationID,
			&partner.BusinessName,
			&partner.KVKNumber,
			&partner.VATNumber,
			&partner.AddressLine1,
			&partner.AddressLine2,
			&partner.HouseNumber,
			&partner.PostalCode,
			&partner.City,
			&partner.Country,
			&partner.Latitude,
			&partner.Longitude,
			&partner.ContactName,
			&partner.ContactEmail,
			&partner.ContactPhone,
			&partner.LogoFileKey,
			&partner.LogoFileName,
			&partner.LogoContentType,
			&partner.LogoSizeBytes,
			&partner.CreatedAt,
			&partner.UpdatedAt,
		); err != nil {
			return ListResult{}, fmt.Errorf("scan partner: %w", err)
		}
		items = append(items, partner)
	}
	if err := rows.Err(); err != nil {
		return ListResult{}, fmt.Errorf("iterate partners: %w", err)
	}

	return ListResult{Items: items, Total: total, Page: page, PageSize: pageSize, TotalPages: pageTotal}, nil
}

func (r *Repository) Exists(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM RAC_partners WHERE id = $1 AND organization_id = $2)`
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check partner exists: %w", err)
	}
	return exists, nil
}

func (r *Repository) LeadExists(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM RAC_leads WHERE id = $1 AND organization_id = $2)`
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check lead exists: %w", err)
	}
	return exists, nil
}

func (r *Repository) LeadServiceExists(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM RAC_lead_services WHERE id = $1 AND organization_id = $2)`
	if err := r.pool.QueryRow(ctx, query, id, organizationID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check lead service exists: %w", err)
	}
	return exists, nil
}

// GetLeadIDForService resolves the parent lead_id for a lead-service row.
func (r *Repository) GetLeadIDForService(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) (uuid.UUID, error) {
	var leadID uuid.UUID
	query := `SELECT lead_id FROM RAC_lead_services WHERE id = $1 AND organization_id = $2`
	if err := r.pool.QueryRow(ctx, query, serviceID, organizationID).Scan(&leadID); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return uuid.UUID{}, apperr.NotFound("lead service not found")
		}
		return uuid.UUID{}, fmt.Errorf("get lead id for service: %w", err)
	}
	return leadID, nil
}

func (r *Repository) LinkLead(ctx context.Context, organizationID, partnerID, leadID uuid.UUID) error {
	query := `
		INSERT INTO RAC_partner_leads (organization_id, partner_id, lead_id)
		VALUES ($1, $2, $3)
		ON CONFLICT DO NOTHING
	`
	result, err := r.pool.Exec(ctx, query, organizationID, partnerID, leadID)
	if err != nil {
		return fmt.Errorf("link partner lead: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.Conflict("lead already linked to partner")
	}
	return nil
}

func (r *Repository) UnlinkLead(ctx context.Context, organizationID, partnerID, leadID uuid.UUID) error {
	query := `DELETE FROM RAC_partner_leads WHERE organization_id = $1 AND partner_id = $2 AND lead_id = $3`
	result, err := r.pool.Exec(ctx, query, organizationID, partnerID, leadID)
	if err != nil {
		return fmt.Errorf("unlink partner lead: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound("link not found")
	}
	return nil
}

func (r *Repository) ListLeads(ctx context.Context, organizationID, partnerID uuid.UUID) ([]PartnerLead, error) {
	query := `
		SELECT l.id, l.consumer_first_name, l.consumer_last_name, l.consumer_phone,
			l.address_street, l.address_house_number, l.address_city
		FROM RAC_partner_leads pl
		JOIN RAC_leads l ON l.id = pl.lead_id
		WHERE pl.organization_id = $1 AND pl.partner_id = $2
		ORDER BY l.created_at DESC
	`

	rows, err := r.pool.Query(ctx, query, organizationID, partnerID)
	if err != nil {
		return nil, fmt.Errorf("list partner leads: %w", err)
	}
	defer rows.Close()

	leads := make([]PartnerLead, 0)
	for rows.Next() {
		var lead PartnerLead
		if err := rows.Scan(
			&lead.ID,
			&lead.FirstName,
			&lead.LastName,
			&lead.Phone,
			&lead.Street,
			&lead.HouseNumber,
			&lead.City,
		); err != nil {
			return nil, fmt.Errorf("scan partner lead: %w", err)
		}
		leads = append(leads, lead)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate partner leads: %w", err)
	}

	return leads, nil
}

func (r *Repository) CreateInvite(ctx context.Context, invite PartnerInvite) (PartnerInvite, error) {
	query := `
		INSERT INTO RAC_partner_invites (
			id, organization_id, partner_id, email, token_hash, expires_at, created_by,
			created_at, used_at, used_by, lead_id, lead_service_id
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7,
			$8, $9, $10, $11, $12
		)
	`

	_, err := r.pool.Exec(ctx, query,
		invite.ID,
		invite.OrganizationID,
		invite.PartnerID,
		invite.Email,
		invite.TokenHash,
		invite.ExpiresAt,
		invite.CreatedBy,
		invite.CreatedAt,
		invite.UsedAt,
		invite.UsedBy,
		invite.LeadID,
		invite.LeadServiceID,
	)
	if err != nil {
		return PartnerInvite{}, fmt.Errorf("create partner invite: %w", err)
	}

	return invite, nil
}

func (r *Repository) ListInvites(ctx context.Context, organizationID, partnerID uuid.UUID) ([]PartnerInvite, error) {
	query := `
		SELECT id, organization_id, partner_id, email, token_hash, expires_at, created_by,
			created_at, used_at, used_by, lead_id, lead_service_id
		FROM RAC_partner_invites
		WHERE organization_id = $1 AND partner_id = $2
		ORDER BY created_at DESC
	`

	rows, err := r.pool.Query(ctx, query, organizationID, partnerID)
	if err != nil {
		return nil, fmt.Errorf("list partner invites: %w", err)
	}
	defer rows.Close()

	invites := make([]PartnerInvite, 0)
	for rows.Next() {
		var invite PartnerInvite
		if err := rows.Scan(
			&invite.ID,
			&invite.OrganizationID,
			&invite.PartnerID,
			&invite.Email,
			&invite.TokenHash,
			&invite.ExpiresAt,
			&invite.CreatedBy,
			&invite.CreatedAt,
			&invite.UsedAt,
			&invite.UsedBy,
			&invite.LeadID,
			&invite.LeadServiceID,
		); err != nil {
			return nil, fmt.Errorf("scan partner invite: %w", err)
		}
		invites = append(invites, invite)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate partner invites: %w", err)
	}

	return invites, nil
}

func (r *Repository) RevokeInvite(ctx context.Context, organizationID, inviteID uuid.UUID) (PartnerInvite, error) {
	query := `
		UPDATE RAC_partner_invites
		SET expires_at = now()
		WHERE id = $1 AND organization_id = $2 AND used_at IS NULL
		RETURNING id, organization_id, partner_id, email, token_hash, expires_at, created_by,
			created_at, used_at, used_by, lead_id, lead_service_id
	`

	var invite PartnerInvite
	err := r.pool.QueryRow(ctx, query, inviteID, organizationID).Scan(
		&invite.ID,
		&invite.OrganizationID,
		&invite.PartnerID,
		&invite.Email,
		&invite.TokenHash,
		&invite.ExpiresAt,
		&invite.CreatedBy,
		&invite.CreatedAt,
		&invite.UsedAt,
		&invite.UsedBy,
		&invite.LeadID,
		&invite.LeadServiceID,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return PartnerInvite{}, apperr.NotFound(partnerInviteNotFoundMsg)
		}
		return PartnerInvite{}, fmt.Errorf("revoke partner invite: %w", err)
	}

	return invite, nil
}

func (r *Repository) UpdateLogo(ctx context.Context, organizationID, partnerID uuid.UUID, logo PartnerLogo) (Partner, error) {
	query := `
		UPDATE RAC_partners
		SET logo_file_key = $3,
			logo_file_name = $4,
			logo_content_type = $5,
			logo_size_bytes = $6,
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone,
			logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
			created_at, updated_at
	`

	var partner Partner
	err := r.pool.QueryRow(ctx, query,
		partnerID,
		organizationID,
		logo.FileKey,
		logo.FileName,
		logo.ContentType,
		logo.SizeBytes,
	).Scan(
		&partner.ID,
		&partner.OrganizationID,
		&partner.BusinessName,
		&partner.KVKNumber,
		&partner.VATNumber,
		&partner.AddressLine1,
		&partner.AddressLine2,
		&partner.HouseNumber,
		&partner.PostalCode,
		&partner.City,
		&partner.Country,
		&partner.Latitude,
		&partner.Longitude,
		&partner.ContactName,
		&partner.ContactEmail,
		&partner.ContactPhone,
		&partner.LogoFileKey,
		&partner.LogoFileName,
		&partner.LogoContentType,
		&partner.LogoSizeBytes,
		&partner.CreatedAt,
		&partner.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Partner{}, apperr.NotFound(partnerNotFoundMsg)
		}
		return Partner{}, fmt.Errorf("update partner logo: %w", err)
	}

	return partner, nil
}

func (r *Repository) ClearLogo(ctx context.Context, organizationID, partnerID uuid.UUID) (Partner, error) {
	query := `
		UPDATE RAC_partners
		SET logo_file_key = NULL,
			logo_file_name = NULL,
			logo_content_type = NULL,
			logo_size_bytes = NULL,
			updated_at = now()
		WHERE id = $1 AND organization_id = $2
		RETURNING id, organization_id, business_name, kvk_number, vat_number,
			address_line1, address_line2, house_number, postal_code, city, country,
			latitude, longitude,
			contact_name, contact_email, contact_phone,
			logo_file_key, logo_file_name, logo_content_type, logo_size_bytes,
			created_at, updated_at
	`

	var partner Partner
	err := r.pool.QueryRow(ctx, query, partnerID, organizationID).Scan(
		&partner.ID,
		&partner.OrganizationID,
		&partner.BusinessName,
		&partner.KVKNumber,
		&partner.VATNumber,
		&partner.AddressLine1,
		&partner.AddressLine2,
		&partner.HouseNumber,
		&partner.PostalCode,
		&partner.City,
		&partner.Country,
		&partner.Latitude,
		&partner.Longitude,
		&partner.ContactName,
		&partner.ContactEmail,
		&partner.ContactPhone,
		&partner.LogoFileKey,
		&partner.LogoFileName,
		&partner.LogoContentType,
		&partner.LogoSizeBytes,
		&partner.CreatedAt,
		&partner.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return Partner{}, apperr.NotFound(partnerNotFoundMsg)
		}
		return Partner{}, fmt.Errorf("clear partner logo: %w", err)
	}

	return partner, nil
}

func (r *Repository) ValidateServiceTypeIDs(ctx context.Context, organizationID uuid.UUID, ids []uuid.UUID) error {
	if len(ids) == 0 {
		return nil
	}

	uniqueIDs := make([]uuid.UUID, 0, len(ids))
	seen := make(map[uuid.UUID]struct{}, len(ids))
	for _, id := range ids {
		if _, ok := seen[id]; ok {
			continue
		}
		seen[id] = struct{}{}
		uniqueIDs = append(uniqueIDs, id)
	}

	query := `SELECT id FROM RAC_service_types WHERE organization_id = $1 AND id = ANY($2)`
	rows, err := r.pool.Query(ctx, query, organizationID, uniqueIDs)
	if err != nil {
		return fmt.Errorf("validate service types: %w", err)
	}
	defer rows.Close()

	count := 0
	for rows.Next() {
		count++
	}
	if err := rows.Err(); err != nil {
		return fmt.Errorf("validate service types: %w", err)
	}
	if count != len(uniqueIDs) {
		return apperr.Validation("invalid service type id")
	}

	return nil
}

func (r *Repository) ReplaceServiceTypes(ctx context.Context, partnerID uuid.UUID, ids []uuid.UUID) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf(replacePartnerServiceTypesErr, err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	if _, err := tx.Exec(ctx, `DELETE FROM RAC_partner_service_types WHERE partner_id = $1`, partnerID); err != nil {
		return fmt.Errorf(replacePartnerServiceTypesErr, err)
	}

	for _, id := range ids {
		if _, err := tx.Exec(
			ctx,
			`INSERT INTO RAC_partner_service_types (partner_id, service_type_id) VALUES ($1, $2)`,
			partnerID,
			id,
		); err != nil {
			return fmt.Errorf(replacePartnerServiceTypesErr, err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf(replacePartnerServiceTypesErr, err)
	}
	return nil
}

func (r *Repository) ListServiceTypeIDs(ctx context.Context, organizationID, partnerID uuid.UUID) ([]uuid.UUID, error) {
	query := `
		SELECT pst.service_type_id
		FROM RAC_partner_service_types pst
		JOIN RAC_service_types st ON st.id = pst.service_type_id
		WHERE pst.partner_id = $1 AND st.organization_id = $2
		ORDER BY st.name ASC
	`
	rows, err := r.pool.Query(ctx, query, partnerID, organizationID)
	if err != nil {
		return nil, fmt.Errorf("list partner service types: %w", err)
	}
	defer rows.Close()

	ids := make([]uuid.UUID, 0)
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("scan partner service type: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate partner service types: %w", err)
	}

	return ids, nil
}

func (r *Repository) GetOrganizationName(ctx context.Context, organizationID uuid.UUID) (string, error) {
	var name string
	query := `SELECT name FROM RAC_organizations WHERE id = $1`
	if err := r.pool.QueryRow(ctx, query, organizationID).Scan(&name); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return "", apperr.NotFound("organization not found")
		}
		return "", fmt.Errorf("get organization name: %w", err)
	}
	return name, nil
}

func resolveSortBy(value string) (string, error) {
	if value == "" {
		return "createdAt", nil
	}
	switch value {
	case "businessName", "contactName", "createdAt", "updatedAt":
		return value, nil
	default:
		return "", apperr.BadRequest("invalid sort field")
	}
}

func resolveSortOrder(value string) (string, error) {
	if value == "" {
		return "desc", nil
	}
	switch value {
	case "asc", "desc":
		return value, nil
	default:
		return "", apperr.BadRequest("invalid sort order")
	}
}

func optionalSearch(value string) interface{} {
	if value == "" {
		return nil
	}
	return "%" + value + "%"
}
</file>

<file path="internal/partners/transport/offer_dto.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

// --- Internal API (Dispatcher / Agent) ---

// CreateOfferRequest is the internal request to create a partner offer.
type CreateOfferRequest struct {
	PartnerID          uuid.UUID `json:"partnerId" validate:"required"`
	LeadServiceID      uuid.UUID `json:"leadServiceId" validate:"required"`
	PricingSource      string    `json:"pricingSource" validate:"required,oneof=quote estimate"`
	CustomerPriceCents int64     `json:"customerPriceCents" validate:"min=0"`
	ExpiresInHours     int       `json:"expiresInHours" validate:"required,min=1,max=168"`
	JobSummaryShort    string    `json:"jobSummaryShort,omitempty" validate:"omitempty,max=200"`
}

// CreateOfferResponse is returned after successfully creating an offer.
type CreateOfferResponse struct {
	ID               uuid.UUID `json:"id"`
	PublicToken      string    `json:"publicToken"`
	VakmanPriceCents int64     `json:"vakmanPriceCents"`
	ExpiresAt        time.Time `json:"expiresAt"`
}

// OfferResponse is the admin/agent view of an offer.
type OfferResponse struct {
	ID                 uuid.UUID  `json:"id"`
	PartnerID          uuid.UUID  `json:"partnerId"`
	PartnerName        string     `json:"partnerName"`
	LeadServiceID      uuid.UUID  `json:"leadServiceId"`
	PricingSource      string     `json:"pricingSource"`
	CustomerPriceCents int64      `json:"customerPriceCents"`
	VakmanPriceCents   int64      `json:"vakmanPriceCents"`
	Status             string     `json:"status"`
	PublicToken        string     `json:"publicToken"`
	ExpiresAt          time.Time  `json:"expiresAt"`
	AcceptedAt         *time.Time `json:"acceptedAt,omitempty"`
	RejectedAt         *time.Time `json:"rejectedAt,omitempty"`
	RejectionReason    string     `json:"rejectionReason,omitempty"`
	CreatedAt          time.Time  `json:"createdAt"`
}

// ListOffersResponse is the paginated list of offers for a lead service.
type ListOffersResponse struct {
	Items []OfferResponse `json:"items"`
}

// --- Public API (Vakman-facing) ---

// PublicOfferResponse is the Vakman's view. Hides customer markup.
type PublicOfferResponse struct {
	OfferID          uuid.UUID `json:"offerId"`
	OrganizationName string    `json:"organizationName"`
	JobSummary       string    `json:"jobSummary"`
	JobSummaryShort  *string   `json:"jobSummaryShort,omitempty"`
	BuilderSummary   *string   `json:"builderSummary,omitempty"`
	City             string    `json:"city"`
	Postcode4        *string   `json:"postcode4,omitempty"`
	Buurtcode        *string   `json:"buurtcode,omitempty"`
	ConstructionYear *int      `json:"constructionYear,omitempty"`
	ScopeAssessment  *string   `json:"scopeAssessment,omitempty"`
	UrgencyLevel     *string   `json:"urgencyLevel,omitempty"`
	VakmanPriceCents int64     `json:"vakmanPriceCents"`
	PricingSource    string    `json:"pricingSource"`
	Status           string    `json:"status"`
	ExpiresAt        time.Time `json:"expiresAt"`
	CreatedAt        time.Time `json:"createdAt"`
}

// AcceptOfferRequest is the vakman's acceptance payload.
type AcceptOfferRequest struct {
	InspectionSlots []TimeSlot `json:"inspectionSlots" validate:"required,min=1,dive"`
	JobSlots        []TimeSlot `json:"jobSlots,omitempty" validate:"omitempty,dive"`
}

// RejectOfferRequest is the vakman's rejection payload.
type RejectOfferRequest struct {
	Reason string `json:"reason" validate:"omitempty,max=500"`
}

// TimeSlot represents a block of availability.
type TimeSlot struct {
	Start time.Time `json:"start" validate:"required"`
	End   time.Time `json:"end" validate:"required,gtfield=Start"`
}
</file>

<file path="internal/pdf/templates/quote.html">
<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Offerte</title>
    <style>
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            color: #111827;
            font-size: 9pt;
            line-height: 1.5;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }

        .page {
            width: 100%;
            padding: 0;
            overflow: hidden;
        }

        /*  Accent color from cover page  */
        :root {
            --accent: #F59E0B;
            --accent-light: #FEF3C7;
            --dark: #111827;
            --gray-500: #6b7280;
            --gray-400: #9ca3af;
            --gray-200: #e5e7eb;
            --gray-100: #f3f4f6;
            --gray-50: #f9fafb;
            --slate-200: #e2e8f0;
            --slate-100: #f1f5f9;
            --green-600: #16a34a;
            --green-100: #dcfce7;
            --red-600: #dc2626;
            --red-100: #fee2e2;
        }

        /*  Header  */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 3px solid var(--accent);
        }

        .header-logo img {
            max-height: 52px;
            max-width: 180px;
        }

        .header-logo .org-name-fallback {
            font-size: 18pt;
            font-weight: 700;
            color: var(--dark);
        }

        .header-title {
            text-align: right;
        }

        .header-title h1 {
            font-size: 20pt;
            font-weight: 800;
            color: var(--dark);
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.1;
        }

        .header-title .quote-number {
            font-size: 10pt;
            color: var(--gray-500);
            margin-top: 4px;
            font-weight: 400;
        }

        /*  Address Block  */
        .address-block {
            display: flex;
            gap: 20px;
            margin-bottom: 16px;
        }

        .address-col {
            flex: 1;
        }

        .address-col.meta {
            flex: 0 0 35%;
            text-align: right;
        }

        .address-label {
            font-size: 7pt;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .address-name {
            font-size: 10pt;
            font-weight: 600;
            color: var(--dark);
        }

        .address-detail {
            font-size: 8.5pt;
            color: var(--gray-500);
            line-height: 1.6;
        }

        .meta-row {
            font-size: 8.5pt;
            color: var(--gray-500);
            line-height: 1.8;
        }

        .meta-row .label {
            color: var(--gray-400);
        }

        .meta-row .value {
            font-weight: 600;
            color: var(--dark);
        }

        .meta-row.status .value {
            font-weight: 700;
        }

        .status-accepted { color: var(--green-600); }
        .status-rejected { color: var(--red-600); }
        .status-sent     { color: var(--accent); }
        .status-default  { color: var(--gray-500); }

        /*  Status Banner  */
        .status-banner {
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 9pt;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .status-banner.accepted {
            background-color: var(--green-100);
            color: var(--green-600);
            border-left: 4px solid var(--green-600);
        }

        .status-banner.rejected {
            background-color: var(--red-100);
            color: var(--red-600);
            border-left: 4px solid var(--red-600);
        }

        /*  Items Table  */
        .section-title {
            font-size: 8pt;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .items-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            margin-bottom: 16px;
        }

        .items-table thead th {
            background-color: var(--dark);
            color: #ffffff;
            font-size: 7.5pt;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 8px 6px;
            text-align: left;
        }

        .items-table thead th.right {
            text-align: right;
        }

        .items-table tbody td {
            font-size: 8.5pt;
            padding: 7px 6px;
            border-bottom: 1px solid var(--gray-200);
            vertical-align: top;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .items-table tbody td.right {
            text-align: right;
            white-space: nowrap;
        }

        .items-table tbody tr:nth-child(even) {
            background-color: var(--gray-50);
        }

        .items-table tbody tr.deselected td {
            color: #a0a0a0;
        }

        .optional-badge {
            font-size: 7pt;
            color: var(--gray-500);
            font-style: italic;
        }

        .optional-badge.deselected {
            color: #a0a0a0;
        }

        /*  Totals  */
        .totals-block {
            margin-left: auto;
            width: 48%;
            min-width: 200px;
            border-top: 2px solid var(--gray-200);
            padding-top: 8px;
        }

        .totals-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 9pt;
        }

        .totals-row .label {
            color: var(--gray-500);
            font-weight: 500;
        }

        .totals-row .value {
            color: var(--dark);
            font-weight: 600;
        }

        .totals-row.discount .value {
            color: var(--green-600);
        }

        .totals-row.grand-total {
            margin-top: 8px;
            padding: 12px 14px;
            background-color: var(--accent);
            border-radius: 4px;
            font-size: 12pt;
            font-weight: 800;
        }

        .totals-row.grand-total .label,
        .totals-row.grand-total .value {
            color: #ffffff;
            font-weight: 800;
        }

        /*  Notes  */
        .notes-block {
            margin-top: 20px;
            padding: 12px 14px;
            background-color: var(--accent-light);
            border-left: 4px solid var(--accent);
            border-radius: 4px;
        }

        .notes-block .notes-title {
            font-size: 8pt;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .notes-block .notes-text {
            font-size: 8.5pt;
            color: var(--gray-500);
            white-space: pre-wrap;
        }

        /*  Legal Terms  */
        .legal-terms {
            margin-top: 24px;
            padding-top: 12px;
            border-top: 1px solid var(--gray-200);
        }

        .legal-terms .legal-title {
            font-size: 7pt;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .legal-terms ol {
            padding-left: 16px;
            font-size: 7pt;
            color: var(--gray-500);
            line-height: 1.6;
        }

        .legal-terms li {
            margin-bottom: 2px;
        }

        @media print {
            body { background: none; padding: 0; margin: 0; }
            .items-table { page-break-inside: auto; }
            .items-table tr { page-break-inside: avoid; }
            .totals-block { page-break-inside: avoid; }
            .legal-terms { page-break-inside: avoid; }
            .notes-block { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="page">
        <!--  Header  -->
        <div class="header">
            <div class="header-logo">
                {{if .LogoBase64}}
                    <img src="data:{{.LogoMimeType}};base64,{{.LogoBase64}}" alt="Logo">
                {{else}}
                    <span class="org-name-fallback">{{.OrganizationName}}</span>
                {{end}}
            </div>
            <div class="header-title">
                <h1>OFFERTE</h1>
                <div class="quote-number">{{.QuoteNumber}}</div>
            </div>
        </div>

        <!--  Address Block  -->
        <div class="address-block">
            <div class="address-col">
                <div class="address-label">Van</div>
                <div class="address-name">{{.OrganizationName}}</div>
                <div class="address-detail">
                    {{if .OrgAddressLine1}}{{.OrgAddressLine1}}{{end}}{{if .OrgAddressLine2}}, {{.OrgAddressLine2}}{{end}}<br>
                    {{if or .OrgPostalCode .OrgCity}}{{.OrgPostalCode}} {{.OrgCity}}<br>{{end}}
                    {{if .OrgEmail}}{{.OrgEmail}}{{end}}{{if and .OrgEmail .OrgPhone}} &nbsp;|&nbsp; {{end}}{{if .OrgPhone}}{{.OrgPhone}}{{end}}<br>
                    {{if .OrgKvkNumber}}KVK: {{.OrgKvkNumber}}{{end}}{{if and .OrgKvkNumber .OrgVatNumber}} &nbsp;|&nbsp; {{end}}{{if .OrgVatNumber}}BTW: {{.OrgVatNumber}}{{end}}
                </div>
            </div>
            <div class="address-col">
                <div class="address-label">Aan</div>
                <div class="address-name">{{.CustomerName}}</div>
            </div>
            <div class="address-col meta">
                <div class="meta-row"><span class="label">Datum:</span> <span class="value">{{.CreatedAtFormatted}}</span></div>
                {{if .ValidUntilFormatted}}<div class="meta-row"><span class="label">Geldig tot:</span> <span class="value">{{.ValidUntilFormatted}}</span></div>{{end}}
                <div class="meta-row status"><span class="label">Status:</span> <span class="value {{.StatusClass}}">{{.StatusLabel}}</span></div>
            </div>
        </div>

        <!--  Status Banner  -->
        {{if eq .Status "Accepted"}}
        <div class="status-banner accepted">
             Offerte geaccepteerd{{if .AcceptedAtFormatted}} op {{.AcceptedAtFormatted}}{{end}}
        </div>
        {{end}}
        {{if eq .Status "Rejected"}}
        <div class="status-banner rejected">
             Offerte afgewezen
        </div>
        {{end}}

        <!--  Line Items  -->
        <div class="section-title">Onderdelen</div>
        <table class="items-table">
            <thead>
                <tr>
                    <th style="width: 44%">Omschrijving</th>
                    <th style="width: 10%">Aantal</th>
                    <th style="width: 15%" class="right">Stuksprijs</th>
                    <th style="width: 9%" class="right">BTW</th>
                    <th style="width: 22%" class="right">Bedrag</th>
                </tr>
            </thead>
            <tbody>
                {{range .Items}}
                <tr{{if and .IsOptional (not .IsSelected)}} class="deselected"{{end}}>
                    <td>
                        {{.Description}}
                        {{if .IsOptional}}
                            {{if .IsSelected}}
                                <span class="optional-badge">(optioneel)</span>
                            {{else}}
                                <span class="optional-badge deselected">(optioneel - niet geselecteerd)</span>
                            {{end}}
                        {{end}}
                    </td>
                    <td>{{.Quantity}}</td>
                    <td class="right">{{.UnitPriceFormatted}}</td>
                    <td class="right">{{.VatPctFormatted}}</td>
                    <td class="right">{{.LineTotalFormatted}}</td>
                </tr>
                {{end}}
            </tbody>
        </table>

        <!--  Totals  -->
        <div class="totals-block">
            <div class="totals-row">
                <span class="label">Subtotaal</span>
                <span class="value">{{.SubtotalFormatted}}</span>
            </div>
            {{if .HasDiscount}}
            <div class="totals-row discount">
                <span class="label">Korting</span>
                <span class="value">-{{.DiscountFormatted}}</span>
            </div>
            {{end}}
            {{range .VatBreakdown}}
            <div class="totals-row">
                <span class="label">BTW {{.PctFormatted}}</span>
                <span class="value">{{.AmountFormatted}}</span>
            </div>
            {{end}}
            <div class="totals-row grand-total">
                <span class="label">TOTAAL</span>
                <span class="value">{{.TotalFormatted}}</span>
            </div>
        </div>

        <!--  Notes  -->
        {{if .Notes}}
        <div class="notes-block">
            <div class="notes-title">Opmerkingen</div>
            <div class="notes-text">{{.Notes}}</div>
        </div>
        {{end}}

        <!--  Legal Terms  -->
        <div class="legal-terms">
            <div class="legal-title">Voorwaarden</div>
            <ol>
                <li>Deze offerte is vrijblijvend en onder voorbehoud van tussentijdse wijzigingen.</li>
                <li>Betaling dient te geschieden binnen {{.PaymentDays}} dagen na factuurdatum, tenzij anders overeengekomen.</li>
                <li>Op al onze offertes, overeenkomsten en leveringen zijn onze algemene voorwaarden van toepassing.</li>
                <li>Alle genoemde bedragen zijn in euro's. BTW is gespecificeerd conform Nederlandse wetgeving.</li>
                <li>Deze offerte is {{.QuoteValidDays}} dagen geldig vanaf de offertedatum.</li>
            </ol>
        </div>

    </div>
</body>
</html>
</file>

<file path="internal/quotes/handler/public_handler.go">
package handler

import (
	"context"
	"fmt"
	"io"
	"net/http"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/internal/quotes/service"
	"portal_final_backend/internal/quotes/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

const (
	msgInvalidItemID = "invalid item ID"
	contentTypePDF   = "application/pdf"
)

// PDFOnDemandGenerator generates and stores a quote PDF on the fly.
// Used for lazy PDF generation when the PDF wasn't created at acceptance time.
type PDFOnDemandGenerator interface {
	RegeneratePDF(ctx context.Context, quoteID, organizationID uuid.UUID) (fileKey string, pdfBytes []byte, err error)
}

// PublicHandler handles unauthenticated HTTP requests for public quote proposals.
type PublicHandler struct {
	svc        *service.Service
	val        *validator.Validator
	sse        *sse.Service
	storageSvc storage.StorageService
	pdfBucket  string
	pdfGen     PDFOnDemandGenerator
}

// NewPublicHandler creates a new public quotes handler.
func NewPublicHandler(svc *service.Service, val *validator.Validator) *PublicHandler {
	return &PublicHandler{svc: svc, val: val}
}

// SetSSE injects the SSE service for public real-time events.
func (h *PublicHandler) SetSSE(s *sse.Service) {
	h.sse = s
}

// SetStorageForPDF injects the storage service and bucket for PDF downloads.
func (h *PublicHandler) SetStorageForPDF(svc storage.StorageService, bucket string) {
	h.storageSvc = svc
	h.pdfBucket = bucket
}

// SetPDFGenerator injects the on-demand PDF generator for lazy PDF creation.
func (h *PublicHandler) SetPDFGenerator(gen PDFOnDemandGenerator) {
	h.pdfGen = gen
}

// RegisterRoutes registers the public quote routes (no auth middleware).
func (h *PublicHandler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("/:token", h.GetPublicQuote)
	rg.PATCH("/:token/items/:itemId/toggle", h.ToggleItem)
	rg.POST("/:token/items/:itemId/annotations", h.AnnotateItem)
	rg.PATCH(":token/items/:itemId/annotations/:annotationId", h.UpdateAnnotation)
	rg.DELETE(":token/items/:itemId/annotations/:annotationId", h.DeleteAnnotation)
	rg.POST("/:token/accept", h.Accept)
	rg.POST("/:token/reject", h.Reject)
	rg.GET("/:token/pdf", h.DownloadPDF)

	// Public SSE  customer page gets real-time updates
	if h.sse != nil {
		rg.GET("/:token/events", h.sse.PublicQuoteHandler(h.resolveQuoteID))
	}
}

// resolveQuoteID maps a public token to a quote UUID.
func (h *PublicHandler) resolveQuoteID(token string) (uuid.UUID, error) {
	ctx := context.Background()
	return h.svc.GetPublicQuoteID(ctx, token)
}

// GetPublicQuote handles GET /api/v1/public/quotes/:token
func (h *PublicHandler) GetPublicQuote(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		httpkit.Error(c, http.StatusBadRequest, "token is required", nil)
		return
	}

	result, err := h.svc.GetPublic(c.Request.Context(), token)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// ToggleItem handles PATCH /api/v1/public/quotes/:token/items/:itemId/toggle
func (h *PublicHandler) ToggleItem(c *gin.Context) {
	token := c.Param("token")
	itemID, err := uuid.Parse(c.Param("itemId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidItemID, nil)
		return
	}

	var req transport.ToggleItemRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.svc.ToggleLineItem(c.Request.Context(), token, itemID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// AnnotateItem handles POST /api/v1/public/quotes/:token/items/:itemId/annotations
func (h *PublicHandler) AnnotateItem(c *gin.Context) {
	token := c.Param("token")
	itemID, err := uuid.Parse(c.Param("itemId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidItemID, nil)
		return
	}

	var req transport.AnnotateItemRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	// For public (customer) annotations, use client IP as author ID
	authorID := c.ClientIP()
	result, err := h.svc.AnnotateItem(c.Request.Context(), token, itemID, "customer", authorID, req.Text)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// UpdateAnnotation handles PATCH /api/v1/public/quotes/:token/items/:itemId/annotations/:annotationId
func (h *PublicHandler) UpdateAnnotation(c *gin.Context) {
	token := c.Param("token")
	itemID, err := uuid.Parse(c.Param("itemId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidItemID, nil)
		return
	}
	annotationID, err := uuid.Parse(c.Param("annotationId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid annotation ID", nil)
		return
	}

	var req transport.AnnotateItemRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.svc.UpdateAnnotation(c.Request.Context(), token, itemID, annotationID, "customer", req.Text)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// DeleteAnnotation handles DELETE /api/v1/public/quotes/:token/items/:itemId/annotations/:annotationId
func (h *PublicHandler) DeleteAnnotation(c *gin.Context) {
	token := c.Param("token")
	itemID, err := uuid.Parse(c.Param("itemId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidItemID, nil)
		return
	}
	annotationID, err := uuid.Parse(c.Param("annotationId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid annotation ID", nil)
		return
	}

	if err := h.svc.DeleteAnnotation(c.Request.Context(), token, itemID, annotationID, "customer"); httpkit.HandleError(c, err) {
		return
	}

	c.Status(http.StatusNoContent)
}

// Accept handles POST /api/v1/public/quotes/:token/accept
func (h *PublicHandler) Accept(c *gin.Context) {
	token := c.Param("token")

	var req transport.AcceptQuoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	clientIP := c.ClientIP()
	result, err := h.svc.Accept(c.Request.Context(), token, req, clientIP)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// DownloadPDF handles GET /api/v1/public/quotes/:token/pdf
// Allows customers to download the generated PDF using the public token.
func (h *PublicHandler) DownloadPDF(c *gin.Context) {
	if h.storageSvc == nil {
		httpkit.Error(c, http.StatusServiceUnavailable, "PDF downloads are not configured", nil)
		return
	}

	token := c.Param("token")
	if token == "" {
		httpkit.Error(c, http.StatusBadRequest, "token is required", nil)
		return
	}

	result, err := h.svc.GetPublic(c.Request.Context(), token)
	if httpkit.HandleError(c, err) {
		return
	}

	// Only accepted quotes have a PDF
	if result.Status != transport.QuoteStatusAccepted {
		httpkit.Error(c, http.StatusNotFound, "PDF is alleen beschikbaar voor geaccepteerde offertes", nil)
		return
	}

	// We need to get the internal quote to access the PDF file key (not exposed in public response)
	quoteID, err := h.svc.GetPublicQuoteID(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to resolve quote", nil)
		return
	}

	pdfFileKey, err := h.svc.GetPDFFileKey(c.Request.Context(), quoteID)
	if err != nil || pdfFileKey == "" {
		// Lazy generation: if no PDF is stored yet but the quote is accepted, generate on the fly
		if h.tryServeOnDemandPDF(c, quoteID, result.QuoteNumber) {
			return
		}
		httpkit.Error(c, http.StatusNotFound, "no PDF available for this quote", nil)
		return
	}

	reader, err := h.storageSvc.DownloadFile(c.Request.Context(), h.pdfBucket, pdfFileKey)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to retrieve PDF", err.Error())
		return
	}
	defer func() { _ = reader.Close() }()

	fileName := fmt.Sprintf("Offerte-%s.pdf", result.QuoteNumber)
	c.Header("Content-Type", contentTypePDF)
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, fileName))
	c.Status(http.StatusOK)

	if _, err := io.Copy(c.Writer, reader); err != nil {
		_ = c.Error(err)
	}
}

func (h *PublicHandler) tryServeOnDemandPDF(c *gin.Context, quoteID uuid.UUID, quoteNumber string) bool {
	if h.pdfGen == nil {
		return false
	}

	orgID, orgErr := h.svc.GetOrganizationID(c.Request.Context(), quoteID)
	if orgErr != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to resolve organization", nil)
		return true
	}

	fileKey, pdfBytes, genErr := h.pdfGen.RegeneratePDF(c.Request.Context(), quoteID, orgID)
	if genErr != nil {
		httpkit.Error(c, http.StatusInternalServerError, "PDF generatie mislukt", genErr.Error())
		return true
	}

	fileName := fmt.Sprintf("Offerte-%s.pdf", quoteNumber)
	c.Header("Content-Type", contentTypePDF)
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, fileName))
	c.Data(http.StatusOK, contentTypePDF, pdfBytes)
	_ = fileKey // stored by the processor
	return true
}

// Reject handles POST /api/v1/public/quotes/:token/reject
func (h *PublicHandler) Reject(c *gin.Context) {
	token := c.Param("token")

	var req transport.RejectQuoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.svc.Reject(c.Request.Context(), token, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}
</file>

<file path="internal/webhook/service.go">
package webhook

import (
	"context"
	"encoding/json"
	"io"
	"strings"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/platform/logger"

	"github.com/google/uuid"
)

// LeadCreator is the interface for creating leads. Satisfied by management.Service.
type LeadCreator interface {
	Create(ctx context.Context, req transport.CreateLeadRequest, tenantID uuid.UUID) (transport.LeadResponse, error)
}

// FormSubmission represents an inbound form submission via the webhook.
type FormSubmission struct {
	Fields       map[string]string // all form fields as key-value
	Files        []FormFile        // uploaded files
	SourceDomain string            // origin domain of the form
	APIKeyID     uuid.UUID         // the API key that authenticated this request
}

// FormFile represents an uploaded file within a form submission.
type FormFile struct {
	FieldName   string
	FileName    string
	ContentType string
	Size        int64
	Reader      io.Reader
}

// FormSubmissionResponse is returned to the caller on success.
type FormSubmissionResponse struct {
	LeadID       uuid.UUID         `json:"leadId"`
	IsIncomplete bool              `json:"isIncomplete"`
	Extracted    map[string]string `json:"extractedFields"`
	Message      string            `json:"message"`
}

// Service handles inbound form submissions and API key management.
type Service struct {
	repo          *Repository
	leadCreator   LeadCreator
	storageSvc    storage.StorageService
	storageBucket string
	eventBus      events.Bus
	log           *logger.Logger
}

// NewService creates a new webhook service.
func NewService(repo *Repository, leadCreator LeadCreator, storageSvc storage.StorageService, storageBucket string, eventBus events.Bus, log *logger.Logger) *Service {
	return &Service{
		repo:          repo,
		leadCreator:   leadCreator,
		storageSvc:    storageSvc,
		storageBucket: storageBucket,
		eventBus:      eventBus,
		log:           log,
	}
}

// ProcessFormSubmission handles an inbound form submission: extract fields, create lead, upload files, store raw data.
func (s *Service) ProcessFormSubmission(ctx context.Context, sub FormSubmission, orgID uuid.UUID) (FormSubmissionResponse, error) {
	extracted := ExtractFields(sub.Fields)
	isIncomplete := extracted.IsIncomplete()

	createReq := buildCreateLeadRequest(extracted, sub.SourceDomain)
	applyLeadPlaceholders(&createReq)

	leadResp, err := s.leadCreator.Create(ctx, createReq, orgID)
	if err != nil {
		s.log.Error("webhook: failed to create lead from form submission", "error", err, "domain", sub.SourceDomain)
		return FormSubmissionResponse{}, err
	}

	// 4. Store the raw form data + webhook metadata on the lead
	rawData, _ := json.Marshal(sub.Fields)
	if err := s.repo.UpdateWebhookLeadData(ctx, leadResp.ID, orgID, rawData, sub.SourceDomain, isIncomplete); err != nil {
		s.log.Error("webhook: failed to store raw form data", "error", err, "leadId", leadResp.ID)
		// Non-fatal: don't fail the request
	}

	// 5. Upload files as lead service attachments
	if len(sub.Files) > 0 && len(leadResp.Services) > 0 {
		serviceID := leadResp.Services[0].ID
		s.uploadFiles(ctx, leadResp.ID, serviceID, orgID, sub.Files)
	}

	// 6. Publish event
	s.eventBus.Publish(ctx, events.WebhookLeadCreated{
		BaseEvent:    events.NewBaseEvent(),
		LeadID:       leadResp.ID,
		TenantID:     orgID,
		SourceDomain: sub.SourceDomain,
		IsIncomplete: isIncomplete,
	})

	extractedMap := buildExtractedMap(extracted)
	msg := buildWebhookMessage(isIncomplete)

	return FormSubmissionResponse{
		LeadID:       leadResp.ID,
		IsIncomplete: isIncomplete,
		Extracted:    extractedMap,
		Message:      msg,
	}, nil
}

func buildCreateLeadRequest(extracted ExtractedFields, sourceDomain string) transport.CreateLeadRequest {
	return transport.CreateLeadRequest{
		FirstName:     normalizeName(extracted.FirstName),
		LastName:      normalizeName(extracted.LastName),
		Phone:         extracted.Phone,
		Email:         extracted.Email,
		ConsumerRole:  transport.ConsumerRoleOwner,
		Street:        extracted.Street,
		HouseNumber:   extracted.HouseNumber,
		ZipCode:       extracted.ZipCode,
		City:          extracted.City,
		ServiceType:   transport.ServiceType(resolveServiceType(extracted.ServiceType)),
		ConsumerNote:  extracted.Message,
		Source:        "webhook:" + sourceDomain,
		GCLID:         extracted.GCLID,
		UTMSource:     extracted.UTMSource,
		UTMMedium:     extracted.UTMMedium,
		UTMCampaign:   extracted.UTMCampaign,
		UTMContent:    extracted.UTMContent,
		UTMTerm:       extracted.UTMTerm,
		AdLandingPage: extracted.AdLandingPage,
		ReferrerURL:   extracted.ReferrerURL,
	}
}

func normalizeName(value string) string {
	if value != "" {
		return value
	}
	return "Onbekend"
}

func resolveServiceType(value string) string {
	if value != "" {
		return value
	}
	return "Algemeen"
}

func applyLeadPlaceholders(createReq *transport.CreateLeadRequest) {
	if createReq.Phone == "" {
		createReq.Phone = "+31000000000"
	}
	if createReq.Street == "" {
		createReq.Street = "Onbekend"
	}
	if createReq.HouseNumber == "" {
		createReq.HouseNumber = "-"
	}
	if createReq.ZipCode == "" {
		createReq.ZipCode = "0000AA"
	}
	if createReq.City == "" {
		createReq.City = "Onbekend"
	}
}

func buildExtractedMap(extracted ExtractedFields) map[string]string {
	result := map[string]string{}
	if extracted.FirstName != "" {
		result["firstName"] = extracted.FirstName
	}
	if extracted.LastName != "" {
		result["lastName"] = extracted.LastName
	}
	if extracted.Email != "" {
		result["email"] = extracted.Email
	}
	if extracted.Phone != "" {
		result["phone"] = extracted.Phone
	}
	if extracted.Street != "" {
		result["street"] = extracted.Street
	}
	if extracted.HouseNumber != "" {
		result["houseNumber"] = extracted.HouseNumber
	}
	if extracted.ZipCode != "" {
		result["zipCode"] = extracted.ZipCode
	}
	if extracted.City != "" {
		result["city"] = extracted.City
	}
	if extracted.ServiceType != "" {
		result["serviceType"] = extracted.ServiceType
	}
	return result
}

func buildWebhookMessage(isIncomplete bool) string {
	if isIncomplete {
		return "Lead created with incomplete data  manual review recommended"
	}
	return "Lead created successfully"
}

func (s *Service) uploadFiles(ctx context.Context, leadID, serviceID, orgID uuid.UUID, files []FormFile) {
	folder := strings.Join([]string{orgID.String(), leadID.String(), serviceID.String()}, "/")
	for _, f := range files {
		fileKey, err := s.storageSvc.UploadFile(ctx, s.storageBucket, folder, f.FileName, f.ContentType, f.Reader, f.Size)
		if err != nil {
			s.log.Error("webhook: failed to upload file",
				"error", err,
				"leadId", leadID,
				"fileName", f.FileName,
			)
			continue
		}

		// Publish attachment uploaded event so existing photo analysis pipelines kick in
		s.eventBus.Publish(ctx, events.AttachmentUploaded{
			BaseEvent:     events.NewBaseEvent(),
			LeadID:        leadID,
			LeadServiceID: serviceID,
			TenantID:      orgID,
			AttachmentID:  uuid.New(),
			FileName:      f.FileName,
			FileKey:       fileKey,
			ContentType:   f.ContentType,
			SizeBytes:     f.Size,
		})

		s.log.Info("webhook: uploaded file", "leadId", leadID, "fileKey", fileKey)
	}
}
</file>

<file path="internal/whatsapp/client.go">
package whatsapp

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/phone"
)

// gowaLoginResponse is the JSON envelope GoWA returns for /devices/:id/login.
// Results.QRLink is a URL pointing to a static QR image on the GoWA server.
type gowaLoginResponse struct {
	Code    string `json:"code"`
	Message string `json:"message"`
	Results struct {
		QRLink     string `json:"qr_link"`
		QRDuration int    `json:"qr_duration"`
	} `json:"results"`
}

type Client struct {
	baseURL         string
	apiKey          string
	defaultDeviceID string
	http            *http.Client
	log             *logger.Logger
}

type gowaRequest struct {
	Phone   string `json:"phone"`
	Message string `json:"message"`
}

type DeviceInput struct {
	DeviceID string `json:"device_id"`
}

// gowaStatusResponse is the raw JSON envelope from GoWA's /devices/:id/status.
type gowaStatusResponse struct {
	Code    string `json:"code"`
	Status  int    `json:"status"`
	Message string `json:"message"`
	Results struct {
		DeviceID    string `json:"device_id"`
		IsConnected bool   `json:"is_connected"`
		IsLoggedIn  bool   `json:"is_logged_in"`
	} `json:"results"`
}

// DeviceStatusResponse is the normalised device status exposed to callers.
type DeviceStatusResponse struct {
	DeviceID    string
	IsConnected bool
	IsLoggedIn  bool
}

var ErrNoDevice = errors.New("no whatsapp device configured")

func NewClient(cfg config.WhatsAppConfig, log *logger.Logger) *Client {
	if cfg.GetWhatsAppURL() == "" {
		return nil
	}

	return &Client{
		baseURL:         strings.TrimRight(cfg.GetWhatsAppURL(), "/"),
		apiKey:          cfg.GetWhatsAppKey(),
		defaultDeviceID: cfg.GetWhatsAppDeviceID(),
		http:            &http.Client{Timeout: 10 * time.Second},
		log:             log,
	}
}

func (c *Client) SendMessage(ctx context.Context, deviceID string, phoneNumber string, message string) error {
	if c == nil {
		return nil
	}

	targetDevice := deviceID
	if targetDevice == "" {
		targetDevice = c.defaultDeviceID
	}
	if targetDevice == "" {
		return ErrNoDevice
	}

	normalized := strings.TrimPrefix(phone.NormalizeE164(phoneNumber), "+")
	payload := gowaRequest{
		Phone:   normalized,
		Message: message,
	}

	err := c.doSendMessage(ctx, targetDevice, payload)
	if err != nil && isConnectionError(err) {
		c.log.Warn("whatsapp connection lost, attempting reconnect", "deviceId", targetDevice)
		if reconErr := c.ReconnectDevice(ctx, targetDevice); reconErr == nil {
			time.Sleep(2 * time.Second)
			return c.doSendMessage(ctx, targetDevice, payload)
		}
	}

	if err == nil {
		c.log.Info("whatsapp sent via gowa", "phone", normalized, "deviceId", targetDevice)
	}
	return err
}

func (c *Client) doSendMessage(ctx context.Context, deviceID string, payload gowaRequest) error {
	body, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("marshal whatsapp payload: %w", err)
	}

	url := fmt.Sprintf("%s/send/message", c.baseURL)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(body))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	c.addHeaders(req, deviceID)

	resp, err := c.http.Do(req)
	if err != nil {
		return fmt.Errorf("whatsapp request failed: %w", err)
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode >= http.StatusBadRequest {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("whatsapp service returned %d: %s", resp.StatusCode, strings.TrimSpace(string(data)))
	}

	return nil
}

func (c *Client) CreateDevice(ctx context.Context, deviceID string) error {
	if c == nil {
		return nil
	}

	payload := DeviceInput{
		DeviceID: deviceID,
	}
	body, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("marshal device payload: %w", err)
	}

	url := fmt.Sprintf("%s/devices", c.baseURL)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(body))
	if err != nil {
		return err
	}

	c.addHeaders(req, "")

	resp, err := c.http.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode == http.StatusConflict {
		return nil
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to create device, status %d: %s", resp.StatusCode, strings.TrimSpace(string(data)))
	}
	return nil
}

func (c *Client) GetLoginQR(ctx context.Context, deviceID string) ([]byte, error) {
	if c == nil {
		return nil, fmt.Errorf("whatsapp client not initialized")
	}

	// Use a generous timeout for QR generation (WhatsApp handshake can be slow).
	qrCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// 1st attempt: per-device login endpoint (GoWA v8 multi-device)
	primaryURL := fmt.Sprintf("%s/devices/%s/login?output=image", c.baseURL, deviceID)
	qrBytes, fallback, err := c.fetchLoginQR(qrCtx, primaryURL, deviceID)
	if err == nil {
		return qrBytes, nil
	}
	if !fallback {
		return nil, err
	}

	// 2nd attempt: legacy endpoint with device_id query param
	fallbackURL := fmt.Sprintf("%s/app/login?output=image&device_id=%s", c.baseURL, deviceID)
	qrBytes, fallback, err = c.fetchLoginQR(qrCtx, fallbackURL, "")
	if err == nil {
		return qrBytes, nil
	}
	if !fallback {
		return nil, err
	}

	// 3rd attempt: plain legacy endpoint (single-device GoWA builds)
	finalFallbackURL := fmt.Sprintf("%s/app/login?output=image", c.baseURL)
	qrBytes, _, err = c.fetchLoginQR(qrCtx, finalFallbackURL, "")
	if err == nil {
		return qrBytes, nil
	}

	return nil, err
}

func (c *Client) fetchLoginQR(ctx context.Context, url string, deviceID string) ([]byte, bool, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, false, err
	}

	c.addHeaders(req, deviceID)
	req.Header.Set("Accept", "image/png, image/*, application/json")

	resp, err := c.http.Do(req)
	if err != nil {
		return nil, false, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		data, _ := io.ReadAll(resp.Body)
		body := strings.TrimSpace(string(data))
		msgLower := strings.ToLower(body)
		// If the endpoint says "not implemented", signal the caller to try the next fallback.
		if resp.StatusCode >= http.StatusInternalServerError && strings.Contains(msgLower, "not implemented") {
			return nil, true, fmt.Errorf("failed to get QR, status %d: %s", resp.StatusCode, body)
		}
		// Also treat 404 as "try next"  some GoWA builds don't expose the endpoint.
		if resp.StatusCode == http.StatusNotFound {
			return nil, true, fmt.Errorf("QR endpoint not found: %d: %s", resp.StatusCode, body)
		}
		return nil, false, fmt.Errorf("failed to get QR, status %d: %s", resp.StatusCode, body)
	}

	qrBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, false, err
	}

	// If GoWA returned JSON instead of an image, extract the QR URL and fetch it.
	ct := resp.Header.Get("Content-Type")
	if strings.Contains(ct, "application/json") || (len(qrBytes) > 0 && qrBytes[0] == '{') {
		if img, err := c.extractQRFromJSON(ctx, qrBytes); err == nil && img != nil {
			return img, false, nil
		}
		// JSON but no extractable image  treat as fallback-worthy.
		return nil, true, fmt.Errorf("QR endpoint returned JSON without image data")
	}

	return qrBytes, false, nil
}

// extractQRFromJSON parses the GoWA login JSON response and returns the QR
// image bytes. If qr_link is a URL (the normal case), the image is fetched
// from the GoWA server. Falls back to base64 data-URI decoding.
func (c *Client) extractQRFromJSON(ctx context.Context, data []byte) ([]byte, error) {
	var resp gowaLoginResponse
	if err := json.Unmarshal(data, &resp); err != nil {
		return nil, err
	}
	qr := resp.Results.QRLink
	if qr == "" {
		return nil, fmt.Errorf("no qr_link in response")
	}

	// GoWA returns qr_link as a URL to a static PNG on the server.
	if strings.HasPrefix(qr, "http://") || strings.HasPrefix(qr, "https://") {
		resolved := c.resolveGoWAURL(qr)
		c.log.Info("fetching QR image from URL", "url", resolved)
		return c.fetchImageFromURL(ctx, resolved)
	}

	// Fallback: try to decode as base64 data URI.
	if idx := strings.Index(qr, ","); idx >= 0 {
		qr = qr[idx+1:]
	}
	decoded, err := base64.StdEncoding.DecodeString(qr)
	if err != nil {
		decoded, err = base64.RawStdEncoding.DecodeString(qr)
		if err != nil {
			return nil, fmt.Errorf("failed to decode QR data: %w", err)
		}
	}
	return decoded, nil
}

// resolveGoWAURL rewrites a URL returned by GoWA so it uses the configured
// base URL's scheme and host (GoWA often returns http://localhost:3000/).
func (c *Client) resolveGoWAURL(rawURL string) string {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		return rawURL
	}
	baseParsed, err := url.Parse(c.baseURL)
	if err != nil {
		return rawURL
	}
	parsed.Scheme = baseParsed.Scheme
	parsed.Host = baseParsed.Host
	return parsed.String()
}

// fetchImageFromURL downloads an image from the given URL with auth headers.
func (c *Client) fetchImageFromURL(ctx context.Context, imageURL string) ([]byte, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, imageURL, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "image/png, image/*")
	if c.apiKey != "" {
		req.Header.Set("Authorization", formatAuthHeader(c.apiKey))
	}

	resp, err := c.http.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch QR image: %w", err)
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("QR image fetch returned %d", resp.StatusCode)
	}

	return io.ReadAll(resp.Body)
}

func (c *Client) DeleteDevice(ctx context.Context, deviceID string) error {
	if c == nil {
		return nil
	}

	url := fmt.Sprintf("%s/devices/%s", c.baseURL, deviceID)
	req, err := http.NewRequestWithContext(ctx, http.MethodDelete, url, nil)
	if err != nil {
		return err
	}

	c.addHeaders(req, deviceID)

	resp, err := c.http.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode >= http.StatusBadRequest && resp.StatusCode != http.StatusNotFound {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to delete device, status %d: %s", resp.StatusCode, strings.TrimSpace(string(data)))
	}
	return nil
}

func (c *Client) GetDeviceStatus(ctx context.Context, deviceID string) (*DeviceStatusResponse, error) {
	if c == nil {
		return nil, fmt.Errorf("whatsapp client not initialized")
	}

	url := fmt.Sprintf("%s/devices/%s/status", c.baseURL, deviceID)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	c.addHeaders(req, deviceID)

	resp, err := c.http.Do(req)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode == http.StatusNotFound {
		return nil, apperr.NotFound("device not found in provider")
	}
	if resp.StatusCode != http.StatusOK {
		data, _ := io.ReadAll(resp.Body)
		body := strings.TrimSpace(string(data))
		if resp.StatusCode >= http.StatusInternalServerError {
			msgLower := strings.ToLower(body)
			if strings.Contains(msgLower, "device") && strings.Contains(msgLower, "not found") {
				return nil, apperr.NotFound("device not found in provider")
			}
		}
		return nil, fmt.Errorf("provider error: %d: %s", resp.StatusCode, body)
	}

	var raw gowaStatusResponse
	if err := json.NewDecoder(resp.Body).Decode(&raw); err != nil {
		return nil, err
	}

	return &DeviceStatusResponse{
		DeviceID:    raw.Results.DeviceID,
		IsConnected: raw.Results.IsConnected,
		IsLoggedIn:  raw.Results.IsLoggedIn,
	}, nil
}

func (c *Client) ReconnectDevice(ctx context.Context, deviceID string) error {
	if c == nil {
		return nil
	}

	url := fmt.Sprintf("%s/devices/%s/reconnect", c.baseURL, deviceID)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, nil)
	if err != nil {
		return err
	}

	c.addHeaders(req, deviceID)

	resp, err := c.http.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		data, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("reconnect failed (%d): %s", resp.StatusCode, strings.TrimSpace(string(data)))
	}

	return nil
}

func (c *Client) addHeaders(req *http.Request, deviceID string) {
	req.Header.Set("Content-Type", "application/json")
	if c.apiKey != "" {
		req.Header.Set("Authorization", formatAuthHeader(c.apiKey))
	}
	if deviceID != "" {
		req.Header.Set("X-Device-Id", deviceID)
	}
}

func isConnectionError(err error) bool {
	msg := strings.ToLower(err.Error())
	return strings.Contains(msg, "client is not connected") || strings.Contains(msg, "context deadline exceeded")
}

func formatAuthHeader(apiKey string) string {
	if strings.HasPrefix(strings.ToLower(apiKey), "basic ") {
		return apiKey
	}

	encoded := base64.StdEncoding.EncodeToString([]byte(apiKey))
	return "Basic " + encoded
}
</file>

<file path="internal/leads/ports/public_interfaces.go">
package ports

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// PublicQuoteSummary represents what the lead portal needs to know about a quote.
type PublicQuoteSummary struct {
	ID          uuid.UUID
	QuoteNumber string
	Status      string
	PublicToken string
	TotalCents  int64
	PDFFileKey  *string
}

// PublicAppointmentSummary represents what the lead portal needs to know about a visit.
type PublicAppointmentSummary struct {
	ID        uuid.UUID `json:"id"`
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
	Title     string    `json:"title"`
	Status    string    `json:"status"`
}

// OrganizationPublicViewer allows the lead portal to fetch organization contact info.
type OrganizationPublicViewer interface {
	GetPublicPhone(ctx context.Context, organizationID uuid.UUID) (string, error)
}

// PublicTimeSlot represents a single public-facing available time slot.
type PublicTimeSlot struct {
	UserID    uuid.UUID `json:"userId"`
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
}

// PublicDaySlots groups available slots by date.
type PublicDaySlots struct {
	Date  string           `json:"date"`
	Slots []PublicTimeSlot `json:"slots"`
}

// PublicAvailableSlotsResponse is returned by the public availability endpoint.
type PublicAvailableSlotsResponse struct {
	Days []PublicDaySlots `json:"days"`
}

// QuotePublicViewer allows the leads domain to fetch active quotes.
type QuotePublicViewer interface {
	GetActiveQuote(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*PublicQuoteSummary, error)
}

// AppointmentPublicViewer allows the leads domain to fetch scheduled visits.
type AppointmentPublicViewer interface {
	GetUpcomingVisit(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*PublicAppointmentSummary, error)
	GetPendingVisit(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*PublicAppointmentSummary, error)
	ListVisits(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]PublicAppointmentSummary, error)
}

// AppointmentSlotProvider exposes availability and booking for the public portal.
type AppointmentSlotProvider interface {
	HasAvailabilityRules(ctx context.Context, organizationID uuid.UUID) (bool, error)
	GetAvailableSlots(ctx context.Context, organizationID uuid.UUID, startDate string, endDate string, slotDuration int) (*PublicAvailableSlotsResponse, error)
	CreateRequestedAppointment(ctx context.Context, userID uuid.UUID, organizationID uuid.UUID, leadID uuid.UUID, leadServiceID uuid.UUID, startTime time.Time, endTime time.Time) (*PublicAppointmentSummary, error)
}
</file>

<file path="internal/services/service/service.go">
package service

import (
	"context"
	"errors"
	"regexp"
	"strings"

	"github.com/google/uuid"

	"portal_final_backend/internal/services/repository"
	"portal_final_backend/internal/services/transport"
	"portal_final_backend/platform/logger"

	"github.com/jackc/pgx/v5/pgconn"
)

// Service provides business logic for service types.
type Service struct {
	repo repository.Repository
	log  *logger.Logger
}

// New creates a new service types service.
func New(repo repository.Repository, log *logger.Logger) *Service {
	return &Service{repo: repo, log: log}
}

// GetByID retrieves a service type by ID.
func (s *Service) GetByID(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.ServiceTypeResponse, error) {
	st, err := s.repo.GetByID(ctx, tenantID, id)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}
	return toResponse(st), nil
}

// GetBySlug retrieves a service type by slug.
func (s *Service) GetBySlug(ctx context.Context, tenantID uuid.UUID, slug string) (transport.ServiceTypeResponse, error) {
	st, err := s.repo.GetBySlug(ctx, tenantID, slug)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}
	return toResponse(st), nil
}

// List retrieves all service types (admin default list).
func (s *Service) List(ctx context.Context, tenantID uuid.UUID) (transport.ServiceTypeListResponse, error) {
	items, err := s.repo.List(ctx, tenantID)
	if err != nil {
		return transport.ServiceTypeListResponse{}, err
	}
	return toListResponseWithPagination(items, len(items), 1, len(items)), nil
}

// ListWithFilters retrieves service types with search, filters, and pagination (admin).
func (s *Service) ListWithFilters(ctx context.Context, tenantID uuid.UUID, req transport.ListServiceTypesRequest) (transport.ServiceTypeListResponse, error) {
	page := req.Page
	pageSize := req.PageSize
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}

	isActive := req.IsActive
	if isActive == nil {
		defaultActive := true
		isActive = &defaultActive
	}

	params := repository.ListParams{
		OrganizationID: tenantID,
		Search:         req.Search,
		IsActive:       isActive,
		Offset:         (page - 1) * pageSize,
		Limit:          pageSize,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
	}

	items, total, err := s.repo.ListWithFilters(ctx, params)
	if err != nil {
		return transport.ServiceTypeListResponse{}, err
	}

	return toListResponseWithPagination(items, total, page, pageSize), nil
}

// ListActive retrieves only active service types.
func (s *Service) ListActive(ctx context.Context, tenantID uuid.UUID) (transport.ServiceTypeListResponse, error) {
	items, err := s.repo.ListActive(ctx, tenantID)
	if err != nil {
		return transport.ServiceTypeListResponse{}, err
	}
	return toListResponseWithPagination(items, len(items), 1, len(items)), nil
}

// Create creates a new service type.
func (s *Service) Create(ctx context.Context, tenantID uuid.UUID, req transport.CreateServiceTypeRequest) (transport.ServiceTypeResponse, error) {
	params := repository.CreateParams{
		OrganizationID:   tenantID,
		Name:             req.Name,
		Slug:             generateSlug(req.Name),
		Description:      req.Description,
		IntakeGuidelines: req.IntakeGuidelines,
		Icon:             req.Icon,
		Color:            req.Color,
	}

	st, err := s.repo.Create(ctx, params)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}

	s.log.Info("service type created", "id", st.ID, "name", st.Name, "slug", st.Slug)
	return toResponse(st), nil
}

// Update updates an existing service type.
func (s *Service) Update(ctx context.Context, tenantID uuid.UUID, id uuid.UUID, req transport.UpdateServiceTypeRequest) (transport.ServiceTypeResponse, error) {
	var slug *string
	if req.Name != nil {
		newSlug := generateSlug(*req.Name)
		slug = &newSlug
	}

	params := repository.UpdateParams{
		ID:               id,
		OrganizationID:   tenantID,
		Name:             req.Name,
		Slug:             slug,
		Description:      req.Description,
		IntakeGuidelines: req.IntakeGuidelines,
		Icon:             req.Icon,
		Color:            req.Color,
	}

	st, err := s.repo.Update(ctx, params)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}

	s.log.Info("service type updated", "id", st.ID, "name", st.Name)
	return toResponse(st), nil
}

// Delete removes or deactivates a service type based on usage.
func (s *Service) Delete(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.DeleteServiceTypeResponse, error) {
	used, err := s.repo.HasLeadServices(ctx, tenantID, id)
	if err != nil {
		return transport.DeleteServiceTypeResponse{}, err
	}

	if used {
		if err := s.repo.SetActive(ctx, tenantID, id, false); err != nil {
			return transport.DeleteServiceTypeResponse{}, err
		}
		s.log.Info("service type deactivated", "id", id)
		return transport.DeleteServiceTypeResponse{Status: "deactivated"}, nil
	}

	if err := s.repo.Delete(ctx, tenantID, id); err != nil {
		return transport.DeleteServiceTypeResponse{}, err
	}

	s.log.Info("service type deleted", "id", id)
	return transport.DeleteServiceTypeResponse{Status: "deleted"}, nil
}

// ToggleActive toggles the is_active flag for a service type.
func (s *Service) ToggleActive(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.ServiceTypeResponse, error) {
	// Get current state
	st, err := s.repo.GetByID(ctx, tenantID, id)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}

	// Toggle
	newActive := !st.IsActive
	if err := s.repo.SetActive(ctx, tenantID, id, newActive); err != nil {
		return transport.ServiceTypeResponse{}, err
	}

	// Get updated record
	st, err = s.repo.GetByID(ctx, tenantID, id)
	if err != nil {
		return transport.ServiceTypeResponse{}, err
	}

	s.log.Info("service type active toggled", "id", id, "isActive", newActive)
	return toResponse(st), nil
}

// Exists checks if a service type exists by ID.
func (s *Service) Exists(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (bool, error) {
	return s.repo.Exists(ctx, tenantID, id)
}

// SeedDefaults ensures a tenant has the default service types.
func (s *Service) SeedDefaults(ctx context.Context, tenantID uuid.UUID) error {
	items, err := s.repo.List(ctx, tenantID)
	if err != nil {
		return err
	}

	// If the org has existing types, only ensure "Algemeen" exists (the catch-all).
	// If the org has no types at all, seed everything.
	if len(items) > 0 {
		return s.ensureAlgemeen(ctx, tenantID, items)
	}

	for _, def := range defaultServiceTypes {
		_, err := s.repo.Create(ctx, repository.CreateParams{
			OrganizationID:   tenantID,
			Name:             def.Name,
			Slug:             def.Slug,
			Description:      toPtr(def.Description),
			IntakeGuidelines: toPtr(def.IntakeGuidelines),
			Icon:             toPtr(def.Icon),
			Color:            toPtr(def.Color),
		})
		if err != nil {
			if isDuplicateServiceType(err) {
				continue
			}
			return err
		}
	}

	return nil
}

// ensureAlgemeen makes sure the "Algemeen" service type exists for a tenant.
func (s *Service) ensureAlgemeen(ctx context.Context, tenantID uuid.UUID, existing []repository.ServiceType) error {
	for _, st := range existing {
		if st.Slug == "algemeen" {
			return nil // already exists
		}
	}

	// Find the Algemeen definition
	for _, def := range defaultServiceTypes {
		if def.Slug == "algemeen" {
			_, err := s.repo.Create(ctx, repository.CreateParams{
				OrganizationID:   tenantID,
				Name:             def.Name,
				Slug:             def.Slug,
				Description:      toPtr(def.Description),
				IntakeGuidelines: toPtr(def.IntakeGuidelines),
				Icon:             toPtr(def.Icon),
				Color:            toPtr(def.Color),
			})
			if err != nil && !isDuplicateServiceType(err) {
				return err
			}
			return nil
		}
	}
	return nil
}

// toResponse converts a repository ServiceType to transport response.
func toResponse(st repository.ServiceType) transport.ServiceTypeResponse {
	return transport.ServiceTypeResponse{
		ID:               st.ID,
		Name:             st.Name,
		Slug:             st.Slug,
		Description:      st.Description,
		IntakeGuidelines: st.IntakeGuidelines,
		Icon:             st.Icon,
		Color:            st.Color,
		IsActive:         st.IsActive,
		CreatedAt:        st.CreatedAt,
		UpdatedAt:        st.UpdatedAt,
	}
}

// toListResponseWithPagination converts a slice of repository ServiceTypes to transport response.
func toListResponseWithPagination(items []repository.ServiceType, total int, page int, pageSize int) transport.ServiceTypeListResponse {
	responses := make([]transport.ServiceTypeResponse, len(items))
	for i, item := range items {
		responses[i] = toResponse(item)
	}
	if pageSize < 1 {
		pageSize = len(items)
	}
	totalPages := 0
	if pageSize > 0 {
		totalPages = (total + pageSize - 1) / pageSize
	}
	return transport.ServiceTypeListResponse{
		Items:      responses,
		Total:      total,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}
}

// generateSlug creates a URL-friendly slug from a name.
func generateSlug(name string) string {
	// Convert to lowercase
	slug := strings.ToLower(name)

	// Replace spaces with hyphens
	slug = strings.ReplaceAll(slug, " ", "-")

	// Remove special characters (keep only alphanumeric and hyphens)
	reg := regexp.MustCompile(`[^a-z0-9-]+`)
	slug = reg.ReplaceAllString(slug, "")

	// Remove multiple consecutive hyphens
	reg = regexp.MustCompile(`-+`)
	slug = reg.ReplaceAllString(slug, "-")

	// Trim hyphens from start and end
	slug = strings.Trim(slug, "-")

	return slug
}

type defaultServiceType struct {
	Name             string
	Slug             string
	Description      string
	Icon             string
	Color            string
	IntakeGuidelines string
}

var defaultServiceTypes = []defaultServiceType{
	{
		Name:        "Ramen en deuren",
		Slug:        "ramen-deuren",
		Description: "Plaatsing, vervanging en reparatie van ramen en deuren",
		Icon:        "window",
		Color:       "#3B82F6",
		IntakeGuidelines: `## Benodigde informatie

### Metingen
- Aantal ramen en/of deuren
- Afmetingen per kozijn (hoogte x breedte)
- Verdieping en bereikbaarheid

### Huidige situatie
- Type glas (enkel, dubbel, HR++)
- Materiaal kozijn (hout, kunststof, aluminium)
- Staat van bestaande kozijnen

### Wensen en planning
- Gewenst glastype (HR++, triple)
- Kleur en afwerking
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Isolatie",
		Slug:        "isolatie",
		Description: "Dak-, vloer- en spouwmuurisolatie voor woningen",
		Icon:        "home",
		Color:       "#10B981",
		IntakeGuidelines: `## Benodigde informatie

### Type isolatie
- Dak, vloer, spouwmuur of gevel
- Beschikbaar oppervlak (m2)
- Huidige isolatielaag (ja/nee, dikte)

### Huidige situatie
- Bouwjaar woning
- Toegang tot dak/vloer/spouw
- Eventuele vochtproblemen

### Wensen en planning
- Voorkeur materiaal (glaswol, PIR, EPS)
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Zonnepanelen",
		Slug:        "zonnepanelen",
		Description: "Installatie en onderhoud van zonnepanelen",
		Icon:        "sun",
		Color:       "#F59E0B",
		IntakeGuidelines: `## Benodigde informatie

### Dak en ligging
- Type dak (plat, schuin)
- Orientatie (noord, oost, zuid, west)
- Dakhelling en schaduw (bomen/gebouw)

### Techniek
- Huidige meterkast (aantal groepen)
- Beschikbare ruimte voor omvormer
- Gewenst aantal panelen

### Wensen en planning
- Doel (besparing, teruglevering)
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Loodgieterswerk",
		Slug:        "loodgieterswerk",
		Description: "Reparaties en installatie van leidingen, kranen en afvoer",
		Icon:        "droplet",
		Color:       "#0EA5E9",
		IntakeGuidelines: `## Benodigde informatie

### Probleemomschrijving
- Type klus (lekkage, verstopping, installatie)
- Locatie in de woning
- Ernst en urgentie

### Huidige situatie
- Materiaal leidingen (koper, pvc, staal)
- Bereikbaarheid (vloer, kruipruimte)
- Vorige reparaties

### Wensen en planning
- Gewenste oplossing
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Verwarming en klimaat",
		Slug:        "verwarming-klimaat",
		Description: "CV, warmtepompen, ventilatie en airco systemen",
		Icon:        "flame",
		Color:       "#EF4444",
		IntakeGuidelines: `## Benodigde informatie

### Type systeem
- CV ketel, warmtepomp, ventilatie of airco
- Gewenst vermogen of capaciteit

### Huidige situatie
- Bestaand systeem en leeftijd
- Woningtype en oppervlakte
- Beschikbare ruimte voor installatie

### Wensen en planning
- Doel (comfort, besparen, vervangen)
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Elektra",
		Slug:        "elektra",
		Description: "Elektrische installaties, uitbreidingen en reparaties",
		Icon:        "zap",
		Color:       "#8B5CF6",
		IntakeGuidelines: `## Benodigde informatie

### Werkzaamheden
- Type klus (groepenkast, stopcontacten, verlichting)
- Aantal punten of groepen

### Huidige situatie
- Huidige groepenkast (aantal groepen)
- Bekabeling en bereikbaarheid
- Eventuele storingen

### Wensen en planning
- Gewenste functionaliteit
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Timmerwerk",
		Slug:        "timmerwerk",
		Description: "Houtwerk, deuren, vloeren en maatwerk",
		Icon:        "hammer",
		Color:       "#D97706",
		IntakeGuidelines: `## Benodigde informatie

### Werkomschrijving
- Type project (kast, vloer, trap, kozijn)
- Afmetingen of tekeningen

### Huidige situatie
- Materiaal en staat
- Montageplek en bereikbaarheid

### Wensen en planning
- Gewenste afwerking en kleur
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Klusbedrijf",
		Slug:        "klusbedrijf",
		Description: "Algemene klussen en kleine verbouwingen",
		Icon:        "tool",
		Color:       "#6B7280",
		IntakeGuidelines: `## Benodigde informatie

### Kluslijst
- Overzicht van alle taken
- Aantal en afmetingen per taak

### Huidige situatie
- Locatie per klus
- Toegang en bereikbaarheid

### Wensen en planning
- Gewenste materialen of afwerking
- Gewenste uitvoerdatum

### Budget indicatie
- Richtbudget of bandbreedte`,
	},
	{
		Name:        "Algemeen",
		Slug:        "algemeen",
		Description: "Algemene aanvragen en niet-gecategoriseerde verzoeken",
		Icon:        "inbox",
		Color:       "#9CA3AF",
		IntakeGuidelines: `## Benodigde informatie

### Probleemomschrijving
- Korte omschrijving van de aanvraag
- Locatie in de woning
- Urgentie

### Basisgegevens
- Afmetingen of aantallen indien relevant
- Fotos indien mogelijk

### Wensen en planning
- Gewenste uitvoerdatum
- Indicatief budget`,
	},
}

func toPtr(value string) *string {
	if value == "" {
		return nil
	}
	return &value
}

func isDuplicateServiceType(err error) bool {
	var pgErr *pgconn.PgError
	if !errors.As(err, &pgErr) {
		return false
	}
	if pgErr.Code != "23505" {
		return false
	}
	return pgErr.ConstraintName == "idx_service_types_org_name" || pgErr.ConstraintName == "idx_service_types_org_slug"
}
</file>

<file path="platform/config/config.go">
// Package config provides application configuration loading.
// This is part of the platform layer and contains no business logic.
package config

import (
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/joho/godotenv"
)

// =============================================================================
// Module-Specific Config Interfaces (Principle of Least Privilege)
// =============================================================================

// DatabaseConfig provides database connection settings.
type DatabaseConfig interface {
	GetDatabaseURL() string
}

// JWTConfig provides JWT validation settings for middleware.
type JWTConfig interface {
	GetJWTAccessSecret() string
}

// AuthServiceConfig provides settings needed by the auth service.
type AuthServiceConfig interface {
	JWTConfig
	GetAccessTokenTTL() time.Duration
	GetRefreshTokenTTL() time.Duration
	GetVerifyTokenTTL() time.Duration
	GetResetTokenTTL() time.Duration
}

// CookieConfig provides settings for refresh token cookies.
type CookieConfig interface {
	GetRefreshCookieName() string
	GetRefreshCookieDomain() string
	GetRefreshCookiePath() string
	GetRefreshCookieSecure() bool
	GetRefreshCookieSameSite() http.SameSite
	GetRefreshTokenTTL() time.Duration
}

// EmailConfig provides settings for email sending.
type EmailConfig interface {
	GetEmailEnabled() bool
	GetBrevoAPIKey() string
	GetEmailFromName() string
	GetEmailFromAddress() string
}

// NotificationConfig provides settings for the notification module.
type NotificationConfig interface {
	GetAppBaseURL() string
}

// WhatsAppConfig provides settings for the WhatsApp HTTP client.
type WhatsAppConfig interface {
	GetWhatsAppURL() string
	GetWhatsAppKey() string
	GetWhatsAppDeviceID() string
}

// SchedulerConfig provides settings for the background scheduler.
type SchedulerConfig interface {
	GetRedisURL() string
	GetRedisTLSInsecure() bool
	GetAsynqQueueName() string
	GetAsynqConcurrency() int
}

// HTTPConfig provides settings for the HTTP server.
type HTTPConfig interface {
	GetHTTPAddr() string
	GetCORSAllowAll() bool
	GetCORSOrigins() []string
	GetCORSAllowCreds() bool
}

// MinIOConfig provides settings for MinIO S3-compatible storage.
type MinIOConfig interface {
	GetMinIOEndpoint() string
	GetMinIOAccessKey() string
	GetMinIOSecretKey() string
	GetMinIOUseSSL() bool
	GetMinIOMaxFileSize() int64
	GetMinioBucketLeadServiceAttachments() string
	GetMinioBucketCatalogAssets() string
	GetMinioBucketPartnerLogos() string
	GetMinioBucketOrganizationLogos() string
	GetMinioBucketQuotePDFs() string
	GetMinioBucketQuoteAttachments() string
	IsMinIOEnabled() bool
}

// GotenbergConfig provides settings for the Gotenberg HTML-to-PDF service.
type GotenbergConfig interface {
	GetGotenbergURL() string
	GetGotenbergUsername() string
	GetGotenbergPassword() string
	IsGotenbergEnabled() bool
}

// EnergyLabelConfig provides settings for EP-Online energy label API.
type EnergyLabelConfig interface {
	GetEPOnlineAPIKey() string
	IsEnergyLabelEnabled() bool
}

// QdrantConfig provides settings for Qdrant vector database.
type QdrantConfig interface {
	GetQdrantURL() string
	GetQdrantAPIKey() string
	GetQdrantCollection() string
	IsQdrantEnabled() bool
}

// EmbeddingConfig provides settings for the embedding API service.
type EmbeddingConfig interface {
	GetEmbeddingAPIURL() string
	GetEmbeddingAPIKey() string
	IsEmbeddingEnabled() bool
}

// CatalogEmbeddingConfig provides settings for catalog embedding indexing.
type CatalogEmbeddingConfig interface {
	GetCatalogEmbeddingAPIURL() string
	GetCatalogEmbeddingAPIKey() string
	GetCatalogEmbeddingCollection() string
	IsCatalogEmbeddingEnabled() bool
}

// =============================================================================
// Main Config Struct
// =============================================================================

// Config holds all application configuration values.
type Config struct {
	Env                               string
	HTTPAddr                          string
	DatabaseURL                       string
	JWTAccessSecret                   string
	JWTRefreshSecret                  string
	AccessTokenTTL                    time.Duration
	RefreshTokenTTL                   time.Duration
	VerifyTokenTTL                    time.Duration
	ResetTokenTTL                     time.Duration
	CORSAllowAll                      bool
	CORSOrigins                       []string
	CORSAllowCreds                    bool
	AppBaseURL                        string
	EmailEnabled                      bool
	BrevoAPIKey                       string
	EmailFromName                     string
	EmailFromAddress                  string
	RefreshCookieName                 string
	RefreshCookieDomain               string
	RefreshCookiePath                 string
	RefreshCookieSecure               bool
	RefreshCookieSameSite             http.SameSite
	MoonshotAPIKey                    string
	EPOnlineAPIKey                    string
	MinIOEndpoint                     string
	MinIOAccessKey                    string
	MinIOSecretKey                    string
	MinIOUseSSL                       bool
	MinIOMaxFileSize                  int64
	MinioBucketLeadServiceAttachments string
	MinioBucketCatalogAssets          string
	MinioBucketPartnerLogos           string
	MinioBucketOrganizationLogos      string
	MinioBucketQuotePDFs              string
	MinioBucketQuoteAttachments       string
	GotenbergURL                      string
	GotenbergUsername                 string
	GotenbergPassword                 string
	QdrantURL                         string
	QdrantAPIKey                      string
	QdrantCollection                  string
	EmbeddingAPIURL                   string
	EmbeddingAPIKey                   string
	CatalogEmbeddingAPIURL            string
	CatalogEmbeddingAPIKey            string
	CatalogEmbeddingCollection        string
	WhatsAppURL                       string
	WhatsAppKey                       string
	WhatsAppDeviceID                  string
	RedisURL                          string
	RedisTLSInsecure                  bool
	AsynqQueueName                    string
	AsynqConcurrency                  int
}

// =============================================================================
// Interface Implementations
// =============================================================================

// DatabaseConfig implementation
func (c *Config) GetDatabaseURL() string { return c.DatabaseURL }

// JWTConfig implementation
func (c *Config) GetJWTAccessSecret() string { return c.JWTAccessSecret }

// AuthServiceConfig implementation
func (c *Config) GetAccessTokenTTL() time.Duration  { return c.AccessTokenTTL }
func (c *Config) GetRefreshTokenTTL() time.Duration { return c.RefreshTokenTTL }
func (c *Config) GetVerifyTokenTTL() time.Duration  { return c.VerifyTokenTTL }
func (c *Config) GetResetTokenTTL() time.Duration   { return c.ResetTokenTTL }

// CookieConfig implementation
func (c *Config) GetRefreshCookieName() string            { return c.RefreshCookieName }
func (c *Config) GetRefreshCookieDomain() string          { return c.RefreshCookieDomain }
func (c *Config) GetRefreshCookiePath() string            { return c.RefreshCookiePath }
func (c *Config) GetRefreshCookieSecure() bool            { return c.RefreshCookieSecure }
func (c *Config) GetRefreshCookieSameSite() http.SameSite { return c.RefreshCookieSameSite }

// EmailConfig implementation
func (c *Config) GetEmailEnabled() bool       { return c.EmailEnabled }
func (c *Config) GetBrevoAPIKey() string      { return c.BrevoAPIKey }
func (c *Config) GetEmailFromName() string    { return c.EmailFromName }
func (c *Config) GetEmailFromAddress() string { return c.EmailFromAddress }

// NotificationConfig implementation
func (c *Config) GetAppBaseURL() string { return c.AppBaseURL }

// WhatsAppConfig implementation
func (c *Config) GetWhatsAppURL() string      { return c.WhatsAppURL }
func (c *Config) GetWhatsAppKey() string      { return c.WhatsAppKey }
func (c *Config) GetWhatsAppDeviceID() string { return c.WhatsAppDeviceID }

// SchedulerConfig implementation
func (c *Config) GetRedisURL() string       { return c.RedisURL }
func (c *Config) GetRedisTLSInsecure() bool { return c.RedisTLSInsecure }
func (c *Config) GetAsynqQueueName() string { return c.AsynqQueueName }
func (c *Config) GetAsynqConcurrency() int  { return c.AsynqConcurrency }

// HTTPConfig implementation
func (c *Config) GetHTTPAddr() string      { return c.HTTPAddr }
func (c *Config) GetCORSAllowAll() bool    { return c.CORSAllowAll }
func (c *Config) GetCORSOrigins() []string { return c.CORSOrigins }
func (c *Config) GetCORSAllowCreds() bool  { return c.CORSAllowCreds }

// MinIOConfig implementation
func (c *Config) GetMinIOEndpoint() string   { return c.MinIOEndpoint }
func (c *Config) GetMinIOAccessKey() string  { return c.MinIOAccessKey }
func (c *Config) GetMinIOSecretKey() string  { return c.MinIOSecretKey }
func (c *Config) GetMinIOUseSSL() bool       { return c.MinIOUseSSL }
func (c *Config) GetMinIOMaxFileSize() int64 { return c.MinIOMaxFileSize }
func (c *Config) GetMinioBucketLeadServiceAttachments() string {
	return c.MinioBucketLeadServiceAttachments
}
func (c *Config) GetMinioBucketCatalogAssets() string {
	return c.MinioBucketCatalogAssets
}
func (c *Config) GetMinioBucketPartnerLogos() string {
	return c.MinioBucketPartnerLogos
}
func (c *Config) GetMinioBucketOrganizationLogos() string {
	return c.MinioBucketOrganizationLogos
}
func (c *Config) GetMinioBucketQuotePDFs() string {
	return c.MinioBucketQuotePDFs
}
func (c *Config) GetMinioBucketQuoteAttachments() string {
	return c.MinioBucketQuoteAttachments
}
func (c *Config) IsMinIOEnabled() bool { return c.MinIOEndpoint != "" }

// GotenbergConfig implementation
func (c *Config) GetGotenbergURL() string      { return c.GotenbergURL }
func (c *Config) GetGotenbergUsername() string { return c.GotenbergUsername }
func (c *Config) GetGotenbergPassword() string { return c.GotenbergPassword }
func (c *Config) IsGotenbergEnabled() bool     { return c.GotenbergURL != "" }

// EnergyLabelConfig implementation
func (c *Config) GetEPOnlineAPIKey() string  { return c.EPOnlineAPIKey }
func (c *Config) IsEnergyLabelEnabled() bool { return c.EPOnlineAPIKey != "" }

// QdrantConfig implementation
func (c *Config) GetQdrantURL() string        { return c.QdrantURL }
func (c *Config) GetQdrantAPIKey() string     { return c.QdrantAPIKey }
func (c *Config) GetQdrantCollection() string { return c.QdrantCollection }
func (c *Config) IsQdrantEnabled() bool {
	return c.QdrantURL != "" && c.QdrantCollection != ""
}

// EmbeddingConfig implementation
func (c *Config) GetEmbeddingAPIURL() string { return c.EmbeddingAPIURL }
func (c *Config) GetEmbeddingAPIKey() string { return c.EmbeddingAPIKey }
func (c *Config) IsEmbeddingEnabled() bool   { return c.EmbeddingAPIURL != "" }

// CatalogEmbeddingConfig implementation
func (c *Config) GetCatalogEmbeddingAPIURL() string { return c.CatalogEmbeddingAPIURL }
func (c *Config) GetCatalogEmbeddingAPIKey() string { return c.CatalogEmbeddingAPIKey }
func (c *Config) GetCatalogEmbeddingCollection() string {
	return c.CatalogEmbeddingCollection
}
func (c *Config) IsCatalogEmbeddingEnabled() bool {
	return c.CatalogEmbeddingAPIURL != ""
}

// Load reads configuration from environment variables.
func Load() (*Config, error) {
	_ = godotenv.Load()

	corsOrigins := splitCSV(getEnv("CORS_ORIGINS", "http://localhost:4200"))
	corsAllowAll := strings.EqualFold(getEnv("CORS_ALLOW_ALL", "false"), "true")
	if containsWildcard(corsOrigins) {
		corsAllowAll = true
	}

	brevoAPIKey := getEnv("BREVO_API_KEY", "")
	emailEnabled := strings.EqualFold(getEnv("EMAIL_ENABLED", "true"), "true")

	refreshCookieSecure := strings.EqualFold(getEnv("REFRESH_COOKIE_SECURE", ""), "true")
	if getEnv("REFRESH_COOKIE_SECURE", "") == "" {
		refreshCookieSecure = strings.EqualFold(getEnv("APP_ENV", "development"), "production")
	}

	cfg := &Config{
		Env:                               getEnv("APP_ENV", "development"),
		HTTPAddr:                          getEnv("HTTP_ADDR", ":8080"),
		DatabaseURL:                       getEnv("DATABASE_URL", ""),
		JWTAccessSecret:                   getEnv("JWT_ACCESS_SECRET", ""),
		JWTRefreshSecret:                  getEnv("JWT_REFRESH_SECRET", ""),
		AccessTokenTTL:                    mustDuration(getEnv("JWT_ACCESS_TTL", "15m")),
		RefreshTokenTTL:                   mustDuration(getEnv("JWT_REFRESH_TTL", "720h")),
		VerifyTokenTTL:                    mustDuration(getEnv("VERIFY_TOKEN_TTL", "30m")),
		ResetTokenTTL:                     mustDuration(getEnv("RESET_TOKEN_TTL", "30m")),
		CORSAllowAll:                      corsAllowAll,
		CORSOrigins:                       corsOrigins,
		CORSAllowCreds:                    strings.EqualFold(getEnv("CORS_ALLOW_CREDENTIALS", "true"), "true"),
		AppBaseURL:                        getEnv("APP_BASE_URL", "http://localhost:4200"),
		EmailEnabled:                      emailEnabled && brevoAPIKey != "",
		BrevoAPIKey:                       brevoAPIKey,
		EmailFromName:                     getEnv("EMAIL_FROM_NAME", "Portal"),
		EmailFromAddress:                  getEnv("EMAIL_FROM_ADDRESS", ""),
		RefreshCookieName:                 getEnv("REFRESH_COOKIE_NAME", "portal_refresh"),
		RefreshCookieDomain:               getEnv("REFRESH_COOKIE_DOMAIN", ""),
		RefreshCookiePath:                 getEnv("REFRESH_COOKIE_PATH", "/api/v1/auth"),
		RefreshCookieSecure:               refreshCookieSecure,
		RefreshCookieSameSite:             parseSameSite(getEnv("REFRESH_COOKIE_SAMESITE", "Lax")),
		MoonshotAPIKey:                    getEnv("MOONSHOT_API_KEY", ""),
		EPOnlineAPIKey:                    getEnv("EP_ONLINE_API_KEY", ""),
		MinIOEndpoint:                     getEnv("MINIO_ENDPOINT", ""),
		MinIOAccessKey:                    getEnv("MINIO_ACCESS_KEY", ""),
		MinIOSecretKey:                    getEnv("MINIO_SECRET_KEY", ""),
		MinIOUseSSL:                       strings.EqualFold(getEnv("MINIO_USE_SSL", "false"), "true"),
		MinIOMaxFileSize:                  mustInt64(getEnv("MINIO_MAX_FILE_SIZE", "104857600")),
		MinioBucketLeadServiceAttachments: getEnv("MINIO_BUCKET_LEAD_SERVICE_ATTACHMENTS", "lead-service-attachments"),
		MinioBucketCatalogAssets:          getEnv("MINIO_BUCKET_CATALOG_ASSETS", "catalog-assets"),
		MinioBucketPartnerLogos:           getEnv("MINIO_BUCKET_PARTNER_LOGOS", "partner-logos"),
		MinioBucketOrganizationLogos:      getEnv("MINIO_BUCKET_ORGANIZATION_LOGOS", "organization-logos"),
		MinioBucketQuotePDFs:              getEnv("MINIO_BUCKET_QUOTE_PDFS", "quote-pdfs"),
		MinioBucketQuoteAttachments:       getEnv("MINIO_BUCKET_QUOTE_ATTACHMENTS", "quote-attachments"),
		GotenbergURL:                      getEnv("GOTENBERG_URL", ""),
		GotenbergUsername:                 getEnv("GOTENBERG_USERNAME", ""),
		GotenbergPassword:                 getEnv("GOTENBERG_PASSWORD", ""),
		QdrantURL:                         getEnv("QDRANT_URL", ""),
		QdrantAPIKey:                      getEnv("QDRANT_API_KEY", ""),
		QdrantCollection:                  getEnv("QDRANT_COLLECTION", ""),
		EmbeddingAPIURL:                   getEnv("EMBEDDING_API_URL", ""),
		EmbeddingAPIKey:                   getEnv("EMBEDDING_API_KEY", ""),
		CatalogEmbeddingAPIURL:            getEnv("CATALOG_EMBEDDING_API_URL", ""),
		CatalogEmbeddingAPIKey:            getEnv("CATALOG_EMBEDDING_API_KEY", ""),
		CatalogEmbeddingCollection:        getEnv("CATALOG_EMBEDDING_COLLECTION", "catalog"),
		WhatsAppURL:                       getEnv("WHATSAPP_SERVICE_URL", ""),
		WhatsAppKey:                       getEnv("WHATSAPP_API_KEY", ""),
		WhatsAppDeviceID:                  getEnv("WHATSAPP_DEVICE_ID", ""),
		RedisURL:                          getEnv("REDIS_URL", ""),
		RedisTLSInsecure:                  strings.EqualFold(getEnv("REDIS_TLS_INSECURE", "false"), "true"),
		AsynqQueueName:                    getEnv("ASYNQ_QUEUE_NAME", "default"),
		AsynqConcurrency:                  mustInt(getEnv("ASYNQ_CONCURRENCY", "10")),
	}

	if cfg.DatabaseURL == "" {
		return nil, fmt.Errorf("DATABASE_URL is required")
	}
	if cfg.JWTAccessSecret == "" || cfg.JWTRefreshSecret == "" {
		return nil, fmt.Errorf("JWT_ACCESS_SECRET and JWT_REFRESH_SECRET are required")
	}
	if emailEnabled && cfg.BrevoAPIKey == "" {
		return nil, fmt.Errorf("BREVO_API_KEY is required when EMAIL_ENABLED is true")
	}
	if cfg.EmailEnabled && cfg.EmailFromAddress == "" {
		return nil, fmt.Errorf("EMAIL_FROM_ADDRESS is required when email is enabled")
	}
	if cfg.CORSAllowAll && cfg.CORSAllowCreds {
		return nil, fmt.Errorf("CORS_ALLOW_CREDENTIALS cannot be true when CORS_ALLOW_ALL is true")
	}

	return cfg, nil
}

func getEnv(key, fallback string) string {
	if val, ok := os.LookupEnv(key); ok {
		return val
	}
	return fallback
}

func mustDuration(value string) time.Duration {
	d, err := time.ParseDuration(value)
	if err != nil {
		return 0
	}
	return d
}

func mustInt64(value string) int64 {
	result, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return 0
	}
	return result
}

func mustInt(value string) int {
	result, err := strconv.Atoi(value)
	if err != nil {
		return 0
	}
	return result
}

func splitCSV(value string) []string {
	parts := strings.Split(value, ",")
	results := make([]string, 0, len(parts))
	for _, part := range parts {
		trimmed := strings.TrimSpace(part)
		if trimmed != "" {
			results = append(results, trimmed)
		}
	}
	return results
}

func containsWildcard(values []string) bool {
	for _, value := range values {
		if value == "*" {
			return true
		}
	}
	return false
}

func parseSameSite(value string) http.SameSite {
	switch strings.ToLower(strings.TrimSpace(value)) {
	case "none":
		return http.SameSiteNoneMode
	case "strict":
		return http.SameSiteStrictMode
	default:
		return http.SameSiteLaxMode
	}
}
</file>

<file path="internal/catalog/service/service.go">
package service

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/catalog/repository"
	"portal_final_backend/internal/catalog/transport"
	"portal_final_backend/platform/ai/embeddingapi"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/sanitize"
)

// Service provides business logic for catalog.
type Service struct {
	repo                repository.Repository
	storage             storage.StorageService
	bucket              string
	log                 *logger.Logger
	embeddingClient     *embeddingapi.Client
	embeddingCollection string
}

// New creates a new catalog service.
func New(repo repository.Repository, storageSvc storage.StorageService, bucket string, log *logger.Logger, embeddingClient *embeddingapi.Client, embeddingCollection string) *Service {
	return &Service{
		repo:                repo,
		storage:             storageSvc,
		bucket:              bucket,
		log:                 log,
		embeddingClient:     embeddingClient,
		embeddingCollection: strings.TrimSpace(embeddingCollection),
	}
}

// GetVatRateByID retrieves a VAT rate by ID.
func (s *Service) GetVatRateByID(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.VatRateResponse, error) {
	rate, err := s.repo.GetVatRateByID(ctx, tenantID, id)
	if err != nil {
		return transport.VatRateResponse{}, err
	}
	return toVatRateResponse(rate), nil
}

// ListVatRatesWithFilters retrieves VAT rates with search and pagination.
func (s *Service) ListVatRatesWithFilters(ctx context.Context, tenantID uuid.UUID, req transport.ListVatRatesRequest) (transport.VatRateListResponse, error) {
	page := req.Page
	pageSize := req.PageSize
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}

	params := repository.ListVatRatesParams{
		OrganizationID: tenantID,
		Search:         strings.TrimSpace(req.Search),
		Offset:         (page - 1) * pageSize,
		Limit:          pageSize,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
	}

	items, total, err := s.repo.ListVatRates(ctx, params)
	if err != nil {
		return transport.VatRateListResponse{}, err
	}

	return toVatRateListResponse(items, total, page, pageSize), nil
}

// CreateVatRate creates a new VAT rate.
func (s *Service) CreateVatRate(ctx context.Context, tenantID uuid.UUID, req transport.CreateVatRateRequest) (transport.VatRateResponse, error) {
	rate, err := s.repo.CreateVatRate(ctx, repository.CreateVatRateParams{
		OrganizationID: tenantID,
		Name:           strings.TrimSpace(req.Name),
		RateBps:        *req.RateBps,
	})
	if err != nil {
		return transport.VatRateResponse{}, err
	}

	s.log.Info("vat rate created", "id", rate.ID, "name", rate.Name)
	return toVatRateResponse(rate), nil
}

// UpdateVatRate updates an existing VAT rate.
func (s *Service) UpdateVatRate(ctx context.Context, tenantID uuid.UUID, id uuid.UUID, req transport.UpdateVatRateRequest) (transport.VatRateResponse, error) {
	name := req.Name
	if name != nil {
		trimmed := strings.TrimSpace(*name)
		name = &trimmed
	}

	rate, err := s.repo.UpdateVatRate(ctx, repository.UpdateVatRateParams{
		ID:             id,
		OrganizationID: tenantID,
		Name:           name,
		RateBps:        req.RateBps,
	})
	if err != nil {
		return transport.VatRateResponse{}, err
	}

	s.log.Info("vat rate updated", "id", rate.ID, "name", rate.Name)
	return toVatRateResponse(rate), nil
}

// DeleteVatRate deletes a VAT rate if not referenced by products.
func (s *Service) DeleteVatRate(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) error {
	used, err := s.repo.HasProductsWithVatRate(ctx, tenantID, id)
	if err != nil {
		return err
	}
	if used {
		return apperr.Conflict("vat rate is in use")
	}
	if err := s.repo.DeleteVatRate(ctx, tenantID, id); err != nil {
		return err
	}

	s.log.Info("vat rate deleted", "id", id)
	return nil
}

// SeedDefaultVatRates ensures a tenant has the standard VAT rates.
func (s *Service) SeedDefaultVatRates(ctx context.Context, tenantID uuid.UUID) error {
	items, total, err := s.repo.ListVatRates(ctx, repository.ListVatRatesParams{
		OrganizationID: tenantID,
		Offset:         0,
		Limit:          1,
	})
	if err != nil {
		return err
	}
	if total > 0 || len(items) > 0 {
		return nil
	}

	for _, def := range defaultVatRates {
		_, err := s.repo.CreateVatRate(ctx, repository.CreateVatRateParams{
			OrganizationID: tenantID,
			Name:           def.Name,
			RateBps:        def.RateBps,
		})
		if err != nil {
			return err
		}
	}

	return nil
}

// GetProductByID retrieves a product by ID.
func (s *Service) GetProductByID(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) (transport.ProductResponse, error) {
	product, err := s.repo.GetProductByID(ctx, tenantID, id)
	if err != nil {
		return transport.ProductResponse{}, err
	}
	return toProductResponse(product), nil
}

// ListProductsWithFilters retrieves products with search and pagination.
func (s *Service) ListProductsWithFilters(ctx context.Context, tenantID uuid.UUID, req transport.ListProductsRequest, vatRateID *uuid.UUID) (transport.ProductListResponse, error) {
	page := req.Page
	pageSize := req.PageSize
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 20
	}
	if pageSize > 100 {
		pageSize = 100
	}

	createdAtFrom, err := parseOptionalTime(req.CreatedAtFrom)
	if err != nil {
		return transport.ProductListResponse{}, err
	}
	createdAtTo, err := parseOptionalTime(req.CreatedAtTo)
	if err != nil {
		return transport.ProductListResponse{}, err
	}
	updatedAtFrom, err := parseOptionalTime(req.UpdatedAtFrom)
	if err != nil {
		return transport.ProductListResponse{}, err
	}
	updatedAtTo, err := parseOptionalTime(req.UpdatedAtTo)
	if err != nil {
		return transport.ProductListResponse{}, err
	}

	params := repository.ListProductsParams{
		OrganizationID: tenantID,
		Search:         strings.TrimSpace(req.Search),
		Title:          strings.TrimSpace(req.Title),
		Reference:      strings.TrimSpace(req.Reference),
		Type:           strings.TrimSpace(req.Type),
		VatRateID:      vatRateID,
		CreatedAtFrom:  createdAtFrom,
		CreatedAtTo:    createdAtTo,
		UpdatedAtFrom:  updatedAtFrom,
		UpdatedAtTo:    updatedAtTo,
		Offset:         (page - 1) * pageSize,
		Limit:          pageSize,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
	}

	items, total, err := s.repo.ListProducts(ctx, params)
	if err != nil {
		return transport.ProductListResponse{}, err
	}

	return toProductListResponse(items, total, page, pageSize), nil
}

func parseOptionalTime(value string) (*time.Time, error) {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return nil, nil
	}
	if parsed, err := time.Parse(time.RFC3339, trimmed); err == nil {
		return &parsed, nil
	}
	if parsed, err := time.Parse("2006-01-02", trimmed); err == nil {
		return &parsed, nil
	}
	return nil, apperr.Validation("invalid date format")
}

// CreateProduct creates a new product.
func (s *Service) CreateProduct(ctx context.Context, tenantID uuid.UUID, req transport.CreateProductRequest) (transport.ProductResponse, error) {
	if err := s.validatePeriod(req.PeriodCount, req.PeriodUnit); err != nil {
		return transport.ProductResponse{}, err
	}
	unitLabel, err := s.validatePricingCreate(req.PriceCents, req.UnitPriceCents, req.UnitLabel)
	if err != nil {
		return transport.ProductResponse{}, err
	}
	if _, err := s.repo.GetVatRateByID(ctx, tenantID, req.VatRateID); err != nil {
		return transport.ProductResponse{}, err
	}

	product, err := s.repo.CreateProduct(ctx, repository.CreateProductParams{
		OrganizationID: tenantID,
		VatRateID:      req.VatRateID,
		Title:          strings.TrimSpace(req.Title),
		Reference:      strings.TrimSpace(req.Reference),
		Description:    sanitize.TextPtr(req.Description),
		PriceCents:     req.PriceCents,
		UnitPriceCents: req.UnitPriceCents,
		UnitLabel:      unitLabel,
		LaborTimeText:  trimPtr(req.LaborTimeText),
		Type:           req.Type,
		PeriodCount:    req.PeriodCount,
		PeriodUnit:     req.PeriodUnit,
	})
	if err != nil {
		return transport.ProductResponse{}, err
	}

	s.log.Info("product created", "id", product.ID, "reference", product.Reference)
	s.indexProductAsync(ctx, tenantID, product, "create")
	return toProductResponse(product), nil
}

// UpdateProduct updates an existing product.
func (s *Service) UpdateProduct(ctx context.Context, tenantID uuid.UUID, id uuid.UUID, req transport.UpdateProductRequest) (transport.ProductResponse, error) {
	if err := s.ensureVatRateExists(ctx, tenantID, req.VatRateID); err != nil {
		return transport.ProductResponse{}, err
	}
	unitLabel, err := s.validatePricingUpdate(req.PriceCents, req.UnitPriceCents, req.UnitLabel)
	if err != nil {
		return transport.ProductResponse{}, err
	}
	if err := s.validatePeriodUpdate(req); err != nil {
		return transport.ProductResponse{}, err
	}
	if err := s.ensureTypeChangeAllowed(ctx, tenantID, id, req.Type); err != nil {
		return transport.ProductResponse{}, err
	}

	params := repository.UpdateProductParams{
		ID:             id,
		OrganizationID: tenantID,
		VatRateID:      req.VatRateID,
		Title:          trimPtr(req.Title),
		Reference:      trimPtr(req.Reference),
		Description:    sanitize.TextPtr(req.Description),
		PriceCents:     req.PriceCents,
		UnitPriceCents: req.UnitPriceCents,
		UnitLabel:      unitLabel,
		LaborTimeText:  trimPtr(req.LaborTimeText),
		Type:           req.Type,
		PeriodCount:    req.PeriodCount,
		PeriodUnit:     req.PeriodUnit,
	}

	product, err := s.repo.UpdateProduct(ctx, params)
	if err != nil {
		return transport.ProductResponse{}, err
	}

	s.log.Info("product updated", "id", product.ID, "reference", product.Reference)
	s.indexProductAsync(ctx, tenantID, product, "update")
	return toProductResponse(product), nil
}

func (s *Service) indexProductAsync(ctx context.Context, tenantID uuid.UUID, product repository.Product, reason string) {
	if s.embeddingClient == nil {
		return
	}

	request := embeddingapi.AddDocumentsRequest{
		Documents:  []map[string]any{s.buildCatalogDocument(tenantID, product)},
		TextFields: []string{"name", "description", "reference", "type", "labor_time_text", "unit_label"},
		IDField:    "id",
		Collection: s.embeddingCollection,
	}

	loggerWithCtx := s.log.WithContext(ctx)
	go func() {
		resp, err := s.embeddingClient.AddDocuments(context.Background(), request)
		if err != nil {
			loggerWithCtx.Error("catalog indexing failed", "error", err, "productId", product.ID, "reason", reason)
			return
		}
		loggerWithCtx.Info("catalog indexed", "productId", product.ID, "documentsAdded", resp.DocumentsAdded, "reason", reason)
	}()
}

func (s *Service) buildCatalogDocument(tenantID uuid.UUID, product repository.Product) map[string]any {
	document := map[string]any{
		"id":               product.ID.String(),
		"organization_id":  tenantID.String(),
		"name":             product.Title,
		"reference":        product.Reference,
		"type":             product.Type,
		"price":            float64(product.PriceCents) / 100,
		"price_cents":      product.PriceCents,
		"unit_price":       float64(product.UnitPriceCents) / 100,
		"unit_price_cents": product.UnitPriceCents,
		"vat_rate_id":      product.VatRateID.String(),
	}
	if product.UnitLabel != nil && strings.TrimSpace(*product.UnitLabel) != "" {
		document["unit_label"] = strings.TrimSpace(*product.UnitLabel)
	}
	if product.LaborTimeText != nil {
		trimmed := strings.TrimSpace(*product.LaborTimeText)
		if trimmed != "" {
			document["labor_time_text"] = trimmed
		}
	}

	if product.Description != nil {
		trimmed := strings.TrimSpace(*product.Description)
		if trimmed != "" {
			document["description"] = trimmed
		}
	}
	if product.PeriodCount != nil {
		document["period_count"] = *product.PeriodCount
	}
	if product.PeriodUnit != nil {
		document["period_unit"] = *product.PeriodUnit
	}

	return document
}

// DeleteProduct deletes a product.
func (s *Service) DeleteProduct(ctx context.Context, tenantID uuid.UUID, id uuid.UUID) error {
	if err := s.repo.DeleteProduct(ctx, tenantID, id); err != nil {
		return err
	}
	s.log.Info("product deleted", "id", id)
	return nil
}

// AddProductMaterials adds material products to a service product.
func (s *Service) AddProductMaterials(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error {
	if err := s.ensureServiceProduct(ctx, tenantID, productID); err != nil {
		return err
	}
	uniqueIDs, err := s.ensureValidMaterialIDs(productID, materialIDs)
	if err != nil {
		return err
	}
	materials, err := s.loadAndValidateMaterials(ctx, tenantID, uniqueIDs)
	if err != nil {
		return err
	}
	if err := s.ensureMaterialsNoChildren(ctx, tenantID, materials); err != nil {
		return err
	}

	if err := s.repo.AddProductMaterials(ctx, tenantID, productID, uniqueIDs); err != nil {
		return err
	}

	s.log.Info("product materials added", "productId", productID, "count", len(uniqueIDs))
	return nil
}

// RemoveProductMaterials removes materials from a product.
func (s *Service) RemoveProductMaterials(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, materialIDs []uuid.UUID) error {
	uniqueIDs := uniqueUUIDs(materialIDs)
	if err := s.repo.RemoveProductMaterials(ctx, tenantID, productID, uniqueIDs); err != nil {
		return err
	}

	s.log.Info("product materials removed", "productId", productID, "count", len(uniqueIDs))
	return nil
}

func (s *Service) ensureVatRateExists(ctx context.Context, tenantID uuid.UUID, vatRateID *uuid.UUID) error {
	if vatRateID == nil {
		return nil
	}
	_, err := s.repo.GetVatRateByID(ctx, tenantID, *vatRateID)
	return err
}

func (s *Service) validatePeriodUpdate(req transport.UpdateProductRequest) error {
	if req.PeriodCount == nil && req.PeriodUnit == nil {
		return nil
	}
	return s.validatePeriod(req.PeriodCount, req.PeriodUnit)
}

func (s *Service) ensureTypeChangeAllowed(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, productType *string) error {
	if productType == nil || *productType == "service" {
		return nil
	}
	hasMaterials, err := s.repo.HasProductMaterials(ctx, tenantID, productID)
	if err != nil {
		return err
	}
	if hasMaterials {
		return apperr.Conflict("product has materials and cannot change type")
	}
	return nil
}

func (s *Service) ensureServiceProduct(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID) error {
	product, err := s.repo.GetProductByID(ctx, tenantID, productID)
	if err != nil {
		return err
	}
	if product.Type != "service" {
		return apperr.Validation("materials can only be linked to service products")
	}
	return nil
}

func (s *Service) ensureValidMaterialIDs(productID uuid.UUID, materialIDs []uuid.UUID) ([]uuid.UUID, error) {
	uniqueIDs := uniqueUUIDs(materialIDs)
	for _, id := range uniqueIDs {
		if id == productID {
			return nil, apperr.Validation("product cannot reference itself as a material")
		}
	}
	return uniqueIDs, nil
}

func (s *Service) loadAndValidateMaterials(ctx context.Context, tenantID uuid.UUID, materialIDs []uuid.UUID) ([]repository.Product, error) {
	materials, err := s.repo.GetProductsByIDs(ctx, tenantID, materialIDs)
	if err != nil {
		return nil, err
	}
	if len(materials) != len(materialIDs) {
		return nil, apperr.Validation("one or more materials were not found")
	}
	for _, material := range materials {
		if material.Type != "material" {
			return nil, apperr.Validation("only material products can be linked")
		}
	}
	return materials, nil
}

func (s *Service) ensureMaterialsNoChildren(ctx context.Context, tenantID uuid.UUID, materials []repository.Product) error {
	// Defense-in-depth: verify materials don't have their own children.
	// The type system already prevents this (only "material" types can be added,
	// and "material" types cannot have children), but this check ensures
	// future changes don't accidentally create circular dependencies.
	for _, material := range materials {
		hasChildren, err := s.repo.HasProductMaterials(ctx, tenantID, material.ID)
		if err != nil {
			return err
		}
		if hasChildren {
			return apperr.Validation("cannot add a material that is composed of other materials")
		}
	}
	return nil
}

// ListProductMaterials lists materials linked to a product.
func (s *Service) ListProductMaterials(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID) ([]transport.ProductResponse, error) {
	items, err := s.repo.ListProductMaterials(ctx, tenantID, productID)
	if err != nil {
		return nil, err
	}

	responses := make([]transport.ProductResponse, len(items))
	for i, item := range items {
		responses[i] = toProductResponse(item)
	}

	return responses, nil
}

func (s *Service) validatePeriod(count *int, unit *string) error {
	if count == nil && unit == nil {
		return nil
	}
	if count == nil || unit == nil {
		return apperr.Validation("periodCount and periodUnit must be provided together")
	}
	if *count <= 0 {
		return apperr.Validation("periodCount must be greater than 0")
	}
	if !isAllowedPeriodUnit(*unit) {
		return apperr.Validation("invalid periodUnit")
	}
	return nil
}

func isAllowedPeriodUnit(unit string) bool {
	switch unit {
	case "day", "week", "month", "quarter", "year":
		return true
	default:
		return false
	}
}

func trimPtr(value *string) *string {
	if value == nil {
		return nil
	}
	trimmed := strings.TrimSpace(*value)
	return &trimmed
}

func uniqueUUIDs(values []uuid.UUID) []uuid.UUID {
	seen := make(map[uuid.UUID]struct{}, len(values))
	result := make([]uuid.UUID, 0, len(values))
	for _, value := range values {
		if _, ok := seen[value]; ok {
			continue
		}
		seen[value] = struct{}{}
		result = append(result, value)
	}
	return result
}

func toVatRateResponse(rate repository.VatRate) transport.VatRateResponse {
	return transport.VatRateResponse{
		ID:        rate.ID,
		Name:      rate.Name,
		RateBps:   rate.RateBps,
		CreatedAt: rate.CreatedAt,
		UpdatedAt: rate.UpdatedAt,
	}
}

func toVatRateListResponse(items []repository.VatRate, total int, page int, pageSize int) transport.VatRateListResponse {
	responses := make([]transport.VatRateResponse, len(items))
	for i, item := range items {
		responses[i] = toVatRateResponse(item)
	}
	if pageSize < 1 {
		pageSize = len(items)
	}
	totalPages := 0
	if pageSize > 0 {
		totalPages = (total + pageSize - 1) / pageSize
	}
	return transport.VatRateListResponse{
		Items:      responses,
		Total:      total,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}
}

// SearchForAutocomplete returns a lightweight list of products with their document
// and URL assets for use in quote-line ghost-text autocomplete.
func (s *Service) SearchForAutocomplete(ctx context.Context, tenantID uuid.UUID, req transport.AutocompleteSearchRequest) ([]transport.AutocompleteItemResponse, error) {
	limit := req.Limit
	if limit <= 0 {
		limit = 5
	}

	products, _, err := s.repo.ListProducts(ctx, repository.ListProductsParams{
		OrganizationID: tenantID,
		Search:         strings.TrimSpace(req.Query),
		Limit:          limit,
		Offset:         0,
		SortBy:         "title",
		SortOrder:      "asc",
	})
	if err != nil {
		return nil, fmt.Errorf("search products: %w", err)
	}

	result := make([]transport.AutocompleteItemResponse, 0, len(products))
	for _, p := range products {
		item, err := s.buildAutocompleteItem(ctx, tenantID, p)
		if err != nil {
			return nil, err
		}
		result = append(result, item)
	}

	return result, nil
}

func (s *Service) buildAutocompleteItem(ctx context.Context, tenantID uuid.UUID, p repository.Product) (transport.AutocompleteItemResponse, error) {
	docs, err := s.repo.ListProductAssets(ctx, repository.ListProductAssetsParams{
		OrganizationID: tenantID,
		ProductID:      p.ID,
		AssetType:      strPtr("document"),
	})
	if err != nil {
		return transport.AutocompleteItemResponse{}, fmt.Errorf("list product assets: %w", err)
	}

	urls, err := s.repo.ListProductAssets(ctx, repository.ListProductAssetsParams{
		OrganizationID: tenantID,
		ProductID:      p.ID,
		AssetType:      strPtr("terms_url"),
	})
	if err != nil {
		return transport.AutocompleteItemResponse{}, fmt.Errorf("list product url assets: %w", err)
	}

	var vatRateBps int
	rate, err := s.repo.GetVatRateByID(ctx, tenantID, p.VatRateID)
	if err == nil {
		vatRateBps = rate.RateBps
	}

	return transport.AutocompleteItemResponse{
		ID:             p.ID,
		Title:          p.Title,
		Description:    p.Description,
		PriceCents:     p.PriceCents,
		UnitPriceCents: p.UnitPriceCents,
		UnitLabel:      p.UnitLabel,
		VatRateID:      p.VatRateID,
		VatRateBps:     vatRateBps,
		Documents:      toAutocompleteDocuments(docs),
		URLs:           toAutocompleteURLs(urls),
	}, nil
}

func strPtr(s string) *string { return &s }

func toAutocompleteDocuments(assets []repository.ProductAsset) []transport.AutocompleteDocumentResponse {
	out := make([]transport.AutocompleteDocumentResponse, 0, len(assets))
	for _, d := range assets {
		if d.FileKey != nil && d.FileName != nil {
			out = append(out, transport.AutocompleteDocumentResponse{
				ID:       d.ID,
				Filename: *d.FileName,
				FileKey:  *d.FileKey,
			})
		}
	}
	return out
}

func toAutocompleteURLs(assets []repository.ProductAsset) []transport.AutocompleteURLResponse {
	out := make([]transport.AutocompleteURLResponse, 0, len(assets))
	for _, u := range assets {
		if u.URL == nil {
			continue
		}
		label := "Voorwaarden"
		if u.FileName != nil {
			label = *u.FileName
		}
		out = append(out, transport.AutocompleteURLResponse{
			Label: label,
			Href:  *u.URL,
		})
	}
	return out
}

func toProductResponse(product repository.Product) transport.ProductResponse {
	return transport.ProductResponse{
		ID:             product.ID,
		VatRateID:      product.VatRateID,
		Title:          product.Title,
		Reference:      product.Reference,
		Description:    product.Description,
		PriceCents:     product.PriceCents,
		UnitPriceCents: product.UnitPriceCents,
		UnitLabel:      product.UnitLabel,
		LaborTimeText:  product.LaborTimeText,
		Type:           product.Type,
		PeriodCount:    product.PeriodCount,
		PeriodUnit:     product.PeriodUnit,
		CreatedAt:      product.CreatedAt,
		UpdatedAt:      product.UpdatedAt,
	}
}

func (s *Service) validatePricingCreate(priceCents int64, unitPriceCents int64, unitLabel *string) (*string, error) {
	trimmed := trimPtr(unitLabel)
	if priceCents > 0 && unitPriceCents > 0 {
		return nil, apperr.Validation("choose either priceCents or unitPriceCents")
	}
	if priceCents <= 0 && unitPriceCents <= 0 {
		return nil, apperr.Validation("priceCents or unitPriceCents is required")
	}
	if unitPriceCents > 0 && (trimmed == nil || *trimmed == "") {
		return nil, apperr.Validation("unitLabel is required when unitPriceCents is set")
	}
	return trimmed, nil
}

func (s *Service) validatePricingUpdate(priceCents *int64, unitPriceCents *int64, unitLabel *string) (*string, error) {
	trimmed := trimPtr(unitLabel)
	if priceCents == nil && unitPriceCents == nil {
		return trimmed, nil
	}
	price := int64(0)
	unitPrice := int64(0)
	if priceCents != nil {
		price = *priceCents
	}
	if unitPriceCents != nil {
		unitPrice = *unitPriceCents
	}
	if price > 0 && unitPrice > 0 {
		return nil, apperr.Validation("choose either priceCents or unitPriceCents")
	}
	if price <= 0 && unitPrice <= 0 {
		return nil, apperr.Validation("priceCents or unitPriceCents is required")
	}
	if unitPrice > 0 && (trimmed == nil || *trimmed == "") {
		return nil, apperr.Validation("unitLabel is required when unitPriceCents is set")
	}
	return trimmed, nil
}

func toProductListResponse(items []repository.Product, total int, page int, pageSize int) transport.ProductListResponse {
	responses := make([]transport.ProductResponse, len(items))
	for i, item := range items {
		responses[i] = toProductResponse(item)
	}
	if pageSize < 1 {
		pageSize = len(items)
	}
	totalPages := 0
	if pageSize > 0 {
		totalPages = (total + pageSize - 1) / pageSize
	}
	return transport.ProductListResponse{
		Items:      responses,
		Total:      total,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}
}

// Asset operations

func (s *Service) GetCatalogAssetPresign(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, req transport.PresignCatalogAssetRequest) (transport.PresignedUploadResponse, error) {
	if _, err := s.repo.GetProductByID(ctx, tenantID, productID); err != nil {
		return transport.PresignedUploadResponse{}, err
	}

	if err := s.storage.ValidateContentType(req.ContentType); err != nil {
		return transport.PresignedUploadResponse{}, apperr.Validation("file type not allowed")
	}
	if err := s.storage.ValidateFileSize(req.SizeBytes); err != nil {
		return transport.PresignedUploadResponse{}, apperr.Validation(err.Error())
	}
	if err := validateAssetType(req.AssetType, req.ContentType); err != nil {
		return transport.PresignedUploadResponse{}, err
	}

	folder := fmt.Sprintf("%s/%s/%s", tenantID.String(), productID.String(), req.AssetType)
	presigned, err := s.storage.GenerateUploadURL(ctx, s.bucket, folder, req.FileName, req.ContentType, req.SizeBytes)
	if err != nil {
		return transport.PresignedUploadResponse{}, err
	}

	return transport.PresignedUploadResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	}, nil
}

func (s *Service) CreateCatalogAsset(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, req transport.CreateCatalogAssetRequest) (transport.CatalogAssetResponse, error) {
	if _, err := s.repo.GetProductByID(ctx, tenantID, productID); err != nil {
		return transport.CatalogAssetResponse{}, err
	}

	if err := s.storage.ValidateContentType(req.ContentType); err != nil {
		return transport.CatalogAssetResponse{}, apperr.Validation("file type not allowed")
	}
	if err := s.storage.ValidateFileSize(req.SizeBytes); err != nil {
		return transport.CatalogAssetResponse{}, apperr.Validation(err.Error())
	}

	if err := validateAssetType(req.AssetType, req.ContentType); err != nil {
		return transport.CatalogAssetResponse{}, err
	}

	fileKey := strings.TrimSpace(req.FileKey)
	fileName := strings.TrimSpace(req.FileName)
	contentType := strings.TrimSpace(req.ContentType)
	sizeBytes := req.SizeBytes

	asset, err := s.repo.CreateProductAsset(ctx, repository.CreateProductAssetParams{
		OrganizationID: tenantID,
		ProductID:      productID,
		AssetType:      req.AssetType,
		FileKey:        &fileKey,
		FileName:       &fileName,
		ContentType:    &contentType,
		SizeBytes:      &sizeBytes,
		URL:            nil,
	})
	if err != nil {
		return transport.CatalogAssetResponse{}, err
	}

	s.log.Info("catalog asset created", "productId", productID, "assetId", asset.ID, "type", asset.AssetType)
	return toCatalogAssetResponse(asset), nil
}

func (s *Service) CreateCatalogURLAsset(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, req transport.CreateCatalogURLAssetRequest) (transport.CatalogAssetResponse, error) {
	if _, err := s.repo.GetProductByID(ctx, tenantID, productID); err != nil {
		return transport.CatalogAssetResponse{}, err
	}

	if req.AssetType != "terms_url" {
		return transport.CatalogAssetResponse{}, apperr.Validation("invalid assetType")
	}

	url := strings.TrimSpace(req.URL)
	var label *string
	if req.Label != nil {
		trimmed := strings.TrimSpace(*req.Label)
		label = &trimmed
	}

	asset, err := s.repo.CreateProductAsset(ctx, repository.CreateProductAssetParams{
		OrganizationID: tenantID,
		ProductID:      productID,
		AssetType:      req.AssetType,
		FileName:       label,
		URL:            &url,
	})
	if err != nil {
		return transport.CatalogAssetResponse{}, err
	}

	s.log.Info("catalog url asset created", "productId", productID, "assetId", asset.ID)
	return toCatalogAssetResponse(asset), nil
}

func (s *Service) ListCatalogAssets(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, assetType *string) (transport.CatalogAssetListResponse, error) {
	if _, err := s.repo.GetProductByID(ctx, tenantID, productID); err != nil {
		return transport.CatalogAssetListResponse{}, err
	}

	items, err := s.repo.ListProductAssets(ctx, repository.ListProductAssetsParams{
		OrganizationID: tenantID,
		ProductID:      productID,
		AssetType:      assetType,
	})
	if err != nil {
		return transport.CatalogAssetListResponse{}, err
	}

	responses := make([]transport.CatalogAssetResponse, len(items))
	for i, item := range items {
		responses[i] = toCatalogAssetResponse(item)
	}

	return transport.CatalogAssetListResponse{Items: responses}, nil
}

func (s *Service) GetCatalogAssetDownloadURL(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, assetID uuid.UUID) (transport.PresignedDownloadResponse, error) {
	asset, err := s.repo.GetProductAssetByID(ctx, tenantID, assetID)
	if err != nil {
		return transport.PresignedDownloadResponse{}, err
	}
	if asset.ProductID != productID {
		return transport.PresignedDownloadResponse{}, apperr.NotFound("product asset not found")
	}

	if asset.URL != nil {
		return transport.PresignedDownloadResponse{DownloadURL: *asset.URL}, nil
	}
	if asset.FileKey == nil {
		return transport.PresignedDownloadResponse{}, apperr.Validation("missing file key")
	}

	presigned, err := s.storage.GenerateDownloadURL(ctx, s.bucket, *asset.FileKey)
	if err != nil {
		return transport.PresignedDownloadResponse{}, err
	}
	expiresAt := presigned.ExpiresAt.Unix()

	return transport.PresignedDownloadResponse{
		DownloadURL: presigned.URL,
		ExpiresAt:   &expiresAt,
	}, nil
}

func (s *Service) DeleteCatalogAsset(ctx context.Context, tenantID uuid.UUID, productID uuid.UUID, assetID uuid.UUID) error {
	asset, err := s.repo.GetProductAssetByID(ctx, tenantID, assetID)
	if err != nil {
		return err
	}
	if asset.ProductID != productID {
		return apperr.NotFound("product asset not found")
	}

	if asset.FileKey != nil {
		if err := s.storage.DeleteObject(ctx, s.bucket, *asset.FileKey); err != nil {
			return err
		}
	}

	if err := s.repo.DeleteProductAsset(ctx, tenantID, assetID); err != nil {
		return err
	}

	s.log.Info("catalog asset deleted", "productId", productID, "assetId", assetID)
	return nil
}

func validateAssetType(assetType string, contentType string) error {
	normalized := strings.TrimSpace(strings.Split(contentType, ";")[0])
	switch assetType {
	case "image":
		if !storage.IsImageContentType(normalized) {
			return apperr.Validation("assetType image requires image content type")
		}
	case "document":
		if !storage.IsDocumentContentType(normalized) {
			return apperr.Validation("assetType document requires document content type")
		}
	default:
		return apperr.Validation("invalid assetType")
	}
	return nil
}

func toCatalogAssetResponse(asset repository.ProductAsset) transport.CatalogAssetResponse {
	return transport.CatalogAssetResponse{
		ID:          asset.ID,
		ProductID:   asset.ProductID,
		AssetType:   asset.AssetType,
		FileKey:     asset.FileKey,
		FileName:    asset.FileName,
		ContentType: asset.ContentType,
		SizeBytes:   asset.SizeBytes,
		URL:         asset.URL,
		CreatedAt:   asset.CreatedAt,
	}
}

type defaultVatRate struct {
	Name    string
	RateBps int
}

var defaultVatRates = []defaultVatRate{
	{Name: "BTW 21%", RateBps: 2100},
	{Name: "BTW 9%", RateBps: 900},
	{Name: "BTW 0%", RateBps: 0},
}
</file>

<file path="internal/partners/repository/offer_repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// PartnerOffer represents a job offer to a vakman partner.
type PartnerOffer struct {
	ID                     uuid.UUID
	OrganizationID         uuid.UUID
	PartnerID              uuid.UUID
	LeadServiceID          uuid.UUID
	PublicToken            string
	ExpiresAt              time.Time
	PricingSource          string
	CustomerPriceCents     int64
	VakmanPriceCents       int64
	JobSummaryShort        *string
	BuilderSummary         *string
	Status                 string
	AcceptedAt             *time.Time
	RejectedAt             *time.Time
	RejectionReason        *string
	InspectionAvailability []byte // Raw JSONB
	JobAvailability        []byte // Raw JSONB
	CreatedAt              time.Time
	UpdatedAt              time.Time
}

// PartnerOfferWithContext enriches a PartnerOffer with display information.
type PartnerOfferWithContext struct {
	PartnerOffer
	PartnerName        string
	OrganizationName   string
	LeadCity           string
	ServiceType        string
	LeadPostcode4      *string
	LeadBuurtcode      *string
	LeadEnergyBouwjaar *int
	UrgencyLevel       *string
}

// QuoteItemSummary is a minimal view of a quote line item for summary generation.
type QuoteItemSummary struct {
	Description string
	Quantity    string
}

// LeadServiceSummaryContext captures non-PII fields for summary generation.
type LeadServiceSummaryContext struct {
	LeadID       uuid.UUID
	ServiceType  string
	UrgencyLevel *string
}

const offerNotFoundMsg = "offer not found"

// CreateOffer inserts a new partner offer.
func (r *Repository) CreateOffer(ctx context.Context, offer PartnerOffer) (PartnerOffer, error) {
	query := `
		INSERT INTO RAC_partner_offers (
			organization_id, partner_id, lead_service_id, public_token, expires_at,
			pricing_source, customer_price_cents, vakman_price_cents, job_summary_short, builder_summary, status
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'pending')
		RETURNING id, status, created_at, updated_at`

	err := r.pool.QueryRow(ctx, query,
		offer.OrganizationID, offer.PartnerID, offer.LeadServiceID,
		offer.PublicToken, offer.ExpiresAt,
		offer.PricingSource, offer.CustomerPriceCents, offer.VakmanPriceCents, offer.JobSummaryShort, offer.BuilderSummary,
	).Scan(&offer.ID, &offer.Status, &offer.CreatedAt, &offer.UpdatedAt)
	if err != nil {
		return PartnerOffer{}, fmt.Errorf("create partner offer: %w", err)
	}

	return offer, nil
}

// GetOfferByToken retrieves an offer by its public token with context info.
func (r *Repository) GetOfferByToken(ctx context.Context, token string) (PartnerOfferWithContext, error) {
	query := `
		SELECT o.id, o.organization_id, o.partner_id, o.lead_service_id,
		       o.public_token, o.expires_at,
		       o.pricing_source, o.customer_price_cents, o.vakman_price_cents,
		       o.job_summary_short,
		       o.builder_summary,
		       o.status, o.accepted_at, o.rejected_at, o.rejection_reason,
		       o.inspection_availability, o.job_availability,
		       o.created_at, o.updated_at,
		       p.business_name,
		       org.name,
		       l.address_city,
		       st.name AS service_type,
		       l.lead_enrichment_postcode4,
		       l.lead_enrichment_buurtcode,
		       l.energy_bouwjaar,
		       ai.urgency_level
		FROM RAC_partner_offers o
		JOIN RAC_partners p ON p.id = o.partner_id
		JOIN RAC_organizations org ON org.id = o.organization_id
		JOIN RAC_lead_services ls ON ls.id = o.lead_service_id
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		JOIN RAC_leads l ON l.id = ls.lead_id
		LEFT JOIN LATERAL (
			SELECT urgency_level
			FROM RAC_lead_ai_analysis
			WHERE lead_service_id = ls.id
			ORDER BY created_at DESC
			LIMIT 1
		) ai ON true
		WHERE o.public_token = $1`

	var oc PartnerOfferWithContext
	err := r.pool.QueryRow(ctx, query, token).Scan(
		&oc.ID, &oc.OrganizationID, &oc.PartnerID, &oc.LeadServiceID,
		&oc.PublicToken, &oc.ExpiresAt,
		&oc.PricingSource, &oc.CustomerPriceCents, &oc.VakmanPriceCents,
		&oc.JobSummaryShort,
		&oc.BuilderSummary,
		&oc.Status, &oc.AcceptedAt, &oc.RejectedAt, &oc.RejectionReason,
		&oc.InspectionAvailability, &oc.JobAvailability,
		&oc.CreatedAt, &oc.UpdatedAt,
		&oc.PartnerName,
		&oc.OrganizationName,
		&oc.LeadCity,
		&oc.ServiceType,
		&oc.LeadPostcode4,
		&oc.LeadBuurtcode,
		&oc.LeadEnergyBouwjaar,
		&oc.UrgencyLevel,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return PartnerOfferWithContext{}, apperr.NotFound(offerNotFoundMsg)
	}
	if err != nil {
		return PartnerOfferWithContext{}, fmt.Errorf("get offer by token: %w", err)
	}

	return oc, nil
}

// GetOfferByID retrieves an offer by its ID within a tenant.
func (r *Repository) GetOfferByID(ctx context.Context, offerID uuid.UUID, organizationID uuid.UUID) (PartnerOffer, error) {
	query := `
		SELECT id, organization_id, partner_id, lead_service_id,
		       public_token, expires_at,
		       pricing_source, customer_price_cents, vakman_price_cents,
		       job_summary_short,
		       builder_summary,
		       status, accepted_at, rejected_at, rejection_reason,
		       created_at, updated_at
		FROM RAC_partner_offers
		WHERE id = $1 AND organization_id = $2`

	var o PartnerOffer
	err := r.pool.QueryRow(ctx, query, offerID, organizationID).Scan(
		&o.ID, &o.OrganizationID, &o.PartnerID, &o.LeadServiceID,
		&o.PublicToken, &o.ExpiresAt,
		&o.PricingSource, &o.CustomerPriceCents, &o.VakmanPriceCents,
		&o.JobSummaryShort,
		&o.BuilderSummary,
		&o.Status, &o.AcceptedAt, &o.RejectedAt, &o.RejectionReason,
		&o.CreatedAt, &o.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return PartnerOffer{}, apperr.NotFound(offerNotFoundMsg)
	}
	if err != nil {
		return PartnerOffer{}, fmt.Errorf("get offer by id: %w", err)
	}

	return o, nil
}

// GetLeadServiceSummaryContext fetches non-PII data used to build offer summaries.
func (r *Repository) GetLeadServiceSummaryContext(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) (LeadServiceSummaryContext, error) {
	query := `
		SELECT ls.lead_id,
		       st.name AS service_type,
		       ai.urgency_level
		FROM RAC_lead_services ls
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		LEFT JOIN LATERAL (
			SELECT urgency_level
			FROM RAC_lead_ai_analysis
			WHERE lead_service_id = ls.id
			ORDER BY created_at DESC
			LIMIT 1
		) ai ON true
		WHERE ls.id = $1 AND ls.organization_id = $2`

	var ctxData LeadServiceSummaryContext
	if err := r.pool.QueryRow(ctx, query, leadServiceID, organizationID).Scan(&ctxData.LeadID, &ctxData.ServiceType, &ctxData.UrgencyLevel); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return LeadServiceSummaryContext{}, apperr.NotFound("lead service not found")
		}
		return LeadServiceSummaryContext{}, fmt.Errorf("get lead service summary context: %w", err)
	}

	return ctxData, nil
}

// GetOfferByIDWithContext retrieves an offer by ID with display context (partner name, city, etc.).
func (r *Repository) GetOfferByIDWithContext(ctx context.Context, offerID uuid.UUID, organizationID uuid.UUID) (PartnerOfferWithContext, error) {
	query := `
		SELECT o.id, o.organization_id, o.partner_id, o.lead_service_id,
		       o.public_token, o.expires_at,
		       o.pricing_source, o.customer_price_cents, o.vakman_price_cents,
		       o.job_summary_short,
		       o.builder_summary,
		       o.status, o.accepted_at, o.rejected_at, o.rejection_reason,
		       o.inspection_availability, o.job_availability,
		       o.created_at, o.updated_at,
		       p.business_name,
		       org.name,
		       l.address_city,
		       st.name AS service_type,
		       l.lead_enrichment_postcode4,
		       l.lead_enrichment_buurtcode,
		       l.energy_bouwjaar,
		       ai.urgency_level
		FROM RAC_partner_offers o
		JOIN RAC_partners p ON p.id = o.partner_id
		JOIN RAC_organizations org ON org.id = o.organization_id
		JOIN RAC_lead_services ls ON ls.id = o.lead_service_id
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		JOIN RAC_leads l ON l.id = ls.lead_id
		LEFT JOIN LATERAL (
			SELECT urgency_level
			FROM RAC_lead_ai_analysis
			WHERE lead_service_id = ls.id
			ORDER BY created_at DESC
			LIMIT 1
		) ai ON true
		WHERE o.id = $1 AND o.organization_id = $2`

	var oc PartnerOfferWithContext
	err := r.pool.QueryRow(ctx, query, offerID, organizationID).Scan(
		&oc.ID, &oc.OrganizationID, &oc.PartnerID, &oc.LeadServiceID,
		&oc.PublicToken, &oc.ExpiresAt,
		&oc.PricingSource, &oc.CustomerPriceCents, &oc.VakmanPriceCents,
		&oc.JobSummaryShort,
		&oc.BuilderSummary,
		&oc.Status, &oc.AcceptedAt, &oc.RejectedAt, &oc.RejectionReason,
		&oc.InspectionAvailability, &oc.JobAvailability,
		&oc.CreatedAt, &oc.UpdatedAt,
		&oc.PartnerName,
		&oc.OrganizationName,
		&oc.LeadCity,
		&oc.ServiceType,
		&oc.LeadPostcode4,
		&oc.LeadBuurtcode,
		&oc.LeadEnergyBouwjaar,
		&oc.UrgencyLevel,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return PartnerOfferWithContext{}, apperr.NotFound(offerNotFoundMsg)
	}
	if err != nil {
		return PartnerOfferWithContext{}, fmt.Errorf("get offer by id with context: %w", err)
	}

	return oc, nil
}

// GetLatestQuoteItemsForService returns line items from the latest non-draft quote for a lead service.
func (r *Repository) GetLatestQuoteItemsForService(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) ([]QuoteItemSummary, error) {
	query := `
		WITH latest_quote AS (
			SELECT id
			FROM RAC_quotes
			WHERE lead_service_id = $1 AND organization_id = $2 AND status != 'Draft'
			ORDER BY created_at DESC
			LIMIT 1
		)
		SELECT qi.description, qi.quantity
		FROM RAC_quote_items qi
		JOIN latest_quote lq ON lq.id = qi.quote_id
		WHERE qi.is_optional = false OR qi.is_selected = true
		ORDER BY qi.sort_order ASC`

	rows, err := r.pool.Query(ctx, query, leadServiceID, organizationID)
	if err != nil {
		return nil, fmt.Errorf("query quote items for service: %w", err)
	}
	defer rows.Close()

	var items []QuoteItemSummary
	for rows.Next() {
		var it QuoteItemSummary
		if err := rows.Scan(&it.Description, &it.Quantity); err != nil {
			return nil, fmt.Errorf("scan quote item summary: %w", err)
		}
		items = append(items, it)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate quote item summaries: %w", err)
	}

	return items, nil
}

// ListOffersForService returns all offers for a given lead service.
func (r *Repository) ListOffersForService(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) ([]PartnerOfferWithContext, error) {
	query := `
		SELECT o.id, o.organization_id, o.partner_id, o.lead_service_id,
		       o.public_token, o.expires_at,
		       o.pricing_source, o.customer_price_cents, o.vakman_price_cents,
		       o.status, o.accepted_at, o.rejected_at, o.rejection_reason,
		       o.inspection_availability, o.job_availability,
		       o.created_at, o.updated_at,
		       p.business_name
		FROM RAC_partner_offers o
		JOIN RAC_partners p ON p.id = o.partner_id
		WHERE o.lead_service_id = $1 AND o.organization_id = $2
		ORDER BY o.created_at DESC`

	rows, err := r.pool.Query(ctx, query, leadServiceID, organizationID)
	if err != nil {
		return nil, fmt.Errorf("list offers for service: %w", err)
	}
	defer rows.Close()

	var offers []PartnerOfferWithContext
	for rows.Next() {
		var oc PartnerOfferWithContext
		if err := rows.Scan(
			&oc.ID, &oc.OrganizationID, &oc.PartnerID, &oc.LeadServiceID,
			&oc.PublicToken, &oc.ExpiresAt,
			&oc.PricingSource, &oc.CustomerPriceCents, &oc.VakmanPriceCents,
			&oc.Status, &oc.AcceptedAt, &oc.RejectedAt, &oc.RejectionReason,
			&oc.InspectionAvailability, &oc.JobAvailability,
			&oc.CreatedAt, &oc.UpdatedAt,
			&oc.PartnerName,
		); err != nil {
			return nil, fmt.Errorf("scan offer: %w", err)
		}
		offers = append(offers, oc)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate offers: %w", err)
	}

	return offers, nil
}

// ListOffersByPartner returns all offers for a given partner within a tenant.
func (r *Repository) ListOffersByPartner(ctx context.Context, partnerID uuid.UUID, organizationID uuid.UUID) ([]PartnerOfferWithContext, error) {
	query := `
		SELECT o.id, o.organization_id, o.partner_id, o.lead_service_id,
		       o.public_token, o.expires_at,
		       o.pricing_source, o.customer_price_cents, o.vakman_price_cents,
		       o.status, o.accepted_at, o.rejected_at, o.rejection_reason,
		       o.inspection_availability, o.job_availability,
		       o.created_at, o.updated_at,
		       p.business_name,
		       org.name,
		       l.address_city,
		       st.name AS service_type
		FROM RAC_partner_offers o
		JOIN RAC_partners p ON p.id = o.partner_id
		JOIN RAC_organizations org ON org.id = o.organization_id
		JOIN RAC_lead_services ls ON ls.id = o.lead_service_id
		JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = ls.organization_id
		JOIN RAC_leads l ON l.id = ls.lead_id
		WHERE o.partner_id = $1 AND o.organization_id = $2
		ORDER BY o.created_at DESC`

	rows, err := r.pool.Query(ctx, query, partnerID, organizationID)
	if err != nil {
		return nil, fmt.Errorf("list offers by partner: %w", err)
	}
	defer rows.Close()

	var offers []PartnerOfferWithContext
	for rows.Next() {
		var oc PartnerOfferWithContext
		if err := rows.Scan(
			&oc.ID, &oc.OrganizationID, &oc.PartnerID, &oc.LeadServiceID,
			&oc.PublicToken, &oc.ExpiresAt,
			&oc.PricingSource, &oc.CustomerPriceCents, &oc.VakmanPriceCents,
			&oc.Status, &oc.AcceptedAt, &oc.RejectedAt, &oc.RejectionReason,
			&oc.InspectionAvailability, &oc.JobAvailability,
			&oc.CreatedAt, &oc.UpdatedAt,
			&oc.PartnerName,
			&oc.OrganizationName,
			&oc.LeadCity,
			&oc.ServiceType,
		); err != nil {
			return nil, fmt.Errorf("scan partner offer: %w", err)
		}
		offers = append(offers, oc)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate partner offers: %w", err)
	}

	return offers, nil
}

// HasActiveOffer returns true if there is already a pending/sent offer for the lead service.
func (r *Repository) HasActiveOffer(ctx context.Context, leadServiceID uuid.UUID) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(
		SELECT 1 FROM RAC_partner_offers
		WHERE lead_service_id = $1 AND status IN ('pending', 'sent')
	)`
	if err := r.pool.QueryRow(ctx, query, leadServiceID).Scan(&exists); err != nil {
		return false, fmt.Errorf("check active offer: %w", err)
	}
	return exists, nil
}

// AcceptOffer atomically accepts an offer and records availability.
// The unique index idx_partner_offers_exclusive_acceptance prevents double-acceptance.
func (r *Repository) AcceptOffer(ctx context.Context, offerID uuid.UUID, inspectionSlots []byte, jobSlots []byte) error {
	query := `
		UPDATE RAC_partner_offers
		SET status = 'accepted',
		    accepted_at = now(),
		    inspection_availability = $2,
		    job_availability = $3,
		    updated_at = now()
		WHERE id = $1 AND status IN ('pending', 'sent')`

	tag, err := r.pool.Exec(ctx, query, offerID, inspectionSlots, jobSlots)
	if err != nil {
		errMsg := err.Error()
		if strings.Contains(errMsg, "idx_partner_offers_exclusive_acceptance") {
			return apperr.Conflict("job already assigned to another partner")
		}
		return fmt.Errorf("accept offer: %w", err)
	}
	if tag.RowsAffected() == 0 {
		return apperr.Conflict("offer is not in a valid state to be accepted")
	}

	return nil
}

// RejectOffer marks an offer as rejected with an optional reason.
func (r *Repository) RejectOffer(ctx context.Context, offerID uuid.UUID, reason string) error {
	query := `
		UPDATE RAC_partner_offers
		SET status = 'rejected',
		    rejected_at = now(),
		    rejection_reason = $2,
		    updated_at = now()
		WHERE id = $1 AND status IN ('pending', 'sent')`

	var reasonPtr *string
	if reason != "" {
		reasonPtr = &reason
	}

	tag, err := r.pool.Exec(ctx, query, offerID, reasonPtr)
	if err != nil {
		return fmt.Errorf("reject offer: %w", err)
	}
	if tag.RowsAffected() == 0 {
		return apperr.Conflict("offer is not in a valid state to be rejected")
	}

	return nil
}

// ExpireOffers marks all pending/sent offers past their expiry as expired.
// Returns the expired offers for event publishing.
func (r *Repository) ExpireOffers(ctx context.Context) ([]PartnerOffer, error) {
	query := `
		UPDATE RAC_partner_offers
		SET status = 'expired', updated_at = now()
		WHERE status IN ('pending', 'sent') AND expires_at < now()
		RETURNING id, organization_id, partner_id, lead_service_id`

	rows, err := r.pool.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("expire offers: %w", err)
	}
	defer rows.Close()

	var expired []PartnerOffer
	for rows.Next() {
		var o PartnerOffer
		if err := rows.Scan(&o.ID, &o.OrganizationID, &o.PartnerID, &o.LeadServiceID); err != nil {
			return nil, fmt.Errorf("scan expired offer: %w", err)
		}
		expired = append(expired, o)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate expired offers: %w", err)
	}

	return expired, nil
}
</file>

<file path="internal/quotes/handler/handler.go">
package handler

import (
	"fmt"
	"io"
	"net/http"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/quotes/service"
	"portal_final_backend/internal/quotes/transport"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
)

// Handler handles HTTP requests for quotes
type Handler struct {
	svc              *service.Service
	val              *validator.Validator
	storageSvc       storage.StorageService
	pdfBucket        string
	attachmentBucket string
	catalogBucket    string
	pdfGen           PDFOnDemandGenerator
}

// New creates a new quotes handler
func New(svc *service.Service, val *validator.Validator) *Handler {
	return &Handler{svc: svc, val: val}
}

// SetStorageForPDF injects the storage service and bucket for PDF downloads.
func (h *Handler) SetStorageForPDF(svc storage.StorageService, bucket string) {
	h.storageSvc = svc
	h.pdfBucket = bucket
}

// SetAttachmentBucket injects the bucket name for manual quote attachments.
func (h *Handler) SetAttachmentBucket(bucket string) {
	h.attachmentBucket = bucket
}

// SetCatalogBucket injects the bucket name for catalog asset downloads.
func (h *Handler) SetCatalogBucket(bucket string) {
	h.catalogBucket = bucket
}

// SetPDFGenerator injects the on-demand PDF generator for lazy PDF creation.
func (h *Handler) SetPDFGenerator(gen PDFOnDemandGenerator) {
	h.pdfGen = gen
}

// RegisterRoutes registers the quote routes
func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("", h.List)
	rg.POST("", h.Create)
	rg.POST("/calculate", h.PreviewCalculation)
	rg.POST("/generate", h.Generate)
	rg.GET("/:id", h.GetByID)
	rg.PUT("/:id", h.Update)
	rg.PATCH("/:id/status", h.UpdateStatus)
	rg.POST("/:id/send", h.Send)
	rg.GET("/:id/preview-link", h.GetPreviewLink)
	rg.POST("/:id/items/:itemId/annotations", h.AgentAnnotate)
	rg.GET("/:id/activities", h.ListActivities)
	rg.GET("/:id/pdf", h.DownloadPDF)
	rg.POST("/:id/attachments/presign", h.PresignAttachmentUpload)
	rg.GET("/:id/attachments/:attachmentId/download", h.GetAttachmentDownloadURL)
	rg.DELETE("/:id", h.Delete)
}

// List handles GET /api/v1/quotes
func (h *Handler) List(c *gin.Context) {
	var req transport.ListQuotesRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	result, err := h.svc.List(c.Request.Context(), tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Create handles POST /api/v1/quotes
func (h *Handler) Create(c *gin.Context) {
	var req transport.CreateQuoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	identity := httpkit.MustGetIdentity(c)
	result, err := h.svc.Create(c.Request.Context(), tenantID, identity.UserID(), req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// Generate handles POST /api/v1/quotes/generate
// Generates a draft quote from a user prompt using the AI agent pipeline.
func (h *Handler) Generate(c *gin.Context) {
	var req transport.GenerateQuoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	// LeadServiceID is required for generation
	if req.LeadServiceID == nil {
		httpkit.Error(c, http.StatusBadRequest, "leadServiceId is required for quote generation", nil)
		return
	}

	result, err := h.svc.GenerateQuote(c.Request.Context(), tenantID, req.LeadID, *req.LeadServiceID, req.Prompt, req.QuoteID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, transport.GenerateQuoteResponse{
		QuoteID:     result.QuoteID,
		QuoteNumber: result.QuoteNumber,
		ItemCount:   result.ItemCount,
	})
}

// GetByID handles GET /api/v1/quotes/:id
func (h *Handler) GetByID(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	result, err := h.svc.GetByID(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Update handles PUT /api/v1/quotes/:id
func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateQuoteRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	result, err := h.svc.Update(c.Request.Context(), id, tenantID, req)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// UpdateStatus handles PATCH /api/v1/quotes/:id/status
func (h *Handler) UpdateStatus(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateQuoteStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	identity := httpkit.MustGetIdentity(c)
	result, err := h.svc.UpdateStatus(c.Request.Context(), id, tenantID, identity.UserID(), req.Status)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// Delete handles DELETE /api/v1/quotes/:id
func (h *Handler) Delete(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	if err := h.svc.Delete(c.Request.Context(), id, tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "quote deleted"})
}

// PreviewCalculation handles POST /api/v1/quotes/calculate
// Returns calculated totals without persisting anything.
func (h *Handler) PreviewCalculation(c *gin.Context) {
	var req transport.QuoteCalculationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result := service.CalculateQuote(req)
	httpkit.OK(c, result)
}

// Send handles POST /api/v1/quotes/:id/send
// Generates a public token and transitions the quote to "Sent" status.
func (h *Handler) Send(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	identity := httpkit.MustGetIdentity(c)
	result, err := h.svc.Send(c.Request.Context(), id, tenantID, identity.UserID())
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// GetPreviewLink handles GET /api/v1/quotes/:id/preview-link
// Returns a read-only preview token for internal agent preview.
func (h *Handler) GetPreviewLink(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	result, err := h.svc.GetPreviewLink(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// AgentAnnotate handles POST /api/v1/quotes/:id/items/:itemId/annotations
// Allows an authenticated agent to add an annotation to a quote item.
func (h *Handler) AgentAnnotate(c *gin.Context) {
	quoteID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	itemID, err := uuid.Parse(c.Param("itemId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid item ID", nil)
		return
	}

	var req transport.AnnotateItemRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	identity := httpkit.MustGetIdentity(c)
	result, err := h.svc.AgentAnnotateItem(c.Request.Context(), quoteID, itemID, tenantID, identity.UserID(), req.Text)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, result)
}

// ListActivities handles GET /api/v1/quotes/:id/activities
func (h *Handler) ListActivities(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	activities, err := h.svc.ListActivities(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, activities)
}

// DownloadPDF handles GET /api/v1/quotes/:id/pdf
// Streams the generated PDF directly from object storage.
func (h *Handler) DownloadPDF(c *gin.Context) {
	if h.storageSvc == nil {
		httpkit.Error(c, http.StatusServiceUnavailable, "PDF downloads are not configured", nil)
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	result, err := h.svc.GetByID(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	if result.PDFFileKey == nil || *result.PDFFileKey == "" {
		// Lazy generation: if no PDF is stored yet, generate on the fly
		if h.pdfGen != nil {
			fileKey, pdfBytes, genErr := h.pdfGen.RegeneratePDF(c.Request.Context(), id, tenantID)
			if genErr != nil {
				httpkit.Error(c, http.StatusInternalServerError, "PDF generatie mislukt", genErr.Error())
				return
			}

			fileName := fmt.Sprintf("Offerte-%s.pdf", result.QuoteNumber)
			c.Header("Content-Type", contentTypePDF)
			c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, fileName))
			c.Data(http.StatusOK, contentTypePDF, pdfBytes)
			_ = fileKey
			return
		}
		httpkit.Error(c, http.StatusNotFound, "no PDF available for this quote", nil)
		return
	}

	reader, err := h.storageSvc.DownloadFile(c.Request.Context(), h.pdfBucket, *result.PDFFileKey)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to retrieve PDF", err.Error())
		return
	}
	defer func() { _ = reader.Close() }()

	fileName := fmt.Sprintf("Offerte-%s.pdf", result.QuoteNumber)
	c.Header("Content-Type", contentTypePDF)
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, fileName))
	c.Status(http.StatusOK)

	if _, err := io.Copy(c.Writer, reader); err != nil {
		// Headers already sent  can't return a JSON error at this point
		_ = c.Error(err)
	}
}

// PresignAttachmentUpload handles POST /api/v1/quotes/:id/attachments/presign
// Generates a presigned URL for uploading a manual PDF attachment.
func (h *Handler) PresignAttachmentUpload(c *gin.Context) {
	if h.storageSvc == nil || h.attachmentBucket == "" {
		httpkit.Error(c, http.StatusServiceUnavailable, "attachment uploads are not configured", nil)
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	// Verify the quote exists and belongs to this tenant
	if _, err := h.svc.GetByID(c.Request.Context(), id, tenantID); err != nil {
		if httpkit.HandleError(c, err) {
			return
		}
		return
	}

	var req transport.PresignAttachmentUploadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	// Validate via storage service
	if err := h.storageSvc.ValidateContentType(req.ContentType); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "file type not allowed", nil)
		return
	}
	if err := h.storageSvc.ValidateFileSize(req.SizeBytes); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	// Folder path: {org_id}/quotes/{quote_id}
	folder := fmt.Sprintf("%s/quotes/%s", tenantID.String(), id.String())

	presigned, err := h.storageSvc.GenerateUploadURL(c.Request.Context(), h.attachmentBucket, folder, req.FileName, req.ContentType, req.SizeBytes)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate upload URL", nil)
		return
	}

	httpkit.OK(c, transport.PresignedUploadResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	})
}

// GetAttachmentDownloadURL handles GET /api/v1/quotes/:id/attachments/:attachmentId/download
// Returns a presigned download URL for the attachment, resolving the bucket by source.
func (h *Handler) GetAttachmentDownloadURL(c *gin.Context) {
	if h.storageSvc == nil {
		httpkit.Error(c, http.StatusServiceUnavailable, "storage is not configured", nil)
		return
	}

	quoteID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	attachmentID, err := uuid.Parse(c.Param("attachmentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	tenantID, ok := mustGetTenantID(c)
	if !ok {
		return
	}

	att, err := h.svc.GetAttachmentByID(c.Request.Context(), attachmentID, quoteID, tenantID)
	if err != nil {
		if httpkit.HandleError(c, err) {
			return
		}
		return
	}

	bucket := h.attachmentBucket
	if att.Source == "catalog" {
		bucket = h.catalogBucket
	}

	if bucket == "" {
		httpkit.Error(c, http.StatusServiceUnavailable, "storage bucket not configured for source: "+att.Source, nil)
		return
	}

	presigned, err := h.storageSvc.GenerateDownloadURL(c.Request.Context(), bucket, att.FileKey)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to generate download URL", nil)
		return
	}

	httpkit.OK(c, transport.PresignedDownloadResponse{
		DownloadURL: presigned.URL,
		ExpiresAt:   presigned.ExpiresAt.Unix(),
	})
}

// mustGetTenantID extracts the tenant ID from identity.
func mustGetTenantID(c *gin.Context) (uuid.UUID, bool) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return uuid.UUID{}, false
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusBadRequest, "tenant ID is required", nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}
</file>

<file path="internal/leads/agent/estimator.go">
package agent

import (
	"context"
	"fmt"
	"log"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/adk/tool"
	"google.golang.org/genai"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/platform/ai/embeddings"
	"portal_final_backend/platform/ai/moonshot"
	"portal_final_backend/platform/qdrant"
)

// Estimator determines scope and pricing estimates.
type Estimator struct {
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
	appName        string
	repo           repository.LeadsRepository
	toolDeps       *ToolDependencies
	runMu          sync.Mutex
}

// EstimatorConfig holds configuration for creating an Estimator agent.
type EstimatorConfig struct {
	APIKey              string
	Repo                repository.LeadsRepository
	EventBus            events.Bus
	EmbeddingClient     *embeddings.Client  // Optional: enables product search
	QdrantClient        *qdrant.Client      // Optional: fallback collection search
	CatalogQdrantClient *qdrant.Client      // Optional: catalog collection search
	CatalogReader       ports.CatalogReader // Optional: hydrate search results from DB
	QuoteDrafter        ports.QuoteDrafter  // Optional: draft quotes from agent
}

// NewEstimator creates an Estimator agent.
func NewEstimator(cfg EstimatorConfig) (*Estimator, error) {
	kimi := moonshot.NewModel(moonshot.Config{
		APIKey:          cfg.APIKey,
		Model:           "kimi-k2.5",
		DisableThinking: true,
	})

	deps := &ToolDependencies{
		Repo:                cfg.Repo,
		EventBus:            cfg.EventBus,
		EmbeddingClient:     cfg.EmbeddingClient,
		QdrantClient:        cfg.QdrantClient,
		CatalogQdrantClient: cfg.CatalogQdrantClient,
		CatalogReader:       cfg.CatalogReader,
		QuoteDrafter:        cfg.QuoteDrafter,
	}

	saveEstimationTool, err := createSaveEstimationTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build SaveEstimation tool: %w", err)
	}

	updateStageTool, err := createUpdatePipelineStageTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build UpdatePipelineStage tool: %w", err)
	}

	calculateEstimateTool, err := createCalculateEstimateTool()
	if err != nil {
		return nil, fmt.Errorf("failed to build CalculateEstimate tool: %w", err)
	}

	calculatorTool, err := createCalculatorTool()
	if err != nil {
		return nil, fmt.Errorf("failed to build Calculator tool: %w", err)
	}

	// Build the tools list.
	// DraftQuote is always registered because QuoteDrafter is injected after
	// construction via SetQuoteDrafter (to break circular dependencies).
	// handleDraftQuote gracefully returns an error when the drafter is still nil.
	draftQuoteTool, err := createDraftQuoteTool(deps)
	if err != nil {
		return nil, fmt.Errorf("failed to build DraftQuote tool: %w", err)
	}

	tools := []tool.Tool{calculatorTool, calculateEstimateTool, saveEstimationTool, updateStageTool, draftQuoteTool}

	// Add product search tool if configured
	if deps.IsProductSearchEnabled() {
		searchProductsTool, err := createSearchProductMaterialsTool(deps)
		if err != nil {
			return nil, fmt.Errorf("failed to build SearchProductMaterials tool: %w", err)
		}
		tools = append(tools, searchProductsTool)
		log.Printf("Estimator: product search enabled")
	} else {
		log.Printf("Estimator: product search disabled (embedding or qdrant client not configured)")
	}

	adkAgent, err := llmagent.New(llmagent.Config{
		Name:        "Estimator",
		Model:       kimi,
		Description: "Technical estimator that scopes work and suggests price ranges.",
		Instruction: "You are a Technical Estimator.",
		Tools:       tools,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create estimator agent: %w", err)
	}

	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "estimator",
		Agent:          adkAgent,
		SessionService: sessionService,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create estimator runner: %w", err)
	}

	return &Estimator{
		agent:          adkAgent,
		runner:         r,
		sessionService: sessionService,
		appName:        "estimator",
		repo:           cfg.Repo,
		toolDeps:       deps,
	}, nil
}

// SetCatalogReader injects the catalog reader (set after construction to break circular deps).
func (e *Estimator) SetCatalogReader(cr ports.CatalogReader) {
	e.toolDeps.CatalogReader = cr
}

// SetQuoteDrafter injects the quote drafter (set after construction to break circular deps).
func (e *Estimator) SetQuoteDrafter(qd ports.QuoteDrafter) {
	e.toolDeps.QuoteDrafter = qd
}

// Run executes estimation for a lead service.
func (e *Estimator) Run(ctx context.Context, leadID, serviceID, tenantID uuid.UUID) error {
	e.runMu.Lock()
	defer e.runMu.Unlock()

	e.toolDeps.SetTenantID(tenantID)
	e.toolDeps.SetLeadContext(leadID, serviceID)
	e.toolDeps.SetActor("AI", "Estimator")
	e.toolDeps.ResetToolCallTracking()

	lead, err := e.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return err
	}
	service, err := e.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		return err
	}

	notes, err := e.repo.ListNotesByService(ctx, leadID, serviceID, tenantID)
	if err != nil {
		log.Printf("estimator notes fetch failed: %v", err)
		notes = nil
	}

	var photo *repository.PhotoAnalysis
	if analysis, err := e.repo.GetLatestPhotoAnalysis(ctx, serviceID, tenantID); err == nil {
		photo = &analysis
	}

	promptText := buildEstimatorPrompt(lead, service, notes, photo)
	if err := e.runWithPrompt(ctx, promptText, leadID); err != nil {
		return err
	}

	if !e.toolDeps.WasSaveEstimationCalled() {
		warn := "Estimator heeft geen schatting opgeslagen. Handmatige controle vereist."
		_, _ = e.repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
			LeadID:         leadID,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      "System",
			ActorName:      "Estimator",
			EventType:      "alert",
			Title:          "Schatting ontbreekt",
			Summary:        &warn,
		})
		log.Printf("estimator: SaveEstimation was not called for lead=%s service=%s", leadID, serviceID)
	}

	if !e.toolDeps.WasDraftQuoteCalled() {
		log.Printf("estimator: DraftQuote was not called for lead=%s service=%s", leadID, serviceID)
	}

	return nil
}

func (e *Estimator) runWithPrompt(ctx context.Context, promptText string, leadID uuid.UUID) error {
	sessionID := uuid.New().String()
	userID := "estimator-" + leadID.String()

	_, err := e.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   e.appName,
		UserID:    userID,
		SessionID: sessionID,
	})
	if err != nil {
		return fmt.Errorf("failed to create estimator session: %w", err)
	}
	defer func() {
		_ = e.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   e.appName,
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	userMessage := &genai.Content{
		Role:  "user",
		Parts: []*genai.Part{{Text: promptText}},
	}

	runConfig := agent.RunConfig{StreamingMode: agent.StreamingModeNone}
	for event := range e.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		_ = event
	}

	return nil
}
</file>

<file path="internal/leads/handler/photo_analysis.go">
package handler

import (
	"context"
	"io"
	"log"
	"net/http"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/leads/agent"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// PhotoAnalysisHandler handles HTTP requests for photo analysis.
type PhotoAnalysisHandler struct {
	analyzer *agent.PhotoAnalyzer
	repo     repository.LeadsRepository
	storage  storage.StorageService
	bucket   string
	sse      *sse.Service
	val      *validator.Validator
}

// NewPhotoAnalysisHandler creates a new photo analysis handler.
func NewPhotoAnalysisHandler(analyzer *agent.PhotoAnalyzer, repo repository.LeadsRepository, storageSvc storage.StorageService, bucket string, sseSvc *sse.Service, val *validator.Validator) *PhotoAnalysisHandler {
	return &PhotoAnalysisHandler{
		analyzer: analyzer,
		repo:     repo,
		storage:  storageSvc,
		bucket:   bucket,
		sse:      sseSvc,
		val:      val,
	}
}

// RegisterRoutes registers photo analysis routes.
func (h *PhotoAnalysisHandler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.POST("/analyze-photos", h.AnalyzePhotos)
	rg.GET("/photo-analysis", h.GetPhotoAnalysis)
	rg.GET("/photo-analysis/history", h.ListPhotoAnalyses)
}

// PhotoAnalysisRequest represents the request to analyze photos.
type PhotoAnalysisRequest struct {
	Context string `json:"context"` // Optional context about the issue
}

const (
	errTenantContextRequired = "tenant context required"
	errInvalidServiceID      = "invalid service id"
)

// AnalyzePhotos triggers AI analysis of photos for a lead service.
// This analyzes all attachments that are images for the given service.
func (h *PhotoAnalysisHandler) AnalyzePhotos(c *gin.Context) {
	identity, tenantID, ok := h.getIdentityAndTenant(c)
	if !ok {
		return
	}

	leadID, serviceID, ok := h.parseLeadServiceIDs(c)
	if !ok {
		return
	}

	contextInfo := parsePhotoAnalysisContext(c)

	imageAttachments, ok := h.loadImageAttachments(c, serviceID, *tenantID)
	if !ok {
		return
	}

	userID := identity.UserID()
	go h.runPhotoAnalysis(context.Background(), leadID, serviceID, *tenantID, &userID, imageAttachments, contextInfo)

	httpkit.OK(c, gin.H{
		"status":     "processing",
		"message":    "Photo analysis started",
		"photoCount": len(imageAttachments),
	})
}

func (h *PhotoAnalysisHandler) getIdentityAndTenant(c *gin.Context) (httpkit.Identity, *uuid.UUID, bool) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return nil, nil, false
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, errTenantContextRequired, nil)
		return nil, nil, false
	}
	return identity, tenantID, true
}

func (h *PhotoAnalysisHandler) parseLeadServiceIDs(c *gin.Context) (uuid.UUID, uuid.UUID, bool) {
	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid lead id", nil)
		return uuid.UUID{}, uuid.UUID{}, false
	}
	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, errInvalidServiceID, nil)
		return uuid.UUID{}, uuid.UUID{}, false
	}
	return leadID, serviceID, true
}

func parsePhotoAnalysisContext(c *gin.Context) string {
	var req PhotoAnalysisRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		return ""
	}
	return req.Context
}

func (h *PhotoAnalysisHandler) loadImageAttachments(c *gin.Context, serviceID, tenantID uuid.UUID) ([]repository.Attachment, bool) {
	attachments, err := h.repo.ListAttachmentsByService(c.Request.Context(), serviceID, tenantID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to fetch attachments", nil)
		return nil, false
	}

	imageAttachments := filterImageAttachments(attachments)
	if len(imageAttachments) == 0 {
		httpkit.Error(c, http.StatusBadRequest, "no image attachments found for this service", nil)
		return nil, false
	}

	return imageAttachments, true
}

func filterImageAttachments(attachments []repository.Attachment) []repository.Attachment {
	imageAttachments := make([]repository.Attachment, 0, len(attachments))
	for _, att := range attachments {
		if att.ContentType != nil && isImageContentType(*att.ContentType) {
			imageAttachments = append(imageAttachments, att)
		}
	}
	return imageAttachments
}

// runPhotoAnalysis performs the photo analysis in the background and sends SSE notification when done.
func (h *PhotoAnalysisHandler) runPhotoAnalysis(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, userID *uuid.UUID, attachments []repository.Attachment, contextInfo string) {
	serviceType, intakeRequirements := h.getServiceAnalysisContext(ctx, serviceID, tenantID)
	images := h.loadImages(ctx, attachments)
	if len(images) == 0 {
		h.publishPhotoAnalysisFailure(userID, leadID, serviceID, "Failed to load images for analysis", "no_valid_images")
		return
	}

	result, err := h.analyzer.AnalyzePhotos(ctx, agent.PhotoAnalysisRequest{
		LeadID:             leadID,
		ServiceID:          serviceID,
		TenantID:           tenantID,
		Images:             images,
		ContextInfo:        contextInfo,
		ServiceType:        serviceType,
		IntakeRequirements: intakeRequirements,
	})
	if err != nil {
		h.publishPhotoAnalysisFailure(userID, leadID, serviceID, "Photo analysis failed", err.Error())
		return
	}

	result.PhotoCount = len(images)
	h.persistPhotoAnalysis(ctx, leadID, serviceID, tenantID, result)
	h.writePhotoAnalysisTimeline(ctx, leadID, serviceID, tenantID, result, attachments)
	h.publishPhotoAnalysisSuccess(userID, leadID, serviceID, result)
}

// RunAutoAnalysis triggers photo analysis without user-specific SSE notifications.
func (h *PhotoAnalysisHandler) RunAutoAnalysis(leadID, serviceID, tenantID uuid.UUID) {
	attachments, err := h.repo.ListAttachmentsByService(context.Background(), serviceID, tenantID)
	if err != nil {
		log.Printf("photo analysis: failed to load attachments for service %s: %v", serviceID, err)
		return
	}

	imageAttachments := filterImageAttachments(attachments)
	if len(imageAttachments) == 0 {
		return
	}

	go h.runPhotoAnalysis(context.Background(), leadID, serviceID, tenantID, nil, imageAttachments, "")
}

func (h *PhotoAnalysisHandler) getServiceAnalysisContext(ctx context.Context, serviceID, tenantID uuid.UUID) (string, string) {
	serviceType := ""
	intakeRequirements := ""
	svc, svcErr := h.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if svcErr != nil {
		return serviceType, intakeRequirements
	}
	serviceType = svc.ServiceType

	serviceTypes, stErr := h.repo.ListActiveServiceTypes(ctx, tenantID)
	if stErr != nil {
		return serviceType, intakeRequirements
	}
	for _, st := range serviceTypes {
		if st.Name == serviceType && st.IntakeGuidelines != nil {
			intakeRequirements = *st.IntakeGuidelines
			break
		}
	}

	return serviceType, intakeRequirements
}

func (h *PhotoAnalysisHandler) loadImages(ctx context.Context, attachments []repository.Attachment) []agent.ImageData {
	images := make([]agent.ImageData, 0, len(attachments))
	for _, att := range attachments {
		data, err := h.storage.DownloadFile(ctx, h.bucket, att.FileKey)
		if err != nil {
			continue
		}
		imgData, readErr := readAllAndClose(data)
		if readErr != nil {
			continue
		}

		mimeType := "image/jpeg"
		if att.ContentType != nil {
			mimeType = *att.ContentType
		}

		images = append(images, agent.ImageData{
			MIMEType: mimeType,
			Data:     imgData,
			Filename: att.FileName,
		})
	}

	return images
}

func readAllAndClose(data io.ReadCloser) ([]byte, error) {
	defer func() {
		_ = data.Close()
	}()
	return io.ReadAll(data)
}

func (h *PhotoAnalysisHandler) publishPhotoAnalysisFailure(userID *uuid.UUID, leadID, serviceID uuid.UUID, message, errCode string) {
	if userID == nil {
		return
	}
	h.sse.Publish(*userID, sse.Event{
		Type:      sse.EventPhotoAnalysisComplete,
		LeadID:    leadID,
		ServiceID: serviceID,
		Message:   message,
		Data:      gin.H{"success": false, "error": errCode},
	})
}

func (h *PhotoAnalysisHandler) persistPhotoAnalysis(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, result *agent.PhotoAnalysis) {
	repoMeasurements := make([]repository.Measurement, 0, len(result.Measurements))
	for _, m := range result.Measurements {
		repoMeasurements = append(repoMeasurements, repository.Measurement{
			Description: m.Description,
			Value:       m.Value,
			Unit:        m.Unit,
			Type:        m.Type,
			Confidence:  m.Confidence,
			PhotoRef:    m.PhotoRef,
		})
	}

	_, dbErr := h.repo.CreatePhotoAnalysis(ctx, repository.CreatePhotoAnalysisParams{
		LeadID:                 leadID,
		ServiceID:              serviceID,
		OrganizationID:         tenantID,
		Summary:                result.Summary,
		Observations:           result.Observations,
		ScopeAssessment:        result.ScopeAssessment,
		CostIndicators:         result.CostIndicators,
		SafetyConcerns:         result.SafetyConcerns,
		AdditionalInfo:         result.AdditionalInfo,
		ConfidenceLevel:        result.ConfidenceLevel,
		PhotoCount:             result.PhotoCount,
		Measurements:           repoMeasurements,
		NeedsOnsiteMeasurement: result.NeedsOnsiteMeasurement,
		Discrepancies:          result.Discrepancies,
		ExtractedText:          result.ExtractedText,
		SuggestedSearchTerms:   result.SuggestedSearchTerms,
	})
	if dbErr != nil {
		log.Printf("warning: failed to persist photo analysis for lead %s service %s: %v", leadID, serviceID, dbErr)
	}
}

func (h *PhotoAnalysisHandler) writePhotoAnalysisTimeline(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, result *agent.PhotoAnalysis, attachments []repository.Attachment) {
	summary := result.Summary
	if len(result.Observations) > 0 && summary == "" {
		summary = result.Observations[0]
	}

	metadata := buildPhotoAnalysisMetadata(result, attachments)
	_, _ = h.repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &serviceID,
		OrganizationID: tenantID,
		ActorType:      "AI",
		ActorName:      "Foto-analyse Agent",
		EventType:      "photo_analysis_completed",
		Title:          "Foto-analyse voltooid",
		Summary:        &summary,
		Metadata:       metadata,
	})
}

func buildPhotoAnalysisMetadata(result *agent.PhotoAnalysis, attachments []repository.Attachment) map[string]any {
	metadata := buildPhotoAnalysisBaseMetadata(result)
	addPhotoAnalysisSlices(metadata, result)
	addPhotoAttachmentMetadata(metadata, attachments)
	return metadata
}

func buildPhotoAnalysisBaseMetadata(result *agent.PhotoAnalysis) map[string]any {
	return map[string]any{
		"photoCount":      result.PhotoCount,
		"scopeAssessment": result.ScopeAssessment,
		"confidenceLevel": result.ConfidenceLevel,
		"observations":    result.Observations,
		"costIndicators":  result.CostIndicators,
	}
}

func addPhotoAnalysisSlices(metadata map[string]any, result *agent.PhotoAnalysis) {
	if len(result.SafetyConcerns) > 0 {
		metadata["safetyConcerns"] = result.SafetyConcerns
	}
	if len(result.AdditionalInfo) > 0 {
		metadata["additionalInfo"] = result.AdditionalInfo
	}
	if len(result.Measurements) > 0 {
		metadata["measurements"] = result.Measurements
	}
	if len(result.NeedsOnsiteMeasurement) > 0 {
		metadata["needsOnsiteMeasurement"] = result.NeedsOnsiteMeasurement
	}
	if len(result.Discrepancies) > 0 {
		metadata["discrepancies"] = result.Discrepancies
	}
	if len(result.ExtractedText) > 0 {
		metadata["extractedText"] = result.ExtractedText
	}
	if len(result.SuggestedSearchTerms) > 0 {
		metadata["suggestedSearchTerms"] = result.SuggestedSearchTerms
	}
}

func addPhotoAttachmentMetadata(metadata map[string]any, attachments []repository.Attachment) {
	if len(attachments) == 0 {
		return
	}
	photoAttachments := buildPhotoAttachments(attachments)
	if len(photoAttachments) > 0 {
		metadata["photos"] = photoAttachments
	}
}

func buildPhotoAttachments(attachments []repository.Attachment) []map[string]any {
	photoAttachments := make([]map[string]any, 0, len(attachments))
	for _, att := range attachments {
		if att.ContentType != nil && isImageContentType(*att.ContentType) {
			photoInfo := map[string]any{
				"id":       att.ID.String(),
				"fileName": att.FileName,
			}
			if att.ContentType != nil {
				photoInfo["contentType"] = *att.ContentType
			}
			photoAttachments = append(photoAttachments, photoInfo)
		}
	}
	return photoAttachments
}

func (h *PhotoAnalysisHandler) publishPhotoAnalysisSuccess(userID *uuid.UUID, leadID, serviceID uuid.UUID, result *agent.PhotoAnalysis) {
	if userID == nil {
		return
	}
	h.sse.Publish(*userID, sse.Event{
		Type:      sse.EventPhotoAnalysisComplete,
		LeadID:    leadID,
		ServiceID: serviceID,
		Message:   "Foto-analyse voltooid",
		Data: gin.H{
			"success":  true,
			"analysis": result,
		},
	})
}

// GetPhotoAnalysis retrieves the latest photo analysis for a service.
func (h *PhotoAnalysisHandler) GetPhotoAnalysis(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, errTenantContextRequired, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, errInvalidServiceID, nil)
		return
	}

	analysis, err := h.repo.GetLatestPhotoAnalysis(c.Request.Context(), serviceID, *tenantID)
	if err == repository.ErrPhotoAnalysisNotFound {
		httpkit.OK(c, gin.H{"analysis": nil})
		return
	}
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to fetch photo analysis", nil)
		return
	}

	httpkit.OK(c, gin.H{"analysis": analysis})
}

// ListPhotoAnalyses retrieves all photo analyses for a service.
func (h *PhotoAnalysisHandler) ListPhotoAnalyses(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, errTenantContextRequired, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, errInvalidServiceID, nil)
		return
	}

	analyses, err := h.repo.ListPhotoAnalysesByService(c.Request.Context(), serviceID, *tenantID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "failed to fetch photo analyses", nil)
		return
	}

	httpkit.OK(c, gin.H{"items": analyses})
}

// isImageContentType checks if a content type is an image type supported by Kimi
func isImageContentType(contentType string) bool {
	switch contentType {
	case "image/jpeg", "image/jpg", "image/png", "image/webp", "image/gif":
		return true
	default:
		return false
	}
}
</file>

<file path="internal/partners/service/offer_service.go">
package service

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/partners/repository"
	"portal_final_backend/internal/partners/transport"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/sanitize"

	"github.com/google/uuid"
)

type OfferSummaryItem struct {
	Description string
	Quantity    string
}

// OfferSummaryInput defines the fields sent to the summary generator (no PII).
type OfferSummaryInput struct {
	LeadID        uuid.UUID
	LeadServiceID uuid.UUID
	ServiceType   string
	Scope         *string
	UrgencyLevel  *string
	Items         []OfferSummaryItem
}

// OfferSummaryGenerator generates a markdown summary for partner offers.
type OfferSummaryGenerator interface {
	GenerateSummary(ctx context.Context, tenantID uuid.UUID, input OfferSummaryInput) (string, error)
}

const (
	offerTokenBytes = 32
	// platformFeeMultiplier: vakman receives 90% of customer price (10% platform fee).
	platformFeeMultiplier = 0.90
)

// CreateOffer generates a new job offer for a vakman based on customer pricing.
func (s *Service) CreateOffer(ctx context.Context, tenantID uuid.UUID, req transport.CreateOfferRequest) (transport.CreateOfferResponse, error) {
	partner, err := s.repo.GetByID(ctx, req.PartnerID, tenantID)
	if err != nil {
		return transport.CreateOfferResponse{}, err
	}

	serviceCtx, err := s.resolveOfferContext(ctx, tenantID, req.LeadServiceID)
	if err != nil {
		return transport.CreateOfferResponse{}, err
	}

	if err := s.ensureOfferAvailable(ctx, req.LeadServiceID); err != nil {
		return transport.CreateOfferResponse{}, err
	}

	rawToken, err := token.GenerateRandomToken(offerTokenBytes)
	if err != nil {
		return transport.CreateOfferResponse{}, err
	}

	vakmanPrice := calculateVakmanPrice(req.CustomerPriceCents)
	expiry := time.Now().UTC().Add(time.Duration(req.ExpiresInHours) * time.Hour)
	items := s.fetchOfferItems(ctx, req.LeadServiceID, tenantID)

	scopeAssessment := buildScopeAssessment(items)
	builderSummaryPtr := s.resolveBuilderSummary(ctx, tenantID, items, scopeAssessment, serviceCtx, req.LeadServiceID)
	jobSummaryPtr := sanitizeJobSummary(req.JobSummaryShort)

	offer, err := s.repo.CreateOffer(ctx, repository.PartnerOffer{
		OrganizationID:     tenantID,
		PartnerID:          req.PartnerID,
		LeadServiceID:      req.LeadServiceID,
		PublicToken:        rawToken,
		ExpiresAt:          expiry,
		PricingSource:      req.PricingSource,
		CustomerPriceCents: req.CustomerPriceCents,
		VakmanPriceCents:   vakmanPrice,
		JobSummaryShort:    jobSummaryPtr,
		BuilderSummary:     builderSummaryPtr,
	})
	if err != nil {
		return transport.CreateOfferResponse{}, err
	}

	s.publishOfferCreated(ctx, offerCreatedParams{
		offerID:       offer.ID,
		tenantID:      tenantID,
		partnerID:     req.PartnerID,
		leadServiceID: req.LeadServiceID,
		leadID:        serviceCtx.LeadID,
		vakmanPrice:   vakmanPrice,
		rawToken:      rawToken,
		partner:       partner,
	})

	return transport.CreateOfferResponse{
		ID:               offer.ID,
		PublicToken:      rawToken,
		VakmanPriceCents: vakmanPrice,
		ExpiresAt:        expiry,
	}, nil
}

// GetPublicOffer retrieves offer details for the vakman-facing view.
// Only exposes the vakman's price  customer markup is never served.
func (s *Service) GetPublicOffer(ctx context.Context, publicToken string) (transport.PublicOfferResponse, error) {
	oc, err := s.repo.GetOfferByToken(ctx, publicToken)
	if err != nil {
		return transport.PublicOfferResponse{}, err
	}

	items, itemsErr := s.repo.GetLatestQuoteItemsForService(ctx, oc.LeadServiceID, oc.OrganizationID)
	if itemsErr != nil {
		items = nil
	}
	scopeAssessment := buildScopeAssessment(items)
	builderSummary := oc.BuilderSummary
	if builderSummary == nil {
		builderSummary = buildBuilderSummary(items, scopeAssessment, oc.UrgencyLevel)
	}

	return transport.PublicOfferResponse{
		OfferID:          oc.ID,
		OrganizationName: oc.OrganizationName,
		JobSummary:       oc.ServiceType,
		JobSummaryShort:  oc.JobSummaryShort,
		BuilderSummary:   builderSummary,
		City:             oc.LeadCity,
		Postcode4:        oc.LeadPostcode4,
		Buurtcode:        oc.LeadBuurtcode,
		ConstructionYear: oc.LeadEnergyBouwjaar,
		ScopeAssessment:  scopeAssessment,
		UrgencyLevel:     oc.UrgencyLevel,
		VakmanPriceCents: oc.VakmanPriceCents,
		PricingSource:    oc.PricingSource,
		Status:           oc.Status,
		ExpiresAt:        oc.ExpiresAt,
		CreatedAt:        oc.CreatedAt,
	}, nil
}

// AcceptOffer processes a vakman's acceptance, locks the job via the unique index.
func (s *Service) AcceptOffer(ctx context.Context, publicToken string, req transport.AcceptOfferRequest) error {
	oc, err := s.repo.GetOfferByToken(ctx, publicToken)
	if err != nil {
		return err
	}

	// Validation
	if time.Now().After(oc.ExpiresAt) {
		return apperr.Gone("this offer has expired")
	}
	if oc.Status != "pending" && oc.Status != "sent" {
		return apperr.Conflict("offer cannot be accepted in current state")
	}

	// Serialize availability slots
	inspectionJSON, err := json.Marshal(req.InspectionSlots)
	if err != nil {
		return apperr.Validation("invalid inspection slots")
	}

	var jobJSON []byte
	if len(req.JobSlots) > 0 {
		jobJSON, err = json.Marshal(req.JobSlots)
		if err != nil {
			return apperr.Validation("invalid job slots")
		}
	}

	// Atomic update (unique index enforces exclusivity)
	if err := s.repo.AcceptOffer(ctx, oc.ID, inspectionJSON, jobJSON); err != nil {
		return err
	}

	// Resolve lead ID for timeline/notification handlers
	leadID, _ := s.repo.GetLeadIDForService(ctx, oc.LeadServiceID, oc.OrganizationID)

	// Resolve partner details for confirmation
	var partnerEmail string
	var partnerPhone string
	if partner, pErr := s.repo.GetByID(ctx, oc.PartnerID, oc.OrganizationID); pErr == nil {
		partnerEmail = partner.ContactEmail
		partnerPhone = partner.ContactPhone
	}

	// Publish event
	s.eventBus.Publish(ctx, events.PartnerOfferAccepted{
		BaseEvent:      events.NewBaseEvent(),
		OfferID:        oc.ID,
		OrganizationID: oc.OrganizationID,
		PartnerID:      oc.PartnerID,
		LeadServiceID:  oc.LeadServiceID,
		LeadID:         leadID,
		PartnerName:    oc.PartnerName,
		PartnerEmail:   partnerEmail,
		PartnerPhone:   partnerPhone,
	})

	return nil
}

// RejectOffer processes a vakman's rejection of an offer.
func (s *Service) RejectOffer(ctx context.Context, publicToken string, req transport.RejectOfferRequest) error {
	oc, err := s.repo.GetOfferByToken(ctx, publicToken)
	if err != nil {
		return err
	}

	if oc.Status != "pending" && oc.Status != "sent" {
		return apperr.Conflict("offer cannot be rejected in current state")
	}

	if err := s.repo.RejectOffer(ctx, oc.ID, req.Reason); err != nil {
		return err
	}

	// Resolve lead ID for timeline/notification handlers
	leadID, _ := s.repo.GetLeadIDForService(ctx, oc.LeadServiceID, oc.OrganizationID)

	s.eventBus.Publish(ctx, events.PartnerOfferRejected{
		BaseEvent:      events.NewBaseEvent(),
		OfferID:        oc.ID,
		OrganizationID: oc.OrganizationID,
		PartnerID:      oc.PartnerID,
		LeadServiceID:  oc.LeadServiceID,
		LeadID:         leadID,
		PartnerName:    oc.PartnerName,
		Reason:         req.Reason,
	})

	return nil
}

// GetOfferPreview returns the same vakman-facing view but requires authentication.
// This lets admin users preview what the vakman sees.
func (s *Service) GetOfferPreview(ctx context.Context, tenantID uuid.UUID, offerID uuid.UUID) (transport.PublicOfferResponse, error) {
	oc, err := s.repo.GetOfferByIDWithContext(ctx, offerID, tenantID)
	if err != nil {
		return transport.PublicOfferResponse{}, err
	}

	items, itemsErr := s.repo.GetLatestQuoteItemsForService(ctx, oc.LeadServiceID, oc.OrganizationID)
	if itemsErr != nil {
		items = nil
	}
	scopeAssessment := buildScopeAssessment(items)
	builderSummary := oc.BuilderSummary
	if builderSummary == nil {
		builderSummary = buildBuilderSummary(items, scopeAssessment, oc.UrgencyLevel)
	}

	return transport.PublicOfferResponse{
		OfferID:          oc.ID,
		OrganizationName: oc.OrganizationName,
		JobSummary:       oc.ServiceType,
		JobSummaryShort:  oc.JobSummaryShort,
		BuilderSummary:   builderSummary,
		City:             oc.LeadCity,
		Postcode4:        oc.LeadPostcode4,
		Buurtcode:        oc.LeadBuurtcode,
		ConstructionYear: oc.LeadEnergyBouwjaar,
		ScopeAssessment:  scopeAssessment,
		UrgencyLevel:     oc.UrgencyLevel,
		VakmanPriceCents: oc.VakmanPriceCents,
		PricingSource:    oc.PricingSource,
		Status:           oc.Status,
		ExpiresAt:        oc.ExpiresAt,
		CreatedAt:        oc.CreatedAt,
	}, nil
}

func buildBuilderSummary(items []repository.QuoteItemSummary, scopeAssessment *string, urgencyLevel *string) *string {
	if len(items) == 0 {
		return nil
	}

	lines := buildSummaryHeader(scopeAssessment, urgencyLevel)
	lines = append(lines, buildSummaryItems(items)...)
	if len(lines) == 0 {
		return nil
	}

	result := strings.Join(lines, "\n")
	return &result
}

func (s *Service) resolveOfferContext(ctx context.Context, tenantID, leadServiceID uuid.UUID) (repository.LeadServiceSummaryContext, error) {
	if err := s.ensureLeadServiceExists(ctx, tenantID, leadServiceID); err != nil {
		return repository.LeadServiceSummaryContext{}, err
	}
	return s.repo.GetLeadServiceSummaryContext(ctx, leadServiceID, tenantID)
}

func (s *Service) ensureOfferAvailable(ctx context.Context, leadServiceID uuid.UUID) error {
	hasActive, err := s.repo.HasActiveOffer(ctx, leadServiceID)
	if err != nil {
		return err
	}
	if hasActive {
		return apperr.Conflict("an active offer already exists for this service")
	}
	return nil
}

func (s *Service) fetchOfferItems(ctx context.Context, leadServiceID, tenantID uuid.UUID) []repository.QuoteItemSummary {
	items, err := s.repo.GetLatestQuoteItemsForService(ctx, leadServiceID, tenantID)
	if err != nil {
		return nil
	}
	return items
}

func (s *Service) resolveBuilderSummary(ctx context.Context, tenantID uuid.UUID, items []repository.QuoteItemSummary, scopeAssessment *string, serviceCtx repository.LeadServiceSummaryContext, leadServiceID uuid.UUID) *string {
	if s.summaryGenerator != nil && len(items) > 0 {
		inputItems := make([]OfferSummaryItem, 0, len(items))
		for _, it := range items {
			inputItems = append(inputItems, OfferSummaryItem{
				Description: it.Description,
				Quantity:    it.Quantity,
			})
		}
		summary, err := s.summaryGenerator.GenerateSummary(ctx, tenantID, OfferSummaryInput{
			LeadID:        serviceCtx.LeadID,
			LeadServiceID: leadServiceID,
			ServiceType:   serviceCtx.ServiceType,
			Scope:         scopeAssessment,
			UrgencyLevel:  serviceCtx.UrgencyLevel,
			Items:         inputItems,
		})
		if err == nil {
			clean := strings.TrimSpace(sanitize.Text(summary))
			if clean != "" {
				return &clean
			}
		}
	}

	return buildBuilderSummary(items, scopeAssessment, serviceCtx.UrgencyLevel)
}

func sanitizeJobSummary(value string) *string {
	jobSummary := strings.TrimSpace(value)
	jobSummary = sanitize.Text(jobSummary)
	if jobSummary == "" {
		return nil
	}
	return &jobSummary
}

type offerCreatedParams struct {
	offerID       uuid.UUID
	tenantID      uuid.UUID
	partnerID     uuid.UUID
	leadServiceID uuid.UUID
	leadID        uuid.UUID
	vakmanPrice   int64
	rawToken      string
	partner       repository.Partner
}

func (s *Service) publishOfferCreated(ctx context.Context, params offerCreatedParams) {
	if s.eventBus == nil {
		return
	}
	s.eventBus.Publish(ctx, events.PartnerOfferCreated{
		BaseEvent:        events.NewBaseEvent(),
		OfferID:          params.offerID,
		OrganizationID:   params.tenantID,
		PartnerID:        params.partnerID,
		LeadServiceID:    params.leadServiceID,
		LeadID:           params.leadID,
		VakmanPriceCents: params.vakmanPrice,
		PublicToken:      params.rawToken,
		PartnerName:      params.partner.BusinessName,
		PartnerPhone:     params.partner.ContactPhone,
	})
}

func buildSummaryHeader(scopeAssessment *string, urgencyLevel *string) []string {
	scopeLabel := mapScopeLabel(scopeAssessment)
	urgencyLabel := mapUrgencyLabel(urgencyLevel)
	if scopeLabel == "" && urgencyLabel == "" {
		return nil
	}
	if scopeLabel == "" {
		scopeLabel = "Onbekend"
	}
	if urgencyLabel == "" {
		urgencyLabel = "Onbekend"
	}

	return []string{
		fmt.Sprintf("**Omvang** %s  **Urgentie** %s", scopeLabel, urgencyLabel),
		"",
	}
}

func buildSummaryItems(items []repository.QuoteItemSummary) []string {
	const maxItems = 3
	remaining := len(items) - maxItems
	if remaining < 0 {
		remaining = 0
	}

	lines := make([]string, 0, len(items))
	for i, it := range items {
		if i >= maxItems {
			break
		}
		main, inclusions := buildSummaryItem(it, remaining > 0 && i == maxItems-1, remaining)
		if main == "" {
			continue
		}
		lines = append(lines, fmt.Sprintf("%d. %s", i+1, main))
		for _, inc := range inclusions {
			lines = append(lines, "   - "+inc)
		}
	}

	return lines
}

func buildSummaryItem(item repository.QuoteItemSummary, isLast bool, remaining int) (string, []string) {
	quantity := strings.TrimSpace(item.Quantity)
	main, inclusions := splitInclusions(item.Description)
	main = strings.TrimSpace(main)
	if main == "" {
		return "", nil
	}
	if quantity != "" {
		main = strings.TrimSpace(quantity + " " + main)
	}
	if len(inclusions) > 0 {
		main += " Inclusief:"
	}
	if isLast {
		main = fmt.Sprintf("%s (+%d)", main, remaining)
	}

	return main, inclusions
}

func buildScopeAssessment(items []repository.QuoteItemSummary) *string {
	count := len(items)
	if count == 0 {
		return nil
	}
	var scope string
	switch {
	case count <= 2:
		scope = "Small"
	case count <= 5:
		scope = "Medium"
	default:
		scope = "Large"
	}
	return &scope
}

func mapScopeLabel(scope *string) string {
	if scope == nil {
		return ""
	}
	switch strings.ToLower(strings.TrimSpace(*scope)) {
	case "small":
		return "Klein"
	case "medium":
		return "Middel"
	case "large":
		return "Groot"
	default:
		return ""
	}
}

func mapUrgencyLabel(level *string) string {
	if level == nil {
		return ""
	}
	switch strings.ToLower(strings.TrimSpace(*level)) {
	case "low":
		return "Laag"
	case "medium":
		return "Gemiddeld"
	case "high":
		return "Hoog"
	default:
		return ""
	}
}

func splitInclusions(description string) (string, []string) {
	parts := strings.SplitN(description, "Inclusief:", 2)
	main := strings.TrimSpace(parts[0])
	if len(parts) < 2 {
		return main, nil
	}

	return main, parseInclusionList(parts[1])
}

func parseInclusionList(value string) []string {
	cleaned := strings.ReplaceAll(value, "\n\n", "\n")
	cleaned = strings.ReplaceAll(cleaned, " - ", "\n- ")
	lines := strings.Split(cleaned, "\n")

	items := make([]string, 0, len(lines))
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "-") {
			line = strings.TrimSpace(strings.TrimPrefix(line, "-"))
		}
		if line != "" {
			items = append(items, line)
		}
	}

	return items
}

// ListOffersByPartner returns all offers for a given partner (admin view).
func (s *Service) ListOffersByPartner(ctx context.Context, tenantID uuid.UUID, partnerID uuid.UUID) (transport.ListOffersResponse, error) {
	if err := s.ensurePartnerExists(ctx, tenantID, partnerID); err != nil {
		return transport.ListOffersResponse{}, err
	}

	offers, err := s.repo.ListOffersByPartner(ctx, partnerID, tenantID)
	if err != nil {
		return transport.ListOffersResponse{}, err
	}

	items := make([]transport.OfferResponse, 0, len(offers))
	for _, o := range offers {
		items = append(items, mapOfferResponse(o))
	}

	return transport.ListOffersResponse{Items: items}, nil
}

// ListOffersForService returns all offers for a given lead service (admin view).
func (s *Service) ListOffersForService(ctx context.Context, tenantID uuid.UUID, leadServiceID uuid.UUID) (transport.ListOffersResponse, error) {
	offers, err := s.repo.ListOffersForService(ctx, leadServiceID, tenantID)
	if err != nil {
		return transport.ListOffersResponse{}, err
	}

	items := make([]transport.OfferResponse, 0, len(offers))
	for _, o := range offers {
		items = append(items, mapOfferResponse(o))
	}

	return transport.ListOffersResponse{Items: items}, nil
}

// ExpireOffers is called by a background job to expire stale offers.
func (s *Service) ExpireOffers(ctx context.Context) (int, error) {
	expired, err := s.repo.ExpireOffers(ctx)
	if err != nil {
		return 0, err
	}

	for _, o := range expired {
		// Resolve lead ID and partner name for timeline handlers
		leadID, _ := s.repo.GetLeadIDForService(ctx, o.LeadServiceID, o.OrganizationID)
		var partnerName string
		if p, err := s.repo.GetByID(ctx, o.PartnerID, o.OrganizationID); err == nil {
			partnerName = p.BusinessName
		}

		s.eventBus.Publish(ctx, events.PartnerOfferExpired{
			BaseEvent:      events.NewBaseEvent(),
			OfferID:        o.ID,
			OrganizationID: o.OrganizationID,
			PartnerID:      o.PartnerID,
			LeadServiceID:  o.LeadServiceID,
			LeadID:         leadID,
			PartnerName:    partnerName,
		})
	}

	return len(expired), nil
}

func mapOfferResponse(oc repository.PartnerOfferWithContext) transport.OfferResponse {
	resp := transport.OfferResponse{
		ID:                 oc.ID,
		PartnerID:          oc.PartnerID,
		PartnerName:        oc.PartnerName,
		LeadServiceID:      oc.LeadServiceID,
		PricingSource:      oc.PricingSource,
		CustomerPriceCents: oc.CustomerPriceCents,
		VakmanPriceCents:   oc.VakmanPriceCents,
		Status:             oc.Status,
		PublicToken:        oc.PublicToken,
		ExpiresAt:          oc.ExpiresAt,
		AcceptedAt:         oc.AcceptedAt,
		RejectedAt:         oc.RejectedAt,
		CreatedAt:          oc.CreatedAt,
	}
	if oc.RejectionReason != nil {
		resp.RejectionReason = *oc.RejectionReason
	}
	return resp
}

func calculateVakmanPrice(customerPriceCents int64) int64 {
	return int64(float64(customerPriceCents) * platformFeeMultiplier)
}
</file>

<file path="internal/appointments/service/service.go">
package service

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"portal_final_backend/internal/appointments/repository"
	"portal_final_backend/internal/appointments/transport"
	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/internal/scheduler"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/sanitize"

	"github.com/google/uuid"
)

// Date/time format and error message constants.
const (
	dateFormat           = "2006-01-02"
	errEndTimeAfterStart = "endTime must be after startTime"
)

// LeadAssigner provides minimal lead assignment capabilities for lead visits.
type LeadAssigner interface {
	GetAssignedAgentID(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) (*uuid.UUID, error)
	AssignLead(ctx context.Context, leadID uuid.UUID, agentID uuid.UUID, tenantID uuid.UUID) error
}

// Service provides business logic for appointments
type Service struct {
	repo              *repository.Repository
	leadAssigner      LeadAssigner
	emailSender       email.Sender
	sseService        *sse.Service
	eventBus          events.Bus
	reminderScheduler scheduler.ReminderScheduler
}

// New creates a new appointments service
func New(repo *repository.Repository, leadAssigner LeadAssigner, emailSender email.Sender, eventBus events.Bus, reminderScheduler scheduler.ReminderScheduler) *Service {
	return &Service{
		repo:              repo,
		leadAssigner:      leadAssigner,
		emailSender:       emailSender,
		eventBus:          eventBus,
		reminderScheduler: reminderScheduler,
	}
}

// SetSSE sets the SSE service for real-time event broadcasting.
func (s *Service) SetSSE(sseService *sse.Service) {
	s.sseService = sseService
}

// GetNextScheduledVisit returns the next upcoming scheduled lead visit for a lead.
func (s *Service) GetNextScheduledVisit(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) (*repository.Appointment, error) {
	return s.repo.GetNextScheduledVisit(ctx, leadID, tenantID)
}

// GetNextRequestedVisit returns the next upcoming requested lead visit for a lead.
func (s *Service) GetNextRequestedVisit(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) (*repository.Appointment, error) {
	return s.repo.GetNextRequestedVisit(ctx, leadID, tenantID)
}

// ListLeadVisitsByStatus returns lead visit appointments matching the provided statuses.
func (s *Service) ListLeadVisitsByStatus(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID, statuses []transport.AppointmentStatus) ([]repository.Appointment, error) {
	if len(statuses) == 0 {
		return []repository.Appointment{}, nil
	}

	statusValues := make([]string, 0, len(statuses))
	for _, status := range statuses {
		statusValues = append(statusValues, string(status))
	}

	return s.repo.ListLeadVisitsByStatus(ctx, leadID, tenantID, statusValues)
}

// publishSSE publishes an SSE event to all org members if the SSE service is available.
func (s *Service) publishSSE(orgID uuid.UUID, event sse.Event) {
	if s.sseService != nil {
		s.sseService.PublishToOrganization(orgID, event)
	}
}

// publishLeadSSE publishes an SSE event to public lead viewers if available.
func (s *Service) publishLeadSSE(leadID *uuid.UUID, event sse.Event) {
	if s.sseService == nil || leadID == nil {
		return
	}
	event.LeadID = *leadID
	s.sseService.PublishToLead(*leadID, event)
}

// Create creates a new appointment
func (s *Service) Create(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.CreateAppointmentRequest) (*transport.AppointmentResponse, error) {
	if err := s.validateLeadVisit(ctx, req, userID, isAdmin, tenantID); err != nil {
		return nil, err
	}

	if !req.EndTime.After(req.StartTime) {
		return nil, apperr.BadRequest(errEndTimeAfterStart)
	}

	if err := s.checkTimeConflict(ctx, tenantID, userID, req.StartTime, req.EndTime, uuid.Nil); err != nil {
		return nil, err
	}

	appt := s.buildAppointment(userID, tenantID, req)
	if err := s.repo.Create(ctx, appt); err != nil {
		return nil, err
	}

	leadInfo := s.getLeadInfoIfPresent(ctx, appt.LeadID, tenantID)
	s.sendConfirmationEmailIfNeeded(ctx, req.SendConfirmationEmail, appt, leadInfo, tenantID)

	resp := appt.ToResponse(leadInfo)

	// Broadcast appointment creation via SSE
	s.publishSSE(tenantID, sse.Event{
		Type:    sse.EventAppointmentCreated,
		Message: fmt.Sprintf("Nieuwe afspraak: %s", appt.Title),
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"title":         appt.Title,
			"type":          appt.Type,
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
			"lead":          leadInfo,
		},
	})

	// Notify public lead tracking page (minimal payload)
	s.publishLeadSSE(appt.LeadID, sse.Event{
		Type: sse.EventAppointmentCreated,
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"status":        string(appt.Status),
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
		},
	})

	if s.eventBus != nil {
		evt := events.AppointmentCreated{
			BaseEvent:      events.NewBaseEvent(),
			AppointmentID:  appt.ID,
			OrganizationID: appt.OrganizationID,
			LeadID:         appt.LeadID,
			LeadServiceID:  appt.LeadServiceID,
			UserID:         appt.UserID,
			Type:           appt.Type,
			Title:          appt.Title,
			StartTime:      appt.StartTime,
			EndTime:        appt.EndTime,
			Location:       getOptionalString(appt.Location),
		}
		if leadInfo != nil {
			evt.ConsumerName = formatConsumerName(leadInfo.FirstName, leadInfo.LastName)
			evt.ConsumerPhone = leadInfo.Phone
		}
		s.eventBus.Publish(ctx, evt)
	}

	if s.reminderScheduler != nil && appt.Type == string(transport.AppointmentTypeLeadVisit) && leadInfo != nil && leadInfo.Phone != "" {
		reminderAt := appt.StartTime.Add(-24 * time.Hour)
		if reminderAt.After(time.Now()) {
			_ = s.reminderScheduler.ScheduleAppointmentReminder(ctx, scheduler.AppointmentReminderPayload{
				AppointmentID:  appt.ID.String(),
				OrganizationID: appt.OrganizationID.String(),
			}, reminderAt)
		}
	}

	return &resp, nil
}

// validateLeadVisit validates lead_visit type requirements.
func (s *Service) validateLeadVisit(ctx context.Context, req transport.CreateAppointmentRequest, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) error {
	if req.Type != transport.AppointmentTypeLeadVisit {
		return nil
	}

	if req.LeadID == nil || req.LeadServiceID == nil {
		return apperr.BadRequest("lead_visit type requires leadId and leadServiceId")
	}
	if s.leadAssigner == nil {
		return apperr.BadRequest("lead assignment not configured")
	}

	assignedAgentID, err := s.leadAssigner.GetAssignedAgentID(ctx, *req.LeadID, tenantID)
	if err != nil {
		return err
	}

	if assignedAgentID != nil && *assignedAgentID != userID && !isAdmin {
		return apperr.Forbidden("not authorized to schedule visits for this lead")
	}
	if assignedAgentID == nil && !isAdmin {
		return s.leadAssigner.AssignLead(ctx, *req.LeadID, userID, tenantID)
	}
	return nil
}

// checkTimeConflict checks for overlapping appointments, excluding excludeID if non-nil.
func (s *Service) checkTimeConflict(ctx context.Context, tenantID, userID uuid.UUID, startTime, endTime time.Time, excludeID uuid.UUID) error {
	existing, err := s.repo.ListForDateRange(ctx, tenantID, userID, startTime, endTime)
	if err != nil {
		return err
	}
	for _, appt := range existing {
		if excludeID != uuid.Nil && appt.ID == excludeID {
			continue
		}
		if startTime.Before(appt.EndTime) && endTime.After(appt.StartTime) {
			return apperr.Conflict("timeslot already booked")
		}
	}
	return nil
}

// buildAppointment creates a new Appointment from the request.
func (s *Service) buildAppointment(userID, tenantID uuid.UUID, req transport.CreateAppointmentRequest) *repository.Appointment {
	now := time.Now()
	return &repository.Appointment{
		ID:             uuid.New(),
		OrganizationID: tenantID,
		UserID:         userID,
		LeadID:         req.LeadID,
		LeadServiceID:  req.LeadServiceID,
		Type:           string(req.Type),
		Title:          sanitize.Text(req.Title),
		Description:    sanitize.TextPtr(nilIfEmpty(req.Description)),
		Location:       nilIfEmpty(req.Location),
		MeetingLink:    sanitize.TextPtr(nilIfEmpty(req.MeetingLink)),
		StartTime:      req.StartTime,
		EndTime:        req.EndTime,
		Status:         string(transport.AppointmentStatusScheduled),
		AllDay:         req.AllDay,
		CreatedAt:      now,
		UpdatedAt:      now,
	}
}

// getLeadInfoIfPresent returns lead info if leadID is not nil.
func (s *Service) getLeadInfoIfPresent(ctx context.Context, leadID *uuid.UUID, tenantID uuid.UUID) *transport.AppointmentLeadInfo {
	if leadID == nil {
		return nil
	}
	return s.getLeadInfo(ctx, *leadID, tenantID)
}

// sendConfirmationEmailIfNeeded sends confirmation email if conditions are met.
func (s *Service) sendConfirmationEmailIfNeeded(ctx context.Context, sendEmail *bool, appt *repository.Appointment, leadInfo *transport.AppointmentLeadInfo, tenantID uuid.UUID) {
	if sendEmail == nil || !*sendEmail || leadInfo == nil || s.emailSender == nil || appt.LeadID == nil {
		return
	}
	if consumerEmail := s.getLeadEmail(ctx, *appt.LeadID, tenantID); consumerEmail != "" {
		scheduledDate := appt.StartTime.Format("Monday, January 2, 2006 at 15:04")
		_ = s.emailSender.SendVisitInviteEmail(ctx, consumerEmail, leadInfo.FirstName, scheduledDate, leadInfo.Address)
	}
}

// GetByID retrieves an appointment by ID
func (s *Service) GetByID(ctx context.Context, id uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) (*transport.AppointmentResponse, error) {
	appt, err := s.ensureAccess(ctx, id, userID, isAdmin, tenantID)
	if err != nil {
		return nil, err
	}

	var leadInfo *transport.AppointmentLeadInfo
	if appt.LeadID != nil {
		leadInfo = s.getLeadInfo(ctx, *appt.LeadID, tenantID)
	}

	resp := appt.ToResponse(leadInfo)
	return &resp, nil
}

// GetByLeadServiceID retrieves the latest non-cancelled appointment for a lead service.
func (s *Service) GetByLeadServiceID(ctx context.Context, leadServiceID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) (*transport.AppointmentResponse, error) {
	appt, err := s.repo.GetByLeadServiceID(ctx, leadServiceID, tenantID)
	if err != nil {
		return nil, err
	}
	if appt == nil {
		return nil, apperr.NotFound("appointment not found")
	}
	if !isAdmin && appt.UserID != userID {
		return nil, apperr.Forbidden("not authorized to access this appointment")
	}

	leadInfo := s.getLeadInfoIfPresent(ctx, appt.LeadID, tenantID)
	resp := appt.ToResponse(leadInfo)
	return &resp, nil
}

// Update updates an appointment
func (s *Service) Update(ctx context.Context, id uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.UpdateAppointmentRequest) (*transport.AppointmentResponse, error) {
	appt, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	if !isAdmin && appt.UserID != userID {
		return nil, apperr.Forbidden("not authorized to update this appointment")
	}

	applyAppointmentUpdates(appt, req)

	if !appt.EndTime.After(appt.StartTime) {
		return nil, apperr.BadRequest(errEndTimeAfterStart)
	}

	if req.StartTime != nil || req.EndTime != nil {
		if err := s.checkTimeConflict(ctx, tenantID, appt.UserID, appt.StartTime, appt.EndTime, appt.ID); err != nil {
			return nil, err
		}
	}

	appt.UpdatedAt = time.Now()
	if err := s.repo.Update(ctx, appt); err != nil {
		return nil, err
	}

	leadInfo := s.getLeadInfoIfPresent(ctx, appt.LeadID, tenantID)
	resp := appt.ToResponse(leadInfo)

	// Broadcast appointment update via SSE
	s.publishSSE(tenantID, sse.Event{
		Type:    sse.EventAppointmentUpdated,
		Message: fmt.Sprintf("Afspraak bijgewerkt: %s", appt.Title),
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"title":         appt.Title,
			"type":          appt.Type,
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
			"lead":          leadInfo,
		},
	})

	// Notify public lead tracking page (minimal payload)
	s.publishLeadSSE(appt.LeadID, sse.Event{
		Type: sse.EventAppointmentUpdated,
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"status":        string(appt.Status),
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
		},
	})

	return &resp, nil
}

// applyAppointmentUpdates applies partial updates from the request to the appointment.
func applyAppointmentUpdates(appt *repository.Appointment, req transport.UpdateAppointmentRequest) {
	if req.Title != nil {
		appt.Title = sanitize.Text(*req.Title)
	}
	if req.Description != nil {
		appt.Description = sanitize.TextPtr(req.Description)
	}
	if req.Location != nil {
		appt.Location = req.Location
	}
	if req.MeetingLink != nil {
		appt.MeetingLink = sanitize.TextPtr(nilIfEmpty(*req.MeetingLink))
	}
	if req.StartTime != nil {
		appt.StartTime = *req.StartTime
	}
	if req.EndTime != nil {
		appt.EndTime = *req.EndTime
	}
	if req.AllDay != nil {
		appt.AllDay = *req.AllDay
	}
}

// UpdateStatus updates the status of an appointment
func (s *Service) UpdateStatus(ctx context.Context, id uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.UpdateAppointmentStatusRequest) (*transport.AppointmentResponse, error) {
	appt, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	// Check ownership (admin can update any)
	if !isAdmin && appt.UserID != userID {
		return nil, apperr.Forbidden("not authorized to update this appointment")
	}

	if err := s.repo.UpdateStatus(ctx, id, tenantID, string(req.Status)); err != nil {
		return nil, err
	}

	// Refetch to get updated data
	appt, err = s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	var leadInfo *transport.AppointmentLeadInfo
	if appt.LeadID != nil {
		leadInfo = s.getLeadInfo(ctx, *appt.LeadID, tenantID)
	}

	resp := appt.ToResponse(leadInfo)

	// Broadcast status change via SSE
	s.publishSSE(tenantID, sse.Event{
		Type:    sse.EventAppointmentStatusChanged,
		Message: fmt.Sprintf("Afspraak status: %s  %s", appt.Title, req.Status),
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"title":         appt.Title,
			"type":          appt.Type,
			"status":        string(req.Status),
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
			"lead":          leadInfo,
		},
	})

	// Notify public lead tracking page (minimal payload)
	s.publishLeadSSE(appt.LeadID, sse.Event{
		Type: sse.EventAppointmentStatusChanged,
		Data: map[string]interface{}{
			"appointmentId": appt.ID,
			"status":        string(req.Status),
			"startTime":     appt.StartTime,
			"endTime":       appt.EndTime,
		},
	})

	return &resp, nil
}

// Delete removes an appointment
func (s *Service) Delete(ctx context.Context, id uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) error {
	appt, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return err
	}

	// Check ownership (admin can delete any)
	if !isAdmin && appt.UserID != userID {
		return apperr.Forbidden("not authorized to delete this appointment")
	}

	return s.repo.Delete(ctx, id, tenantID)
}

// List retrieves appointments with filtering
func (s *Service) List(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.ListAppointmentsRequest) (*transport.AppointmentListResponse, error) {
	filters, err := parseListFilters(req)
	if err != nil {
		return nil, err
	}

	params := buildListParams(tenantID, req, filters, userID, isAdmin)
	result, err := s.repo.List(ctx, params)
	if err != nil {
		return nil, err
	}

	return s.buildListResponse(ctx, result, tenantID)
}

type listFilterValues struct {
	leadID    *uuid.UUID
	reqUserID *uuid.UUID
	startFrom *time.Time
	startTo   *time.Time
}

func parseListFilters(req transport.ListAppointmentsRequest) (listFilterValues, error) {
	leadID, err := parseUUIDFilter(req.LeadID, "leadId")
	if err != nil {
		return listFilterValues{}, err
	}
	reqUserID, err := parseUUIDFilter(req.UserID, "userId")
	if err != nil {
		return listFilterValues{}, err
	}

	startFrom, err := parseDateFilter(req.StartFrom, "startFrom")
	if err != nil {
		return listFilterValues{}, err
	}
	startTo, err := parseDateFilter(req.StartTo, "startTo")
	if err != nil {
		return listFilterValues{}, err
	}
	if startTo != nil {
		endOfDay := startTo.Add(24*time.Hour - time.Nanosecond)
		startTo = &endOfDay
	}

	return listFilterValues{
		leadID:    leadID,
		reqUserID: reqUserID,
		startFrom: startFrom,
		startTo:   startTo,
	}, nil
}

func buildListParams(tenantID uuid.UUID, req transport.ListAppointmentsRequest, filters listFilterValues, userID uuid.UUID, isAdmin bool) repository.ListParams {
	params := repository.ListParams{
		OrganizationID: tenantID,
		LeadID:         filters.leadID,
		Page:           max(req.Page, 1),
		PageSize:       clampPageSize(req.PageSize),
		Search:         req.Search,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
		StartFrom:      filters.startFrom,
		StartTo:        filters.startTo,
	}

	params.UserID = resolveUserIDFilter(userID, isAdmin, filters.reqUserID)

	if req.Type != nil {
		t := string(*req.Type)
		params.Type = &t
	}
	if req.Status != nil {
		st := string(*req.Status)
		params.Status = &st
	}

	return params
}

// resolveUserIDFilter determines which user to filter by based on admin status.
func resolveUserIDFilter(currentUser uuid.UUID, isAdmin bool, requestedUser *uuid.UUID) *uuid.UUID {
	if !isAdmin {
		return &currentUser // Non-admins can only see own appointments
	}
	return requestedUser // Admins can filter by any user (or nil for all)
}

// clampPageSize ensures page size is within valid range.
func clampPageSize(size int) int {
	if size < 1 || size > 100 {
		return 50
	}
	return size
}

// buildListResponse converts repository results to transport response.
func (s *Service) buildListResponse(ctx context.Context, result *repository.ListResult, tenantID uuid.UUID) (*transport.AppointmentListResponse, error) {
	// Build lead ID list for batch fetching
	leadIDs := make([]uuid.UUID, 0, len(result.Items))
	for _, appt := range result.Items {
		if appt.LeadID != nil {
			leadIDs = append(leadIDs, *appt.LeadID)
		}
	}

	// Batch fetch lead info
	leadInfoMap, err := s.repo.GetLeadInfoBatch(ctx, leadIDs, tenantID)
	if err != nil {
		return nil, err
	}

	// Convert to responses
	items := make([]transport.AppointmentResponse, len(result.Items))
	for i, appt := range result.Items {
		leadInfo := buildLeadInfo(appt.LeadID, leadInfoMap)
		items[i] = appt.ToResponse(leadInfo)
	}

	return &transport.AppointmentListResponse{
		Items:      items,
		Total:      result.Total,
		Page:       result.Page,
		PageSize:   result.PageSize,
		TotalPages: result.TotalPages,
	}, nil
}

// buildLeadInfo constructs lead info from the map if available.
func buildLeadInfo(leadID *uuid.UUID, leadInfoMap map[uuid.UUID]*repository.LeadInfo) *transport.AppointmentLeadInfo {
	if leadID == nil {
		return nil
	}
	info, ok := leadInfoMap[*leadID]
	if !ok || info == nil {
		return nil
	}
	return &transport.AppointmentLeadInfo{
		ID:        info.ID,
		FirstName: info.FirstName,
		LastName:  info.LastName,
		Phone:     info.Phone,
		Address:   fmt.Sprintf("%s %s, %s", info.Street, info.HouseNumber, info.City),
	}
}

// Visit reports
func (s *Service) GetVisitReport(ctx context.Context, appointmentID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) (*transport.AppointmentVisitReportResponse, error) {
	if _, err := s.ensureAccess(ctx, appointmentID, userID, isAdmin, tenantID); err != nil {
		return nil, err
	}

	report, err := s.repo.GetVisitReport(ctx, appointmentID, tenantID)
	if err != nil {
		return nil, err
	}

	return &transport.AppointmentVisitReportResponse{
		AppointmentID:    report.AppointmentID,
		Measurements:     report.Measurements,
		AccessDifficulty: toAccessDifficulty(report.AccessDifficulty),
		Notes:            report.Notes,
		CreatedAt:        report.CreatedAt,
		UpdatedAt:        report.UpdatedAt,
	}, nil
}

func (s *Service) UpsertVisitReport(ctx context.Context, appointmentID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.UpsertVisitReportRequest) (*transport.AppointmentVisitReportResponse, error) {
	if _, err := s.ensureAccess(ctx, appointmentID, userID, isAdmin, tenantID); err != nil {
		return nil, err
	}

	existing, _ := s.repo.GetVisitReport(ctx, appointmentID, tenantID)
	measurements := mergeString(existing, func(r *repository.VisitReport) *string { return r.Measurements }, sanitize.TextPtr(req.Measurements))
	accessDifficulty := mergeString(existing, func(r *repository.VisitReport) *string { return r.AccessDifficulty }, toAccessDifficultyString(req.AccessDifficulty))
	notes := mergeString(existing, func(r *repository.VisitReport) *string { return r.Notes }, sanitize.TextPtr(req.Notes))

	saved, err := s.repo.UpsertVisitReport(ctx, repository.VisitReport{
		AppointmentID:    appointmentID,
		OrganizationID:   tenantID,
		Measurements:     measurements,
		AccessDifficulty: accessDifficulty,
		Notes:            notes,
	})
	if err != nil {
		return nil, err
	}

	return &transport.AppointmentVisitReportResponse{
		AppointmentID:    saved.AppointmentID,
		Measurements:     saved.Measurements,
		AccessDifficulty: toAccessDifficulty(saved.AccessDifficulty),
		Notes:            saved.Notes,
		CreatedAt:        saved.CreatedAt,
		UpdatedAt:        saved.UpdatedAt,
	}, nil
}

// Attachments
func (s *Service) CreateAttachment(ctx context.Context, appointmentID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.CreateAppointmentAttachmentRequest) (*transport.AppointmentAttachmentResponse, error) {
	if _, err := s.ensureAccess(ctx, appointmentID, userID, isAdmin, tenantID); err != nil {
		return nil, err
	}

	attachment := repository.AppointmentAttachment{
		ID:             uuid.New(),
		AppointmentID:  appointmentID,
		OrganizationID: tenantID,
		FileKey:        req.FileKey,
		FileName:       req.FileName,
		ContentType:    req.ContentType,
		SizeBytes:      req.SizeBytes,
	}

	saved, err := s.repo.CreateAttachment(ctx, attachment)
	if err != nil {
		return nil, err
	}

	return &transport.AppointmentAttachmentResponse{
		ID:            saved.ID,
		AppointmentID: saved.AppointmentID,
		FileKey:       saved.FileKey,
		FileName:      saved.FileName,
		ContentType:   saved.ContentType,
		SizeBytes:     saved.SizeBytes,
		CreatedAt:     saved.CreatedAt,
	}, nil
}

func (s *Service) ListAttachments(ctx context.Context, appointmentID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) ([]transport.AppointmentAttachmentResponse, error) {
	if _, err := s.ensureAccess(ctx, appointmentID, userID, isAdmin, tenantID); err != nil {
		return nil, err
	}

	items, err := s.repo.ListAttachments(ctx, appointmentID, tenantID)
	if err != nil {
		return nil, err
	}

	resp := make([]transport.AppointmentAttachmentResponse, len(items))
	for i, item := range items {
		resp[i] = transport.AppointmentAttachmentResponse{
			ID:            item.ID,
			AppointmentID: item.AppointmentID,
			FileKey:       item.FileKey,
			FileName:      item.FileName,
			ContentType:   item.ContentType,
			SizeBytes:     item.SizeBytes,
			CreatedAt:     item.CreatedAt,
		}
	}

	return resp, nil
}

// GetAvailableSlots computes available time slots for a user within a date range
func (s *Service) GetAvailableSlots(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.GetAvailableSlotsRequest) (*transport.AvailableSlotsResponse, error) {
	// Parse and validate inputs
	targetUserID, err := s.resolveTargetUserIDFromString(userID, isAdmin, req.UserID)
	if err != nil {
		return nil, err
	}

	startDate, endDate, err := parseAndValidateDateRange(req.StartDate, req.EndDate, 14)
	if err != nil {
		return nil, err
	}

	slotDuration := max(req.SlotDuration, 60)

	// Fetch availability data
	rules, overrideMap, appointments, err := s.fetchAvailabilityData(ctx, tenantID, targetUserID, startDate, endDate)
	if err != nil {
		return nil, err
	}

	// Generate slots for each day
	days := s.generateDaySlots(startDate, endDate, rules, overrideMap, appointments, slotDuration)

	return &transport.AvailableSlotsResponse{Days: days}, nil
}

// parseAndValidateDateRange parses dates and validates the range.
func parseAndValidateDateRange(startStr, endStr string, maxDays int) (time.Time, time.Time, error) {
	startDate, err := time.Parse(dateFormat, startStr)
	if err != nil {
		return time.Time{}, time.Time{}, apperr.BadRequest("invalid startDate format")
	}
	endDate, err := time.Parse(dateFormat, endStr)
	if err != nil {
		return time.Time{}, time.Time{}, apperr.BadRequest("invalid endDate format")
	}
	if endDate.Before(startDate) {
		return time.Time{}, time.Time{}, apperr.BadRequest("endDate must be after startDate")
	}
	if endDate.Sub(startDate).Hours()/24 > float64(maxDays) {
		return time.Time{}, time.Time{}, apperr.BadRequest(fmt.Sprintf("date range cannot exceed %d days", maxDays))
	}
	return startDate, endDate, nil
}

// fetchAvailabilityData fetches rules, overrides, and appointments for slot generation.
func (s *Service) fetchAvailabilityData(ctx context.Context, tenantID, userID uuid.UUID, startDate, endDate time.Time) ([]repository.AvailabilityRule, map[string]*repository.AvailabilityOverride, []repository.Appointment, error) {
	rules, err := s.repo.ListAvailabilityRules(ctx, tenantID, userID)
	if err != nil {
		return nil, nil, nil, err
	}

	overrides, err := s.repo.ListAvailabilityOverrides(ctx, tenantID, userID, &startDate, &endDate)
	if err != nil {
		return nil, nil, nil, err
	}

	overrideMap := make(map[string]*repository.AvailabilityOverride)
	for i := range overrides {
		overrideMap[overrides[i].Date.Format(dateFormat)] = &overrides[i]
	}

	fetchStart := startDate.AddDate(0, 0, -1)
	fetchEnd := endDate.AddDate(0, 0, 2)
	appointments, err := s.repo.ListForDateRange(ctx, tenantID, userID, fetchStart, fetchEnd)
	if err != nil {
		return nil, nil, nil, err
	}

	return rules, overrideMap, appointments, nil
}

// generateDaySlots generates time slots for each day in the range.
func (s *Service) generateDaySlots(startDate, endDate time.Time, rules []repository.AvailabilityRule, overrideMap map[string]*repository.AvailabilityOverride, appointments []repository.Appointment, slotDuration int) []transport.DaySlots {
	var days []transport.DaySlots

	for d := startDate; !d.After(endDate); d = d.AddDate(0, 0, 1) {
		daySlots := s.generateDaySlotsForDate(d, rules, overrideMap, appointments, slotDuration)
		days = append(days, daySlots)
	}

	return days
}

// generateDaySlotsForDate generates slots for a single day.
func (s *Service) generateDaySlotsForDate(d time.Time, rules []repository.AvailabilityRule, overrideMap map[string]*repository.AvailabilityOverride, appointments []repository.Appointment, slotDuration int) transport.DaySlots {
	dateKey := d.Format(dateFormat)
	daySlots := transport.DaySlots{Date: dateKey, Slots: []transport.TimeSlot{}}

	// Check for override
	if override, exists := overrideMap[dateKey]; exists {
		if !override.IsAvailable {
			return daySlots // Day blocked
		}
		if override.StartTime != nil && override.EndTime != nil {
			daySlots.Slots = processTimeWindow(d, override.Timezone, *override.StartTime, *override.EndTime, slotDuration, appointments)
		}
		return daySlots
	}

	// Apply rules for this weekday
	weekday := int(d.Weekday())
	for _, rule := range rules {
		if rule.Weekday == weekday {
			slots := processTimeWindow(d, rule.Timezone, rule.StartTime, rule.EndTime, slotDuration, appointments)
			daySlots.Slots = append(daySlots.Slots, slots...)
		}
	}

	// Sort slots by start time
	sort.Slice(daySlots.Slots, func(i, j int) bool {
		return daySlots.Slots[i].StartTime.Before(daySlots.Slots[j].StartTime)
	})

	return daySlots
}

// processTimeWindow generates slots for a time window on a given date.
func processTimeWindow(d time.Time, tzName string, startClock, endClock time.Time, slotDurationMinutes int, appointments []repository.Appointment) []transport.TimeSlot {
	loc, err := time.LoadLocation(tzName)
	if err != nil {
		loc = time.UTC
	}

	windowStart := time.Date(d.Year(), d.Month(), d.Day(), startClock.Hour(), startClock.Minute(), 0, 0, loc)
	windowEnd := time.Date(d.Year(), d.Month(), d.Day(), endClock.Hour(), endClock.Minute(), 0, 0, loc)

	return generateSlotsForWindow(windowStart.UTC(), windowEnd.UTC(), slotDurationMinutes, appointments)
}

// generateSlotsForWindow generates available slots within a time window (UTC), excluding existing appointments
func generateSlotsForWindow(windowStart, windowEnd time.Time, slotDurationMinutes int, appointments []repository.Appointment) []transport.TimeSlot {
	var slots []transport.TimeSlot
	slotDuration := time.Duration(slotDurationMinutes) * time.Minute

	// Generate slots
	for slotStart := windowStart; slotStart.Add(slotDuration).Before(windowEnd) || slotStart.Add(slotDuration).Equal(windowEnd); slotStart = slotStart.Add(slotDuration) {
		slotEnd := slotStart.Add(slotDuration)

		// Check if slot conflicts with any appointment
		conflicts := false
		for _, appt := range appointments {
			// Check for overlap: slot overlaps if it starts before appt ends AND ends after appt starts
			if slotStart.Before(appt.EndTime) && slotEnd.After(appt.StartTime) {
				conflicts = true
				break
			}
		}

		if !conflicts {
			slots = append(slots, transport.TimeSlot{
				StartTime: slotStart,
				EndTime:   slotEnd,
			})
		}
	}

	return slots
}

func (s *Service) resolveTargetUserIDFromString(userID uuid.UUID, isAdmin bool, target string) (uuid.UUID, error) {
	if target == "" {
		return userID, nil
	}
	parsed, err := uuid.Parse(target)
	if err != nil {
		return uuid.UUID{}, apperr.BadRequest("invalid userId format")
	}
	if !isAdmin && parsed != userID {
		return uuid.UUID{}, apperr.Forbidden("not authorized to view availability for this user")
	}
	return parsed, nil
}

// Availability
func (s *Service) CreateAvailabilityRule(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.CreateAvailabilityRuleRequest) (*transport.AvailabilityRuleResponse, error) {
	targetUserID, err := s.resolveTargetUserID(userID, isAdmin, req.UserID)
	if err != nil {
		return nil, err
	}

	startTime, endTime, timezone, err := parseAvailabilityTimes(req.StartTime, req.EndTime, req.Timezone)
	if err != nil {
		return nil, err
	}

	saved, err := s.repo.CreateAvailabilityRule(ctx, repository.AvailabilityRule{
		ID:             uuid.New(),
		OrganizationID: tenantID,
		UserID:         targetUserID,
		Weekday:        req.Weekday,
		StartTime:      startTime,
		EndTime:        endTime,
		Timezone:       timezone,
	})
	if err != nil {
		return nil, err
	}

	return mapAvailabilityRule(saved), nil
}

func (s *Service) ListAvailabilityRules(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, targetUserID *uuid.UUID) ([]transport.AvailabilityRuleResponse, error) {
	resolvedUserID, err := s.resolveTargetUserID(userID, isAdmin, targetUserID)
	if err != nil {
		return nil, err
	}

	items, err := s.repo.ListAvailabilityRules(ctx, tenantID, resolvedUserID)
	if err != nil {
		return nil, err
	}

	resp := make([]transport.AvailabilityRuleResponse, len(items))
	for i := range items {
		resp[i] = *mapAvailabilityRule(&items[i])
	}

	return resp, nil
}

func (s *Service) ListAvailabilityRuleUserIDs(ctx context.Context, tenantID uuid.UUID) ([]uuid.UUID, error) {
	return s.repo.ListAvailabilityRuleUserIDs(ctx, tenantID)
}

func (s *Service) DeleteAvailabilityRule(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, id uuid.UUID) error {
	rule, err := s.repo.GetAvailabilityRuleByID(ctx, id, tenantID)
	if err != nil {
		return err
	}
	if !isAdmin && rule.UserID != userID {
		return apperr.Forbidden("not authorized to delete this availability rule")
	}

	return s.repo.DeleteAvailabilityRule(ctx, id, tenantID)
}

func (s *Service) UpdateAvailabilityRule(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, id uuid.UUID, req transport.UpdateAvailabilityRuleRequest) (*transport.AvailabilityRuleResponse, error) {
	rule, err := s.repo.GetAvailabilityRuleByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}
	if !isAdmin && rule.UserID != userID {
		return nil, apperr.Forbidden("not authorized to update this availability rule")
	}

	updated, err := applyAvailabilityRuleUpdates(rule, req)
	if err != nil {
		return nil, err
	}

	saved, err := s.repo.UpdateAvailabilityRule(ctx, id, tenantID, updated)
	if err != nil {
		return nil, err
	}

	return mapAvailabilityRule(saved), nil
}

func applyAvailabilityRuleUpdates(rule *repository.AvailabilityRule, req transport.UpdateAvailabilityRuleRequest) (repository.AvailabilityRule, error) {
	updated := *rule
	if req.Weekday != nil {
		updated.Weekday = *req.Weekday
	}

	timezone := updated.Timezone
	if req.Timezone != nil {
		timezone = *req.Timezone
	}

	startTimeStr := updated.StartTime.Format("15:04")
	endTimeStr := updated.EndTime.Format("15:04")
	if req.StartTime != nil {
		startTimeStr = *req.StartTime
	}
	if req.EndTime != nil {
		endTimeStr = *req.EndTime
	}

	startTime, endTime, parsedTimezone, err := parseAvailabilityTimes(startTimeStr, endTimeStr, timezone)
	if err != nil {
		return repository.AvailabilityRule{}, err
	}

	updated.StartTime = startTime
	updated.EndTime = endTime
	updated.Timezone = parsedTimezone
	return updated, nil
}

func (s *Service) CreateAvailabilityOverride(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, req transport.CreateAvailabilityOverrideRequest) (*transport.AvailabilityOverrideResponse, error) {
	targetUserID, err := s.resolveTargetUserID(userID, isAdmin, req.UserID)
	if err != nil {
		return nil, err
	}

	date, err := time.Parse(dateFormat, req.Date)
	if err != nil {
		return nil, apperr.BadRequest("invalid date format")
	}

	startTime, endTime, timezone, err := parseAvailabilityOptionalTimes(req.StartTime, req.EndTime, req.Timezone)
	if err != nil {
		return nil, err
	}

	saved, err := s.repo.CreateAvailabilityOverride(ctx, repository.AvailabilityOverride{
		ID:             uuid.New(),
		OrganizationID: tenantID,
		UserID:         targetUserID,
		Date:           date,
		IsAvailable:    req.IsAvailable,
		StartTime:      startTime,
		EndTime:        endTime,
		Timezone:       timezone,
	})
	if err != nil {
		return nil, err
	}

	return mapAvailabilityOverride(saved), nil
}

func (s *Service) ListAvailabilityOverrides(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, targetUserID *uuid.UUID, startDate *string, endDate *string) ([]transport.AvailabilityOverrideResponse, error) {
	resolvedUserID, err := s.resolveTargetUserID(userID, isAdmin, targetUserID)
	if err != nil {
		return nil, err
	}

	start, end, err := parseOptionalDateRange(startDate, endDate)
	if err != nil {
		return nil, err
	}

	items, err := s.repo.ListAvailabilityOverrides(ctx, tenantID, resolvedUserID, start, end)
	if err != nil {
		return nil, err
	}

	resp := make([]transport.AvailabilityOverrideResponse, len(items))
	for i := range items {
		resp[i] = *mapAvailabilityOverride(&items[i])
	}

	return resp, nil
}

func (s *Service) DeleteAvailabilityOverride(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, id uuid.UUID) error {
	override, err := s.repo.GetAvailabilityOverrideByID(ctx, id, tenantID)
	if err != nil {
		return err
	}
	if !isAdmin && override.UserID != userID {
		return apperr.Forbidden("not authorized to delete this availability override")
	}

	return s.repo.DeleteAvailabilityOverride(ctx, id, tenantID)
}

func (s *Service) UpdateAvailabilityOverride(ctx context.Context, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID, id uuid.UUID, req transport.UpdateAvailabilityOverrideRequest) (*transport.AvailabilityOverrideResponse, error) {
	override, err := s.repo.GetAvailabilityOverrideByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}
	if !isAdmin && override.UserID != userID {
		return nil, apperr.Forbidden("not authorized to update this availability override")
	}

	// Apply partial updates
	if req.Date != nil {
		date, err := time.Parse(dateFormat, *req.Date)
		if err != nil {
			return nil, apperr.BadRequest("invalid date format")
		}
		override.Date = date
	}
	if req.IsAvailable != nil {
		override.IsAvailable = *req.IsAvailable
	}

	timezone := override.Timezone
	if req.Timezone != nil {
		timezone = *req.Timezone
	}

	// Handle time updates
	var startTimeStr *string
	var endTimeStr *string
	if override.StartTime != nil {
		str := override.StartTime.Format("15:04")
		startTimeStr = &str
	}
	if override.EndTime != nil {
		str := override.EndTime.Format("15:04")
		endTimeStr = &str
	}
	if req.StartTime != nil {
		startTimeStr = req.StartTime
	}
	if req.EndTime != nil {
		endTimeStr = req.EndTime
	}

	startTime, endTime, parsedTimezone, err := parseAvailabilityOptionalTimes(startTimeStr, endTimeStr, timezone)
	if err != nil {
		return nil, err
	}

	override.StartTime = startTime
	override.EndTime = endTime
	override.Timezone = parsedTimezone

	saved, err := s.repo.UpdateAvailabilityOverride(ctx, id, tenantID, *override)
	if err != nil {
		return nil, err
	}

	return mapAvailabilityOverride(saved), nil
}

// Helper functions

func (s *Service) getLeadInfo(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) *transport.AppointmentLeadInfo {
	info, err := s.repo.GetLeadInfo(ctx, leadID, tenantID)
	if err != nil || info == nil {
		return nil
	}
	return &transport.AppointmentLeadInfo{
		ID:        info.ID,
		FirstName: info.FirstName,
		LastName:  info.LastName,
		Phone:     info.Phone,
		Address:   fmt.Sprintf("%s %s, %s", info.Street, info.HouseNumber, info.City),
	}
}

func (s *Service) getLeadEmail(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID) string {
	email, err := s.repo.GetLeadEmail(ctx, leadID, tenantID)
	if err != nil {
		return ""
	}
	return email
}

func (s *Service) ensureAccess(ctx context.Context, appointmentID uuid.UUID, userID uuid.UUID, isAdmin bool, tenantID uuid.UUID) (*repository.Appointment, error) {
	appt, err := s.repo.GetByID(ctx, appointmentID, tenantID)
	if err != nil {
		return nil, err
	}
	if !isAdmin && appt.UserID != userID {
		return nil, apperr.Forbidden("not authorized to access this appointment")
	}
	return appt, nil
}

func toAccessDifficulty(value *string) *transport.AccessDifficulty {
	if value == nil {
		return nil
	}
	converted := transport.AccessDifficulty(*value)
	return &converted
}

func toAccessDifficultyString(value *transport.AccessDifficulty) *string {
	if value == nil {
		return nil
	}
	converted := string(*value)
	return &converted
}

func mergeString(existing *repository.VisitReport, getExisting func(*repository.VisitReport) *string, next *string) *string {
	if next != nil {
		return next
	}
	if existing == nil {
		return nil
	}
	return getExisting(existing)
}

func parseAvailabilityTimes(startTime string, endTime string, timezone string) (time.Time, time.Time, string, error) {
	start, err := time.Parse("15:04", startTime)
	if err != nil {
		return time.Time{}, time.Time{}, "", apperr.BadRequest("invalid startTime format")
	}
	end, err := time.Parse("15:04", endTime)
	if err != nil {
		return time.Time{}, time.Time{}, "", apperr.BadRequest("invalid endTime format")
	}
	if !end.After(start) {
		return time.Time{}, time.Time{}, "", apperr.BadRequest(errEndTimeAfterStart)
	}
	if timezone == "" {
		timezone = "Europe/Amsterdam"
	}
	return start, end, timezone, nil
}

func parseAvailabilityOptionalTimes(startTime *string, endTime *string, timezone string) (*time.Time, *time.Time, string, error) {
	if timezone == "" {
		timezone = "Europe/Amsterdam"
	}
	if startTime == nil && endTime == nil {
		return nil, nil, timezone, nil
	}
	if startTime == nil || endTime == nil {
		return nil, nil, "", apperr.BadRequest("startTime and endTime must both be provided")
	}
	start, err := time.Parse("15:04", *startTime)
	if err != nil {
		return nil, nil, "", apperr.BadRequest("invalid startTime format")
	}
	end, err := time.Parse("15:04", *endTime)
	if err != nil {
		return nil, nil, "", apperr.BadRequest("invalid endTime format")
	}
	if !end.After(start) {
		return nil, nil, "", apperr.BadRequest(errEndTimeAfterStart)
	}
	return &start, &end, timezone, nil
}

func parseOptionalDateRange(startDate *string, endDate *string) (*time.Time, *time.Time, error) {
	var start *time.Time
	var end *time.Time

	if startDate != nil && *startDate != "" {
		parsed, err := time.Parse(dateFormat, *startDate)
		if err != nil {
			return nil, nil, apperr.BadRequest("invalid startDate format")
		}
		start = &parsed
	}
	if endDate != nil && *endDate != "" {
		parsed, err := time.Parse(dateFormat, *endDate)
		if err != nil {
			return nil, nil, apperr.BadRequest("invalid endDate format")
		}
		end = &parsed
	}
	if start != nil && end != nil && start.After(*end) {
		return nil, nil, apperr.BadRequest("startDate must be before or equal to endDate")
	}
	return start, end, nil
}

func (s *Service) resolveTargetUserID(userID uuid.UUID, isAdmin bool, target *uuid.UUID) (uuid.UUID, error) {
	if target == nil {
		return userID, nil
	}
	if !isAdmin && *target != userID {
		return uuid.UUID{}, apperr.Forbidden("not authorized to manage availability for this user")
	}
	return *target, nil
}

func mapAvailabilityRule(rule *repository.AvailabilityRule) *transport.AvailabilityRuleResponse {
	return &transport.AvailabilityRuleResponse{
		ID:        rule.ID,
		UserID:    rule.UserID,
		Weekday:   rule.Weekday,
		StartTime: rule.StartTime.Format("15:04"),
		EndTime:   rule.EndTime.Format("15:04"),
		Timezone:  rule.Timezone,
		CreatedAt: rule.CreatedAt,
		UpdatedAt: rule.UpdatedAt,
	}
}

func mapAvailabilityOverride(override *repository.AvailabilityOverride) *transport.AvailabilityOverrideResponse {
	var startTime *string
	var endTime *string
	if override.StartTime != nil {
		value := override.StartTime.Format("15:04")
		startTime = &value
	}
	if override.EndTime != nil {
		value := override.EndTime.Format("15:04")
		endTime = &value
	}

	return &transport.AvailabilityOverrideResponse{
		ID:          override.ID,
		UserID:      override.UserID,
		Date:        override.Date.Format(dateFormat),
		IsAvailable: override.IsAvailable,
		StartTime:   startTime,
		EndTime:     endTime,
		Timezone:    override.Timezone,
		CreatedAt:   override.CreatedAt,
		UpdatedAt:   override.UpdatedAt,
	}
}

func nilIfEmpty(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

func getOptionalString(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}

func formatConsumerName(firstName, lastName string) string {
	name := strings.TrimSpace(firstName + " " + lastName)
	if name == "" {
		return "klant"
	}
	return name
}

// parseUUIDFilter parses an optional UUID string filter.
// Returns nil if empty, error if invalid format.
func parseUUIDFilter(s string, fieldName string) (*uuid.UUID, error) {
	if s == "" {
		return nil, nil
	}
	parsed, err := uuid.Parse(s)
	if err != nil {
		return nil, apperr.BadRequest(fmt.Sprintf("invalid %s format", fieldName))
	}
	return &parsed, nil
}

// parseDateFilter parses date string in 2006-01-02 format.
// Returns nil if empty, error if invalid format.
func parseDateFilter(s string, fieldName string) (*time.Time, error) {
	if s == "" {
		return nil, nil
	}
	t, err := time.Parse(dateFormat, s)
	if err != nil {
		return nil, apperr.BadRequest(fmt.Sprintf("invalid %s date format: %s", fieldName, s))
	}
	return &t, nil
}
</file>

<file path="internal/leads/orchestrator.go">
package leads

import (
	"context"
	"fmt"
	"sync"

	"github.com/google/uuid"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/agent"
	"portal_final_backend/internal/leads/domain"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/platform/logger"
)

// Orchestrator routes pipeline events to specialized agents.
type Orchestrator struct {
	gatekeeper *agent.Gatekeeper
	estimator  *agent.Estimator
	dispatcher *agent.Dispatcher
	repo       repository.LeadsRepository
	eventBus   events.Bus
	sse        *sse.Service
	log        *logger.Logger

	// Idempotency protection: tracks active agent runs
	activeRuns map[string]bool
	runsMu     sync.Mutex
}

const (
	dispatcherAlreadyRunningMsg = "orchestrator: dispatcher already running for service, skipping"
	dispatcherFailedMsg         = "orchestrator: dispatcher failed"
)

func NewOrchestrator(gatekeeper *agent.Gatekeeper, estimator *agent.Estimator, dispatcher *agent.Dispatcher, repo repository.LeadsRepository, eventBus events.Bus, sse *sse.Service, log *logger.Logger) *Orchestrator {
	return &Orchestrator{
		gatekeeper: gatekeeper,
		estimator:  estimator,
		dispatcher: dispatcher,
		repo:       repo,
		eventBus:   eventBus,
		sse:        sse,
		log:        log,
		activeRuns: make(map[string]bool),
	}
}

// markRunning attempts to mark an agent run as active. Returns true if successfully marked, false if already running.
func (o *Orchestrator) markRunning(agentName string, serviceID uuid.UUID) bool {
	o.runsMu.Lock()
	defer o.runsMu.Unlock()

	key := agentName + ":" + serviceID.String()
	if o.activeRuns[key] {
		return false // Already running
	}
	o.activeRuns[key] = true
	return true
}

// markComplete removes the active run marker.
func (o *Orchestrator) markComplete(agentName string, serviceID uuid.UUID) {
	o.runsMu.Lock()
	defer o.runsMu.Unlock()

	key := agentName + ":" + serviceID.String()
	delete(o.activeRuns, key)
}

func (o *Orchestrator) recordDispatcherFailure(ctx context.Context, leadID, serviceID, tenantID uuid.UUID) {
	summary := "Partner matching mislukt. Probeer opnieuw."
	_, _ = o.repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &serviceID,
		OrganizationID: tenantID,
		ActorType:      "System",
		ActorName:      "Dispatcher",
		EventType:      "alert",
		Title:          "Partner matching mislukt",
		Summary:        &summary,
		Metadata: map[string]any{
			"trigger": "dispatcher_run",
		},
	})
}

// ShouldRunAgent checks if a service is eligible for agent processing.
// Returns false if the service is in a terminal state (Closed, Bad_Lead, Surveyed,
// Completed, or Lost).
func (o *Orchestrator) ShouldRunAgent(service repository.LeadService) bool {
	if domain.IsTerminal(service.Status, service.PipelineStage) {
		o.log.Info("orchestrator: skipping agent run for terminal service",
			"serviceId", service.ID,
			"status", service.Status,
			"pipelineStage", service.PipelineStage)
		return false
	}
	return true
}

// OnDataChange handles human data changes and re-triggers agents when needed.
func (o *Orchestrator) OnDataChange(ctx context.Context, evt events.LeadDataChanged) {
	svc, err := o.repo.GetLeadServiceByID(ctx, evt.LeadServiceID, evt.TenantID)
	if err != nil {
		o.log.Error("orchestrator: failed to load lead service", "error", err)
		return
	}

	if !o.ShouldRunAgent(svc) {
		return
	}

	if svc.PipelineStage == "Triage" || svc.PipelineStage == "Nurturing" || svc.PipelineStage == "Manual_Intervention" {
		// Idempotency check
		if !o.markRunning("gatekeeper", evt.LeadServiceID) {
			o.log.Info("orchestrator: gatekeeper already running for service, skipping", "serviceId", evt.LeadServiceID)
			return
		}

		o.log.Info("orchestrator: data changed, waking gatekeeper", "leadId", evt.LeadID, "stage", svc.PipelineStage)
		go func() {
			defer o.markComplete("gatekeeper", evt.LeadServiceID)
			if err := o.gatekeeper.Run(context.Background(), evt.LeadID, evt.LeadServiceID, evt.TenantID); err != nil {
				o.log.Error("orchestrator: gatekeeper failed", "error", err)
			}
		}()
		return
	}
}

// OnStageChange triggers downstream agents based on pipeline transitions.
func (o *Orchestrator) OnStageChange(ctx context.Context, evt events.PipelineStageChanged) {
	// Terminal stages never trigger agents
	if domain.IsTerminalPipelineStage(evt.NewStage) {
		return
	}

	switch evt.NewStage {
	case "Ready_For_Estimator":
		// Idempotency check
		if !o.markRunning("estimator", evt.LeadServiceID) {
			o.log.Info("orchestrator: estimator already running for service, skipping", "serviceId", evt.LeadServiceID)
			return
		}

		o.log.Info("orchestrator: lead ready for estimation", "leadId", evt.LeadID)
		go func() {
			defer o.markComplete("estimator", evt.LeadServiceID)
			if err := o.estimator.Run(context.Background(), evt.LeadID, evt.LeadServiceID, evt.TenantID); err != nil {
				o.log.Error("orchestrator: estimator failed", "error", err)
			}
		}()

	case "Ready_For_Partner":
		// Idempotency check
		if !o.markRunning("dispatcher", evt.LeadServiceID) {
			o.log.Info(dispatcherAlreadyRunningMsg, "serviceId", evt.LeadServiceID)
			return
		}

		o.log.Info("orchestrator: lead ready for dispatch", "leadId", evt.LeadID)
		go func() {
			defer o.markComplete("dispatcher", evt.LeadServiceID)
			if err := o.dispatcher.Run(context.Background(), evt.LeadID, evt.LeadServiceID, evt.TenantID); err != nil {
				o.log.Error(dispatcherFailedMsg, "error", err)
				o.recordDispatcherFailure(context.Background(), evt.LeadID, evt.LeadServiceID, evt.TenantID)
			}
		}()

	case "Manual_Intervention":
		o.log.Warn("orchestrator: manual intervention required", "leadId", evt.LeadID, "serviceId", evt.LeadServiceID)
		// Record timeline event for audit trail
		drafts := buildManualInterventionDrafts(evt.LeadID, evt.LeadServiceID)
		_, _ = o.repo.CreateTimelineEvent(context.Background(), repository.CreateTimelineEventParams{
			LeadID:         evt.LeadID,
			ServiceID:      &evt.LeadServiceID,
			OrganizationID: evt.TenantID,
			ActorType:      "System",
			ActorName:      "Orchestrator",
			EventType:      "alert",
			Title:          "Handmatige interventie vereist",
			Summary:        stringPtr("Geautomatiseerde verwerking vereist menselijke beoordeling"),
			Metadata: map[string]any{
				"previous_stage": evt.OldStage,
				"trigger":        "pipeline_stage_change",
				"drafts":         drafts,
			},
		})

		// Push real-time notification to all org members via SSE
		o.sse.PublishToOrganization(evt.TenantID, sse.Event{
			Type:      sse.EventManualIntervention,
			LeadID:    evt.LeadID,
			ServiceID: evt.LeadServiceID,
			Message:   "Geautomatiseerde verwerking vereist menselijke beoordeling",
			Data: map[string]any{
				"previousStage": evt.OldStage,
			},
		})

		// Publish domain event for downstream handlers (email notifications, etc.)
		o.eventBus.Publish(context.Background(), events.ManualInterventionRequired{
			BaseEvent:     events.NewBaseEvent(),
			LeadID:        evt.LeadID,
			LeadServiceID: evt.LeadServiceID,
			TenantID:      evt.TenantID,
			Reason:        "pipeline_stage_change",
			Context:       "Transitioned from " + evt.OldStage,
		})
	}
}

// OnQuoteAccepted advances pipeline after customer approval.
func (o *Orchestrator) OnQuoteAccepted(ctx context.Context, evt events.QuoteAccepted) {
	if evt.LeadServiceID == nil {
		return
	}
	serviceID := *evt.LeadServiceID

	oldStage := ""
	if svc, err := o.repo.GetLeadServiceByID(ctx, serviceID, evt.OrganizationID); err == nil {
		oldStage = svc.PipelineStage
	}

	summary := fmt.Sprintf("Offerte %s geaccepteerd. Starten met zoeken naar partner.", evt.QuoteNumber)
	_, _ = o.repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         evt.LeadID,
		ServiceID:      evt.LeadServiceID,
		OrganizationID: evt.OrganizationID,
		ActorType:      "System",
		ActorName:      "Orchestrator",
		EventType:      "stage_change",
		Title:          "Offerte Geaccepteerd",
		Summary:        &summary,
		Metadata:       map[string]any{"quoteId": evt.QuoteID},
	})

	if _, err := o.repo.UpdatePipelineStage(ctx, serviceID, evt.OrganizationID, "Ready_For_Partner"); err != nil {
		o.log.Error("orchestrator: failed to advance stage after quote acceptance", "error", err)
		return
	}

	o.eventBus.Publish(ctx, events.PipelineStageChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        evt.LeadID,
		LeadServiceID: serviceID,
		TenantID:      evt.OrganizationID,
		OldStage:      oldStage,
		NewStage:      "Ready_For_Partner",
	})
}

// OnPartnerOfferRejected re-triggers the dispatcher to find a new partner.
func (o *Orchestrator) OnPartnerOfferRejected(ctx context.Context, evt events.PartnerOfferRejected) {
	_ = ctx
	o.log.Info("Orchestrator: Partner rejected offer, re-triggering dispatcher", "leadId", evt.LeadID)
	if !o.markRunning("dispatcher", evt.LeadServiceID) {
		o.log.Info(dispatcherAlreadyRunningMsg, "serviceId", evt.LeadServiceID)
		return
	}
	go func() {
		defer o.markComplete("dispatcher", evt.LeadServiceID)
		if err := o.dispatcher.Run(context.Background(), evt.LeadID, evt.LeadServiceID, evt.OrganizationID); err != nil {
			o.log.Error(dispatcherFailedMsg, "error", err)
			o.recordDispatcherFailure(context.Background(), evt.LeadID, evt.LeadServiceID, evt.OrganizationID)
		}
	}()
}

// OnPartnerOfferExpired re-triggers the dispatcher when an offer expires.
func (o *Orchestrator) OnPartnerOfferExpired(ctx context.Context, evt events.PartnerOfferExpired) {
	_ = ctx
	o.log.Info("Orchestrator: Partner offer expired, re-triggering dispatcher", "leadId", evt.LeadID)
	if !o.markRunning("dispatcher", evt.LeadServiceID) {
		o.log.Info(dispatcherAlreadyRunningMsg, "serviceId", evt.LeadServiceID)
		return
	}
	go func() {
		defer o.markComplete("dispatcher", evt.LeadServiceID)
		if err := o.dispatcher.Run(context.Background(), evt.LeadID, evt.LeadServiceID, evt.OrganizationID); err != nil {
			o.log.Error(dispatcherFailedMsg, "error", err)
			o.recordDispatcherFailure(context.Background(), evt.LeadID, evt.LeadServiceID, evt.OrganizationID)
		}
	}()
}

// OnPartnerOfferAccepted advances pipeline once a partner accepts the offer.
func (o *Orchestrator) OnPartnerOfferAccepted(ctx context.Context, evt events.PartnerOfferAccepted) {
	oldStage := ""
	if svc, err := o.repo.GetLeadServiceByID(ctx, evt.LeadServiceID, evt.OrganizationID); err == nil {
		oldStage = svc.PipelineStage
	}

	if _, err := o.repo.UpdatePipelineStage(ctx, evt.LeadServiceID, evt.OrganizationID, "Partner_Assigned"); err != nil {
		o.log.Error("orchestrator: failed to advance stage after partner acceptance", "error", err)
		return
	}

	o.eventBus.Publish(ctx, events.PipelineStageChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        evt.LeadID,
		LeadServiceID: evt.LeadServiceID,
		TenantID:      evt.OrganizationID,
		OldStage:      oldStage,
		NewStage:      "Partner_Assigned",
	})
}

func stringPtr(s string) *string {
	return &s
}

func buildManualInterventionDrafts(leadID, serviceID uuid.UUID) map[string]any {
	subject := "Handmatige interventie vereist"
	body := fmt.Sprintf("Er is handmatige interventie vereist voor lead %s (service %s).\n\nControleer de intake, ontbrekende gegevens en eventuele AI-analyses en bepaal de volgende stap.", leadID.String(), serviceID.String())
	whatsApp := fmt.Sprintf("Handmatige interventie vereist voor lead %s (service %s). Controleer de intake en bepaal de volgende stap.", leadID.String(), serviceID.String())

	return map[string]any{
		"emailSubject":    subject,
		"emailBody":       body,
		"whatsappMessage": whatsApp,
		"messageLanguage": "nl",
		"messageAudience": "internal",
		"messageCategory": "manual_intervention",
	}
}
</file>

<file path="internal/quotes/transport/dto.go">
package transport

import (
	"time"

	"github.com/google/uuid"
)

// QuoteStatus defines the status of a quote
type QuoteStatus string

const (
	QuoteStatusDraft    QuoteStatus = "Draft"
	QuoteStatusSent     QuoteStatus = "Sent"
	QuoteStatusAccepted QuoteStatus = "Accepted"
	QuoteStatusRejected QuoteStatus = "Rejected"
	QuoteStatusExpired  QuoteStatus = "Expired"
)

//  Requests 

// QuoteItemRequest is the input for a single line item
type QuoteItemRequest struct {
	Description      string     `json:"description" validate:"required"`
	Quantity         string     `json:"quantity" validate:"required"`
	UnitPriceCents   int64      `json:"unitPriceCents" validate:"min=0"`
	TaxRateBps       int        `json:"taxRateBps" validate:"min=0"`
	IsOptional       bool       `json:"isOptional"`
	IsSelected       bool       `json:"isSelected"`
	CatalogProductID *uuid.UUID `json:"catalogProductId,omitempty"`
}

// QuoteAttachmentRequest is the input for a document attachment on a quote.
type QuoteAttachmentRequest struct {
	Filename         string     `json:"filename" validate:"required,min=1,max=500"`
	FileKey          string     `json:"fileKey" validate:"required,min=1,max=1000"`
	Source           string     `json:"source" validate:"required,oneof=catalog manual"`
	CatalogProductID *uuid.UUID `json:"catalogProductId,omitempty"`
	Enabled          bool       `json:"enabled"`
	SortOrder        int        `json:"sortOrder" validate:"min=0"`
}

// QuoteURLRequest is the input for a URL attachment on a quote.
type QuoteURLRequest struct {
	Label            string     `json:"label" validate:"required,min=1,max=500"`
	Href             string     `json:"href" validate:"required,url,max=2000"`
	CatalogProductID *uuid.UUID `json:"catalogProductId,omitempty"`
}

// CreateQuoteRequest is the request body for creating a new quote
type CreateQuoteRequest struct {
	LeadID              uuid.UUID                `json:"leadId" validate:"required"`
	LeadServiceID       *uuid.UUID               `json:"leadServiceId"`
	PricingMode         string                   `json:"pricingMode" validate:"omitempty,oneof=exclusive inclusive"`
	DiscountType        string                   `json:"discountType" validate:"omitempty,oneof=percentage fixed"`
	DiscountValue       int64                    `json:"discountValue" validate:"min=0"`
	ValidUntil          *time.Time               `json:"validUntil"`
	Notes               string                   `json:"notes"`
	Items               []QuoteItemRequest       `json:"items" validate:"required,dive"`
	Attachments         []QuoteAttachmentRequest `json:"attachments" validate:"omitempty,dive"`
	URLs                []QuoteURLRequest        `json:"urls" validate:"omitempty,dive"`
	FinancingDisclaimer bool                     `json:"financingDisclaimer"`
}

// UpdateQuoteRequest is the request body for updating a quote
type UpdateQuoteRequest struct {
	PricingMode         *string                   `json:"pricingMode" validate:"omitempty,oneof=exclusive inclusive"`
	DiscountType        *string                   `json:"discountType" validate:"omitempty,oneof=percentage fixed"`
	DiscountValue       *int64                    `json:"discountValue" validate:"omitempty,min=0"`
	ValidUntil          *time.Time                `json:"validUntil"`
	Notes               *string                   `json:"notes"`
	Items               *[]QuoteItemRequest       `json:"items" validate:"omitempty,dive"`
	Attachments         *[]QuoteAttachmentRequest `json:"attachments" validate:"omitempty,dive"`
	URLs                *[]QuoteURLRequest        `json:"urls" validate:"omitempty,dive"`
	FinancingDisclaimer *bool                     `json:"financingDisclaimer"`
}

// UpdateQuoteStatusRequest is the request body for updating a quote's status
type UpdateQuoteStatusRequest struct {
	Status QuoteStatus `json:"status" validate:"required,oneof=Draft Sent Accepted Rejected Expired"`
}

// QuoteCalculationRequest is the request body for the preview calculation endpoint
type QuoteCalculationRequest struct {
	Items         []QuoteItemRequest `json:"items" validate:"required,dive"`
	PricingMode   string             `json:"pricingMode" validate:"omitempty,oneof=exclusive inclusive"`
	DiscountType  string             `json:"discountType" validate:"omitempty,oneof=percentage fixed"`
	DiscountValue int64              `json:"discountValue" validate:"min=0"`
}

// ListQuotesRequest defines the query parameters for listing quotes
type ListQuotesRequest struct {
	LeadID         string `form:"leadId"`
	Status         string `form:"status" validate:"omitempty,oneof=Draft Sent Accepted Rejected Expired"`
	Search         string `form:"search"`
	CreatedAtFrom  string `form:"createdAtFrom" validate:"omitempty"`
	CreatedAtTo    string `form:"createdAtTo" validate:"omitempty"`
	ValidUntilFrom string `form:"validUntilFrom" validate:"omitempty"`
	ValidUntilTo   string `form:"validUntilTo" validate:"omitempty"`
	TotalFrom      string `form:"totalFrom" validate:"omitempty"`
	TotalTo        string `form:"totalTo" validate:"omitempty"`
	SortBy         string `form:"sortBy" validate:"omitempty,oneof=quoteNumber status total validUntil customerName customerPhone customerAddress createdBy createdAt updatedAt"`
	SortOrder      string `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
	Page           int    `form:"page" validate:"omitempty,min=1"`
	PageSize       int    `form:"pageSize" validate:"omitempty,min=1,max=100"`
}

//  Responses 

// QuoteItemResponse is the response for a single line item
type QuoteItemResponse struct {
	ID                  uuid.UUID            `json:"id"`
	Description         string               `json:"description"`
	Quantity            string               `json:"quantity"`
	UnitPriceCents      int64                `json:"unitPriceCents"`
	TaxRateBps          int                  `json:"taxRateBps"`
	IsOptional          bool                 `json:"isOptional"`
	IsSelected          bool                 `json:"isSelected"`
	SortOrder           int                  `json:"sortOrder"`
	TotalBeforeTaxCents int64                `json:"totalBeforeTaxCents"`
	TotalTaxCents       int64                `json:"totalTaxCents"`
	LineTotalCents      int64                `json:"lineTotalCents"`
	CatalogProductID    *uuid.UUID           `json:"catalogProductId,omitempty"`
	Annotations         []AnnotationResponse `json:"annotations"`
}

// QuoteAttachmentResponse is the response for a document attachment.
type QuoteAttachmentResponse struct {
	ID               uuid.UUID  `json:"id"`
	Filename         string     `json:"filename"`
	FileKey          string     `json:"fileKey"`
	Source           string     `json:"source"`
	CatalogProductID *uuid.UUID `json:"catalogProductId,omitempty"`
	Enabled          bool       `json:"enabled"`
	SortOrder        int        `json:"sortOrder"`
	CreatedAt        time.Time  `json:"createdAt"`
}

// QuoteURLResponse is the response for a URL attachment.
type QuoteURLResponse struct {
	ID               uuid.UUID  `json:"id"`
	Label            string     `json:"label"`
	Href             string     `json:"href"`
	Accepted         bool       `json:"accepted"`
	CatalogProductID *uuid.UUID `json:"catalogProductId,omitempty"`
	CreatedAt        time.Time  `json:"createdAt"`
}

//  Presigned Upload 

// PresignAttachmentUploadRequest is the request for generating a presigned URL
// for uploading a manual PDF attachment to a quote.
type PresignAttachmentUploadRequest struct {
	FileName    string `json:"fileName" validate:"required,min=1,max=255"`
	ContentType string `json:"contentType" validate:"required,eq=application/pdf"`
	SizeBytes   int64  `json:"sizeBytes" validate:"required,min=1"`
}

// PresignedUploadResponse is the generic presigned upload URL response.
type PresignedUploadResponse struct {
	UploadURL string `json:"uploadUrl"`
	FileKey   string `json:"fileKey"`
	ExpiresAt int64  `json:"expiresAt"`
}

// PresignedDownloadResponse is the presigned URL for downloading an attachment.
type PresignedDownloadResponse struct {
	DownloadURL string `json:"downloadUrl"`
	ExpiresAt   int64  `json:"expiresAt"`
}

// QuoteResponse is the response for a quote
type QuoteResponse struct {
	ID                         uuid.UUID                 `json:"id"`
	QuoteNumber                string                    `json:"quoteNumber"`
	LeadID                     uuid.UUID                 `json:"leadId"`
	LeadServiceID              *uuid.UUID                `json:"leadServiceId,omitempty"`
	CreatedByID                *uuid.UUID                `json:"createdById,omitempty"`
	CreatedByFirstName         *string                   `json:"createdByFirstName,omitempty"`
	CreatedByLastName          *string                   `json:"createdByLastName,omitempty"`
	CreatedByEmail             *string                   `json:"createdByEmail,omitempty"`
	CustomerFirstName          *string                   `json:"customerFirstName,omitempty"`
	CustomerLastName           *string                   `json:"customerLastName,omitempty"`
	CustomerPhone              *string                   `json:"customerPhone,omitempty"`
	CustomerEmail              *string                   `json:"customerEmail,omitempty"`
	CustomerAddressStreet      *string                   `json:"customerAddressStreet,omitempty"`
	CustomerAddressHouseNumber *string                   `json:"customerAddressHouseNumber,omitempty"`
	CustomerAddressZipCode     *string                   `json:"customerAddressZipCode,omitempty"`
	CustomerAddressCity        *string                   `json:"customerAddressCity,omitempty"`
	Status                     QuoteStatus               `json:"status"`
	PricingMode                string                    `json:"pricingMode"`
	DiscountType               string                    `json:"discountType"`
	DiscountValue              int64                     `json:"discountValue"`
	SubtotalCents              int64                     `json:"subtotalCents"`
	DiscountAmountCents        int64                     `json:"discountAmountCents"`
	TaxTotalCents              int64                     `json:"taxTotalCents"`
	TotalCents                 int64                     `json:"totalCents"`
	ValidUntil                 *time.Time                `json:"validUntil,omitempty"`
	Notes                      *string                   `json:"notes,omitempty"`
	Items                      []QuoteItemResponse       `json:"items"`
	Attachments                []QuoteAttachmentResponse `json:"attachments"`
	URLs                       []QuoteURLResponse        `json:"urls"`
	ViewedAt                   *time.Time                `json:"viewedAt,omitempty"`
	AcceptedAt                 *time.Time                `json:"acceptedAt,omitempty"`
	RejectedAt                 *time.Time                `json:"rejectedAt,omitempty"`
	PDFFileKey                 *string                   `json:"pdfFileKey,omitempty"`
	FinancingDisclaimer        bool                      `json:"financingDisclaimer"`
	CreatedAt                  time.Time                 `json:"createdAt"`
	UpdatedAt                  time.Time                 `json:"updatedAt"`
}

// QuoteListResponse is the paginated list response
type QuoteListResponse struct {
	Items      []QuoteResponse `json:"items"`
	Total      int             `json:"total"`
	Page       int             `json:"page"`
	PageSize   int             `json:"pageSize"`
	TotalPages int             `json:"totalPages"`
}

// QuotePreviewLinkResponse is the response for a read-only preview link.
type QuotePreviewLinkResponse struct {
	Token     string     `json:"token"`
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

// VatBreakdown represents a single VAT rate line
type VatBreakdown struct {
	RateBps     int   `json:"rateBps"`
	AmountCents int64 `json:"amountCents"`
}

// CalculatedLineItem is a fully calculated line returned from the preview endpoint
type CalculatedLineItem struct {
	Description         string `json:"description"`
	Quantity            string `json:"quantity"`
	UnitPriceCents      int64  `json:"unitPriceCents"`
	TaxRateBps          int    `json:"taxRateBps"`
	IsOptional          bool   `json:"isOptional"`
	IsSelected          bool   `json:"isSelected"`
	TotalBeforeTaxCents int64  `json:"totalBeforeTaxCents"`
	TotalTaxCents       int64  `json:"totalTaxCents"`
	LineTotalCents      int64  `json:"lineTotalCents"`
}

// QuoteCalculationResponse is the response for the preview calculation
type QuoteCalculationResponse struct {
	Lines               []CalculatedLineItem `json:"lines"`
	SubtotalCents       int64                `json:"subtotalCents"`
	DiscountAmountCents int64                `json:"discountAmountCents"`
	VatTotalCents       int64                `json:"vatTotalCents"`
	VatBreakdown        []VatBreakdown       `json:"vatBreakdown"`
	TotalCents          int64                `json:"totalCents"`
}

//  Public Quote DTOs 

// AnnotationResponse is the response for a single annotation on a line item.
type AnnotationResponse struct {
	ID         uuid.UUID  `json:"id"`
	ItemID     uuid.UUID  `json:"itemId"`
	AuthorType string     `json:"authorType"`
	AuthorID   *uuid.UUID `json:"authorId,omitempty"`
	Text       string     `json:"text"`
	IsResolved bool       `json:"isResolved"`
	CreatedAt  time.Time  `json:"createdAt"`
}

// PublicQuoteItemResponse is the public-facing response for a line item (includes annotations).
type PublicQuoteItemResponse struct {
	ID                  uuid.UUID            `json:"id"`
	Description         string               `json:"description"`
	Quantity            string               `json:"quantity"`
	UnitPriceCents      int64                `json:"unitPriceCents"`
	TaxRateBps          int                  `json:"taxRateBps"`
	IsOptional          bool                 `json:"isOptional"`
	IsSelected          bool                 `json:"isSelected"`
	SortOrder           int                  `json:"sortOrder"`
	TotalBeforeTaxCents int64                `json:"totalBeforeTaxCents"`
	TotalTaxCents       int64                `json:"totalTaxCents"`
	LineTotalCents      int64                `json:"lineTotalCents"`
	Annotations         []AnnotationResponse `json:"annotations"`
}

// PublicQuoteResponse is the public-facing response for a quote proposal.
type PublicQuoteResponse struct {
	ID                  uuid.UUID                 `json:"id"`
	QuoteNumber         string                    `json:"quoteNumber"`
	Status              QuoteStatus               `json:"status"`
	PricingMode         string                    `json:"pricingMode"`
	OrganizationName    string                    `json:"organizationName"`
	CustomerName        string                    `json:"customerName"`
	DiscountType        string                    `json:"discountType"`
	DiscountValue       int64                     `json:"discountValue"`
	SubtotalCents       int64                     `json:"subtotalCents"`
	DiscountAmountCents int64                     `json:"discountAmountCents"`
	TaxTotalCents       int64                     `json:"taxTotalCents"`
	TotalCents          int64                     `json:"totalCents"`
	VatBreakdown        []VatBreakdown            `json:"vatBreakdown"`
	ValidUntil          *time.Time                `json:"validUntil,omitempty"`
	Notes               *string                   `json:"notes,omitempty"`
	Items               []PublicQuoteItemResponse `json:"items"`
	Attachments         []QuoteAttachmentResponse `json:"attachments"`
	URLs                []QuoteURLResponse        `json:"urls"`
	AcceptedAt          *time.Time                `json:"acceptedAt,omitempty"`
	RejectedAt          *time.Time                `json:"rejectedAt,omitempty"`
	FinancingDisclaimer bool                      `json:"financingDisclaimer"`
	IsReadOnly          bool                      `json:"isReadOnly,omitempty"`
}

// ToggleItemRequest is the request body for toggling an optional item.
type ToggleItemRequest struct {
	IsSelected bool `json:"isSelected"`
}

// ToggleItemResponse is returned after toggling an item, with recalculated totals.
type ToggleItemResponse struct {
	SubtotalCents       int64          `json:"subtotalCents"`
	DiscountAmountCents int64          `json:"discountAmountCents"`
	TaxTotalCents       int64          `json:"taxTotalCents"`
	TotalCents          int64          `json:"totalCents"`
	VatBreakdown        []VatBreakdown `json:"vatBreakdown"`
}

// AnnotateItemRequest is the request body for creating an annotation on a line item.
type AnnotateItemRequest struct {
	Text string `json:"text" validate:"required,min=1,max=2000"`
}

// AcceptQuoteRequest is the request body for accepting a quote.
type AcceptQuoteRequest struct {
	SignatureName string `json:"signatureName" validate:"required,min=1,max=255"`
	SignatureData string `json:"signatureData" validate:"required"`
}

// RejectQuoteRequest is the request body for rejecting a quote.
type RejectQuoteRequest struct {
	Reason string `json:"reason" validate:"max=2000"`
}

// GenerateQuoteRequest is the request body for AI-generated quote creation.
type GenerateQuoteRequest struct {
	LeadID        uuid.UUID  `json:"leadId" validate:"required"`
	LeadServiceID *uuid.UUID `json:"leadServiceId"`
	Prompt        string     `json:"prompt" validate:"required,min=5,max=2000"`
	QuoteID       *uuid.UUID `json:"quoteId"` // If set, update the existing quote instead of creating a new one
}

// GenerateQuoteResponse is the response for AI-generated quote creation.
type GenerateQuoteResponse struct {
	QuoteID     uuid.UUID `json:"quoteId"`
	QuoteNumber string    `json:"quoteNumber"`
	ItemCount   int       `json:"itemCount"`
}

// QuoteActivityResponse is the response for a single activity log entry.
type QuoteActivityResponse struct {
	ID        uuid.UUID              `json:"id"`
	EventType string                 `json:"eventType"`
	Message   string                 `json:"message"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	CreatedAt time.Time              `json:"createdAt"`
}
</file>

<file path="internal/leads/handler/handler.go">
package handler

import (
	"context"
	"net/http"
	"strconv"
	"strings"
	"time"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/agent"
	"portal_final_backend/internal/leads/domain"
	"portal_final_backend/internal/leads/management"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// Handler handles HTTP requests for RAC_leads.
// Uses focused services following vertical slicing pattern.
type Handler struct {
	mgmt         *management.Service
	notesHandler *NotesHandler
	gatekeeper   *agent.Gatekeeper
	callLogger   *agent.CallLogger
	sse          *sse.Service
	eventBus     events.Bus
	repo         repository.LeadsRepository
	val          *validator.Validator
}

// HandlerDeps bundles dependencies for Handler construction.
type HandlerDeps struct {
	Mgmt         *management.Service
	NotesHandler *NotesHandler
	Gatekeeper   *agent.Gatekeeper
	CallLogger   *agent.CallLogger
	SSE          *sse.Service
	EventBus     events.Bus
	Repo         repository.LeadsRepository
	Validator    *validator.Validator
}

const (
	msgInvalidRequest   = "invalid request"
	msgValidationFailed = "validation failed"
	msgTenantRequired   = "tenant context required"
	msgInvalidServiceID = "invalid serviceId"
	dateLayout          = "2006-01-02"
)

// mustGetTenantID extracts and dereferences the tenant ID from identity.
// Returns the tenant ID and true if valid, or handles the error response and returns false.
func mustGetTenantID(c *gin.Context, identity httpkit.Identity) (uuid.UUID, bool) {
	tenantID := identity.TenantID()
	if tenantID == nil {
		httpkit.Error(c, http.StatusForbidden, msgTenantRequired, nil)
		return uuid.UUID{}, false
	}
	return *tenantID, true
}

// New creates a new RAC_leads handler with focused services.
func New(deps HandlerDeps) *Handler {
	return &Handler{
		mgmt:         deps.Mgmt,
		notesHandler: deps.NotesHandler,
		gatekeeper:   deps.Gatekeeper,
		callLogger:   deps.CallLogger,
		sse:          deps.SSE,
		eventBus:     deps.EventBus,
		repo:         deps.Repo,
		val:          deps.Validator,
	}
}

func (h *Handler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("", h.List)
	rg.POST("", h.Create)
	rg.GET("/metrics", h.GetMetrics)
	rg.GET("/heatmap", h.GetHeatmap)
	rg.GET("/action-items", h.GetActionItems)
	rg.GET("/activity-feed", h.GetActivityFeed)
	rg.GET("/activity-feed/members", h.ListOrgMembers)
	rg.POST("/activity-feed/:eventId/reactions", h.ToggleReaction)
	rg.GET("/activity-feed/:eventId/comments", h.ListComments)
	rg.POST("/activity-feed/:eventId/comments", h.CreateComment)
	rg.DELETE("/activity-feed/comments/:commentId", h.DeleteComment)
	rg.GET("/check-duplicate", h.CheckDuplicate)
	rg.GET("/check-returning-customer", h.CheckReturningCustomer)
	rg.GET("/:id", h.GetByID)
	rg.GET("/:id/timeline", h.GetTimeline)
	rg.PUT("/:id", h.Update)
	rg.DELETE("/:id", h.Delete)
	rg.POST("/bulk-delete", h.BulkDelete)
	rg.PATCH("/:id/status", h.UpdateStatus)
	rg.PUT(":id/assign", h.Assign)
	rg.POST("/:id/view", h.MarkViewed)
	rg.GET("/:id/notes", h.notesHandler.ListNotes)
	rg.POST("/:id/notes", h.notesHandler.AddNote)
	// Service-specific routes
	rg.POST("/:id/services", h.AddService)
	rg.PATCH("/:id/services/:serviceId/status", h.UpdateServiceStatus)
	// AI Advisor routes
	rg.POST("/:id/analyze", h.AnalyzeLead)
	rg.GET("/:id/analysis", h.GetAnalysis)
	rg.GET("/:id/analysis/history", h.ListAnalyses)
	// Call Logger routes
	rg.POST("/:id/services/:serviceId/log-call", h.LogCall)
}

func (h *Handler) GetMetrics(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	metrics, err := h.mgmt.GetMetrics(c.Request.Context(), tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, metrics)
}

func (h *Handler) GetHeatmap(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var req transport.LeadHeatmapRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	startDate, endDate, errMsg := parseDateRange(req.StartDate, req.EndDate)
	if errMsg != "" {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, errMsg)
		return
	}

	result, err := h.mgmt.GetHeatmap(c.Request.Context(), startDate, endDate, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) GetActionItems(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var req transport.ActionItemsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	if req.Page < 1 {
		req.Page = 1
	}
	if req.PageSize < 1 {
		req.PageSize = 5
	}
	if req.PageSize > 50 {
		req.PageSize = 50
	}

	result, err := h.mgmt.GetActionItems(c.Request.Context(), req.Page, req.PageSize, 7, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) GetActivityFeed(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	page := parsePositiveInt(c.Query("page"), 1)
	limit := parsePositiveInt(c.Query("limit"), 20)
	if limit > 50 {
		limit = 50
	}

	result, err := h.mgmt.GetActivityFeed(c.Request.Context(), tenantID, identity.UserID(), page, limit)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func parsePositiveInt(value string, fallback int) int {
	if value == "" {
		return fallback
	}
	parsed, err := strconv.Atoi(value)
	if err != nil || parsed < 1 {
		return fallback
	}
	return parsed
}

func (h *Handler) Create(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var req transport.CreateLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.Create(c.Request.Context(), req, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	h.publishLeadUpdate(tenantID, &lead.ID, "created")
	httpkit.JSON(c, http.StatusCreated, lead)
}

func (h *Handler) GetByID(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	lead, err := h.mgmt.GetByID(c.Request.Context(), id, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, lead)
}

func (h *Handler) GetTimeline(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var serviceID *uuid.UUID
	if raw := c.Query("serviceId"); raw != "" {
		parsed, err := uuid.Parse(raw)
		if err != nil {
			httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
			return
		}
		serviceID = &parsed
	}

	items, err := h.mgmt.GetTimeline(c.Request.Context(), leadID, tenantID, serviceID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"items": items})
}

func (h *Handler) Update(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	lead, err := h.mgmt.Update(c.Request.Context(), id, req, identity.UserID(), tenantID, identity.Roles())
	if httpkit.HandleError(c, err) {
		return
	}

	if lead.CurrentService != nil {
		h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
			BaseEvent:     events.NewBaseEvent(),
			LeadID:        lead.ID,
			LeadServiceID: lead.CurrentService.ID,
			TenantID:      tenantID,
			Source:        "user_update",
		})
	}

	h.publishLeadUpdate(tenantID, &lead.ID, "updated")
	httpkit.OK(c, lead)
}

func (h *Handler) Assign(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.AssignLeadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	lead, err := h.mgmt.Assign(c.Request.Context(), id, req.AssigneeID, identity.UserID(), tenantID, identity.Roles())
	if httpkit.HandleError(c, err) {
		return
	}

	h.publishLeadUpdate(tenantID, &lead.ID, "assigned")
	httpkit.OK(c, lead)
}

func (h *Handler) Delete(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	if err := h.mgmt.Delete(c.Request.Context(), id, tenantID); httpkit.HandleError(c, err) {
		return
	}

	h.publishLeadUpdate(tenantID, &id, "deleted")
	httpkit.OK(c, gin.H{"message": "lead deleted"})
}

func (h *Handler) BulkDelete(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var req transport.BulkDeleteLeadsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	deletedCount, err := h.mgmt.BulkDelete(c.Request.Context(), req.IDs, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	h.publishLeadUpdate(tenantID, nil, "bulk_deleted")
	httpkit.OK(c, transport.BulkDeleteLeadsResponse{DeletedCount: deletedCount})
}

func (h *Handler) UpdateStatus(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateLeadStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.UpdateStatus(c.Request.Context(), id, req, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	h.publishLeadUpdate(tenantID, &lead.ID, "status_updated")
	httpkit.OK(c, lead)
}

func (h *Handler) MarkViewed(c *gin.Context) {
	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	if err := h.mgmt.SetViewedBy(c.Request.Context(), id, identity.UserID(), tenantID); httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, gin.H{"message": "lead marked as viewed"})
}

func (h *Handler) CheckDuplicate(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	phone := c.Query("phone")
	if phone == "" {
		httpkit.Error(c, http.StatusBadRequest, "phone parameter required", nil)
		return
	}

	result, err := h.mgmt.CheckDuplicate(c.Request.Context(), phone, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) CheckReturningCustomer(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	phone := c.Query("phone")
	email := c.Query("email")

	if phone == "" && email == "" {
		httpkit.Error(c, http.StatusBadRequest, "phone or email parameter required", nil)
		return
	}

	result, err := h.mgmt.CheckReturningCustomer(c.Request.Context(), phone, email, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) List(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	var req transport.ListLeadsRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	result, err := h.mgmt.List(c.Request.Context(), req, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

func (h *Handler) AddService(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.AddServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.AddService(c.Request.Context(), id, req, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.JSON(c, http.StatusCreated, lead)
}

func (h *Handler) publishLeadUpdate(tenantID uuid.UUID, leadID *uuid.UUID, action string) {
	if h.sse == nil {
		return
	}

	event := sse.Event{
		Type:    sse.EventLeadUpdated,
		Message: "Lead updated",
		Data:    gin.H{"action": action},
	}
	if leadID != nil {
		event.LeadID = *leadID
	}

	h.sse.PublishToOrganization(tenantID, event)
}

func (h *Handler) UpdateServiceStatus(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.UpdateServiceStatusRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	lead, err := h.mgmt.UpdateServiceStatus(c.Request.Context(), leadID, serviceID, req, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, lead)
}

// AnalyzeLead triggers gatekeeper analysis for a lead service
func (h *Handler) AnalyzeLead(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	// Validate required serviceId with terminal status check
	svcIDStr := c.Query("serviceId")
	if svcIDStr == "" {
		httpkit.Error(c, http.StatusBadRequest, "serviceId parameter is required", nil)
		return
	}
	validation := h.validateServiceForAnalysis(c, svcIDStr, tenantID)
	if validation.ErrMsg != "" {
		httpkit.Error(c, validation.ErrStatus, validation.ErrMsg, nil)
		return
	}

	// Trigger gatekeeper analysis asynchronously
	go func() {
		ctx := context.Background()
		serviceID := validation.ServiceID
		if err := h.gatekeeper.Run(ctx, id, *serviceID, tenantID); err != nil {
			_ = err // log-only: don't expose to client
		}
	}()

	httpkit.OK(c, gin.H{
		"message": "Analysis triggered successfully",
		"leadId":  id,
	})
}

// GetAnalysis returns the latest AI analysis for a lead service
func (h *Handler) GetAnalysis(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	id, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	// Parse required serviceId
	svcID := c.Query("serviceId")
	if svcID == "" {
		httpkit.Error(c, http.StatusBadRequest, "serviceId parameter required", nil)
		return
	}
	serviceID, err := uuid.Parse(svcID)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidServiceID, nil)
		return
	}

	// Get latest analysis from repository
	analysis, err := h.repo.GetLatestAIAnalysis(c.Request.Context(), serviceID, tenantID)
	if err != nil {
		if err == repository.ErrNotFound {
			// Return default/empty analysis
			httpkit.OK(c, gin.H{
				"analysis":  nil,
				"isDefault": true,
				"leadId":    id,
			})
			return
		}
		if httpkit.HandleError(c, err) {
			return
		}
	}

	httpkit.OK(c, gin.H{
		"analysis":  transport.ToAIAnalysisResponse(analysis),
		"isDefault": false,
	})
}

// ListAnalyses returns all AI analyses for a lead service
func (h *Handler) ListAnalyses(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	_, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	// Parse required serviceId
	svcID := c.Query("serviceId")
	if svcID == "" {
		httpkit.Error(c, http.StatusBadRequest, "serviceId parameter required", nil)
		return
	}
	serviceID, err := uuid.Parse(svcID)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidServiceID, nil)
		return
	}

	// Get all analyses from repository
	analyses, err := h.repo.ListAIAnalyses(c.Request.Context(), serviceID, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	items := make([]transport.AIAnalysisResponse, 0, len(analyses))
	for _, analysis := range analyses {
		items = append(items, transport.ToAIAnalysisResponse(analysis))
	}

	httpkit.OK(c, gin.H{"items": items})
}

// LogCall processes a post-call summary and executes appropriate actions (notes, status updates, RAC_appointments)
func (h *Handler) LogCall(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	leadID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	serviceID, err := uuid.Parse(c.Param("serviceId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}

	var req transport.LogCallRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.callLogger.ProcessSummary(c.Request.Context(), leadID, serviceID, identity.UserID(), tenantID, req.Summary)
	if httpkit.HandleError(c, err) {
		return
	}

	actorName := identity.UserID().String()
	if result.AuthorEmail != "" {
		actorName = result.AuthorEmail
	}

	summaryText := req.Summary
	if result.NoteBody != "" {
		summaryText = result.NoteBody
	}

	_, _ = h.repo.CreateTimelineEvent(c.Request.Context(), repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &serviceID,
		OrganizationID: tenantID,
		ActorType:      "User",
		ActorName:      actorName,
		EventType:      "call_log",
		Title:          "Gesprek geregistreerd",
		Summary:        summaryPointer(summaryText, 400),
		Metadata: map[string]any{
			"callOutcome":            result.CallOutcome,
			"noteCreated":            result.NoteCreated,
			"statusUpdated":          result.StatusUpdated,
			"pipelineStageUpdated":   result.PipelineStageUpdated,
			"appointmentBooked":      result.AppointmentBooked,
			"appointmentRescheduled": result.AppointmentRescheduled,
			"appointmentCancelled":   result.AppointmentCancelled,
		},
	})

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        leadID,
		LeadServiceID: serviceID,
		TenantID:      tenantID,
		Source:        "call_log",
	})

	httpkit.OK(c, result)
}

func summaryPointer(text string, maxLen int) *string {
	trimmed := strings.TrimSpace(text)
	if trimmed == "" {
		return nil
	}
	if len(trimmed) > maxLen {
		trimmed = trimmed[:maxLen] + "..."
	}
	return &trimmed
}

// isTerminalStatus checks if a service status is terminal (no further actions allowed).
// Delegates to the centralized domain.IsTerminalStatus for consistency.
func isTerminalStatus(status string) bool {
	return domain.IsTerminalStatus(status)
}

// parseDateRange parses optional start and end date strings and validates the range.
// Returns nil dates for empty strings. Returns an error message if parsing fails or dates are invalid.
func parseDateRange(startDateStr, endDateStr string) (startDate, endDate *time.Time, errMsg string) {
	if startDateStr != "" {
		parsed, err := time.Parse(dateLayout, startDateStr)
		if err != nil {
			return nil, nil, "invalid startDate"
		}
		startDate = &parsed
	}

	if endDateStr != "" {
		parsed, err := time.Parse(dateLayout, endDateStr)
		if err != nil {
			return nil, nil, "invalid endDate"
		}
		endDate = &parsed
	}

	if startDate != nil && endDate != nil && startDate.After(*endDate) {
		return nil, nil, "startDate must be before or equal to endDate"
	}

	return startDate, endDate, ""
}

// serviceValidationResult holds the result of validating a service ID for analysis.
type serviceValidationResult struct {
	ServiceID *uuid.UUID
	ErrMsg    string
	ErrStatus int
}

// validateServiceForAnalysis validates and parses an optional service ID, checking terminal status.
func (h *Handler) validateServiceForAnalysis(ctx *gin.Context, svcIDStr string, tenantID uuid.UUID) serviceValidationResult {
	if svcIDStr == "" {
		return serviceValidationResult{}
	}

	parsed, err := uuid.Parse(svcIDStr)
	if err != nil {
		return serviceValidationResult{ErrMsg: msgInvalidServiceID, ErrStatus: http.StatusBadRequest}
	}

	service, err := h.mgmt.GetLeadServiceByID(ctx.Request.Context(), parsed, tenantID)
	if err != nil {
		return serviceValidationResult{ErrMsg: "service not found", ErrStatus: http.StatusNotFound}
	}

	if domain.IsTerminal(service.Status, service.PipelineStage) {
		return serviceValidationResult{ErrMsg: "cannot analyze a service in terminal state (Closed, Bad_Lead, Surveyed, Completed, or Lost)", ErrStatus: http.StatusBadRequest}
	}

	return serviceValidationResult{ServiceID: &parsed}
}

// 
// Feed Social: Reactions, Comments, @-Mentions
// 

const msgEventIDRequired = "eventId is required"

// ToggleReaction toggles a reaction on a feed event for the current user.
func (h *Handler) ToggleReaction(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	eventID := c.Param("eventId")
	if eventID == "" {
		httpkit.Error(c, http.StatusBadRequest, msgEventIDRequired, nil)
		return
	}

	var req transport.ToggleReactionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	result, err := h.mgmt.ToggleReaction(c.Request.Context(), eventID, req.EventSource, req.ReactionType, identity.UserID(), tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// ListComments returns the comment thread for a feed event.
func (h *Handler) ListComments(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	eventID := c.Param("eventId")
	if eventID == "" {
		httpkit.Error(c, http.StatusBadRequest, msgEventIDRequired, nil)
		return
	}

	eventSource := c.Query("eventSource")
	if eventSource == "" {
		httpkit.Error(c, http.StatusBadRequest, "eventSource is required", nil)
		return
	}

	result, err := h.mgmt.ListComments(c.Request.Context(), eventID, eventSource, tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}

// CreateComment creates a comment on a feed event.
func (h *Handler) CreateComment(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	eventID := c.Param("eventId")
	if eventID == "" {
		httpkit.Error(c, http.StatusBadRequest, msgEventIDRequired, nil)
		return
	}

	var req transport.CreateCommentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, msgValidationFailed, err.Error())
		return
	}

	mentionIDs := make([]uuid.UUID, 0, len(req.MentionIDs))
	for _, raw := range req.MentionIDs {
		id, err := uuid.Parse(raw)
		if err != nil {
			httpkit.Error(c, http.StatusBadRequest, "invalid mentionId: "+raw, nil)
			return
		}
		mentionIDs = append(mentionIDs, id)
	}

	result, err := h.mgmt.CreateComment(c.Request.Context(), eventID, req.EventSource, identity.UserID(), tenantID, req.Body, mentionIDs)
	if httpkit.HandleError(c, err) {
		return
	}

	c.JSON(http.StatusCreated, result)
}

// DeleteComment deletes a comment (author only).
func (h *Handler) DeleteComment(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	commentID, err := uuid.Parse(c.Param("commentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, "invalid commentId", nil)
		return
	}

	if err := h.mgmt.DeleteComment(c.Request.Context(), commentID, identity.UserID(), tenantID); httpkit.HandleError(c, err) {
		return
	}

	c.Status(http.StatusNoContent)
}

// ListOrgMembers returns team members for @-mention autocomplete.
func (h *Handler) ListOrgMembers(c *gin.Context) {
	identity := httpkit.MustGetIdentity(c)
	if identity == nil {
		return
	}
	tenantID, ok := mustGetTenantID(c, identity)
	if !ok {
		return
	}

	result, err := h.mgmt.ListOrgMembers(c.Request.Context(), tenantID)
	if httpkit.HandleError(c, err) {
		return
	}

	httpkit.OK(c, result)
}
</file>

<file path="internal/leads/repository/repository.go">
package repository

import (
	"context"
	"encoding/json"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"

	"portal_final_backend/platform/apperr"
)

var ErrNotFound = errors.New("lead not found")

type Repository struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

// ListActiveServiceTypes returns active service types with intake guidelines for AI context.
func (r *Repository) ListActiveServiceTypes(ctx context.Context, organizationID uuid.UUID) ([]ServiceContextDefinition, error) {
	rows, err := r.pool.Query(ctx, `
		SELECT name, description, intake_guidelines
		FROM RAC_service_types
		WHERE organization_id = $1 AND is_active = true
		ORDER BY name ASC
	`, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]ServiceContextDefinition, 0)
	for rows.Next() {
		var item ServiceContextDefinition
		if err := rows.Scan(&item.Name, &item.Description, &item.IntakeGuidelines); err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return items, nil
}

type Lead struct {
	ID                                      uuid.UUID
	OrganizationID                          uuid.UUID
	ConsumerFirstName                       string
	ConsumerLastName                        string
	ConsumerPhone                           string
	ConsumerEmail                           *string
	ConsumerRole                            string
	AddressStreet                           string
	AddressHouseNumber                      string
	AddressZipCode                          string
	AddressCity                             string
	Latitude                                *float64
	Longitude                               *float64
	AssignedAgentID                         *uuid.UUID
	Source                                  *string
	EnergyClass                             *string
	EnergyIndex                             *float64
	EnergyBouwjaar                          *int
	EnergyGebouwtype                        *string
	EnergyLabelValidUntil                   *time.Time
	EnergyLabelRegisteredAt                 *time.Time
	EnergyPrimairFossiel                    *float64
	EnergyBAGVerblijfsobjectID              *string
	EnergyLabelFetchedAt                    *time.Time
	LeadEnrichmentSource                    *string
	LeadEnrichmentPostcode6                 *string
	LeadEnrichmentPostcode4                 *string
	LeadEnrichmentBuurtcode                 *string
	LeadEnrichmentDataYear                  *int
	LeadEnrichmentGemAardgasverbruik        *float64
	LeadEnrichmentGemElektriciteitsverbruik *float64
	LeadEnrichmentHuishoudenGrootte         *float64
	LeadEnrichmentKoopwoningenPct           *float64
	LeadEnrichmentBouwjaarVanaf2000Pct      *float64
	LeadEnrichmentWOZWaarde                 *float64
	LeadEnrichmentMediaanVermogenX1000      *float64
	LeadEnrichmentGemInkomen                *float64
	LeadEnrichmentPctHoogInkomen            *float64
	LeadEnrichmentPctLaagInkomen            *float64
	LeadEnrichmentHuishoudensMetKinderenPct *float64
	LeadEnrichmentStedelijkheid             *int
	LeadEnrichmentConfidence                *float64
	LeadEnrichmentFetchedAt                 *time.Time
	LeadScore                               *int
	LeadScorePreAI                          *int
	LeadScoreFactors                        []byte
	LeadScoreVersion                        *string
	LeadScoreUpdatedAt                      *time.Time
	ViewedByID                              *uuid.UUID
	ViewedAt                                *time.Time
	CreatedAt                               time.Time
	UpdatedAt                               time.Time
}

// LeadSummary is a lightweight lead representation for returning customer detection
type LeadSummary struct {
	ID              uuid.UUID
	OrganizationID  uuid.UUID
	ConsumerName    string
	ConsumerPhone   string
	ConsumerEmail   *string
	AddressCity     string
	ServiceCount    int
	LastServiceType *string
	LastStatus      *string
	CreatedAt       time.Time
}

type CreateLeadParams struct {
	OrganizationID     uuid.UUID
	ConsumerFirstName  string
	ConsumerLastName   string
	ConsumerPhone      string
	ConsumerEmail      *string
	ConsumerRole       string
	AddressStreet      string
	AddressHouseNumber string
	AddressZipCode     string
	AddressCity        string
	Latitude           *float64
	Longitude          *float64
	AssignedAgentID    *uuid.UUID
	Source             *string
	GCLID              *string
	UTMSource          *string
	UTMMedium          *string
	UTMCampaign        *string
	UTMContent         *string
	UTMTerm            *string
	AdLandingPage      *string
	ReferrerURL        *string
}

func (r *Repository) Create(ctx context.Context, params CreateLeadParams) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		INSERT INTO RAC_leads (
			organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
			assigned_agent_id, source,
			gclid, utm_source, utm_medium, utm_campaign, utm_content, utm_term, ad_landing_page, referrer_url
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
		RETURNING id, organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
			assigned_agent_id, source, energy_class, energy_index, energy_bouwjaar, energy_gebouwtype,
			energy_label_valid_until, energy_label_registered_at, energy_primair_fossiel, energy_bag_verblijfsobject_id,
			energy_label_fetched_at,
			lead_enrichment_source, lead_enrichment_postcode6, lead_enrichment_postcode4, lead_enrichment_buurtcode, lead_enrichment_data_year,
			lead_enrichment_gem_aardgasverbruik, lead_enrichment_gem_elektriciteitsverbruik, lead_enrichment_huishouden_grootte,
			lead_enrichment_koopwoningen_pct, lead_enrichment_bouwjaar_vanaf2000_pct, lead_enrichment_woz_waarde,
			lead_enrichment_mediaan_vermogen_x1000, lead_enrichment_gem_inkomen, lead_enrichment_pct_hoog_inkomen, lead_enrichment_pct_laag_inkomen,
			lead_enrichment_huishoudens_met_kinderen_pct, lead_enrichment_stedelijkheid, lead_enrichment_confidence, lead_enrichment_fetched_at,
			lead_score, lead_score_pre_ai, lead_score_factors, lead_score_version, lead_score_updated_at,
			viewed_by_id, viewed_at, created_at, updated_at
	`,
		params.OrganizationID, params.ConsumerFirstName, params.ConsumerLastName, params.ConsumerPhone, params.ConsumerEmail, params.ConsumerRole,
		params.AddressStreet, params.AddressHouseNumber, params.AddressZipCode, params.AddressCity, params.Latitude, params.Longitude,
		params.AssignedAgentID, params.Source,
		params.GCLID, params.UTMSource, params.UTMMedium, params.UTMCampaign, params.UTMContent, params.UTMTerm, params.AdLandingPage, params.ReferrerURL,
	).Scan(
		&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
		&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
		&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
		&lead.EnergyLabelFetchedAt,
		&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
		&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
		&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
		&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
		&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
		&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
		&lead.ViewedByID, &lead.ViewedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if err != nil {
		return Lead{}, err
	}

	return lead, nil
}

func (r *Repository) GetByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		SELECT id, organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
			assigned_agent_id, source, energy_class, energy_index, energy_bouwjaar, energy_gebouwtype,
			energy_label_valid_until, energy_label_registered_at, energy_primair_fossiel, energy_bag_verblijfsobject_id,
			energy_label_fetched_at,
			lead_enrichment_source, lead_enrichment_postcode6, lead_enrichment_postcode4, lead_enrichment_buurtcode, lead_enrichment_data_year,
			lead_enrichment_gem_aardgasverbruik, lead_enrichment_gem_elektriciteitsverbruik, lead_enrichment_huishouden_grootte,
			lead_enrichment_koopwoningen_pct, lead_enrichment_bouwjaar_vanaf2000_pct, lead_enrichment_woz_waarde,
			lead_enrichment_mediaan_vermogen_x1000, lead_enrichment_gem_inkomen, lead_enrichment_pct_hoog_inkomen, lead_enrichment_pct_laag_inkomen,
			lead_enrichment_huishoudens_met_kinderen_pct, lead_enrichment_stedelijkheid, lead_enrichment_confidence, lead_enrichment_fetched_at,
			lead_score, lead_score_pre_ai, lead_score_factors, lead_score_version, lead_score_updated_at,
			viewed_by_id, viewed_at, created_at, updated_at
		FROM RAC_leads WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
	`, id, organizationID).Scan(
		&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
		&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
		&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
		&lead.EnergyLabelFetchedAt,
		&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
		&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
		&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
		&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
		&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
		&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
		&lead.ViewedByID, &lead.ViewedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

// GetByIDWithServices returns a lead with all its services populated
func (r *Repository) GetByIDWithServices(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Lead, []LeadService, error) {
	lead, err := r.GetByID(ctx, id, organizationID)
	if err != nil {
		return Lead{}, nil, err
	}

	services, err := r.ListLeadServices(ctx, id, organizationID)
	if err != nil {
		return Lead{}, nil, err
	}

	return lead, services, nil
}

func (r *Repository) GetByPhone(ctx context.Context, phone string, organizationID uuid.UUID) (Lead, error) {
	var lead Lead
	err := r.pool.QueryRow(ctx, `
		SELECT id, organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
			assigned_agent_id, source, energy_class, energy_index, energy_bouwjaar, energy_gebouwtype,
			energy_label_valid_until, energy_label_registered_at, energy_primair_fossiel, energy_bag_verblijfsobject_id,
			energy_label_fetched_at,
			lead_enrichment_source, lead_enrichment_postcode6, lead_enrichment_postcode4, lead_enrichment_buurtcode, lead_enrichment_data_year,
			lead_enrichment_gem_aardgasverbruik, lead_enrichment_gem_elektriciteitsverbruik, lead_enrichment_huishouden_grootte,
			lead_enrichment_koopwoningen_pct, lead_enrichment_bouwjaar_vanaf2000_pct, lead_enrichment_woz_waarde,
			lead_enrichment_mediaan_vermogen_x1000, lead_enrichment_gem_inkomen, lead_enrichment_pct_hoog_inkomen, lead_enrichment_pct_laag_inkomen,
			lead_enrichment_huishoudens_met_kinderen_pct, lead_enrichment_stedelijkheid, lead_enrichment_confidence, lead_enrichment_fetched_at,
			lead_score, lead_score_pre_ai, lead_score_factors, lead_score_version, lead_score_updated_at,
			viewed_by_id, viewed_at, created_at, updated_at
		FROM RAC_leads WHERE consumer_phone = $1 AND organization_id = $2 AND deleted_at IS NULL
		ORDER BY created_at DESC
		LIMIT 1
	`, phone, organizationID).Scan(
		&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
		&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
		&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
		&lead.EnergyLabelFetchedAt,
		&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
		&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
		&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
		&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
		&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
		&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
		&lead.ViewedByID, &lead.ViewedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

// GetByPhoneOrEmail finds a lead matching the given phone or email for returning customer detection.
// Returns the first matching lead with its services, or nil if not found.
func (r *Repository) GetByPhoneOrEmail(ctx context.Context, phone string, email string, organizationID uuid.UUID) (*LeadSummary, []LeadService, error) {
	if phone == "" && email == "" {
		return nil, nil, nil
	}

	var summary LeadSummary
	err := r.pool.QueryRow(ctx, `
		SELECT 
			l.id,
			l.organization_id,
			l.consumer_first_name || ' ' || l.consumer_last_name AS consumer_name,
			l.consumer_phone,
			l.consumer_email,
			l.address_city,
			COUNT(ls.id) AS service_count,
			(SELECT st.name FROM RAC_lead_services ls2 
			 JOIN RAC_service_types st ON st.id = ls2.service_type_id AND st.organization_id = l.organization_id
			 WHERE ls2.lead_id = l.id ORDER BY ls2.created_at DESC LIMIT 1) AS last_service_type,
			(SELECT ls2.status FROM RAC_lead_services ls2 
			 WHERE ls2.lead_id = l.id ORDER BY ls2.created_at DESC LIMIT 1) AS last_status,
			l.created_at
		FROM RAC_leads l
		LEFT JOIN RAC_lead_services ls ON ls.lead_id = l.id
		WHERE l.deleted_at IS NULL 
		  AND l.organization_id = $3
		  AND (($1 != '' AND l.consumer_phone = $1) OR ($2 != '' AND l.consumer_email = $2))
		GROUP BY l.id
		ORDER BY l.created_at DESC
		LIMIT 1
	`, phone, email, organizationID).Scan(
		&summary.ID, &summary.OrganizationID, &summary.ConsumerName, &summary.ConsumerPhone, &summary.ConsumerEmail,
		&summary.AddressCity, &summary.ServiceCount, &summary.LastServiceType, &summary.LastStatus,
		&summary.CreatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil, nil
	}
	if err != nil {
		return nil, nil, err
	}

	// Fetch services for the found lead
	services, err := r.ListLeadServices(ctx, summary.ID, organizationID)
	if err != nil {
		return nil, nil, err
	}

	return &summary, services, nil
}

// GetLatestQuoteTotal returns the most recent quote total for a lead service.
func (r *Repository) GetLatestQuoteTotal(ctx context.Context, serviceID, organizationID uuid.UUID) (int64, error) {
	var total int64
	err := r.pool.QueryRow(ctx, `
		SELECT total_cents
		FROM RAC_quotes
		WHERE lead_service_id = $1 AND organization_id = $2
		ORDER BY created_at DESC
		LIMIT 1
	`, serviceID, organizationID).Scan(&total)
	if errors.Is(err, pgx.ErrNoRows) {
		return 0, apperr.NotFound("quote not found")
	}
	if err != nil {
		return 0, err
	}
	return total, nil
}

type UpdateLeadParams struct {
	ConsumerFirstName  *string
	ConsumerLastName   *string
	ConsumerPhone      *string
	ConsumerEmail      *string
	ConsumerRole       *string
	AddressStreet      *string
	AddressHouseNumber *string
	AddressZipCode     *string
	AddressCity        *string
	Latitude           *float64
	Longitude          *float64
	AssignedAgentID    *uuid.UUID
	AssignedAgentIDSet bool
}

type UpdateEnergyLabelParams struct {
	Class          *string
	Index          *float64
	Bouwjaar       *int
	Gebouwtype     *string
	ValidUntil     *time.Time
	RegisteredAt   *time.Time
	PrimairFossiel *float64
	BAGObjectID    *string
	FetchedAt      time.Time
}

type UpdateLeadEnrichmentParams struct {
	Source                    *string
	Postcode6                 *string
	Postcode4                 *string
	Buurtcode                 *string
	DataYear                  *int
	GemAardgasverbruik        *float64
	GemElektriciteitsverbruik *float64
	HuishoudenGrootte         *float64
	KoopwoningenPct           *float64
	BouwjaarVanaf2000Pct      *float64
	WOZWaarde                 *float64
	MediaanVermogenX1000      *float64
	GemInkomen                *float64
	PctHoogInkomen            *float64
	PctLaagInkomen            *float64
	HuishoudensMetKinderenPct *float64
	Stedelijkheid             *int
	Confidence                *float64
	FetchedAt                 time.Time
	Score                     *int
	ScorePreAI                *int
	ScoreFactors              []byte
	ScoreVersion              *string
	ScoreUpdatedAt            *time.Time
}

type UpdateLeadScoreParams struct {
	Score          *int
	ScorePreAI     *int
	ScoreFactors   []byte
	ScoreVersion   *string
	ScoreUpdatedAt time.Time
}

func nullable[T any](value *T) interface{} {
	if value == nil {
		return nil
	}
	return *value
}

func (r *Repository) Update(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadParams) (Lead, error) {
	hasUpdates := params.ConsumerFirstName != nil ||
		params.ConsumerLastName != nil ||
		params.ConsumerPhone != nil ||
		params.ConsumerEmail != nil ||
		params.ConsumerRole != nil ||
		params.AddressStreet != nil ||
		params.AddressHouseNumber != nil ||
		params.AddressZipCode != nil ||
		params.AddressCity != nil ||
		params.Latitude != nil ||
		params.Longitude != nil ||
		params.AssignedAgentIDSet

	if !hasUpdates {
		return r.GetByID(ctx, id, organizationID)
	}

	query := `
		UPDATE RAC_leads
		SET
			consumer_first_name = COALESCE($3, consumer_first_name),
			consumer_last_name = COALESCE($4, consumer_last_name),
			consumer_phone = COALESCE($5, consumer_phone),
			consumer_email = COALESCE($6, consumer_email),
			consumer_role = COALESCE($7, consumer_role),
			address_street = COALESCE($8, address_street),
			address_house_number = COALESCE($9, address_house_number),
			address_zip_code = COALESCE($10, address_zip_code),
			address_city = COALESCE($11, address_city),
			latitude = COALESCE($12, latitude),
			longitude = COALESCE($13, longitude),
			assigned_agent_id = CASE WHEN $15 THEN $14 ELSE assigned_agent_id END,
			updated_at = now()
		WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
		RETURNING id, organization_id, consumer_first_name, consumer_last_name, consumer_phone, consumer_email, consumer_role,
			address_street, address_house_number, address_zip_code, address_city, latitude, longitude,
			assigned_agent_id, source, energy_class, energy_index, energy_bouwjaar, energy_gebouwtype,
			energy_label_valid_until, energy_label_registered_at, energy_primair_fossiel, energy_bag_verblijfsobject_id,
			energy_label_fetched_at,
			lead_enrichment_source, lead_enrichment_postcode6, lead_enrichment_postcode4, lead_enrichment_buurtcode, lead_enrichment_data_year,
			lead_enrichment_gem_aardgasverbruik, lead_enrichment_gem_elektriciteitsverbruik, lead_enrichment_huishouden_grootte,
			lead_enrichment_koopwoningen_pct, lead_enrichment_bouwjaar_vanaf2000_pct, lead_enrichment_woz_waarde,
			lead_enrichment_mediaan_vermogen_x1000, lead_enrichment_gem_inkomen, lead_enrichment_pct_hoog_inkomen, lead_enrichment_pct_laag_inkomen,
			lead_enrichment_huishoudens_met_kinderen_pct, lead_enrichment_stedelijkheid, lead_enrichment_confidence, lead_enrichment_fetched_at,
			lead_score, lead_score_pre_ai, lead_score_factors, lead_score_version, lead_score_updated_at,
			viewed_by_id, viewed_at, created_at, updated_at
	`

	var assignedAgentParam interface{}
	if params.AssignedAgentIDSet {
		assignedAgentParam = params.AssignedAgentID
	}

	var lead Lead
	err := r.pool.QueryRow(
		ctx,
		query,
		id,
		organizationID,
		nullable(params.ConsumerFirstName),
		nullable(params.ConsumerLastName),
		nullable(params.ConsumerPhone),
		nullable(params.ConsumerEmail),
		nullable(params.ConsumerRole),
		nullable(params.AddressStreet),
		nullable(params.AddressHouseNumber),
		nullable(params.AddressZipCode),
		nullable(params.AddressCity),
		nullable(params.Latitude),
		nullable(params.Longitude),
		assignedAgentParam,
		params.AssignedAgentIDSet,
	).Scan(
		&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
		&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
		&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
		&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
		&lead.EnergyLabelFetchedAt,
		&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
		&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
		&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
		&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
		&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
		&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
		&lead.ViewedByID, &lead.ViewedAt,
		&lead.CreatedAt, &lead.UpdatedAt,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Lead{}, ErrNotFound
	}
	return lead, err
}

func (r *Repository) UpdateEnergyLabel(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateEnergyLabelParams) error {
	result, err := r.pool.Exec(ctx, `
		UPDATE RAC_leads
		SET energy_class = $3,
			energy_index = $4,
			energy_bouwjaar = $5,
			energy_gebouwtype = $6,
			energy_label_valid_until = $7,
			energy_label_registered_at = $8,
			energy_primair_fossiel = $9,
			energy_bag_verblijfsobject_id = $10,
			energy_label_fetched_at = $11,
			updated_at = $12
		WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
	`,
		id,
		organizationID,
		nullable(params.Class),
		nullable(params.Index),
		nullable(params.Bouwjaar),
		nullable(params.Gebouwtype),
		nullable(params.ValidUntil),
		nullable(params.RegisteredAt),
		nullable(params.PrimairFossiel),
		nullable(params.BAGObjectID),
		params.FetchedAt,
		params.FetchedAt,
	)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (r *Repository) UpdateLeadEnrichment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadEnrichmentParams) error {
	result, err := r.pool.Exec(ctx, `
		UPDATE RAC_leads
		SET lead_enrichment_source = $3,
			lead_enrichment_postcode6 = $4,
			lead_enrichment_postcode4 = $5,
			lead_enrichment_buurtcode = $6,
			lead_enrichment_data_year = $7,
			lead_enrichment_gem_aardgasverbruik = $8,
			lead_enrichment_gem_elektriciteitsverbruik = $9,
			lead_enrichment_huishouden_grootte = $10,
			lead_enrichment_koopwoningen_pct = $11,
			lead_enrichment_bouwjaar_vanaf2000_pct = $12,
			lead_enrichment_woz_waarde = $13,
			lead_enrichment_mediaan_vermogen_x1000 = $14,
			lead_enrichment_gem_inkomen = $15,
			lead_enrichment_pct_hoog_inkomen = $16,
			lead_enrichment_pct_laag_inkomen = $17,
			lead_enrichment_huishoudens_met_kinderen_pct = $18,
			lead_enrichment_stedelijkheid = $19,
			lead_enrichment_confidence = $20,
			lead_enrichment_fetched_at = $21,
			lead_score = $22,
			lead_score_pre_ai = $23,
			lead_score_factors = $24,
			lead_score_version = $25,
			lead_score_updated_at = $26,
			updated_at = $27
		WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
	`,
		id,
		organizationID,
		nullable(params.Source),
		nullable(params.Postcode6),
		nullable(params.Postcode4),
		nullable(params.Buurtcode),
		nullable(params.DataYear),
		nullable(params.GemAardgasverbruik),
		nullable(params.GemElektriciteitsverbruik),
		nullable(params.HuishoudenGrootte),
		nullable(params.KoopwoningenPct),
		nullable(params.BouwjaarVanaf2000Pct),
		nullable(params.WOZWaarde),
		nullable(params.MediaanVermogenX1000),
		nullable(params.GemInkomen),
		nullable(params.PctHoogInkomen),
		nullable(params.PctLaagInkomen),
		nullable(params.HuishoudensMetKinderenPct),
		nullable(params.Stedelijkheid),
		nullable(params.Confidence),
		params.FetchedAt,
		nullable(params.Score),
		nullable(params.ScorePreAI),
		params.ScoreFactors,
		nullable(params.ScoreVersion),
		nullable(params.ScoreUpdatedAt),
		params.FetchedAt,
	)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (r *Repository) UpdateLeadScore(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadScoreParams) error {
	result, err := r.pool.Exec(ctx, `
		UPDATE RAC_leads
		SET lead_score = $3,
			lead_score_pre_ai = $4,
			lead_score_factors = $5,
			lead_score_version = $6,
			lead_score_updated_at = $7,
			updated_at = $8
		WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
	`,
		id,
		organizationID,
		nullable(params.Score),
		nullable(params.ScorePreAI),
		params.ScoreFactors,
		nullable(params.ScoreVersion),
		params.ScoreUpdatedAt,
		params.ScoreUpdatedAt,
	)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (r *Repository) SetViewedBy(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, userID uuid.UUID) error {
	_, err := r.pool.Exec(ctx, `
		UPDATE RAC_leads SET viewed_by_id = $3, viewed_at = now(), updated_at = now()
		WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
	`, id, organizationID, userID)
	return err
}

func (r *Repository) AddActivity(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID, userID uuid.UUID, action string, meta map[string]interface{}) error {
	var metaJSON []byte
	if meta != nil {
		encoded, err := json.Marshal(meta)
		if err != nil {
			return err
		}
		metaJSON = encoded
	}

	_, err := r.pool.Exec(ctx, `
		INSERT INTO RAC_lead_activity (lead_id, organization_id, user_id, action, meta)
		VALUES ($1, $2, $3, $4, $5)
	`, leadID, organizationID, userID, action, metaJSON)
	return err
}

type ListParams struct {
	OrganizationID  uuid.UUID
	Status          *string
	ServiceType     *string
	Search          string
	FirstName       *string
	LastName        *string
	Phone           *string
	Email           *string
	Role            *string
	Street          *string
	HouseNumber     *string
	ZipCode         *string
	City            *string
	AssignedAgentID *uuid.UUID
	CreatedAtFrom   *time.Time
	CreatedAtTo     *time.Time
	Offset          int
	Limit           int
	SortBy          string
	SortOrder       string
}

func (r *Repository) List(ctx context.Context, params ListParams) ([]Lead, int, error) {
	filters := buildLeadListFilters(params)

	sortBy, err := resolveLeadSortBy(params.SortBy)
	if err != nil {
		return nil, 0, err
	}

	sortOrder, err := resolveLeadSortOrder(params.SortOrder)
	if err != nil {
		return nil, 0, err
	}

	baseQuery := `
		FROM RAC_leads l
		LEFT JOIN LATERAL (
			SELECT ls.id, ls.status, ls.service_type_id
			FROM RAC_lead_services ls
			WHERE ls.lead_id = l.id AND ls.status NOT IN ('Closed', 'Bad_Lead', 'Surveyed')
			ORDER BY ls.created_at DESC
			LIMIT 1
		) cs ON true
		LEFT JOIN RAC_service_types st ON st.id = cs.service_type_id AND st.organization_id = l.organization_id
		WHERE l.organization_id = $1
			AND l.deleted_at IS NULL
			AND ($2::text IS NULL OR cs.status = $2)
			AND ($3::text IS NULL OR st.name = $3)
			AND ($4::text IS NULL OR (
				l.consumer_first_name ILIKE $4 OR l.consumer_last_name ILIKE $4 OR l.consumer_phone ILIKE $4 OR l.consumer_email ILIKE $4 OR l.address_city ILIKE $4
			))
			AND ($5::text IS NULL OR l.consumer_first_name ILIKE $5)
			AND ($6::text IS NULL OR l.consumer_last_name ILIKE $6)
			AND ($7::text IS NULL OR l.consumer_phone ILIKE $7)
			AND ($8::text IS NULL OR l.consumer_email ILIKE $8)
			AND ($9::text IS NULL OR l.consumer_role = $9)
			AND ($10::text IS NULL OR l.address_street ILIKE $10)
			AND ($11::text IS NULL OR l.address_house_number ILIKE $11)
			AND ($12::text IS NULL OR l.address_zip_code ILIKE $12)
			AND ($13::text IS NULL OR l.address_city ILIKE $13)
			AND ($14::uuid IS NULL OR l.assigned_agent_id = $14)
			AND ($15::timestamptz IS NULL OR l.created_at >= $15)
			AND ($16::timestamptz IS NULL OR l.created_at < $16)
	`

	args := []interface{}{
		params.OrganizationID,
		filters.status,
		filters.serviceType,
		filters.search,
		filters.firstName,
		filters.lastName,
		filters.phone,
		filters.email,
		filters.role,
		filters.street,
		filters.houseNumber,
		filters.zipCode,
		filters.city,
		filters.assignedAgentID,
		filters.createdAtFrom,
		filters.createdAtTo,
	}

	var total int
	countQuery := "SELECT COUNT(DISTINCT l.id) " + baseQuery
	if err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, err
	}

	innerQuery := `
		SELECT DISTINCT l.id, l.organization_id, l.consumer_first_name, l.consumer_last_name, l.consumer_phone, l.consumer_email, l.consumer_role,
			l.address_street, l.address_house_number, l.address_zip_code, l.address_city, l.latitude, l.longitude,
			l.assigned_agent_id, l.source, l.energy_class, l.energy_index, l.energy_bouwjaar, l.energy_gebouwtype,
			l.energy_label_valid_until, l.energy_label_registered_at, l.energy_primair_fossiel, l.energy_bag_verblijfsobject_id,
			l.energy_label_fetched_at,
			l.lead_enrichment_source, l.lead_enrichment_postcode6, l.lead_enrichment_postcode4, l.lead_enrichment_buurtcode, l.lead_enrichment_data_year,
			l.lead_enrichment_gem_aardgasverbruik, l.lead_enrichment_gem_elektriciteitsverbruik, l.lead_enrichment_huishouden_grootte,
			l.lead_enrichment_koopwoningen_pct, l.lead_enrichment_bouwjaar_vanaf2000_pct, l.lead_enrichment_woz_waarde,
			l.lead_enrichment_mediaan_vermogen_x1000, l.lead_enrichment_gem_inkomen, l.lead_enrichment_pct_hoog_inkomen, l.lead_enrichment_pct_laag_inkomen,
			l.lead_enrichment_huishoudens_met_kinderen_pct, l.lead_enrichment_stedelijkheid, l.lead_enrichment_confidence, l.lead_enrichment_fetched_at,
			l.lead_score, l.lead_score_pre_ai, l.lead_score_factors, l.lead_score_version, l.lead_score_updated_at,
			l.viewed_by_id, l.viewed_at, l.created_at, l.updated_at
		` + baseQuery + `
	`

	query := `
		SELECT * FROM (
			` + innerQuery + `
		) leads
		ORDER BY
			CASE WHEN $17 = 'createdAt' AND $18 = 'asc' THEN leads.created_at END ASC,
			CASE WHEN $17 = 'createdAt' AND $18 = 'desc' THEN leads.created_at END DESC,
			CASE WHEN $17 = 'firstName' AND $18 = 'asc' THEN leads.consumer_first_name END ASC,
			CASE WHEN $17 = 'firstName' AND $18 = 'desc' THEN leads.consumer_first_name END DESC,
			CASE WHEN $17 = 'lastName' AND $18 = 'asc' THEN leads.consumer_last_name END ASC,
			CASE WHEN $17 = 'lastName' AND $18 = 'desc' THEN leads.consumer_last_name END DESC,
			CASE WHEN $17 = 'phone' AND $18 = 'asc' THEN leads.consumer_phone END ASC,
			CASE WHEN $17 = 'phone' AND $18 = 'desc' THEN leads.consumer_phone END DESC,
			CASE WHEN $17 = 'email' AND $18 = 'asc' THEN leads.consumer_email END ASC,
			CASE WHEN $17 = 'email' AND $18 = 'desc' THEN leads.consumer_email END DESC,
			CASE WHEN $17 = 'role' AND $18 = 'asc' THEN leads.consumer_role END ASC,
			CASE WHEN $17 = 'role' AND $18 = 'desc' THEN leads.consumer_role END DESC,
			CASE WHEN $17 = 'street' AND $18 = 'asc' THEN leads.address_street END ASC,
			CASE WHEN $17 = 'street' AND $18 = 'desc' THEN leads.address_street END DESC,
			CASE WHEN $17 = 'houseNumber' AND $18 = 'asc' THEN leads.address_house_number END ASC,
			CASE WHEN $17 = 'houseNumber' AND $18 = 'desc' THEN leads.address_house_number END DESC,
			CASE WHEN $17 = 'zipCode' AND $18 = 'asc' THEN leads.address_zip_code END ASC,
			CASE WHEN $17 = 'zipCode' AND $18 = 'desc' THEN leads.address_zip_code END DESC,
			CASE WHEN $17 = 'city' AND $18 = 'asc' THEN leads.address_city END ASC,
			CASE WHEN $17 = 'city' AND $18 = 'desc' THEN leads.address_city END DESC,
			CASE WHEN $17 = 'assignedAgentId' AND $18 = 'asc' THEN leads.assigned_agent_id END ASC,
			CASE WHEN $17 = 'assignedAgentId' AND $18 = 'desc' THEN leads.assigned_agent_id END DESC,
			leads.created_at DESC
		LIMIT $19 OFFSET $20
	`

	args = append(args, sortBy, sortOrder, params.Limit, params.Offset)

	rows, err := r.pool.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	leads := make([]Lead, 0)
	for rows.Next() {
		var lead Lead
		if err := rows.Scan(
			&lead.ID, &lead.OrganizationID, &lead.ConsumerFirstName, &lead.ConsumerLastName, &lead.ConsumerPhone, &lead.ConsumerEmail, &lead.ConsumerRole,
			&lead.AddressStreet, &lead.AddressHouseNumber, &lead.AddressZipCode, &lead.AddressCity, &lead.Latitude, &lead.Longitude,
			&lead.AssignedAgentID, &lead.Source, &lead.EnergyClass, &lead.EnergyIndex, &lead.EnergyBouwjaar, &lead.EnergyGebouwtype,
			&lead.EnergyLabelValidUntil, &lead.EnergyLabelRegisteredAt, &lead.EnergyPrimairFossiel, &lead.EnergyBAGVerblijfsobjectID,
			&lead.EnergyLabelFetchedAt,
			&lead.LeadEnrichmentSource, &lead.LeadEnrichmentPostcode6, &lead.LeadEnrichmentPostcode4, &lead.LeadEnrichmentBuurtcode, &lead.LeadEnrichmentDataYear,
			&lead.LeadEnrichmentGemAardgasverbruik, &lead.LeadEnrichmentGemElektriciteitsverbruik, &lead.LeadEnrichmentHuishoudenGrootte,
			&lead.LeadEnrichmentKoopwoningenPct, &lead.LeadEnrichmentBouwjaarVanaf2000Pct, &lead.LeadEnrichmentWOZWaarde,
			&lead.LeadEnrichmentMediaanVermogenX1000, &lead.LeadEnrichmentGemInkomen, &lead.LeadEnrichmentPctHoogInkomen, &lead.LeadEnrichmentPctLaagInkomen,
			&lead.LeadEnrichmentHuishoudensMetKinderenPct, &lead.LeadEnrichmentStedelijkheid, &lead.LeadEnrichmentConfidence, &lead.LeadEnrichmentFetchedAt,
			&lead.LeadScore, &lead.LeadScorePreAI, &lead.LeadScoreFactors, &lead.LeadScoreVersion, &lead.LeadScoreUpdatedAt,
			&lead.ViewedByID, &lead.ViewedAt,
			&lead.CreatedAt, &lead.UpdatedAt,
		); err != nil {
			return nil, 0, err
		}
		leads = append(leads, lead)
	}

	if rows.Err() != nil {
		return nil, 0, rows.Err()
	}

	return leads, total, nil
}

type leadListFilters struct {
	status          interface{}
	serviceType     interface{}
	search          interface{}
	firstName       interface{}
	lastName        interface{}
	phone           interface{}
	email           interface{}
	role            interface{}
	street          interface{}
	houseNumber     interface{}
	zipCode         interface{}
	city            interface{}
	assignedAgentID interface{}
	createdAtFrom   interface{}
	createdAtTo     interface{}
}

func buildLeadListFilters(params ListParams) leadListFilters {
	return leadListFilters{
		status:          nullable(params.Status),
		serviceType:     nullable(params.ServiceType),
		search:          optionalSearchParam(params.Search),
		firstName:       optionalLikeParam(params.FirstName),
		lastName:        optionalLikeParam(params.LastName),
		phone:           optionalLikeParam(params.Phone),
		email:           optionalLikeParam(params.Email),
		role:            nullable(params.Role),
		street:          optionalLikeParam(params.Street),
		houseNumber:     optionalLikeParam(params.HouseNumber),
		zipCode:         optionalLikeParam(params.ZipCode),
		city:            optionalLikeParam(params.City),
		assignedAgentID: nullable(params.AssignedAgentID),
		createdAtFrom:   nullable(params.CreatedAtFrom),
		createdAtTo:     nullable(params.CreatedAtTo),
	}
}

func optionalLikeParam(value *string) interface{} {
	if value == nil {
		return nil
	}
	return "%" + *value + "%"
}

func optionalSearchParam(value string) interface{} {
	if value == "" {
		return nil
	}
	return "%" + value + "%"
}

func resolveLeadSortBy(sortBy string) (string, error) {
	if sortBy == "" {
		return "createdAt", nil
	}
	switch sortBy {
	case "createdAt", "firstName", "lastName", "phone", "email", "role", "street", "houseNumber", "zipCode", "city", "assignedAgentId":
		return sortBy, nil
	default:
		return "", apperr.BadRequest("invalid sort field")
	}
}

func resolveLeadSortOrder(sortOrder string) (string, error) {
	if sortOrder == "" {
		return "desc", nil
	}
	switch sortOrder {
	case "asc", "desc":
		return sortOrder, nil
	default:
		return "", apperr.BadRequest("invalid sort order")
	}
}

type HeatmapPoint struct {
	Latitude  float64
	Longitude float64
}

func (r *Repository) ListHeatmapPoints(ctx context.Context, organizationID uuid.UUID, startDate *time.Time, endDate *time.Time) ([]HeatmapPoint, error) {
	var startParam interface{}
	if startDate != nil {
		startParam = *startDate
	}
	var endParam interface{}
	if endDate != nil {
		endParam = *endDate
	}

	query := `
		SELECT latitude, longitude
		FROM RAC_leads
		WHERE organization_id = $1
			AND deleted_at IS NULL
			AND latitude IS NOT NULL
			AND longitude IS NOT NULL
			AND ($2::timestamptz IS NULL OR created_at >= $2)
			AND ($3::timestamptz IS NULL OR created_at < $3)
	`

	rows, err := r.pool.Query(ctx, query, organizationID, startParam, endParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	points := make([]HeatmapPoint, 0)
	for rows.Next() {
		var point HeatmapPoint
		if err := rows.Scan(&point.Latitude, &point.Longitude); err != nil {
			return nil, err
		}
		points = append(points, point)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return points, nil
}

type ActionItem struct {
	ID            uuid.UUID
	FirstName     string
	LastName      string
	UrgencyLevel  *string
	UrgencyReason *string
	CreatedAt     time.Time
}

type ActionItemListResult struct {
	Items []ActionItem
	Total int
}

func (r *Repository) ListActionItems(ctx context.Context, organizationID uuid.UUID, newLeadDays int, limit int, offset int) (ActionItemListResult, error) {
	countQuery := `
		SELECT COUNT(*)
		FROM RAC_leads l
		LEFT JOIN (
			SELECT DISTINCT ON (lead_id) lead_id, urgency_level, urgency_reason, created_at
			FROM RAC_lead_ai_analysis
			ORDER BY lead_id, created_at DESC
		) ai ON ai.lead_id = l.id
		WHERE l.organization_id = $1
			AND l.deleted_at IS NULL
			AND (ai.urgency_level = 'High' OR l.created_at >= now() - ($2::int || ' days')::interval)
	`

	var total int
	if err := r.pool.QueryRow(ctx, countQuery, organizationID, newLeadDays).Scan(&total); err != nil {
		return ActionItemListResult{}, err
	}

	query := `
		SELECT l.id, l.consumer_first_name, l.consumer_last_name, ai.urgency_level, ai.urgency_reason, l.created_at
		FROM RAC_leads l
		LEFT JOIN (
			SELECT DISTINCT ON (lead_id) lead_id, urgency_level, urgency_reason, created_at
			FROM RAC_lead_ai_analysis
			ORDER BY lead_id, created_at DESC
		) ai ON ai.lead_id = l.id
		WHERE l.organization_id = $1
			AND l.deleted_at IS NULL
			AND (ai.urgency_level = 'High' OR l.created_at >= now() - ($2::int || ' days')::interval)
		ORDER BY
			CASE WHEN ai.urgency_level = 'High' THEN 0 ELSE 1 END,
			l.created_at DESC
		LIMIT $3 OFFSET $4
	`

	rows, err := r.pool.Query(ctx, query, organizationID, newLeadDays, limit, offset)
	if err != nil {
		return ActionItemListResult{}, err
	}
	defer rows.Close()

	items := make([]ActionItem, 0)
	for rows.Next() {
		var item ActionItem
		if err := rows.Scan(&item.ID, &item.FirstName, &item.LastName, &item.UrgencyLevel, &item.UrgencyReason, &item.CreatedAt); err != nil {
			return ActionItemListResult{}, err
		}
		items = append(items, item)
	}

	if rows.Err() != nil {
		return ActionItemListResult{}, rows.Err()
	}

	return ActionItemListResult{Items: items, Total: total}, nil
}

func (r *Repository) Delete(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error {
	result, err := r.pool.Exec(ctx, "UPDATE RAC_leads SET deleted_at = now(), updated_at = now() WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL", id, organizationID)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

// ListRecentActivity returns the most recent org-wide activity by unioning
// lead activity, quote activity, and recent appointments.
// Events are clustered: sequential events with the same lead, event type, and category
// within a 15-minute window are grouped into a single row with a group_count.
func (r *Repository) ListRecentActivity(ctx context.Context, organizationID uuid.UUID, limit int, offset int) ([]ActivityFeedEntry, error) {
	if limit <= 0 {
		limit = 50
	}
	if offset < 0 {
		offset = 0
	}

	query := `
		WITH unified AS (
			-- Lead activity
			SELECT
				la.id,
				'leads' AS category,
				la.action AS event_type,
				la.action AS title,
				'' AS description,
				la.lead_id AS entity_id,
				COALESCE(NULLIF(trim(concat_ws(' ', l.consumer_first_name, l.consumer_last_name)), ''), '') AS lead_name,
				COALESCE(l.consumer_phone, '') AS phone,
				COALESCE(l.consumer_email, '') AS email,
				COALESCE(svc.status, '') AS lead_status,
				COALESCE(svc.name, '') AS service_type,
				l.lead_score,
				NULL::text AS address,
				NULL::double precision AS latitude,
				NULL::double precision AS longitude,
				NULL::timestamptz AS scheduled_at,
				la.created_at,
				COALESCE(NULLIF(trim(concat_ws(' ', u.first_name, u.last_name)), ''), 'Systeem') AS actor_name,
				la.meta AS raw_metadata,
				NULL::uuid AS service_id
			FROM RAC_lead_activity la
			LEFT JOIN RAC_leads l ON l.id = la.lead_id AND l.organization_id = la.organization_id
			LEFT JOIN RAC_users u ON u.id = la.user_id
			LEFT JOIN LATERAL (
				SELECT ls.status, st.name
				FROM RAC_lead_services ls
				LEFT JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = l.organization_id
				WHERE ls.lead_id = l.id
				ORDER BY ls.created_at DESC
				LIMIT 1
			) svc ON true
			WHERE la.organization_id = $1
			  AND la.action != 'lead_viewed'

			UNION ALL

			-- Quote activity
			SELECT
				qa.id,
				'quotes' AS category,
				qa.event_type,
				qa.message AS title,
				'' AS description,
				qa.quote_id AS entity_id,
				COALESCE(NULLIF(trim(concat_ws(' ', l.consumer_first_name, l.consumer_last_name)), ''), '') AS lead_name,
				COALESCE(l.consumer_phone, '') AS phone,
				COALESCE(l.consumer_email, '') AS email,
				COALESCE(ls.status, '') AS lead_status,
				COALESCE(st.name, '') AS service_type,
				l.lead_score,
				NULL::text AS address,
				NULL::double precision AS latitude,
				NULL::double precision AS longitude,
				NULL::timestamptz AS scheduled_at,
				qa.created_at,
				'Systeem' AS actor_name,
				qa.metadata AS raw_metadata,
				NULL::uuid AS service_id
			FROM RAC_quote_activity qa
			LEFT JOIN RAC_quotes q ON q.id = qa.quote_id
			LEFT JOIN RAC_lead_services ls ON ls.id = q.lead_service_id
			LEFT JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = qa.organization_id
			LEFT JOIN RAC_leads l ON l.id = ls.lead_id AND l.organization_id = qa.organization_id
			WHERE qa.organization_id = $1

			UNION ALL

			-- Appointment activity (recent creates/updates)
			SELECT
				a.id,
				'appointments' AS category,
				CASE
					WHEN a.created_at = a.updated_at THEN 'appointment_created'
					ELSE 'appointment_updated'
				END AS event_type,
				a.title,
				COALESCE(a.description, '') AS description,
				a.id AS entity_id,
				COALESCE(NULLIF(trim(concat_ws(' ', l.consumer_first_name, l.consumer_last_name)), ''), '') AS lead_name,
				COALESCE(l.consumer_phone, '') AS phone,
				COALESCE(l.consumer_email, '') AS email,
				COALESCE(als.status, svc.status, '') AS lead_status,
				COALESCE(ast.name, svc.name, '') AS service_type,
				l.lead_score,
				COALESCE(
					NULLIF(a.location, ''),
					concat_ws(', ',
						concat_ws(' ', l.address_street, l.address_house_number),
						concat_ws(' ', l.address_zip_code, l.address_city)
					)
				) AS address,
				l.latitude,
				l.longitude,
				a.start_time AS scheduled_at,
				a.updated_at AS created_at,
				'Systeem' AS actor_name,
				NULL::jsonb AS raw_metadata,
				NULL::uuid AS service_id
			FROM RAC_appointments a
			LEFT JOIN RAC_leads l ON l.id = a.lead_id AND l.organization_id = a.organization_id
			LEFT JOIN RAC_lead_services als ON als.id = a.lead_service_id
			LEFT JOIN RAC_service_types ast ON ast.id = als.service_type_id AND ast.organization_id = a.organization_id
			LEFT JOIN LATERAL (
				SELECT ls.status, st.name
				FROM RAC_lead_services ls
				LEFT JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = l.organization_id
				WHERE ls.lead_id = l.id
				ORDER BY ls.created_at DESC
				LIMIT 1
			) svc ON true
			WHERE a.organization_id = $1

			UNION ALL

			-- AI timeline activity
			SELECT
				te.id,
				'ai' AS category,
				te.event_type,
				te.title,
				COALESCE(te.summary, '') AS description,
				te.lead_id AS entity_id,
				COALESCE(NULLIF(trim(concat_ws(' ', l.consumer_first_name, l.consumer_last_name)), ''), '') AS lead_name,
				COALESCE(l.consumer_phone, '') AS phone,
				COALESCE(l.consumer_email, '') AS email,
				COALESCE(svc.status, '') AS lead_status,
				COALESCE(svc.name, '') AS service_type,
				l.lead_score,
				NULL::text AS address,
				NULL::double precision AS latitude,
				NULL::double precision AS longitude,
				NULL::timestamptz AS scheduled_at,
				te.created_at,
				COALESCE(te.actor_name, 'AI') AS actor_name,
				te.metadata AS raw_metadata,
				te.service_id
			FROM lead_timeline_events te
			LEFT JOIN RAC_leads l ON l.id = te.lead_id AND l.organization_id = te.organization_id
			LEFT JOIN LATERAL (
				SELECT ls.status, st.name
				FROM RAC_lead_services ls
				LEFT JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = l.organization_id
				WHERE ls.lead_id = l.id
				ORDER BY ls.created_at DESC
				LIMIT 1
			) svc ON true
			WHERE te.organization_id = $1
				AND te.event_type IN ('ai', 'photo_analysis_completed')
		),
		-- Step 1: compute the time gap from the previous event in the same partition.
		with_gap AS (
			SELECT *,
				CASE
					WHEN created_at - LAG(created_at) OVER (
						PARTITION BY entity_id, event_type, category
						ORDER BY created_at
					) <= interval '15 minutes' THEN 0
					ELSE 1
				END AS is_new_cluster
			FROM unified
		),
		-- Step 2: running SUM over the gap flag to assign a cluster_id.
		clustered AS (
			SELECT *,
				SUM(is_new_cluster) OVER (
					PARTITION BY entity_id, event_type, category
					ORDER BY created_at
				) AS cluster_id
			FROM with_gap
		),
		-- Attach per-cluster count to every row, then pick the latest row per cluster.
		with_count AS (
			SELECT *,
				COUNT(*) OVER (
					PARTITION BY entity_id, event_type, category, cluster_id
				)::int AS group_count
			FROM clustered
		),
		deduped AS (
			SELECT DISTINCT ON (entity_id, event_type, category, cluster_id)
			       id, category, event_type, title, description, entity_id,
			       service_id,
			       lead_name, phone, email, lead_status, service_type, lead_score,
			       COALESCE(address, '') AS address, latitude, longitude,
			       scheduled_at, created_at, 0 AS priority,
			       group_count, COALESCE(actor_name, '') AS actor_name, raw_metadata
			FROM with_count
			ORDER BY entity_id, event_type, category, cluster_id, created_at DESC
		)
		SELECT * FROM deduped
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3
	`

	rows, err := r.pool.Query(ctx, query, organizationID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	entries := make([]ActivityFeedEntry, 0, limit)
	for rows.Next() {
		var e ActivityFeedEntry
		if err := rows.Scan(
			&e.ID,
			&e.Category,
			&e.EventType,
			&e.Title,
			&e.Description,
			&e.EntityID,
			&e.ServiceID,
			&e.LeadName,
			&e.Phone,
			&e.Email,
			&e.LeadStatus,
			&e.ServiceType,
			&e.LeadScore,
			&e.Address,
			&e.Latitude,
			&e.Longitude,
			&e.ScheduledAt,
			&e.CreatedAt,
			&e.Priority,
			&e.GroupCount,
			&e.ActorName,
			&e.RawMetadata,
		); err != nil {
			return nil, err
		}
		entries = append(entries, e)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entries, nil
}

// ListUpcomingAppointments returns soon upcoming scheduled appointments for the org.
func (r *Repository) ListUpcomingAppointments(ctx context.Context, organizationID uuid.UUID, limit int) ([]ActivityFeedEntry, error) {
	if limit <= 0 {
		limit = 5
	}

	query := `
		SELECT
			a.id,
			'appointments' AS category,
			'appointment_upcoming' AS event_type,
			a.title,
			COALESCE(a.description, '') AS description,
			a.id AS entity_id,
			COALESCE(NULLIF(trim(concat_ws(' ', l.consumer_first_name, l.consumer_last_name)), ''), '') AS lead_name,
			COALESCE(l.consumer_phone, '') AS phone,
			COALESCE(l.consumer_email, '') AS email,
			COALESCE(als.status, svc.status, '') AS lead_status,
			COALESCE(ast.name, svc.name, '') AS service_type,
			l.lead_score,
			COALESCE(
				NULLIF(a.location, ''),
				concat_ws(', ',
					concat_ws(' ', l.address_street, l.address_house_number),
					concat_ws(' ', l.address_zip_code, l.address_city)
				)
			) AS address,
			l.latitude,
			l.longitude,
			a.start_time AS scheduled_at,
			now() AS created_at,
			2 AS priority
		FROM RAC_appointments a
		LEFT JOIN RAC_leads l ON l.id = a.lead_id AND l.organization_id = a.organization_id
		LEFT JOIN RAC_lead_services als ON als.id = a.lead_service_id
		LEFT JOIN RAC_service_types ast ON ast.id = als.service_type_id AND ast.organization_id = a.organization_id
		LEFT JOIN LATERAL (
			SELECT ls.status, st.name
			FROM RAC_lead_services ls
			LEFT JOIN RAC_service_types st ON st.id = ls.service_type_id AND st.organization_id = l.organization_id
			WHERE ls.lead_id = l.id
			ORDER BY ls.created_at DESC
			LIMIT 1
		) svc ON true
		WHERE a.organization_id = $1
			AND a.status = 'scheduled'
			AND a.start_time > now()
			AND a.start_time <= now() + interval '48 hours'
		ORDER BY a.start_time ASC
		LIMIT $2
	`

	rows, err := r.pool.Query(ctx, query, organizationID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	entries := make([]ActivityFeedEntry, 0, limit)
	for rows.Next() {
		var e ActivityFeedEntry
		if err := rows.Scan(
			&e.ID,
			&e.Category,
			&e.EventType,
			&e.Title,
			&e.Description,
			&e.EntityID,
			&e.LeadName,
			&e.Phone,
			&e.Email,
			&e.LeadStatus,
			&e.ServiceType,
			&e.LeadScore,
			&e.Address,
			&e.Latitude,
			&e.Longitude,
			&e.ScheduledAt,
			&e.CreatedAt,
			&e.Priority,
		); err != nil {
			return nil, err
		}
		entries = append(entries, e)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entries, nil
}

func (r *Repository) BulkDelete(ctx context.Context, ids []uuid.UUID, organizationID uuid.UUID) (int, error) {
	result, err := r.pool.Exec(ctx, "UPDATE RAC_leads SET deleted_at = now(), updated_at = now() WHERE id = ANY($1) AND organization_id = $2 AND deleted_at IS NULL", ids, organizationID)
	if err != nil {
		return 0, err
	}
	return int(result.RowsAffected()), nil
}
</file>

<file path="internal/leads/agent/types.go">
package agent

import (
	"github.com/google/uuid"
)

// ============================================================================
// TOOL INPUT/OUTPUT TYPES
// ============================================================================

// SaveAnalysisInput is the structured input for the SaveAnalysis tool
type SaveAnalysisInput struct {
	LeadID                  string   `json:"leadId"`
	LeadServiceID           string   `json:"leadServiceId"`           // The specific service this analysis is for
	UrgencyLevel            string   `json:"urgencyLevel"`            // High, Medium, Low
	UrgencyReason           string   `json:"urgencyReason"`           // Why this urgency level
	LeadQuality             string   `json:"leadQuality"`             // Junk, Low, Potential, High, Urgent
	RecommendedAction       string   `json:"recommendedAction"`       // Reject, RequestInfo, ScheduleSurvey, CallImmediately
	MissingInformation      []string `json:"missingInformation"`      // Missing critical info for triage
	PreferredContactChannel string   `json:"preferredContactChannel"` // WhatsApp, Email
	SuggestedContactMessage string   `json:"suggestedContactMessage"` // Message to send via chosen channel
	Summary                 string   `json:"summary"`                 // Brief overall analysis
}

type SaveAnalysisOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// UpdateLeadServiceTypeInput allows the agent to correct a mismatched service type.
type UpdateLeadServiceTypeInput struct {
	LeadID        string `json:"leadId"`
	LeadServiceID string `json:"leadServiceId"`
	ServiceType   string `json:"serviceType"` // Name or slug of an active service type
	Reason        string `json:"reason"`
}

type UpdateLeadServiceTypeOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// UpdateLeadDetailsInput allows the agent to correct lead details with high confidence.
type UpdateLeadDetailsInput struct {
	LeadID       string   `json:"leadId"`
	FirstName    *string  `json:"firstName,omitempty"`
	LastName     *string  `json:"lastName,omitempty"`
	Phone        *string  `json:"phone,omitempty"`
	Email        *string  `json:"email,omitempty"`
	ConsumerRole *string  `json:"consumerRole,omitempty"`
	Street       *string  `json:"street,omitempty"`
	HouseNumber  *string  `json:"houseNumber,omitempty"`
	ZipCode      *string  `json:"zipCode,omitempty"`
	City         *string  `json:"city,omitempty"`
	Latitude     *float64 `json:"latitude,omitempty"`
	Longitude    *float64 `json:"longitude,omitempty"`
	Reason       string   `json:"reason,omitempty"`
	Confidence   *float64 `json:"confidence,omitempty"`
}

type UpdateLeadDetailsOutput struct {
	Success       bool     `json:"success"`
	Message       string   `json:"message"`
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

// UpdatePipelineStageInput updates the pipeline stage for the lead service.
type UpdatePipelineStageInput struct {
	Stage  string `json:"stage"`
	Reason string `json:"reason"`
}

type UpdatePipelineStageOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// FindMatchingPartnersInput searches for partner matches.
type FindMatchingPartnersInput struct {
	ServiceType       string   `json:"serviceType"`
	ZipCode           string   `json:"zipCode"`
	RadiusKm          int      `json:"radiusKm"`
	ExcludePartnerIDs []string `json:"excludePartnerIds"`
}

type PartnerMatch struct {
	PartnerID    string  `json:"partnerId"`
	BusinessName string  `json:"businessName"`
	Email        string  `json:"email"`
	DistanceKm   float64 `json:"distanceKm"`
}

type FindMatchingPartnersOutput struct {
	Matches []PartnerMatch `json:"matches"`
}

// CreatePartnerOfferInput creates a partner offer for the selected match.
type CreatePartnerOfferInput struct {
	PartnerID       string `json:"partnerId"`
	ExpirationHours int    `json:"expirationHours"`
	JobSummaryShort string `json:"jobSummaryShort,omitempty"`
}

type CreatePartnerOfferOutput struct {
	Success     bool   `json:"success"`
	Message     string `json:"message"`
	OfferID     string `json:"offerId,omitempty"`
	PublicToken string `json:"publicToken,omitempty"`
}

// SaveEstimationInput stores scope and price range in the timeline.
type SaveEstimationInput struct {
	Scope      string `json:"scope"`
	PriceRange string `json:"priceRange"`
	Notes      string `json:"notes"`
	Summary    string `json:"summary"`
}

type SaveEstimationOutput struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// SearchProductMaterialsInput searches the product catalog for matching materials.
type SearchProductMaterialsInput struct {
	Query      string   `json:"query"`                // Natural language description of materials needed
	Limit      int      `json:"limit"`                // Max number of results (default 5)
	UseCatalog *bool    `json:"useCatalog,omitempty"` // Prefer catalog collection when true
	MinScore   *float64 `json:"minScore,omitempty"`   // Minimum similarity score (0-1, default 0.35)
}

// ProductResult represents a product found in the catalog.
type ProductResult struct {
	ID          string   `json:"id,omitempty"` // Catalog product UUID (present for catalog items)
	Name        string   `json:"name"`
	Description string   `json:"description,omitempty"`
	Type        string   `json:"type"`           // "service", "digital_service", "product", or "material"
	PriceEuros  float64  `json:"priceEuros"`     // Unit price in euros (e.g., 7.93 = EUR 7.93)
	PriceCents  int64    `json:"priceCents"`     // Unit price in euro-cents, ready for unitPriceCents (e.g., 793)
	Unit        string   `json:"unit,omitempty"` // e.g., "per m2", "per stuk", "per m1"
	LaborTime   string   `json:"laborTime,omitempty"`
	VatRateBps  int      `json:"vatRateBps,omitempty"` // VAT rate in basis points (e.g. 2100 = 21%)
	Materials   []string `json:"materials,omitempty"`  // Included materials (human-readable names)
	Category    string   `json:"category,omitempty"`   // Product category path (e.g., "Douglas hout > balken")
	SourceURL   string   `json:"sourceUrl,omitempty"`  // Reference URL (fallback/scraped products only)
	Score       float64  `json:"score"`                // Similarity score
}

// SearchProductMaterialsOutput contains the search results.
type SearchProductMaterialsOutput struct {
	Products []ProductResult `json:"products"`
	Message  string          `json:"message"`
}

// CalculatorInput is the input for the general-purpose Calculator tool.
// The LLM MUST use this for ANY arithmetic to avoid mental-math errors.
type CalculatorInput struct {
	Operation string  `json:"operation"` // "add", "subtract", "multiply", "divide", "ceil_divide", "ceil", "floor", "round", "percentage"
	A         float64 `json:"a"`         // First operand (always required)
	B         float64 `json:"b"`         // Second operand (required for binary ops; for "round" = decimal places)
}

// CalculatorOutput returns the exact arithmetic result.
type CalculatorOutput struct {
	Result     float64 `json:"result"`     // The computed value
	Expression string  `json:"expression"` // Human-readable expression, e.g. "2  1.5 = 3"
}

// CalculateEstimateInput performs deterministic totals for materials and labor.
type CalculateEstimateInput struct {
	MaterialItems  []EstimateItem `json:"materialItems"`
	LaborHoursLow  float64        `json:"laborHoursLow"`
	LaborHoursHigh float64        `json:"laborHoursHigh"`
	HourlyRateLow  float64        `json:"hourlyRateLow"`
	HourlyRateHigh float64        `json:"hourlyRateHigh"`
	ExtraCosts     float64        `json:"extraCosts,omitempty"`
}

type EstimateItem struct {
	Label     string  `json:"label"`
	UnitPrice float64 `json:"unitPrice"`
	Quantity  float64 `json:"quantity"`
}

type CalculateEstimateOutput struct {
	MaterialSubtotal  float64 `json:"materialSubtotal"`
	LaborSubtotalLow  float64 `json:"laborSubtotalLow"`
	LaborSubtotalHigh float64 `json:"laborSubtotalHigh"`
	TotalLow          float64 `json:"totalLow"`
	TotalHigh         float64 `json:"totalHigh"`
	AppliedExtraCosts float64 `json:"appliedExtraCosts"`
}

// DraftQuoteItem represents a single line item for the DraftQuote tool.
type DraftQuoteItem struct {
	Description      string  `json:"description"`
	Quantity         string  `json:"quantity"` // e.g. "3", "1"
	UnitPriceCents   int64   `json:"unitPriceCents"`
	TaxRateBps       int     `json:"taxRateBps"`
	IsOptional       bool    `json:"isOptional,omitempty"`
	CatalogProductID *string `json:"catalogProductId,omitempty"` // UUID string from search results
}

// DraftQuoteInput is the structured input for the DraftQuote tool.
type DraftQuoteInput struct {
	Notes string           `json:"notes"`
	Items []DraftQuoteItem `json:"items"`
}

// DraftQuoteOutput is the result of the DraftQuote tool.
type DraftQuoteOutput struct {
	Success     bool   `json:"success"`
	Message     string `json:"message"`
	QuoteID     string `json:"quoteId,omitempty"`
	QuoteNumber string `json:"quoteNumber,omitempty"`
	ItemCount   int    `json:"itemCount,omitempty"`
}

// AnalyzeResponse represents the result of an analysis request
type AnalyzeResponse struct {
	Status   string          `json:"status"` // "created", "no_change", "error"
	Message  string          `json:"message"`
	Analysis *AnalysisResult `json:"analysis,omitempty"`
}

// AnalysisResult represents the analysis returned to API consumers
type AnalysisResult struct {
	ID                      uuid.UUID `json:"id"`
	LeadID                  uuid.UUID `json:"leadId"`
	LeadServiceID           uuid.UUID `json:"leadServiceId"`
	UrgencyLevel            string    `json:"urgencyLevel"`
	UrgencyReason           *string   `json:"urgencyReason,omitempty"`
	LeadQuality             string    `json:"leadQuality"`
	RecommendedAction       string    `json:"recommendedAction"`
	MissingInformation      []string  `json:"missingInformation"`
	PreferredContactChannel string    `json:"preferredContactChannel"`
	SuggestedContactMessage string    `json:"suggestedContactMessage"`
	Summary                 string    `json:"summary"`
	CreatedAt               string    `json:"createdAt"`
}
</file>

<file path="internal/leads/handler/public_handler.go">
package handler

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// PublicHandler handles public (unauthenticated) lead portal endpoints.
type PublicHandler struct {
	repo        repository.LeadsRepository
	eventBus    events.Bus
	sse         *sse.Service
	storage     storage.StorageService
	bucket      string
	val         *validator.Validator
	quoteViewer ports.QuotePublicViewer
	apptViewer  ports.AppointmentPublicViewer
	slotViewer  ports.AppointmentSlotProvider
	orgViewer   ports.OrganizationPublicViewer
}

const (
	publicMsgInvalidInput       = "Invalid input"
	publicMsgInvalidRequest     = "Invalid request"
	publicMsgLeadNotFound       = "Lead not found"
	publicMsgServiceUnavailable = "Service data unavailable"
)

// NewPublicHandler creates a new public handler for lead portal access.
func NewPublicHandler(repo repository.LeadsRepository, eventBus events.Bus, sseService *sse.Service, storageSvc storage.StorageService, bucket string, val *validator.Validator) *PublicHandler {
	return &PublicHandler{repo: repo, eventBus: eventBus, sse: sseService, storage: storageSvc, bucket: bucket, val: val}
}

// SetPublicViewers injects external data viewers (quotes and appointments).
func (h *PublicHandler) SetPublicViewers(quoteViewer ports.QuotePublicViewer, apptViewer ports.AppointmentPublicViewer, slotViewer ports.AppointmentSlotProvider) {
	h.quoteViewer = quoteViewer
	h.apptViewer = apptViewer
	h.slotViewer = slotViewer
}

// SetPublicOrgViewer injects the organization viewer for the public portal.
func (h *PublicHandler) SetPublicOrgViewer(orgViewer ports.OrganizationPublicViewer) {
	h.orgViewer = orgViewer
}

// RegisterRoutes registers public lead portal routes under /public/leads.
func (h *PublicHandler) RegisterRoutes(rg *gin.RouterGroup) {
	rg.GET("/:token", h.GetTrackAndTrace)
	if h.sse != nil {
		rg.GET(":token/events", h.sse.PublicLeadHandler(h.resolveLeadID))
	}
	rg.POST("/:token/preferences", h.UpdatePreferences)
	rg.POST("/:token/info", h.AddCustomerInfo)
	rg.GET("/:token/availability/slots", h.GetAvailabilitySlots)
	rg.POST("/:token/appointments/request", h.RequestAppointment)
	rg.POST("/:token/attachments/presign", h.PresignUpload)
	rg.POST("/:token/attachments", h.ConfirmUpload)
	rg.DELETE("/:token/attachments/:attachmentId", h.DeleteAttachment)
}

func (h *PublicHandler) resolveLeadID(token string) (uuid.UUID, error) {
	ctx := context.Background()
	lead, err := h.repo.GetByPublicToken(ctx, token)
	if err != nil {
		return uuid.UUID{}, err
	}
	return lead.ID, nil
}

type PublicPreferencesRequest struct {
	Budget       string `json:"budget" validate:"omitempty,max=200"`
	Timeframe    string `json:"timeframe" validate:"omitempty,max=200"`
	Availability string `json:"availability" validate:"omitempty,max=2000"`
	ExtraNotes   string `json:"extraNotes" validate:"omitempty,max=2000"`
}

type PublicAvailabilitySlotsQuery struct {
	StartDate    string `form:"startDate" validate:"required"`
	EndDate      string `form:"endDate" validate:"required"`
	SlotDuration int    `form:"slotDuration"`
}

type PublicAppointmentRequest struct {
	UserID    uuid.UUID `json:"userId" validate:"required"`
	StartTime time.Time `json:"startTime" validate:"required"`
	EndTime   time.Time `json:"endTime" validate:"required,gtfield=StartTime"`
}

// GetTrackAndTrace returns the public portal data for a lead based on a token.
func (h *PublicHandler) GetTrackAndTrace(c *gin.Context) {
	token := c.Param("token")
	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, "Link expired or invalid", nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	var quote *ports.PublicQuoteSummary
	if h.quoteViewer != nil {
		quote, _ = h.quoteViewer.GetActiveQuote(c.Request.Context(), lead.ID, lead.OrganizationID)
	}

	appt, pendingAppt := h.resolvePublicAppointments(c.Request.Context(), lead.ID, lead.OrganizationID)
	appointments := h.resolvePublicAppointmentsList(c.Request.Context(), lead.ID, lead.OrganizationID)
	slotsAvailable := h.resolveSlotsAvailable(c.Request.Context(), &lead)

	statusLabel, statusDescription, step := resolveCustomerStatus(svc.PipelineStage, quote, appt)

	prefs := normalizePreferences(svc.CustomerPreferences)
	quoteLink, downloadLink := buildQuoteLinks(quote)

	attachments, err := h.repo.ListAttachmentsByService(c.Request.Context(), svc.ID, lead.OrganizationID)
	if err != nil {
		attachments = nil
	}

	attachmentItems := buildAttachmentItems(c.Request.Context(), h.storage, h.bucket, attachments)

	orgPhone := ""
	if h.orgViewer != nil {
		phone, err := h.orgViewer.GetPublicPhone(c.Request.Context(), lead.OrganizationID)
		if err == nil {
			orgPhone = phone
		}
	}

	response := gin.H{
		"consumerName": strings.TrimSpace(lead.ConsumerFirstName),
		"city":         lead.AddressCity,
		"serviceType":  svc.ServiceType,
		"createdAt":    lead.CreatedAt,
		"preferences":  prefs,
		"status": gin.H{
			"label":       statusLabel,
			"description": statusDescription,
			"step":        step,
		},
		"appointment":        appt,
		"appointmentRequest": pendingAppt,
		"appointments":       appointments,
		"organizationPhone":  orgPhone,
		"slotsAvailable":     slotsAvailable,
		"quote": gin.H{
			"available":    quote != nil,
			"status":       statusStatus(quote),
			"link":         quoteLink,
			"downloadLink": downloadLink,
		},
		"attachments": attachmentItems,
	}

	httpkit.OK(c, response)
}

// UpdatePreferences stores lead preferences and triggers AI refresh.
func (h *PublicHandler) UpdatePreferences(c *gin.Context) {
	token := c.Param("token")
	var req PublicPreferencesRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, err.Error())
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}
	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	prefsJSON, err := json.Marshal(req)
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, nil)
		return
	}

	if err := h.repo.UpdateServicePreferences(c.Request.Context(), svc.ID, lead.OrganizationID, prefsJSON); err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Failed to save preferences", nil)
		return
	}

	summary := "Klant heeft voorkeuren bijgewerkt (Budget/Tijd/Beschikbaarheid)"
	_, _ = h.repo.CreateTimelineEvent(c.Request.Context(), repository.CreateTimelineEventParams{
		LeadID:         lead.ID,
		ServiceID:      &svc.ID,
		OrganizationID: lead.OrganizationID,
		ActorType:      "Lead",
		ActorName:      "Klant",
		EventType:      "preferences_updated",
		Title:          "Voorkeuren bijgewerkt",
		Summary:        &summary,
		Metadata: map[string]any{
			"budget":       req.Budget,
			"timeframe":    req.Timeframe,
			"availability": req.Availability,
			"extraNotes":   req.ExtraNotes,
		},
	})

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		Source:        "customer_preferences",
	})

	httpkit.OK(c, gin.H{"status": "updated"})
}

// AddCustomerInfo allows the lead to add extra context.
func (h *PublicHandler) AddCustomerInfo(c *gin.Context) {
	token := c.Param("token")
	var req struct {
		Text string `json:"text" validate:"required,min=5,max=2000"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, err.Error())
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	summary := fmt.Sprintf("Klant heeft info toegevoegd via portaal: %s", req.Text)
	_, _ = h.repo.CreateTimelineEvent(c.Request.Context(), repository.CreateTimelineEventParams{
		LeadID:         lead.ID,
		ServiceID:      &svc.ID,
		OrganizationID: lead.OrganizationID,
		ActorType:      "Lead",
		ActorName:      "Klant",
		EventType:      "info_added",
		Title:          "Klant update",
		Summary:        &summary,
		Metadata: map[string]any{
			"text": req.Text,
		},
	})

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		Source:        "customer_portal_update",
	})

	httpkit.OK(c, gin.H{"status": "received"})
}

// GetAvailabilitySlots returns available inspection slots for the organization.
func (h *PublicHandler) GetAvailabilitySlots(c *gin.Context) {
	token := c.Param("token")
	var req PublicAvailabilitySlotsQuery
	if err := c.ShouldBindQuery(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, err.Error())
		return
	}
	if req.SlotDuration == 0 {
		req.SlotDuration = 60
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	if h.slotViewer == nil {
		httpkit.OK(c, ports.PublicAvailableSlotsResponse{Days: []ports.PublicDaySlots{}})
		return
	}

	resp, err := h.slotViewer.GetAvailableSlots(c.Request.Context(), lead.OrganizationID, req.StartDate, req.EndDate, req.SlotDuration)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	httpkit.OK(c, resp)
}

// RequestAppointment creates a requested inspection appointment for the lead.
func (h *PublicHandler) RequestAppointment(c *gin.Context) {
	token := c.Param("token")
	var req PublicAppointmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidInput, err.Error())
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	if h.slotViewer == nil {
		httpkit.Error(c, http.StatusBadRequest, "Planning niet beschikbaar", nil)
		return
	}

	appointment, err := h.slotViewer.CreateRequestedAppointment(c.Request.Context(), req.UserID, lead.OrganizationID, lead.ID, svc.ID, req.StartTime, req.EndTime)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Afspraak aanvragen mislukt", nil)
		return
	}

	startLabel := req.StartTime.Format("02-01-2006 om 15:04")
	summary := fmt.Sprintf("Klant heeft een inspectie aangevraagd voor %s", startLabel)
	_, _ = h.repo.CreateTimelineEvent(c.Request.Context(), repository.CreateTimelineEventParams{
		LeadID:         lead.ID,
		ServiceID:      &svc.ID,
		OrganizationID: lead.OrganizationID,
		ActorType:      "Lead",
		ActorName:      "Klant",
		EventType:      "appointment_requested",
		Title:          "Inspectie aangevraagd",
		Summary:        &summary,
		Metadata: map[string]any{
			"startTime": req.StartTime,
			"endTime":   req.EndTime,
		},
	})

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		Source:        "appointment_request",
	})

	httpkit.OK(c, gin.H{"status": "requested", "appointment": appointment})
}

// PresignUpload handles file upload initialization for the public portal.
func (h *PublicHandler) PresignUpload(c *gin.Context) {
	token := c.Param("token")
	var req transport.PresignedUploadRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, err.Error())
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	if err := h.storage.ValidateContentType(req.ContentType); err != nil {
		httpkit.Error(c, http.StatusBadRequest, "Invalid file type", nil)
		return
	}
	if err := h.storage.ValidateFileSize(req.SizeBytes); err != nil {
		httpkit.Error(c, http.StatusBadRequest, err.Error(), nil)
		return
	}

	folder := fmt.Sprintf("%s/%s/%s/customer_uploads", lead.OrganizationID, lead.ID, svc.ID)
	presigned, err := h.storage.GenerateUploadURL(c.Request.Context(), h.bucket, folder, req.FileName, req.ContentType, req.SizeBytes)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Storage error", nil)
		return
	}

	httpkit.OK(c, transport.PresignedUploadResponse{
		UploadURL: presigned.URL,
		FileKey:   presigned.FileKey,
		ExpiresAt: presigned.ExpiresAt.Unix(),
	})
}

// ConfirmUpload finalizes the upload and triggers AI refresh.
func (h *PublicHandler) ConfirmUpload(c *gin.Context) {
	token := c.Param("token")
	var req transport.CreateAttachmentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, nil)
		return
	}
	if err := h.val.Struct(req); err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, err.Error())
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	att, err := h.repo.CreateAttachment(c.Request.Context(), repository.CreateAttachmentParams{
		LeadServiceID:  svc.ID,
		OrganizationID: lead.OrganizationID,
		FileKey:        req.FileKey,
		FileName:       req.FileName,
		ContentType:    req.ContentType,
		SizeBytes:      req.SizeBytes,
		UploadedBy:     nil,
	})
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Failed to save attachment", nil)
		return
	}

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		Source:        "customer_portal_upload",
	})

	h.eventBus.Publish(c.Request.Context(), events.AttachmentUploaded{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		AttachmentID:  att.ID,
		FileName:      req.FileName,
		ContentType:   req.ContentType,
	})

	httpkit.OK(c, gin.H{"status": "ok"})
}

// DeleteAttachment removes a public-uploaded attachment.
func (h *PublicHandler) DeleteAttachment(c *gin.Context) {
	token := c.Param("token")
	attachmentID, err := uuid.Parse(c.Param("attachmentId"))
	if err != nil {
		httpkit.Error(c, http.StatusBadRequest, publicMsgInvalidRequest, nil)
		return
	}

	lead, err := h.repo.GetByPublicToken(c.Request.Context(), token)
	if err != nil {
		httpkit.Error(c, http.StatusNotFound, publicMsgLeadNotFound, nil)
		return
	}

	svc, err := h.repo.GetCurrentLeadService(c.Request.Context(), lead.ID, lead.OrganizationID)
	if err != nil {
		httpkit.Error(c, http.StatusInternalServerError, publicMsgServiceUnavailable, nil)
		return
	}

	att, err := h.repo.GetAttachmentByID(c.Request.Context(), attachmentID, lead.OrganizationID)
	if err != nil {
		if errors.Is(err, repository.ErrAttachmentNotFound) {
			httpkit.Error(c, http.StatusNotFound, "Attachment not found", nil)
			return
		}
		httpkit.Error(c, http.StatusInternalServerError, "Failed to load attachment", nil)
		return
	}
	if att.LeadServiceID != svc.ID {
		httpkit.Error(c, http.StatusNotFound, "Attachment not found", nil)
		return
	}

	if err := h.storage.DeleteObject(c.Request.Context(), h.bucket, att.FileKey); err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Failed to delete attachment", nil)
		return
	}
	if err := h.repo.DeleteAttachment(c.Request.Context(), attachmentID, lead.OrganizationID); err != nil {
		httpkit.Error(c, http.StatusInternalServerError, "Failed to delete attachment", nil)
		return
	}

	h.eventBus.Publish(c.Request.Context(), events.LeadDataChanged{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        lead.ID,
		LeadServiceID: svc.ID,
		TenantID:      lead.OrganizationID,
		Source:        "customer_portal_delete",
	})

	httpkit.OK(c, gin.H{"status": "deleted"})
}

func resolveCustomerStatus(stage string, quote *ports.PublicQuoteSummary, appt *ports.PublicAppointmentSummary) (string, string, int) {
	if quote != nil && quote.Status == "Accepted" {
		if stage == "Completed" {
			return "Afgerond", "De werkzaamheden zijn succesvol afgerond.", 4
		}
		return "In Planning", "Bedankt voor uw akkoord! We bereiden de uitvoering voor.", 3
	}

	if quote != nil && quote.Status == "Sent" {
		return "Offerte Klaar", "Er staat een offerte voor u klaar. Bekijk en onderteken deze digitaal.", 3
	}

	if appt != nil {
		apptDate := appt.StartTime.Format("02-01-2006 om 15:04")
		return "In planning", fmt.Sprintf("We hebben een moment gereserveerd op %s.", apptDate), 2
	}

	switch stage {
	case "Triage", "Nurturing", "Manual_Intervention":
		return "Aanvraag Ontvangen", "We hebben uw aanvraag ontvangen en controleren de details.", 1
	case "Ready_For_Estimator":
		return "In Beoordeling", "Onze experts maken een inschatting van de situatie.", 2
	case "Ready_For_Partner", "Partner_Matching", "Partner_Assigned":
		return "In planning", "We plannen een moment voor de volgende stap.", 2
	case "Lost":
		return "Gesloten", "Deze aanvraag is gesloten.", 1
	default:
		return "In Behandeling", "We zijn met uw aanvraag bezig.", 1
	}
}

func statusStatus(quote *ports.PublicQuoteSummary) string {
	if quote == nil {
		return ""
	}
	return quote.Status
}

func normalizePreferences(prefs json.RawMessage) json.RawMessage {
	if len(prefs) == 0 {
		return json.RawMessage(`{}`)
	}
	return prefs
}

func buildQuoteLinks(quote *ports.PublicQuoteSummary) (string, string) {
	if quote == nil {
		return "", ""
	}
	quoteLink := fmt.Sprintf("/quote/%s", quote.PublicToken)
	if quote.Status == "Accepted" && quote.PublicToken != "" {
		return quoteLink, fmt.Sprintf("/api/v1/public/quotes/%s/pdf", quote.PublicToken)
	}
	return quoteLink, ""
}

func buildAttachmentItems(ctx context.Context, storageSvc storage.StorageService, bucket string, attachments []repository.Attachment) []transport.AttachmentResponse {
	items := make([]transport.AttachmentResponse, 0, len(attachments))
	for _, att := range attachments {
		var downloadURL *string
		if presigned, err := storageSvc.GenerateDownloadURL(ctx, bucket, att.FileKey); err == nil {
			url := presigned.URL
			downloadURL = &url
		}
		items = append(items, toAttachmentResponse(att, downloadURL))
	}
	return items
}

func (h *PublicHandler) resolvePublicAppointments(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (*ports.PublicAppointmentSummary, *ports.PublicAppointmentSummary) {
	if h.apptViewer == nil {
		return nil, nil
	}
	appt, _ := h.apptViewer.GetUpcomingVisit(ctx, leadID, organizationID)
	pending, _ := h.apptViewer.GetPendingVisit(ctx, leadID, organizationID)
	return appt, pending
}

func (h *PublicHandler) resolvePublicAppointmentsList(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) []ports.PublicAppointmentSummary {
	if h.apptViewer == nil {
		return []ports.PublicAppointmentSummary{}
	}
	items, err := h.apptViewer.ListVisits(ctx, leadID, organizationID)
	if err != nil {
		return []ports.PublicAppointmentSummary{}
	}
	return items
}

func (h *PublicHandler) resolveSlotsAvailable(ctx context.Context, lead *repository.Lead) bool {
	if h.slotViewer == nil {
		return false
	}
	available, _ := h.slotViewer.HasAvailabilityRules(ctx, lead.OrganizationID)
	return available
}
</file>

<file path="internal/quotes/repository/repository.go">
package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

//  Domain Models 

// Quote is the database model for a quote header
type Quote struct {
	ID                         uuid.UUID  `db:"id"`
	OrganizationID             uuid.UUID  `db:"organization_id"`
	LeadID                     uuid.UUID  `db:"lead_id"`
	LeadServiceID              *uuid.UUID `db:"lead_service_id"`
	CreatedByID                *uuid.UUID `db:"created_by_id"`
	CreatedByFirstName         *string    `db:"created_by_first_name"`
	CreatedByLastName          *string    `db:"created_by_last_name"`
	CreatedByEmail             *string    `db:"created_by_email"`
	CustomerFirstName          *string    `db:"consumer_first_name"`
	CustomerLastName           *string    `db:"consumer_last_name"`
	CustomerPhone              *string    `db:"consumer_phone"`
	CustomerEmail              *string    `db:"consumer_email"`
	CustomerAddressStreet      *string    `db:"address_street"`
	CustomerAddressHouseNumber *string    `db:"address_house_number"`
	CustomerAddressZipCode     *string    `db:"address_zip_code"`
	CustomerAddressCity        *string    `db:"address_city"`
	QuoteNumber                string     `db:"quote_number"`
	Status                     string     `db:"status"`
	PricingMode                string     `db:"pricing_mode"`
	DiscountType               string     `db:"discount_type"`
	DiscountValue              int64      `db:"discount_value"`
	SubtotalCents              int64      `db:"subtotal_cents"`
	DiscountAmountCents        int64      `db:"discount_amount_cents"`
	TaxTotalCents              int64      `db:"tax_total_cents"`
	TotalCents                 int64      `db:"total_cents"`
	ValidUntil                 *time.Time `db:"valid_until"`
	Notes                      *string    `db:"notes"`
	PublicToken                *string    `db:"public_token"`
	PublicTokenExpAt           *time.Time `db:"public_token_expires_at"`
	PreviewToken               *string    `db:"preview_token"`
	PreviewTokenExpAt          *time.Time `db:"preview_token_expires_at"`
	ViewedAt                   *time.Time `db:"viewed_at"`
	AcceptedAt                 *time.Time `db:"accepted_at"`
	RejectedAt                 *time.Time `db:"rejected_at"`
	RejectionReason            *string    `db:"rejection_reason"`
	SignatureName              *string    `db:"signature_name"`
	SignatureData              *string    `db:"signature_data"`
	SignatureIP                *string    `db:"signature_ip"`
	PDFFileKey                 *string    `db:"pdf_file_key"`
	FinancingDisclaimer        bool       `db:"financing_disclaimer"`
	CreatedAt                  time.Time  `db:"created_at"`
	UpdatedAt                  time.Time  `db:"updated_at"`
}

// QuoteItem is the database model for a quote line item
type QuoteItem struct {
	ID               uuid.UUID  `db:"id"`
	QuoteID          uuid.UUID  `db:"quote_id"`
	OrganizationID   uuid.UUID  `db:"organization_id"`
	Description      string     `db:"description"`
	Quantity         string     `db:"quantity"`
	QuantityNumeric  float64    `db:"quantity_numeric"`
	UnitPriceCents   int64      `db:"unit_price_cents"`
	TaxRateBps       int        `db:"tax_rate"`
	IsOptional       bool       `db:"is_optional"`
	IsSelected       bool       `db:"is_selected"`
	SortOrder        int        `db:"sort_order"`
	CatalogProductID *uuid.UUID `db:"catalog_product_id"`
	CreatedAt        time.Time  `db:"created_at"`
}

// QuoteAnnotation is the database model for a quote line item annotation
type QuoteAnnotation struct {
	ID             uuid.UUID  `db:"id"`
	QuoteItemID    uuid.UUID  `db:"quote_item_id"`
	OrganizationID uuid.UUID  `db:"organization_id"`
	AuthorType     string     `db:"author_type"`
	AuthorID       *uuid.UUID `db:"author_id"`
	Text           string     `db:"text"`
	IsResolved     bool       `db:"is_resolved"`
	CreatedAt      time.Time  `db:"created_at"`
}

// ListParams contains parameters for listing quotes
type ListParams struct {
	OrganizationID uuid.UUID
	LeadID         *uuid.UUID
	Status         *string
	Search         string
	CreatedAtFrom  *time.Time
	CreatedAtTo    *time.Time
	ValidUntilFrom *time.Time
	ValidUntilTo   *time.Time
	TotalFrom      *int64
	TotalTo        *int64
	SortBy         string
	SortOrder      string
	Page           int
	PageSize       int
}

// ListResult contains the paginated result of listing quotes
type ListResult struct {
	Items      []Quote
	Total      int
	Page       int
	PageSize   int
	TotalPages int
}

type quoteListFilters struct {
	leadID         interface{}
	status         interface{}
	search         interface{}
	createdAtFrom  interface{}
	createdAtTo    interface{}
	validUntilFrom interface{}
	validUntilTo   interface{}
	totalFrom      interface{}
	totalTo        interface{}
}

func buildQuoteListFilters(params ListParams) quoteListFilters {
	return quoteListFilters{
		leadID:         nullable(params.LeadID),
		status:         nullable(params.Status),
		search:         optionalSearchParam(params.Search),
		createdAtFrom:  nullable(params.CreatedAtFrom),
		createdAtTo:    nullable(params.CreatedAtTo),
		validUntilFrom: nullable(params.ValidUntilFrom),
		validUntilTo:   nullable(params.ValidUntilTo),
		totalFrom:      nullable(params.TotalFrom),
		totalTo:        nullable(params.TotalTo),
	}
}

//  Repository 

const quoteNotFoundMsg = "quote not found"

// Repository provides database operations for quotes
type Repository struct {
	pool *pgxpool.Pool
}

// New creates a new quotes repository
func New(pool *pgxpool.Pool) *Repository {
	return &Repository{pool: pool}
}

// NextQuoteNumber atomically generates the next quote number for an organization
func (r *Repository) NextQuoteNumber(ctx context.Context, orgID uuid.UUID) (string, error) {
	var nextNum int
	query := `
		INSERT INTO RAC_quote_counters (organization_id, last_number)
		VALUES ($1, 1)
		ON CONFLICT (organization_id) DO UPDATE SET last_number = RAC_quote_counters.last_number + 1
		RETURNING last_number`

	if err := r.pool.QueryRow(ctx, query, orgID).Scan(&nextNum); err != nil {
		return "", fmt.Errorf("failed to generate quote number: %w", err)
	}

	year := time.Now().Year()
	return fmt.Sprintf("OFF-%d-%04d", year, nextNum), nil
}

// CreateWithItems inserts a quote and its line items in a single transaction
func (r *Repository) CreateWithItems(ctx context.Context, quote *Quote, items []QuoteItem) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	quoteQuery := `
		INSERT INTO RAC_quotes (
			id, organization_id, lead_id, lead_service_id, created_by_id, quote_number, status,
			pricing_mode, discount_type, discount_value,
			subtotal_cents, discount_amount_cents, tax_total_cents, total_cents,
			valid_until, notes, financing_disclaimer, created_at, updated_at,
			public_token, public_token_expires_at, preview_token, preview_token_expires_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23)`

	if _, err := tx.Exec(ctx, quoteQuery,
		quote.ID, quote.OrganizationID, quote.LeadID, quote.LeadServiceID, quote.CreatedByID,
		quote.QuoteNumber, quote.Status, quote.PricingMode, quote.DiscountType, quote.DiscountValue,
		quote.SubtotalCents, quote.DiscountAmountCents, quote.TaxTotalCents, quote.TotalCents,
		quote.ValidUntil, quote.Notes, quote.FinancingDisclaimer, quote.CreatedAt, quote.UpdatedAt,
		quote.PublicToken, quote.PublicTokenExpAt, quote.PreviewToken, quote.PreviewTokenExpAt,
	); err != nil {
		return fmt.Errorf("failed to insert quote: %w", err)
	}

	if err := r.insertItems(ctx, tx, items); err != nil {
		return err
	}

	return tx.Commit(ctx)
}

// UpdateWithItems updates a quote and optionally replaces its line items
func (r *Repository) UpdateWithItems(ctx context.Context, quote *Quote, items []QuoteItem, replaceItems bool) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	updateQuery := `
		UPDATE RAC_quotes SET
			pricing_mode = $2, discount_type = $3, discount_value = $4,
			subtotal_cents = $5, discount_amount_cents = $6, tax_total_cents = $7, total_cents = $8,
			valid_until = $9, notes = $10, financing_disclaimer = $11, updated_at = $12
		WHERE id = $1 AND organization_id = $13`

	result, err := tx.Exec(ctx, updateQuery,
		quote.ID, quote.PricingMode, quote.DiscountType, quote.DiscountValue,
		quote.SubtotalCents, quote.DiscountAmountCents, quote.TaxTotalCents, quote.TotalCents,
		quote.ValidUntil, quote.Notes, quote.FinancingDisclaimer, quote.UpdatedAt, quote.OrganizationID,
	)
	if err != nil {
		return fmt.Errorf("failed to update quote: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(quoteNotFoundMsg)
	}

	if replaceItems {
		// Delete existing items and insert new ones
		if _, err := tx.Exec(ctx, `DELETE FROM RAC_quote_items WHERE quote_id = $1 AND organization_id = $2`, quote.ID, quote.OrganizationID); err != nil {
			return fmt.Errorf("failed to delete old quote items: %w", err)
		}
		if err := r.insertItems(ctx, tx, items); err != nil {
			return err
		}
	}

	return tx.Commit(ctx)
}

func (r *Repository) insertItems(ctx context.Context, tx pgx.Tx, items []QuoteItem) error {
	itemQuery := `
		INSERT INTO RAC_quote_items (
			id, quote_id, organization_id, description, quantity, quantity_numeric,
			unit_price_cents, tax_rate, is_optional, is_selected, sort_order, catalog_product_id, created_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)`

	for _, item := range items {
		if _, err := tx.Exec(ctx, itemQuery,
			item.ID, item.QuoteID, item.OrganizationID,
			item.Description, item.Quantity, item.QuantityNumeric,
			item.UnitPriceCents, item.TaxRateBps, item.IsOptional, item.IsSelected, item.SortOrder, item.CatalogProductID, item.CreatedAt,
		); err != nil {
			return fmt.Errorf("failed to insert quote item: %w", err)
		}
	}
	return nil
}

// GetByID retrieves a quote by its ID scoped to organization
func (r *Repository) GetByID(ctx context.Context, id uuid.UUID, orgID uuid.UUID) (*Quote, error) {
	var q Quote
	query := `
		SELECT q.id, q.organization_id, q.lead_id, q.lead_service_id, q.created_by_id,
			u.first_name, u.last_name, u.email,
			q.quote_number, q.status,
			pricing_mode, discount_type, discount_value,
			subtotal_cents, discount_amount_cents, tax_total_cents, total_cents,
			valid_until, notes, q.created_at, q.updated_at,
			public_token, public_token_expires_at, preview_token, preview_token_expires_at,
			viewed_at, accepted_at, rejected_at,
			rejection_reason, signature_name, signature_data, signature_ip, pdf_file_key,
			q.financing_disclaimer
		FROM RAC_quotes q
		LEFT JOIN RAC_users u ON u.id = q.created_by_id
		WHERE q.id = $1 AND q.organization_id = $2`

	err := r.pool.QueryRow(ctx, query, id, orgID).Scan(
		&q.ID, &q.OrganizationID, &q.LeadID, &q.LeadServiceID, &q.CreatedByID,
		&q.CreatedByFirstName, &q.CreatedByLastName, &q.CreatedByEmail,
		&q.QuoteNumber, &q.Status,
		&q.PricingMode, &q.DiscountType, &q.DiscountValue,
		&q.SubtotalCents, &q.DiscountAmountCents, &q.TaxTotalCents, &q.TotalCents,
		&q.ValidUntil, &q.Notes, &q.CreatedAt, &q.UpdatedAt,
		&q.PublicToken, &q.PublicTokenExpAt, &q.PreviewToken, &q.PreviewTokenExpAt,
		&q.ViewedAt, &q.AcceptedAt, &q.RejectedAt,
		&q.RejectionReason, &q.SignatureName, &q.SignatureData, &q.SignatureIP, &q.PDFFileKey,
		&q.FinancingDisclaimer,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound(quoteNotFoundMsg)
		}
		return nil, fmt.Errorf("failed to get quote: %w", err)
	}
	return &q, nil
}

// GetLatestNonDraftByLead returns the most recent non-draft quote for a lead.
func (r *Repository) GetLatestNonDraftByLead(ctx context.Context, leadID uuid.UUID, orgID uuid.UUID) (*Quote, error) {
	var q Quote
	query := `
		SELECT id, organization_id, lead_id, lead_service_id, quote_number, status, total_cents, public_token, pdf_file_key
		FROM RAC_quotes
		WHERE lead_id = $1 AND organization_id = $2 AND status != 'Draft'
		ORDER BY created_at DESC
		LIMIT 1
	`

	err := r.pool.QueryRow(ctx, query, leadID, orgID).Scan(
		&q.ID, &q.OrganizationID, &q.LeadID, &q.LeadServiceID, &q.QuoteNumber, &q.Status, &q.TotalCents, &q.PublicToken, &q.PDFFileKey,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get latest non-draft quote: %w", err)
	}
	return &q, nil
}

// GetItemsByQuoteID retrieves all items for a quote
func (r *Repository) GetItemsByQuoteID(ctx context.Context, quoteID uuid.UUID, orgID uuid.UUID) ([]QuoteItem, error) {
	query := `
		SELECT id, quote_id, organization_id, description, quantity, quantity_numeric,
			unit_price_cents, tax_rate, is_optional, is_selected, sort_order, catalog_product_id, created_at
		FROM RAC_quote_items WHERE quote_id = $1 AND organization_id = $2
		ORDER BY sort_order ASC`

	rows, err := r.pool.Query(ctx, query, quoteID, orgID)
	if err != nil {
		return nil, fmt.Errorf("failed to query quote items: %w", err)
	}
	defer rows.Close()

	var items []QuoteItem
	for rows.Next() {
		var it QuoteItem
		if err := rows.Scan(
			&it.ID, &it.QuoteID, &it.OrganizationID,
			&it.Description, &it.Quantity, &it.QuantityNumeric,
			&it.UnitPriceCents, &it.TaxRateBps, &it.IsOptional, &it.IsSelected, &it.SortOrder, &it.CatalogProductID, &it.CreatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan quote item: %w", err)
		}
		items = append(items, it)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate quote items: %w", err)
	}
	return items, nil
}

// UpdateStatus updates the status of a quote
func (r *Repository) UpdateStatus(ctx context.Context, id uuid.UUID, orgID uuid.UUID, status string) error {
	query := `UPDATE RAC_quotes SET status = $3, updated_at = $4 WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, id, orgID, status, time.Now())
	if err != nil {
		return fmt.Errorf("failed to update quote status: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(quoteNotFoundMsg)
	}
	return nil
}

// Delete removes a quote (cascade deletes items)
func (r *Repository) Delete(ctx context.Context, id uuid.UUID, orgID uuid.UUID) error {
	query := `DELETE FROM RAC_quotes WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, id, orgID)
	if err != nil {
		return fmt.Errorf("failed to delete quote: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(quoteNotFoundMsg)
	}
	return nil
}

// List retrieves quotes with filtering and pagination
func (r *Repository) List(ctx context.Context, params ListParams) (*ListResult, error) {
	sortBy, err := resolveSortBy(params.SortBy)
	if err != nil {
		return nil, err
	}
	sortOrder, err := resolveSortOrder(params.SortOrder)
	if err != nil {
		return nil, err
	}

	filters := buildQuoteListFilters(params)

	baseQuery := `
		FROM RAC_quotes q
		LEFT JOIN RAC_leads l ON l.id = q.lead_id AND l.organization_id = q.organization_id
		LEFT JOIN RAC_users u ON u.id = q.created_by_id
		WHERE q.organization_id = $1
			AND ($2::uuid IS NULL OR q.lead_id = $2)
			AND ($3::text IS NULL OR q.status::text = $3)
			AND ($4::text IS NULL OR (
				q.quote_number ILIKE $4 OR q.notes ILIKE $4
				OR l.consumer_first_name ILIKE $4 OR l.consumer_last_name ILIKE $4
				OR l.consumer_phone ILIKE $4 OR l.consumer_email ILIKE $4
				OR l.address_street ILIKE $4 OR l.address_house_number ILIKE $4
				OR l.address_zip_code ILIKE $4 OR l.address_city ILIKE $4
				OR u.first_name ILIKE $4 OR u.last_name ILIKE $4 OR u.email ILIKE $4
				OR EXISTS (
					SELECT 1
					FROM RAC_quote_items qi
					WHERE qi.quote_id = q.id AND qi.organization_id = q.organization_id
						AND qi.description ILIKE $4
				)
			))
			AND ($5::timestamptz IS NULL OR q.created_at >= $5)
			AND ($6::timestamptz IS NULL OR q.created_at < $6)
			AND ($7::timestamptz IS NULL OR q.valid_until >= $7)
			AND ($8::timestamptz IS NULL OR q.valid_until < $8)
			AND ($9::bigint IS NULL OR q.total_cents >= $9)
			AND ($10::bigint IS NULL OR q.total_cents <= $10)
	`
	args := []interface{}{
		params.OrganizationID,
		filters.leadID,
		filters.status,
		filters.search,
		filters.createdAtFrom,
		filters.createdAtTo,
		filters.validUntilFrom,
		filters.validUntilTo,
		filters.totalFrom,
		filters.totalTo,
	}

	var total int
	if err := r.pool.QueryRow(ctx, "SELECT COUNT(DISTINCT q.id) "+baseQuery, args...).Scan(&total); err != nil {
		return nil, fmt.Errorf("failed to count quotes: %w", err)
	}

	totalPages := (total + params.PageSize - 1) / params.PageSize
	offset := (params.Page - 1) * params.PageSize

	selectQuery := `
		SELECT q.id, q.organization_id, q.lead_id, q.lead_service_id,
			q.created_by_id, u.first_name, u.last_name, u.email,
			l.consumer_first_name, l.consumer_last_name, l.consumer_phone, l.consumer_email,
			l.address_street, l.address_house_number, l.address_zip_code, l.address_city,
			q.quote_number, q.status, q.pricing_mode, q.discount_type, q.discount_value,
			q.subtotal_cents, q.discount_amount_cents, q.tax_total_cents, q.total_cents,
			q.valid_until, q.notes, q.created_at, q.updated_at,
			q.public_token, q.public_token_expires_at, q.preview_token, q.preview_token_expires_at,
			q.viewed_at, q.accepted_at, q.rejected_at,
			q.rejection_reason, q.signature_name, q.signature_data, q.signature_ip, q.pdf_file_key,
			q.financing_disclaimer
		` + baseQuery + `
		ORDER BY
			CASE WHEN $11 = 'quoteNumber' AND $12 = 'asc' THEN q.quote_number END ASC,
			CASE WHEN $11 = 'quoteNumber' AND $12 = 'desc' THEN q.quote_number END DESC,
			CASE WHEN $11 = 'status' AND $12 = 'asc' THEN q.status::text END ASC,
			CASE WHEN $11 = 'status' AND $12 = 'desc' THEN q.status::text END DESC,
			CASE WHEN $11 = 'total' AND $12 = 'asc' THEN q.total_cents END ASC,
			CASE WHEN $11 = 'total' AND $12 = 'desc' THEN q.total_cents END DESC,
			CASE WHEN $11 = 'validUntil' AND $12 = 'asc' THEN q.valid_until END ASC,
			CASE WHEN $11 = 'validUntil' AND $12 = 'desc' THEN q.valid_until END DESC,
			CASE WHEN $11 = 'customerName' AND $12 = 'asc' THEN l.consumer_last_name END ASC,
			CASE WHEN $11 = 'customerName' AND $12 = 'desc' THEN l.consumer_last_name END DESC,
			CASE WHEN $11 = 'customerPhone' AND $12 = 'asc' THEN l.consumer_phone END ASC,
			CASE WHEN $11 = 'customerPhone' AND $12 = 'desc' THEN l.consumer_phone END DESC,
			CASE WHEN $11 = 'customerAddress' AND $12 = 'asc' THEN l.address_city END ASC,
			CASE WHEN $11 = 'customerAddress' AND $12 = 'desc' THEN l.address_city END DESC,
			CASE WHEN $11 = 'createdBy' AND $12 = 'asc' THEN u.last_name END ASC,
			CASE WHEN $11 = 'createdBy' AND $12 = 'desc' THEN u.last_name END DESC,
			CASE WHEN $11 = 'createdAt' AND $12 = 'asc' THEN q.created_at END ASC,
			CASE WHEN $11 = 'createdAt' AND $12 = 'desc' THEN q.created_at END DESC,
			CASE WHEN $11 = 'updatedAt' AND $12 = 'asc' THEN q.updated_at END ASC,
			CASE WHEN $11 = 'updatedAt' AND $12 = 'desc' THEN q.updated_at END DESC,
			q.created_at DESC
		LIMIT $13 OFFSET $14`

	args = append(args, sortBy, sortOrder, params.PageSize, offset)

	rows, err := r.pool.Query(ctx, selectQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list quotes: %w", err)
	}
	defer rows.Close()

	var items []Quote
	for rows.Next() {
		var q Quote
		if err := rows.Scan(
			&q.ID, &q.OrganizationID, &q.LeadID, &q.LeadServiceID,
			&q.CreatedByID, &q.CreatedByFirstName, &q.CreatedByLastName, &q.CreatedByEmail,
			&q.CustomerFirstName, &q.CustomerLastName, &q.CustomerPhone, &q.CustomerEmail,
			&q.CustomerAddressStreet, &q.CustomerAddressHouseNumber, &q.CustomerAddressZipCode, &q.CustomerAddressCity,
			&q.QuoteNumber, &q.Status, &q.PricingMode, &q.DiscountType, &q.DiscountValue,
			&q.SubtotalCents, &q.DiscountAmountCents, &q.TaxTotalCents, &q.TotalCents,
			&q.ValidUntil, &q.Notes, &q.CreatedAt, &q.UpdatedAt,
			&q.PublicToken, &q.PublicTokenExpAt, &q.PreviewToken, &q.PreviewTokenExpAt,
			&q.ViewedAt, &q.AcceptedAt, &q.RejectedAt,
			&q.RejectionReason, &q.SignatureName, &q.SignatureData, &q.SignatureIP, &q.PDFFileKey,
			&q.FinancingDisclaimer,
		); err != nil {
			return nil, fmt.Errorf("failed to scan quote: %w", err)
		}
		items = append(items, q)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate quotes: %w", err)
	}

	return &ListResult{
		Items:      items,
		Total:      total,
		Page:       params.Page,
		PageSize:   params.PageSize,
		TotalPages: totalPages,
	}, nil
}

//  Public Access Methods 

// GetByPublicToken retrieves a quote by its public token (no org scoping needed).
func (r *Repository) GetByPublicToken(ctx context.Context, token string) (*Quote, error) {
	var q Quote
	query := `
		SELECT id, organization_id, lead_id, lead_service_id, quote_number, status,
			pricing_mode, discount_type, discount_value,
			subtotal_cents, discount_amount_cents, tax_total_cents, total_cents,
			valid_until, notes, created_at, updated_at,
			public_token, public_token_expires_at, preview_token, preview_token_expires_at,
			viewed_at, accepted_at, rejected_at,
			rejection_reason, signature_name, signature_data, signature_ip, pdf_file_key,
			financing_disclaimer
		FROM RAC_quotes WHERE public_token = $1`

	err := r.pool.QueryRow(ctx, query, token).Scan(
		&q.ID, &q.OrganizationID, &q.LeadID, &q.LeadServiceID, &q.QuoteNumber, &q.Status,
		&q.PricingMode, &q.DiscountType, &q.DiscountValue,
		&q.SubtotalCents, &q.DiscountAmountCents, &q.TaxTotalCents, &q.TotalCents,
		&q.ValidUntil, &q.Notes, &q.CreatedAt, &q.UpdatedAt,
		&q.PublicToken, &q.PublicTokenExpAt, &q.PreviewToken, &q.PreviewTokenExpAt,
		&q.ViewedAt, &q.AcceptedAt, &q.RejectedAt,
		&q.RejectionReason, &q.SignatureName, &q.SignatureData, &q.SignatureIP, &q.PDFFileKey,
		&q.FinancingDisclaimer,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound(quoteNotFoundMsg)
		}
		return nil, fmt.Errorf("failed to get quote by token: %w", err)
	}
	return &q, nil
}

// TokenKind describes which token matched a quote lookup.
type TokenKind string

const (
	TokenKindPublic  TokenKind = "public"
	TokenKindPreview TokenKind = "preview"
)

// GetByToken retrieves a quote by either public or preview token.
func (r *Repository) GetByToken(ctx context.Context, token string) (*Quote, TokenKind, error) {
	var q Quote
	var kind string
	query := `
		SELECT id, organization_id, lead_id, lead_service_id, quote_number, status,
			pricing_mode, discount_type, discount_value,
			subtotal_cents, discount_amount_cents, tax_total_cents, total_cents,
			valid_until, notes, created_at, updated_at,
			public_token, public_token_expires_at, preview_token, preview_token_expires_at,
			viewed_at, accepted_at, rejected_at,
			rejection_reason, signature_name, signature_data, signature_ip, pdf_file_key,
			financing_disclaimer,
			CASE WHEN public_token = $1 THEN 'public' ELSE 'preview' END AS token_kind
		FROM RAC_quotes
		WHERE public_token = $1 OR preview_token = $1`

	err := r.pool.QueryRow(ctx, query, token).Scan(
		&q.ID, &q.OrganizationID, &q.LeadID, &q.LeadServiceID, &q.QuoteNumber, &q.Status,
		&q.PricingMode, &q.DiscountType, &q.DiscountValue,
		&q.SubtotalCents, &q.DiscountAmountCents, &q.TaxTotalCents, &q.TotalCents,
		&q.ValidUntil, &q.Notes, &q.CreatedAt, &q.UpdatedAt,
		&q.PublicToken, &q.PublicTokenExpAt, &q.PreviewToken, &q.PreviewTokenExpAt,
		&q.ViewedAt, &q.AcceptedAt, &q.RejectedAt,
		&q.RejectionReason, &q.SignatureName, &q.SignatureData, &q.SignatureIP, &q.PDFFileKey,
		&q.FinancingDisclaimer,
		&kind,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, "", apperr.NotFound(quoteNotFoundMsg)
		}
		return nil, "", fmt.Errorf("failed to get quote by token: %w", err)
	}

	if kind == string(TokenKindPublic) {
		return &q, TokenKindPublic, nil
	}
	return &q, TokenKindPreview, nil
}

// SetPublicToken sets the public access token and expiry on a quote.
func (r *Repository) SetPublicToken(ctx context.Context, quoteID, orgID uuid.UUID, token string, expiresAt time.Time) error {
	query := `UPDATE RAC_quotes SET public_token = $3, public_token_expires_at = $4, updated_at = $5
		WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, quoteID, orgID, token, expiresAt, time.Now())
	if err != nil {
		return fmt.Errorf("failed to set public token: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(quoteNotFoundMsg)
	}
	return nil
}

// SetPreviewToken sets the read-only preview token and expiry on a quote.
func (r *Repository) SetPreviewToken(ctx context.Context, quoteID, orgID uuid.UUID, token string, expiresAt time.Time) error {
	query := `UPDATE RAC_quotes SET preview_token = $3, preview_token_expires_at = $4, updated_at = $5
		WHERE id = $1 AND organization_id = $2`
	result, err := r.pool.Exec(ctx, query, quoteID, orgID, token, expiresAt, time.Now())
	if err != nil {
		return fmt.Errorf("failed to set preview token: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound(quoteNotFoundMsg)
	}
	return nil
}

// SetViewedAt sets the viewed_at timestamp if it's currently NULL (first view).
func (r *Repository) SetViewedAt(ctx context.Context, quoteID uuid.UUID) error {
	query := `UPDATE RAC_quotes SET viewed_at = $2 WHERE id = $1 AND viewed_at IS NULL`
	_, err := r.pool.Exec(ctx, query, quoteID, time.Now())
	if err != nil {
		return fmt.Errorf("failed to set viewed_at: %w", err)
	}
	return nil
}

// UpdateItemSelection updates the is_selected flag on a quote item.
func (r *Repository) UpdateItemSelection(ctx context.Context, itemID, quoteID uuid.UUID, isSelected bool) error {
	query := `UPDATE RAC_quote_items SET is_selected = $3 WHERE id = $1 AND quote_id = $2`
	result, err := r.pool.Exec(ctx, query, itemID, quoteID, isSelected)
	if err != nil {
		return fmt.Errorf("failed to update item selection: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound("quote item not found")
	}
	return nil
}

// UpdateQuoteTotals updates only the calculated totals on a quote.
func (r *Repository) UpdateQuoteTotals(ctx context.Context, quoteID uuid.UUID, subtotal, discount, tax, total int64) error {
	query := `UPDATE RAC_quotes SET subtotal_cents = $2, discount_amount_cents = $3, tax_total_cents = $4, total_cents = $5, updated_at = $6
		WHERE id = $1`
	_, err := r.pool.Exec(ctx, query, quoteID, subtotal, discount, tax, total, time.Now())
	if err != nil {
		return fmt.Errorf("failed to update quote totals: %w", err)
	}
	return nil
}

// AcceptQuote sets the quote to Accepted status with signature data.
func (r *Repository) AcceptQuote(ctx context.Context, quoteID uuid.UUID, signatureName, signatureData, signatureIP string) error {
	now := time.Now()
	query := `UPDATE RAC_quotes SET status = 'Accepted', accepted_at = $2, signature_name = $3, signature_data = $4, signature_ip = $5, updated_at = $2
		WHERE id = $1 AND status = 'Sent'`
	result, err := r.pool.Exec(ctx, query, quoteID, now, signatureName, signatureData, signatureIP)
	if err != nil {
		return fmt.Errorf("failed to accept quote: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.Conflict("quote cannot be accepted in its current state")
	}
	return nil
}

// RejectQuote sets the quote to Rejected status with an optional reason.
func (r *Repository) RejectQuote(ctx context.Context, quoteID uuid.UUID, reason *string) error {
	now := time.Now()
	query := `UPDATE RAC_quotes SET status = 'Rejected', rejected_at = $2, rejection_reason = $3, updated_at = $2
		WHERE id = $1 AND status = 'Sent'`
	result, err := r.pool.Exec(ctx, query, quoteID, now, reason)
	if err != nil {
		return fmt.Errorf("failed to reject quote: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.Conflict("quote cannot be rejected in its current state")
	}
	return nil
}

// SetPDFFileKey stores the MinIO reference for the generated PDF.
func (r *Repository) SetPDFFileKey(ctx context.Context, quoteID uuid.UUID, fileKey string) error {
	query := `UPDATE RAC_quotes SET pdf_file_key = $2, updated_at = $3 WHERE id = $1`
	_, err := r.pool.Exec(ctx, query, quoteID, fileKey, time.Now())
	if err != nil {
		return fmt.Errorf("failed to set PDF file key: %w", err)
	}
	return nil
}

// GetPDFFileKeyByQuoteID returns the PDF file key for a quote (no org scoping).
func (r *Repository) GetPDFFileKeyByQuoteID(ctx context.Context, quoteID uuid.UUID) (string, error) {
	var fileKey *string
	query := `SELECT pdf_file_key FROM RAC_quotes WHERE id = $1`
	err := r.pool.QueryRow(ctx, query, quoteID).Scan(&fileKey)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return "", apperr.NotFound(quoteNotFoundMsg)
		}
		return "", fmt.Errorf("failed to get PDF file key: %w", err)
	}
	if fileKey == nil {
		return "", nil
	}
	return *fileKey, nil
}

// GetOrganizationIDByQuoteID returns the organization ID for a quote (no org scoping).
func (r *Repository) GetOrganizationIDByQuoteID(ctx context.Context, quoteID uuid.UUID) (uuid.UUID, error) {
	var orgID uuid.UUID
	query := `SELECT organization_id FROM RAC_quotes WHERE id = $1`
	err := r.pool.QueryRow(ctx, query, quoteID).Scan(&orgID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return uuid.Nil, apperr.NotFound(quoteNotFoundMsg)
		}
		return uuid.Nil, fmt.Errorf("failed to get organization ID: %w", err)
	}
	return orgID, nil
}

// GetItemByID retrieves a single quote item by its ID and quote ID.
func (r *Repository) GetItemByID(ctx context.Context, itemID, quoteID uuid.UUID) (*QuoteItem, error) {
	var it QuoteItem
	query := `
		SELECT id, quote_id, organization_id, description, quantity, quantity_numeric,
			unit_price_cents, tax_rate, is_optional, is_selected, sort_order, catalog_product_id, created_at
		FROM RAC_quote_items WHERE id = $1 AND quote_id = $2`
	err := r.pool.QueryRow(ctx, query, itemID, quoteID).Scan(
		&it.ID, &it.QuoteID, &it.OrganizationID,
		&it.Description, &it.Quantity, &it.QuantityNumeric,
		&it.UnitPriceCents, &it.TaxRateBps, &it.IsOptional, &it.IsSelected, &it.SortOrder, &it.CatalogProductID, &it.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound("quote item not found")
		}
		return nil, fmt.Errorf("failed to get quote item: %w", err)
	}
	return &it, nil
}

// GetItemsByQuoteIDNoOrg retrieves all items for a quote without org scoping (for public access).
func (r *Repository) GetItemsByQuoteIDNoOrg(ctx context.Context, quoteID uuid.UUID) ([]QuoteItem, error) {
	query := `
		SELECT id, quote_id, organization_id, description, quantity, quantity_numeric,
			unit_price_cents, tax_rate, is_optional, is_selected, sort_order, catalog_product_id, created_at
		FROM RAC_quote_items WHERE quote_id = $1
		ORDER BY sort_order ASC`
	rows, err := r.pool.Query(ctx, query, quoteID)
	if err != nil {
		return nil, fmt.Errorf("failed to query quote items: %w", err)
	}
	defer rows.Close()
	var items []QuoteItem
	for rows.Next() {
		var it QuoteItem
		if err := rows.Scan(
			&it.ID, &it.QuoteID, &it.OrganizationID,
			&it.Description, &it.Quantity, &it.QuantityNumeric,
			&it.UnitPriceCents, &it.TaxRateBps, &it.IsOptional, &it.IsSelected, &it.SortOrder, &it.CatalogProductID, &it.CreatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan quote item: %w", err)
		}
		items = append(items, it)
	}
	return items, rows.Err()
}

//  Annotation Methods 

// CreateAnnotation inserts a new annotation on a quote item.
func (r *Repository) CreateAnnotation(ctx context.Context, a *QuoteAnnotation) error {
	query := `INSERT INTO RAC_quote_annotations (id, quote_item_id, organization_id, author_type, author_id, text, is_resolved, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`
	_, err := r.pool.Exec(ctx, query, a.ID, a.QuoteItemID, a.OrganizationID, a.AuthorType, a.AuthorID, a.Text, a.IsResolved, a.CreatedAt)
	if err != nil {
		return fmt.Errorf("failed to create annotation: %w", err)
	}
	return nil
}

// ListAnnotationsByQuoteID retrieves all annotations for items belonging to a quote.
func (r *Repository) ListAnnotationsByQuoteID(ctx context.Context, quoteID uuid.UUID) ([]QuoteAnnotation, error) {
	query := `
		SELECT a.id, a.quote_item_id, a.organization_id, a.author_type, a.author_id, a.text, a.is_resolved, a.created_at
		FROM RAC_quote_annotations a
		JOIN RAC_quote_items qi ON qi.id = a.quote_item_id
		WHERE qi.quote_id = $1
		ORDER BY a.created_at ASC`
	rows, err := r.pool.Query(ctx, query, quoteID)
	if err != nil {
		return nil, fmt.Errorf("failed to list annotations: %w", err)
	}
	defer rows.Close()
	var annotations []QuoteAnnotation
	for rows.Next() {
		var a QuoteAnnotation
		if err := rows.Scan(&a.ID, &a.QuoteItemID, &a.OrganizationID, &a.AuthorType, &a.AuthorID, &a.Text, &a.IsResolved, &a.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan annotation: %w", err)
		}
		annotations = append(annotations, a)
	}
	return annotations, rows.Err()
}

// UpdateAnnotationText updates the text for a single annotation (scoped to item and author type).
func (r *Repository) UpdateAnnotationText(ctx context.Context, annotationID, itemID uuid.UUID, authorType, text string) (*QuoteAnnotation, error) {
	query := `
		UPDATE RAC_quote_annotations
		SET text = $1
		WHERE id = $2 AND quote_item_id = $3 AND author_type = $4
		RETURNING id, quote_item_id, organization_id, author_type, author_id, text, is_resolved, created_at`

	var a QuoteAnnotation
	if err := r.pool.QueryRow(ctx, query, text, annotationID, itemID, authorType).Scan(
		&a.ID, &a.QuoteItemID, &a.OrganizationID, &a.AuthorType, &a.AuthorID, &a.Text, &a.IsResolved, &a.CreatedAt,
	); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound("annotation not found")
		}
		return nil, fmt.Errorf("failed to update annotation: %w", err)
	}
	return &a, nil
}

// DeleteAnnotation removes an annotation scoped to item and author type.
func (r *Repository) DeleteAnnotation(ctx context.Context, annotationID, itemID uuid.UUID, authorType string) error {
	query := `DELETE FROM RAC_quote_annotations WHERE id = $1 AND quote_item_id = $2 AND author_type = $3`
	result, err := r.pool.Exec(ctx, query, annotationID, itemID, authorType)
	if err != nil {
		return fmt.Errorf("failed to delete annotation: %w", err)
	}
	if result.RowsAffected() == 0 {
		return apperr.NotFound("annotation not found")
	}
	return nil
}

//  Activity Methods 

// QuoteActivity is the database model for a quote activity log entry
type QuoteActivity struct {
	ID             uuid.UUID `db:"id"`
	QuoteID        uuid.UUID `db:"quote_id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	EventType      string    `db:"event_type"`
	Message        string    `db:"message"`
	Metadata       []byte    `db:"metadata"`
	CreatedAt      time.Time `db:"created_at"`
}

// CreateActivity inserts a new activity log entry for a quote.
func (r *Repository) CreateActivity(ctx context.Context, a *QuoteActivity) error {
	query := `INSERT INTO RAC_quote_activity (id, quote_id, organization_id, event_type, message, metadata, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)`
	_, err := r.pool.Exec(ctx, query, a.ID, a.QuoteID, a.OrganizationID, a.EventType, a.Message, a.Metadata, a.CreatedAt)
	if err != nil {
		return fmt.Errorf("failed to create quote activity: %w", err)
	}
	return nil
}

// ListActivities retrieves all activity log entries for a quote, newest first.
func (r *Repository) ListActivities(ctx context.Context, quoteID uuid.UUID, orgID uuid.UUID) ([]QuoteActivity, error) {
	query := `
		SELECT id, quote_id, organization_id, event_type, message, metadata, created_at
		FROM RAC_quote_activity
		WHERE quote_id = $1 AND organization_id = $2
		ORDER BY created_at DESC`
	rows, err := r.pool.Query(ctx, query, quoteID, orgID)
	if err != nil {
		return nil, fmt.Errorf("failed to list quote activities: %w", err)
	}
	defer rows.Close()
	var activities []QuoteActivity
	for rows.Next() {
		var a QuoteActivity
		if err := rows.Scan(&a.ID, &a.QuoteID, &a.OrganizationID, &a.EventType, &a.Message, &a.Metadata, &a.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan quote activity: %w", err)
		}
		activities = append(activities, a)
	}
	return activities, rows.Err()
}

//  Attachment & URL Methods 

// QuoteAttachment is the database model for a quote document attachment.
type QuoteAttachment struct {
	ID               uuid.UUID  `db:"id"`
	QuoteID          uuid.UUID  `db:"quote_id"`
	OrganizationID   uuid.UUID  `db:"organization_id"`
	Filename         string     `db:"filename"`
	FileKey          string     `db:"file_key"`
	Source           string     `db:"source"`
	CatalogProductID *uuid.UUID `db:"catalog_product_id"`
	Enabled          bool       `db:"enabled"`
	SortOrder        int        `db:"sort_order"`
	CreatedAt        time.Time  `db:"created_at"`
}

// QuoteURL is the database model for a quote URL attachment.
type QuoteURL struct {
	ID               uuid.UUID  `db:"id"`
	QuoteID          uuid.UUID  `db:"quote_id"`
	OrganizationID   uuid.UUID  `db:"organization_id"`
	Label            string     `db:"label"`
	Href             string     `db:"href"`
	Accepted         bool       `db:"accepted"`
	CatalogProductID *uuid.UUID `db:"catalog_product_id"`
	CreatedAt        time.Time  `db:"created_at"`
}

// ReplaceAttachments atomically replaces all attachments for a quote (delete + insert).
func (r *Repository) ReplaceAttachments(ctx context.Context, quoteID, orgID uuid.UUID, attachments []QuoteAttachment) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("begin tx: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	if _, err := tx.Exec(ctx,
		`DELETE FROM RAC_quote_attachments WHERE quote_id = $1 AND organization_id = $2`,
		quoteID, orgID,
	); err != nil {
		return fmt.Errorf("delete old attachments: %w", err)
	}

	query := `INSERT INTO RAC_quote_attachments
		(id, quote_id, organization_id, filename, file_key, source, catalog_product_id, enabled, sort_order, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`

	for _, a := range attachments {
		if _, err := tx.Exec(ctx, query,
			a.ID, a.QuoteID, a.OrganizationID, a.Filename, a.FileKey,
			a.Source, a.CatalogProductID, a.Enabled, a.SortOrder, a.CreatedAt,
		); err != nil {
			return fmt.Errorf("insert attachment: %w", err)
		}
	}

	return tx.Commit(ctx)
}

// ReplaceURLs atomically replaces all URLs for a quote (delete + insert).
func (r *Repository) ReplaceURLs(ctx context.Context, quoteID, orgID uuid.UUID, urls []QuoteURL) error {
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("begin tx: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	if _, err := tx.Exec(ctx,
		`DELETE FROM RAC_quote_urls WHERE quote_id = $1 AND organization_id = $2`,
		quoteID, orgID,
	); err != nil {
		return fmt.Errorf("delete old urls: %w", err)
	}

	query := `INSERT INTO RAC_quote_urls
		(id, quote_id, organization_id, label, href, accepted, catalog_product_id, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

	for _, u := range urls {
		if _, err := tx.Exec(ctx, query,
			u.ID, u.QuoteID, u.OrganizationID, u.Label, u.Href,
			u.Accepted, u.CatalogProductID, u.CreatedAt,
		); err != nil {
			return fmt.Errorf("insert url: %w", err)
		}
	}

	return tx.Commit(ctx)
}

// GetAttachmentsByQuoteID retrieves all attachments for a quote ordered by sort_order.
func (r *Repository) GetAttachmentsByQuoteID(ctx context.Context, quoteID, orgID uuid.UUID) ([]QuoteAttachment, error) {
	query := `SELECT id, quote_id, organization_id, filename, file_key, source, catalog_product_id, enabled, sort_order, created_at
		FROM RAC_quote_attachments WHERE quote_id = $1 AND organization_id = $2 ORDER BY sort_order ASC`
	rows, err := r.pool.Query(ctx, query, quoteID, orgID)
	if err != nil {
		return nil, fmt.Errorf("query attachments: %w", err)
	}
	defer rows.Close()
	var result []QuoteAttachment
	for rows.Next() {
		var a QuoteAttachment
		if err := rows.Scan(&a.ID, &a.QuoteID, &a.OrganizationID, &a.Filename, &a.FileKey, &a.Source, &a.CatalogProductID, &a.Enabled, &a.SortOrder, &a.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan attachment: %w", err)
		}
		result = append(result, a)
	}
	return result, rows.Err()
}

// GetURLsByQuoteID retrieves all URLs for a quote.
func (r *Repository) GetURLsByQuoteID(ctx context.Context, quoteID, orgID uuid.UUID) ([]QuoteURL, error) {
	query := `SELECT id, quote_id, organization_id, label, href, accepted, catalog_product_id, created_at
		FROM RAC_quote_urls WHERE quote_id = $1 AND organization_id = $2 ORDER BY created_at ASC`
	rows, err := r.pool.Query(ctx, query, quoteID, orgID)
	if err != nil {
		return nil, fmt.Errorf("query urls: %w", err)
	}
	defer rows.Close()
	var result []QuoteURL
	for rows.Next() {
		var u QuoteURL
		if err := rows.Scan(&u.ID, &u.QuoteID, &u.OrganizationID, &u.Label, &u.Href, &u.Accepted, &u.CatalogProductID, &u.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan url: %w", err)
		}
		result = append(result, u)
	}
	return result, rows.Err()
}

// GetAttachmentsByQuoteIDNoOrg retrieves all attachments for a quote without org scoping (for public/PDF access).
func (r *Repository) GetAttachmentsByQuoteIDNoOrg(ctx context.Context, quoteID uuid.UUID) ([]QuoteAttachment, error) {
	query := `SELECT id, quote_id, organization_id, filename, file_key, source, catalog_product_id, enabled, sort_order, created_at
		FROM RAC_quote_attachments WHERE quote_id = $1 ORDER BY sort_order ASC`
	rows, err := r.pool.Query(ctx, query, quoteID)
	if err != nil {
		return nil, fmt.Errorf("query attachments: %w", err)
	}
	defer rows.Close()
	var result []QuoteAttachment
	for rows.Next() {
		var a QuoteAttachment
		if err := rows.Scan(&a.ID, &a.QuoteID, &a.OrganizationID, &a.Filename, &a.FileKey, &a.Source, &a.CatalogProductID, &a.Enabled, &a.SortOrder, &a.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan attachment: %w", err)
		}
		result = append(result, a)
	}
	return result, rows.Err()
}

// GetURLsByQuoteIDNoOrg retrieves all URLs for a quote without org scoping (for public access).
func (r *Repository) GetURLsByQuoteIDNoOrg(ctx context.Context, quoteID uuid.UUID) ([]QuoteURL, error) {
	query := `SELECT id, quote_id, organization_id, label, href, accepted, catalog_product_id, created_at
		FROM RAC_quote_urls WHERE quote_id = $1 ORDER BY created_at ASC`
	rows, err := r.pool.Query(ctx, query, quoteID)
	if err != nil {
		return nil, fmt.Errorf("query urls: %w", err)
	}
	defer rows.Close()
	var result []QuoteURL
	for rows.Next() {
		var u QuoteURL
		if err := rows.Scan(&u.ID, &u.QuoteID, &u.OrganizationID, &u.Label, &u.Href, &u.Accepted, &u.CatalogProductID, &u.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan url: %w", err)
		}
		result = append(result, u)
	}
	return result, rows.Err()
}

// GetAttachmentByID returns a single attachment by ID, scoped to quote + org.
func (r *Repository) GetAttachmentByID(ctx context.Context, attachmentID, quoteID, orgID uuid.UUID) (*QuoteAttachment, error) {
	query := `SELECT id, quote_id, organization_id, filename, file_key, source, catalog_product_id, enabled, sort_order, created_at
		FROM "RAC_quote_attachments" WHERE id = $1 AND quote_id = $2 AND organization_id = $3`

	var a QuoteAttachment
	err := r.pool.QueryRow(ctx, query, attachmentID, quoteID, orgID).Scan(
		&a.ID, &a.QuoteID, &a.OrganizationID, &a.Filename, &a.FileKey,
		&a.Source, &a.CatalogProductID, &a.Enabled, &a.SortOrder, &a.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, apperr.NotFound("attachment not found")
		}
		return nil, fmt.Errorf("get attachment by id: %w", err)
	}
	return &a, nil
}

//  Sorting Helpers 

func resolveSortBy(sortBy string) (string, error) {
	if sortBy == "" {
		return "createdAt", nil
	}
	switch sortBy {
	case "quoteNumber", "status", "total", "validUntil", "customerName", "customerPhone", "customerAddress", "createdBy", "createdAt", "updatedAt":
		return sortBy, nil
	default:
		return "", apperr.BadRequest("invalid sort field")
	}
}

func resolveSortOrder(sortOrder string) (string, error) {
	if sortOrder == "" {
		return "desc", nil
	}
	switch sortOrder {
	case "asc", "desc":
		return sortOrder, nil
	default:
		return "", apperr.BadRequest("invalid sort order")
	}
}

func nullable[T any](value *T) interface{} {
	if value == nil {
		return nil
	}
	return *value
}

func optionalSearchParam(value string) interface{} {
	if value == "" {
		return nil
	}
	return "%" + value + "%"
}
</file>

<file path="internal/leads/agent/pipeline_prompts.go">
package agent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"

	"portal_final_backend/internal/leads/repository"
)

func buildGatekeeperPrompt(lead repository.Lead, service repository.LeadService, notes []repository.LeadNote, intakeContext string, attachments []repository.Attachment) string {
	notesSection := buildNotesSection(notes)
	serviceNote := getValue(service.ConsumerNote)
	preferencesSummary := buildPreferencesSummary(service.CustomerPreferences)
	leadContext := buildLeadContextSection(lead, attachments)
	ruleChecks := buildRuleChecksSection(service.ServiceType, serviceNote, notes)

	return fmt.Sprintf(`You validate intake requirements.

Role: You validate intake requirements.
Goal: If valid -> set stage Ready_For_Estimator. If invalid -> set stage Nurturing.
Constraint: Do NOT calculate price. Do NOT look for partners.

Lead:
- Lead ID: %s
- Service ID: %s
- Service Type: %s
- Pipeline Stage: %s
- Created At: %s

Consumer:
- Name: %s %s
- Phone: %s
- Email: %s
- Role: %s

Address:
- %s %s, %s %s

Service Note (raw):
%s

Notes:
%s

Preferences (from customer portal):
%s

Additional Context:
%s

Rule-based checks (heuristic):
%s

Intake Requirements:
%s

CRITICAL REQUIRED TOOL CALLS:
You MUST call BOTH SaveAnalysis AND UpdatePipelineStage in EVERY response.
SaveAnalysis MUST be called BEFORE UpdatePipelineStage.
If you skip SaveAnalysis, the lead timeline will be broken - this is NOT optional.

Instruction:
If you find high-confidence (>=90%%) errors in lead contact or address details, call UpdateLeadDetails.
Only update fields you are confident about. Include a short Dutch reason and your confidence.
0) If the service type is clearly wrong, you may call UpdateLeadServiceType ONLY when you are highly confident (>=90%%).
If you update the service type, do it BEFORE UpdatePipelineStage.
Only change the service type when there is a clear positive match to another service based on notes/service note.
Missing intake information alone is NOT a reason to switch service type.
If the intent is ambiguous, keep the current service type and move to Nurturing with a short Dutch reason.
1) Validate intake requirements for the selected service type.
2) Treat rule-based missing items as critical unless the info is clearly present elsewhere.
3) FIRST call SaveAnalysis with urgencyLevel, leadQuality, recommendedAction, preferredContactChannel, suggestedContactMessage,
   a short Dutch summary, and a Dutch list of missingInformation (empty list if nothing missing).
4) THEN call UpdatePipelineStage with stage="Ready_For_Estimator" (if all required info is present) or stage="Nurturing" (if critical info is missing).
5) Include a short reason in UpdatePipelineStage, written in Dutch.

FINAL REMINDER: You MUST output SaveAnalysis followed by UpdatePipelineStage. No exceptions.
`,
		lead.ID,
		service.ID,
		service.ServiceType,
		service.PipelineStage,
		lead.CreatedAt.Format(time.RFC3339),
		lead.ConsumerFirstName,
		lead.ConsumerLastName,
		lead.ConsumerPhone,
		getValue(lead.ConsumerEmail),
		lead.ConsumerRole,
		lead.AddressStreet,
		lead.AddressHouseNumber,
		lead.AddressZipCode,
		lead.AddressCity,
		wrapUserData(sanitizeUserInput(serviceNote, maxConsumerNote)),
		notesSection,
		preferencesSummary,
		leadContext,
		ruleChecks,
		intakeContext,
	)
}

func buildEstimatorPrompt(lead repository.Lead, service repository.LeadService, notes []repository.LeadNote, photoAnalysis *repository.PhotoAnalysis) string {
	notesSection := buildNotesSection(notes)
	serviceNote := getValue(service.ConsumerNote)
	preferencesSummary := buildPreferencesSummary(service.CustomerPreferences)
	photoSummary := buildPhotoSummary(photoAnalysis)

	return fmt.Sprintf(`You are a Technical Estimator.

Role: You are a Technical Estimator.
Input: Photos, Description.
Goal: Determine Scope, Estimate Price Range, Draft Quote, set stage to Quote_Sent.
Action: Search for products, draft a quote, call SaveEstimation (metadata update), set stage Quote_Sent.

CRITICAL ARITHMETIC RULE:
You MUST use the Calculator tool for ALL math operations. NEVER perform arithmetic in your head.
This includes: area calculations (length  width), quantity calculations (needed  unit_size),
price totals (price  quantity), rounding up, unit conversions, and any other computation.
Examples:
  - Window 2m  1.5m: call Calculator(operation="multiply", a=2, b=1.5)  3 m
  - Need 4 m, sold per plaat 2.5 m: call Calculator(operation="ceil_divide", a=4, b=2.5)  2 sheets
  - Price 15.99  3: call Calculator(operation="multiply", a=15.99, b=3)  47.97

Lead:
- Lead ID: %s
- Service ID: %s
- Service Type: %s
- Pipeline Stage: %s
- Created At: %s

Consumer:
- Name: %s %s
- Phone: %s
- Email: %s

Address:
- %s %s, %s %s

Service Note (raw):
%s

Notes:
%s

Preferences (from customer portal):
%s

Photo Analysis:
%s

Instruction:
1) Identify the materials/products needed based on the service description and photos.
2) Call SearchProductMaterials to find products. The tool uses semantic (vector) search, so craft your queries carefully:
   - Think about what the product might be CALLED in a catalog: use generic category names, brand-neutral terms, and common synonyms.
   - For example, instead of only "RVS scharnieren", also try "deurbeslag scharnier", "deur ophangen", or "scharnier deur montage".
   - Mix Dutch and English terms (e.g., "isolatiemateriaal" AND "insulation panel") since the catalog may contain either.
   - Search broad first (e.g., "deurbeslag"), then narrow (e.g., "scharnier RVS 89mm") to maximize results.
   - Call SearchProductMaterials multiple times with DIFFERENT queries for each material category or synonym.
   Always prefer the catalog collection by default.
   If the user explicitly says not to use the catalog (e.g., "ignore catalog", "no catalog", "zonder catalogus"), set useCatalog=false.
	Use standard, mid-range materials unless the request explicitly calls for heavy-duty or premium.
	If multiple products are returned, prefer the most typical/affordable option for the scenario.
	Products from the catalog will include an "id" field - remember these IDs for step 3a.

   HANDLING NO RESULTS:
   - If SearchProductMaterials returns "No relevant products found", try at least 2 more queries with different terms/synonyms.
   - If still no match, add the item as an ad-hoc line item (without catalogProductId):
     - Use your best estimate for unitPriceCents based on typical Dutch market prices for that product.
     - Keep the description factual (e.g., "RVS scharnieren (3 stuks)")  do NOT add notes like "niet in catalogus".
     - Always check the product score: items with score < 0.4 may be false positives. Verify the product NAME matches what you need.
3) Use CalculateEstimate to compute material subtotal, labor subtotal range, and total range.
	Provide structured inputs (material items, quantities, labor hours range, hourly rate range, optional extra costs).
	For each material item's unitPrice, use the product's "priceEuros" value (in euros, e.g. 7.93).
	If catalog search results include a labor time, use it as the baseline for labor hours (adjust if the scope indicates otherwise).
	IMPORTANT: Before calling CalculateEstimate, use Calculator for each individual quantity or price calculation.

	LABOR RULES  check each product's "type" field:
	- type = "service" or "digital_service": the price already INCLUDES labor/installation. Do NOT add separate arbeid hours for this item.
	- type = "product" or "material": the price is material-only. You MUST add separate arbeid line items for installing/mounting these.
	Example: A "houten kozijn vervangen" at EUR 950/m2 with type "service" includes installation  no extra arbeid.
	But "RVS scharnieren" with type "material" are material-only  add arbeid for mounting them.
3a) Call DraftQuote to create a draft quote for the customer. For each item:
	- Set description using the product name. If the product has materials (the "materials" array), format as:
	  "Product name\nInclusief:\n- Material A\n- Material B"
	  Example: "Houten kozijn 120x80\nInclusief:\n- HR++ glas\n- Beslag set"
	  If materials is empty, just use the product name/description.
	- Set quantity based on the estimated need. IMPORTANT  respect the product's "unit" field:
	  The unit tells you HOW the product is sold (e.g. "per plaat van 2.5 m", "per rol van 10 m", "per stuk", "per m").
	  If the unit indicates a fixed size (e.g. "per plaat van 2.5 m"), use Calculator to compute how many units are needed:
	  Call Calculator(operation="ceil_divide", a=required_area, b=unit_size) to get the quantity (always rounds up).
	  Examples:
	    - Need 4 m, sold "per plaat van 2.5 m"  Calculator(operation="ceil_divide", a=4, b=2.5)  quantity = "2"
	    - Need 12 m, sold "per rol van 5 m"  Calculator(operation="ceil_divide", a=12, b=5)  quantity = "3"
	    - Need 3, sold "per stuk"  quantity = "3"
	  If the unit is "per m" or "per m", use Calculator to compute the raw measurement as quantity.
	- Set unitPriceCents to the product's "priceCents" value (already in euro-cents, e.g. 793 = EUR 7.93). Do NOT use priceEuros.
	- Set taxRateBps from the product's vatRateBps (e.g., 2100 for 21%%). If unknown, use 2100.
	- If the product came from SearchProductMaterials and has an "id", include it as catalogProductId.
	- For labor or ad-hoc items NOT from the catalog, omit catalogProductId.	LABOR RULES  check each product's "type" field:
	- type = "service" or "digital_service": the price already INCLUDES labor. Do NOT add a separate arbeid line item for this product.
	- type = "product" or "material": the price is material-only. Add a separate "Arbeid" line item for installing/mounting these items.
	Only add arbeid for work on material/product items (e.g., mounting hinges, hanging a door).	Include a notes field (in Dutch) summarizing why this quote was generated.
	Note: Catalog product documents (PDFs, specs) and terms URLs are automatically attached to the quote  you do not need to handle attachments yourself.
4) Determine scope: Small, Medium, or Large based on work complexity.
5) Call SaveEstimation with scope, priceRange (e.g. "EUR 500 - 900"), notes, and a short summary. Notes and summary must be in Dutch.
	Include the products found and their prices in the notes. If a catalog item includes labor time, mention it.
	Format notes as multiline Markdown with blank lines between sections.
	Use headings (bold labels) and bullet/numbered lists so each item is on its own line.
	Example structure:
	**Materiaalbenodigdheden:**
	1. ...
	2. ...

	**Subtotaal materiaal:** EUR ...

	**Arbeid:**
	- ...

	**Subtotaal arbeid:** EUR ...

	**Totaal geschatte kosten:** EUR ...

	**Opmerkingen:**
	- ...
6) Call UpdatePipelineStage with stage="Quote_Sent" and a reason in Dutch.
	IMPORTANT: DO NOT use "Ready_For_Partner". We must wait for the customer to accept the quote first.

You MUST call SearchProductMaterials first (if available), then DraftQuote (if available), then SaveEstimation, then UpdatePipelineStage. Respond ONLY with tool calls.
`,
		lead.ID,
		service.ID,
		service.ServiceType,
		service.PipelineStage,
		lead.CreatedAt.Format(time.RFC3339),
		lead.ConsumerFirstName,
		lead.ConsumerLastName,
		lead.ConsumerPhone,
		getValue(lead.ConsumerEmail),
		lead.AddressStreet,
		lead.AddressHouseNumber,
		lead.AddressZipCode,
		lead.AddressCity,
		wrapUserData(sanitizeUserInput(serviceNote, maxConsumerNote)),
		notesSection,
		preferencesSummary,
		photoSummary,
	)
}

func buildDispatcherPrompt(lead repository.Lead, service repository.LeadService, radiusKm int, excludeIDs []uuid.UUID) string {
	exclusionTxt := ""
	if len(excludeIDs) > 0 {
		exclusionTxt = fmt.Sprintf("\nCONTEXT: The following Partner IDs have already been contacted or rejected: %v. You MUST include these in the 'excludePartnerIds' field when calling FindMatchingPartners.", excludeIDs)
	}

	return fmt.Sprintf(`You are the Fulfillment Manager.

Role: You are the Fulfillment Manager.
Action: Find matches, create an offer, update the pipeline stage.%s

Logic:
- If > 0 partners found:
  1) Select the best match (e.g., closest distance).
	2) Call CreatePartnerOffer for that partner, including a short Dutch job summary.
  3) Call UpdatePipelineStage with stage="Partner_Matching" and a short Dutch summary like "Offer verzonden naar [Partnernaam]".
- If 0 partners found:
  - Call UpdatePipelineStage with stage="Manual_Intervention" and summary "Geen partners gevonden binnen bereik." DO NOT REJECT.

Lead:
- Lead ID: %s
- Service ID: %s
- Service Type: %s
- Pipeline Stage: %s
- Zip Code: %s

Instruction:
1) Call FindMatchingPartners with serviceType="%s", zipCode="%s", radiusKm=%d (and include exclusions).
2) If matches exist, you MUST call CreatePartnerOffer BEFORE UpdatePipelineStage.
3) When calling CreatePartnerOffer, set jobSummaryShort to a short Dutch summary (max 120 chars) of what the job entails, based on service type and notes. Do NOT include exact address or personal data.
4) Use Dutch for the UpdatePipelineStage reason.

You MUST call FindMatchingPartners first. If matches exist, you MUST call CreatePartnerOffer before UpdatePipelineStage. Respond ONLY with tool calls.
`,
		exclusionTxt,
		lead.ID,
		service.ID,
		service.ServiceType,
		service.PipelineStage,
		lead.AddressZipCode,
		service.ServiceType,
		lead.AddressZipCode,
		radiusKm,
	)
}

func buildNotesSection(notes []repository.LeadNote) string {
	meaningful := filterMeaningfulNotes(notes)
	if len(meaningful) == 0 {
		return "No notes"
	}

	var sb strings.Builder
	for _, note := range meaningful {
		body := sanitizeUserInput(note.Body, maxNoteLength)
		sb.WriteString(fmt.Sprintf("- [%s] %s: %s\n", note.Type, note.CreatedAt.Format(time.RFC3339), body))
	}
	return wrapUserData(sb.String())
}

func buildLeadContextSection(lead repository.Lead, attachments []repository.Attachment) string {
	energySummary := buildEnergySummary(lead)
	enrichmentSummary := buildEnrichmentSummary(lead)
	attachmentsSummary := buildAttachmentsSummary(attachments)

	return wrapUserData(strings.Join([]string{
		"Energy: " + energySummary,
		"Enrichment: " + enrichmentSummary,
		"Attachments: " + attachmentsSummary,
	}, "\n"))
}

func buildEnergySummary(lead repository.Lead) string {
	if lead.EnergyClass == nil && lead.EnergyIndex == nil && lead.EnergyBouwjaar == nil && lead.EnergyGebouwtype == nil {
		return "No energy label data"
	}

	parts := make([]string, 0, 4)
	if lead.EnergyClass != nil {
		parts = append(parts, "class "+*lead.EnergyClass)
	}
	if lead.EnergyIndex != nil {
		parts = append(parts, fmt.Sprintf("index %.2f", *lead.EnergyIndex))
	}
	if lead.EnergyBouwjaar != nil {
		parts = append(parts, fmt.Sprintf("build year %d", *lead.EnergyBouwjaar))
	}
	if lead.EnergyGebouwtype != nil {
		parts = append(parts, "type "+*lead.EnergyGebouwtype)
	}

	if len(parts) == 0 {
		return "No energy label data"
	}
	return strings.Join(parts, ", ")
}

func buildEnrichmentSummary(lead repository.Lead) string {
	parts := make([]string, 0, 4)
	if lead.LeadEnrichmentSource != nil {
		parts = append(parts, "source "+*lead.LeadEnrichmentSource)
	}
	if lead.LeadEnrichmentPostcode6 != nil {
		parts = append(parts, "postcode6 "+*lead.LeadEnrichmentPostcode6)
	}
	if lead.LeadEnrichmentBuurtcode != nil {
		parts = append(parts, "buurtcode "+*lead.LeadEnrichmentBuurtcode)
	}
	if lead.LeadEnrichmentConfidence != nil {
		parts = append(parts, fmt.Sprintf("confidence %.2f", *lead.LeadEnrichmentConfidence))
	}
	if len(parts) == 0 {
		return "No enrichment data"
	}
	return strings.Join(parts, ", ")
}

func buildAttachmentsSummary(attachments []repository.Attachment) string {
	if len(attachments) == 0 {
		return "No attachments"
	}

	names := make([]string, 0, 5)
	for i, att := range attachments {
		if i >= 5 {
			break
		}
		name := sanitizeUserInput(att.FileName, 80)
		names = append(names, name)
	}
	return fmt.Sprintf("%d file(s): %s", len(attachments), strings.Join(names, ", "))
}

func buildRuleChecksSection(serviceType string, serviceNote string, notes []repository.LeadNote) string {
	serviceName := strings.ToLower(serviceType)
	if !strings.Contains(serviceName, "isolat") {
		return "No rule-based checks for this service type"
	}

	combined := strings.ToLower(serviceNote + "\n" + flattenNotes(notes))
	missing := make([]string, 0, 4)
	if !containsAny(combined, []string{"spouw", "dak", "vloer", "zolder", "gevel", "muur"}) {
		missing = append(missing, "Welke delen isoleren (spouw/dak/vloer/zolder)")
	}
	if !containsAny(combined, []string{"m2", "vierkante meter", "oppervlakte"}) {
		missing = append(missing, "Geschatte oppervlakte (m2)")
	}
	if !hasYear(combined) {
		missing = append(missing, "Bouwjaar van de woning")
	}
	if !containsAny(combined, []string{"geisoleerd", "ongeisoleerd", "isolatie", "na-isolatie"}) {
		missing = append(missing, "Huidige isolatiestatus")
	}

	if len(missing) == 0 {
		return "No missing items detected"
	}

	return "Missing: " + strings.Join(missing, "; ")
}

func flattenNotes(notes []repository.LeadNote) string {
	if len(notes) == 0 {
		return ""
	}

	var sb strings.Builder
	for _, note := range notes {
		body := sanitizeUserInput(note.Body, maxNoteLength)
		sb.WriteString(body)
		sb.WriteString(" ")
	}
	return sb.String()
}

func containsAny(text string, terms []string) bool {
	for _, term := range terms {
		if strings.Contains(text, term) {
			return true
		}
	}
	return false
}

func hasYear(text string) bool {
	for i := 1900; i <= 2026; i++ {
		if strings.Contains(text, fmt.Sprintf("%d", i)) {
			return true
		}
	}
	return false
}

func buildQuoteGeneratePrompt(lead repository.Lead, service repository.LeadService, notes []repository.LeadNote, userPrompt string) string {
	notesSection := buildNotesSection(notes)
	serviceNote := getValue(service.ConsumerNote)
	preferencesSummary := buildPreferencesSummary(service.CustomerPreferences)

	return fmt.Sprintf(`You are a Quote Generator.

Role: You generate draft quotes from a user prompt using catalog product search.
Goal: Search for relevant products and create a draft quote for the customer.
Constraint: You MUST only use SearchProductMaterials, Calculator, and DraftQuote. Do NOT call any other tools.

CRITICAL ARITHMETIC RULE:
You MUST use the Calculator tool for ALL math operations. NEVER perform arithmetic in your head.
This includes: area calculations (length  width), quantity calculations (needed  unit_size),
price totals (price  quantity), rounding up, unit conversions, and any other computation.
Examples:
  - Window 2m  1.5m: call Calculator(operation="multiply", a=2, b=1.5)  3 m
  - Need 4 m, sold per plaat 2.5 m: call Calculator(operation="ceil_divide", a=4, b=2.5)  2 sheets
  - Price 15.99  3: call Calculator(operation="multiply", a=15.99, b=3)  47.97

Lead:
- Lead ID: %s
- Service ID: %s
- Service Type: %s

Consumer:
- Name: %s %s
- Phone: %s
- Email: %s

Address:
- %s %s, %s %s

Service Note (raw):
%s

Notes:
%s

Preferences (from customer portal):
%s

User Prompt:
%s

Instruction:
1) Read the user prompt carefully. Identify what products/materials are needed.
2) Call SearchProductMaterials to find matching products. Use semantic search tips:
   - Use generic product category names and synonyms.
   - Mix Dutch and English terms.
   - Search broad first, then narrow.
   - Call SearchProductMaterials multiple times with DIFFERENT queries for each material category.
   Always prefer the catalog collection by default.

   HANDLING NO RESULTS:
   - If SearchProductMaterials returns "No relevant products found", try at least 2 more queries with different terms/synonyms.
   - If still no match after multiple attempts, add the item as an ad-hoc line item (without catalogProductId):
     - Use your best estimate for unitPriceCents based on typical Dutch market prices.
     - Keep the description factual  do NOT add notes like "niet in catalogus".
   - Always check the product score: items with score < 0.4 may be false positives. Verify the product NAME matches what you need.
3) For each product found, prepare a DraftQuote item:
   - Set description using the product name. If the product has materials (the "materials" array), format as:
     "Product name\nInclusief:\n- Material A\n- Material B"
     If materials is empty, just use the product name/description.
   - Set quantity based on the user prompt. IMPORTANT  respect the product's "unit" field:
     The unit tells you HOW the product is sold (e.g. "per plaat van 2.5 m", "per rol van 10 m", "per stuk").
     If the unit indicates a fixed size, use Calculator to compute the quantity:
     Call Calculator(operation="ceil_divide", a=required_amount, b=unit_size) to get the quantity (always rounds up).
     Examples:
       - Need 4 m, sold "per plaat van 2.5 m"  Calculator(operation="ceil_divide", a=4, b=2.5)  quantity = "2"
       - Need 12 m, sold "per rol van 5 m"  Calculator(operation="ceil_divide", a=12, b=5)  quantity = "3"
   - Set unitPriceCents to the product's "priceCents" value (already in euro-cents). Do NOT use priceEuros.
   - Set taxRateBps from the product's vatRateBps. If unknown, use 2100.
   - If the product has an "id", include it as catalogProductId.
   - For labor or ad-hoc items, omit catalogProductId.
   LABOR RULES  check each product's "type" field:
   - type = "service" or "digital_service": the price already INCLUDES labor. Do NOT add a separate arbeid line item.
   - type = "product" or "material": the price is material-only. Add a separate "Arbeid" line item for installing/mounting these.
   Only add arbeid for work on material/product items (e.g., mounting hinges, hanging a door).
4) Call DraftQuote with all items and a notes field (in Dutch) summarizing what was generated.
   Catalog product documents and URLs are automatically attached  you do not need to handle attachments.

You MUST call SearchProductMaterials first, then use Calculator for all arithmetic, then DraftQuote. Respond ONLY with tool calls.
`,
		lead.ID,
		service.ID,
		service.ServiceType,
		lead.ConsumerFirstName,
		lead.ConsumerLastName,
		lead.ConsumerPhone,
		getValue(lead.ConsumerEmail),
		lead.AddressStreet,
		lead.AddressHouseNumber,
		lead.AddressZipCode,
		lead.AddressCity,
		wrapUserData(sanitizeUserInput(serviceNote, maxConsumerNote)),
		notesSection,
		preferencesSummary,
		wrapUserData(sanitizeUserInput(userPrompt, 2000)),
	)
}

func buildPreferencesSummary(raw json.RawMessage) string {
	if len(raw) == 0 {
		return "No preferences provided"
	}

	var prefs struct {
		Budget       string `json:"budget"`
		Timeframe    string `json:"timeframe"`
		Availability string `json:"availability"`
		ExtraNotes   string `json:"extraNotes"`
	}
	if err := json.Unmarshal(raw, &prefs); err != nil {
		return "No preferences provided"
	}

	budget := strings.TrimSpace(prefs.Budget)
	timeframe := strings.TrimSpace(prefs.Timeframe)
	availability := strings.TrimSpace(prefs.Availability)
	extraNotes := strings.TrimSpace(prefs.ExtraNotes)

	if budget == "" && timeframe == "" && availability == "" && extraNotes == "" {
		return "No preferences provided"
	}

	lines := []string{
		"- Budget: " + preferenceValue(budget),
		"- Timeframe: " + preferenceValue(timeframe),
		"- Availability: " + preferenceValue(availability),
		"- Extra notes: " + preferenceValue(extraNotes),
	}

	return wrapUserData(strings.Join(lines, "\n"))
}

func preferenceValue(value string) string {
	if value == "" {
		return valueNotProvided
	}
	return sanitizeUserInput(value, maxNoteLength)
}

func buildPhotoSummary(photoAnalysis *repository.PhotoAnalysis) string {
	if photoAnalysis == nil {
		return "No photo analysis available."
	}

	var sb strings.Builder
	if photoAnalysis.Summary != "" {
		sb.WriteString("Summary: " + photoAnalysis.Summary + "\n")
	}
	if photoAnalysis.ScopeAssessment != "" {
		sb.WriteString("Scope: " + photoAnalysis.ScopeAssessment + "\n")
	}
	if photoAnalysis.CostIndicators != "" {
		sb.WriteString("Cost: " + photoAnalysis.CostIndicators + "\n")
	}
	if len(photoAnalysis.Observations) > 0 {
		sb.WriteString("Observations: " + strings.Join(photoAnalysis.Observations, "; ") + "\n")
	}
	if len(photoAnalysis.SafetyConcerns) > 0 {
		sb.WriteString("Safety: " + strings.Join(photoAnalysis.SafetyConcerns, "; ") + "\n")
	}
	if len(photoAnalysis.AdditionalInfo) > 0 {
		sb.WriteString("Additional: " + strings.Join(photoAnalysis.AdditionalInfo, "; ") + "\n")
	}

	// New v2 fields
	if len(photoAnalysis.Measurements) > 0 {
		sb.WriteString("Measurements:\n")
		for _, m := range photoAnalysis.Measurements {
			sb.WriteString(fmt.Sprintf("  - %s: %.2f %s (%s, confidence: %s)\n", m.Description, m.Value, m.Unit, m.Type, m.Confidence))
		}
	}
	if len(photoAnalysis.NeedsOnsiteMeasurement) > 0 {
		sb.WriteString("Needs on-site measurement: " + strings.Join(photoAnalysis.NeedsOnsiteMeasurement, "; ") + "\n")
	}
	if len(photoAnalysis.Discrepancies) > 0 {
		sb.WriteString(" Discrepancies (consumer claims vs photos): " + strings.Join(photoAnalysis.Discrepancies, "; ") + "\n")
	}
	if len(photoAnalysis.ExtractedText) > 0 {
		sb.WriteString("Extracted text (OCR): " + strings.Join(photoAnalysis.ExtractedText, "; ") + "\n")
	}
	if len(photoAnalysis.SuggestedSearchTerms) > 0 {
		sb.WriteString("Suggested product search terms: " + strings.Join(photoAnalysis.SuggestedSearchTerms, ", ") + "\n")
	}

	return wrapUserData(sb.String())
}
</file>

<file path="internal/leads/repository/interface.go">
package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

// =====================================
// Segregated Interfaces (Interface Segregation Principle)
// =====================================

// LeadReader provides read-only access to lead data.
type LeadReader interface {
	GetByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Lead, error)
	GetByIDWithServices(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Lead, []LeadService, error)
	GetByPhone(ctx context.Context, phone string, organizationID uuid.UUID) (Lead, error)
	GetByPhoneOrEmail(ctx context.Context, phone string, email string, organizationID uuid.UUID) (*LeadSummary, []LeadService, error)
	GetByPublicToken(ctx context.Context, token string) (Lead, error)
	List(ctx context.Context, params ListParams) ([]Lead, int, error)
	ListHeatmapPoints(ctx context.Context, organizationID uuid.UUID, startDate *time.Time, endDate *time.Time) ([]HeatmapPoint, error)
	ListActionItems(ctx context.Context, organizationID uuid.UUID, newLeadDays int, limit int, offset int) (ActionItemListResult, error)
}

// LeadWriter provides write operations for lead management.
type LeadWriter interface {
	Create(ctx context.Context, params CreateLeadParams) (Lead, error)
	Update(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadParams) (Lead, error)
	Delete(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error
	BulkDelete(ctx context.Context, ids []uuid.UUID, organizationID uuid.UUID) (int, error)
	SetPublicToken(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, token string, expiresAt time.Time) error
}

// LeadEnrichmentWriter updates enrichment and scoring data for RAC_leads.
type LeadEnrichmentWriter interface {
	UpdateLeadEnrichment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadEnrichmentParams) error
	UpdateLeadScore(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadScoreParams) error
}

// LeadViewTracker tracks which RAC_users have viewed RAC_leads.
type LeadViewTracker interface {
	SetViewedBy(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, userID uuid.UUID) error
}

// ActivityLogger records activity/audit trail on RAC_leads.
type ActivityLogger interface {
	AddActivity(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID, userID uuid.UUID, action string, meta map[string]interface{}) error
}

// MetricsReader provides access to lead KPI metrics.
type MetricsReader interface {
	GetMetrics(ctx context.Context, organizationID uuid.UUID) (LeadMetrics, error)
}

// LeadServiceReader provides read access to lead services.
type LeadServiceReader interface {
	GetLeadServiceByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (LeadService, error)
	ListLeadServices(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]LeadService, error)
	GetCurrentLeadService(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (LeadService, error)
}

// LeadServiceWriter provides write operations for lead services.
type LeadServiceWriter interface {
	CreateLeadService(ctx context.Context, params CreateLeadServiceParams) (LeadService, error)
	UpdateLeadService(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params UpdateLeadServiceParams) (LeadService, error)
	UpdateLeadServiceType(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, serviceType string) (LeadService, error)
	UpdateServiceStatus(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, status string) (LeadService, error)
	UpdatePipelineStage(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, stage string) (LeadService, error)
	UpdateServicePreferences(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID, prefs []byte) error
	CloseAllActiveServices(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) error
}

// ServiceContextDefinition provides context for the AI gatekeeper.
type ServiceContextDefinition struct {
	Name             string
	Description      *string
	IntakeGuidelines *string
}

// ServiceTypeContextReader provides read access to active service definitions for AI context.
type ServiceTypeContextReader interface {
	ListActiveServiceTypes(ctx context.Context, organizationID uuid.UUID) ([]ServiceContextDefinition, error)
}

// NoteStore manages lead notes.
type NoteStore interface {
	CreateLeadNote(ctx context.Context, params CreateLeadNoteParams) (LeadNote, error)
	ListLeadNotes(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]LeadNote, error)
	ListNotesByService(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, organizationID uuid.UUID) ([]LeadNote, error)
}

// TimelineEventStore manages immutable lead timeline events.
type TimelineEventStore interface {
	CreateTimelineEvent(ctx context.Context, params CreateTimelineEventParams) (TimelineEvent, error)
	ListTimelineEvents(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]TimelineEvent, error)
	ListTimelineEventsByService(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, organizationID uuid.UUID) ([]TimelineEvent, error)
}

// AIAnalysisStore manages AI-generated analyses for RAC_leads.
type AIAnalysisStore interface {
	CreateAIAnalysis(ctx context.Context, params CreateAIAnalysisParams) (AIAnalysis, error)
	GetLatestAIAnalysis(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) (AIAnalysis, error)
	ListAIAnalyses(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) ([]AIAnalysis, error)
}

// AttachmentStore manages file attachments for lead services.
type AttachmentStore interface {
	CreateAttachment(ctx context.Context, params CreateAttachmentParams) (Attachment, error)
	GetAttachmentByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (Attachment, error)
	ListAttachmentsByService(ctx context.Context, leadServiceID uuid.UUID, organizationID uuid.UUID) ([]Attachment, error)
	DeleteAttachment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) error
}

// PhotoAnalysisStore manages AI photo analyses for lead services.
type PhotoAnalysisStore interface {
	CreatePhotoAnalysis(ctx context.Context, params CreatePhotoAnalysisParams) (PhotoAnalysis, error)
	GetPhotoAnalysisByID(ctx context.Context, id uuid.UUID, organizationID uuid.UUID) (PhotoAnalysis, error)
	GetLatestPhotoAnalysis(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) (PhotoAnalysis, error)
	ListPhotoAnalysesByService(ctx context.Context, serviceID uuid.UUID, organizationID uuid.UUID) ([]PhotoAnalysis, error)
	ListPhotoAnalysesByLead(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) ([]PhotoAnalysis, error)
}

// LeadAppointmentStats holds appointment statistics for scoring.
type LeadAppointmentStats struct {
	Total       int
	Scheduled   int
	Completed   int
	Cancelled   int
	HasUpcoming bool
}

// AppointmentStatsReader provides appointment stats for RAC_leads (for scoring).
type AppointmentStatsReader interface {
	GetLeadAppointmentStats(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (LeadAppointmentStats, error)
}

// PartnerMatcher provides partner search based on service type and location.
type PartnerMatcher interface {
	FindMatchingPartners(ctx context.Context, organizationID uuid.UUID, serviceType string, zipCode string, radiusKm int, excludePartnerIDs []uuid.UUID) ([]PartnerMatch, error)
	GetInvitedPartnerIDs(ctx context.Context, serviceID uuid.UUID) ([]uuid.UUID, error)
}

// QuotePriceReader provides access to the latest quote total for a lead service.
type QuotePriceReader interface {
	GetLatestQuoteTotal(ctx context.Context, serviceID, organizationID uuid.UUID) (int64, error)
}

// ActivityFeedEntry represents a unified activity entry from multiple sources.
type ActivityFeedEntry struct {
	ID          uuid.UUID
	Category    string // leads, quotes, appointments, ai
	EventType   string
	Title       string
	Description string
	EntityID    uuid.UUID
	ServiceID   *uuid.UUID
	LeadName    string
	Phone       string
	Email       string
	LeadStatus  string
	ServiceType string
	LeadScore   *int
	Address     string
	Latitude    *float64
	Longitude   *float64
	ScheduledAt *time.Time
	CreatedAt   time.Time
	Priority    int
	GroupCount  int
	ActorName   string
	RawMetadata []byte // raw JSONB from the source table
}

// ActivityFeedReader provides recent org-wide activity for the dashboard feed.
type ActivityFeedReader interface {
	ListRecentActivity(ctx context.Context, organizationID uuid.UUID, limit int, offset int) ([]ActivityFeedEntry, error)
	ListUpcomingAppointments(ctx context.Context, organizationID uuid.UUID, limit int) ([]ActivityFeedEntry, error)
}

// FeedReactionStore provides CRUD for feed reactions.
type FeedReactionStore interface {
	ToggleReaction(ctx context.Context, eventID, eventSource, reactionType string, userID, orgID uuid.UUID) (exists bool, err error)
	ListReactionsByEvent(ctx context.Context, eventID, eventSource string, orgID uuid.UUID) ([]FeedReaction, error)
	ListReactionsByEvents(ctx context.Context, eventIDs []string, orgID uuid.UUID) ([]FeedReaction, error)
}

// FeedCommentStore provides CRUD for feed comments (with @-mentions).
type FeedCommentStore interface {
	CreateComment(ctx context.Context, eventID, eventSource string, userID, orgID uuid.UUID, body string, mentionIDs []uuid.UUID) (FeedComment, error)
	ListCommentsByEvent(ctx context.Context, eventID, eventSource string, orgID uuid.UUID) ([]FeedCommentWithAuthor, error)
	DeleteComment(ctx context.Context, commentID uuid.UUID, userID, orgID uuid.UUID) error
	ListCommentCountsByEvents(ctx context.Context, eventIDs []string, orgID uuid.UUID) (map[string]int, error)
}

// OrgMemberReader provides org member listing for @-mention autocomplete.
type OrgMemberReader interface {
	ListOrgMembers(ctx context.Context, orgID uuid.UUID) ([]OrgMember, error)
}

// =====================================
// Composite Interface (for backward compatibility)
// =====================================

// LeadsRepository defines the complete interface for RAC_leads data operations.
// Composed of smaller, focused interfaces for better testability and flexibility.
type LeadsRepository interface {
	LeadReader
	LeadWriter
	LeadEnrichmentWriter
	LeadViewTracker
	ActivityLogger
	MetricsReader
	LeadServiceReader
	LeadServiceWriter
	NoteStore
	TimelineEventStore
	AIAnalysisStore
	AttachmentStore
	PhotoAnalysisStore
	ServiceTypeContextReader
	AppointmentStatsReader
	PartnerMatcher
	QuotePriceReader
	ActivityFeedReader
	FeedReactionStore
	FeedCommentStore
	OrgMemberReader
}

// Ensure Repository implements LeadsRepository
var _ LeadsRepository = (*Repository)(nil)
</file>

<file path="internal/leads/transport/dto.go">
package transport

import (
	"encoding/json"
	"time"

	"portal_final_backend/internal/leads/repository"

	"github.com/google/uuid"
)

// Enum values
type ConsumerRole string

const (
	ConsumerRoleOwner    ConsumerRole = "Owner"
	ConsumerRoleTenant   ConsumerRole = "Tenant"
	ConsumerRoleLandlord ConsumerRole = "Landlord"
)

type ServiceType string

type LeadStatus string

const (
	LeadStatusNew               LeadStatus = "New"
	LeadStatusAttemptedContact  LeadStatus = "Attempted_Contact"
	LeadStatusScheduled         LeadStatus = "Scheduled"
	LeadStatusSurveyed          LeadStatus = "Surveyed"
	LeadStatusBadLead           LeadStatus = "Bad_Lead"
	LeadStatusNeedsRescheduling LeadStatus = "Needs_Rescheduling"
	LeadStatusClosed            LeadStatus = "Closed"
)

type PipelineStage string

const (
	PipelineStageTriage             PipelineStage = "Triage"
	PipelineStageNurturing          PipelineStage = "Nurturing"
	PipelineStageReadyForEstimator  PipelineStage = "Ready_For_Estimator"
	PipelineStageQuoteSent          PipelineStage = "Quote_Sent"
	PipelineStageReadyForPartner    PipelineStage = "Ready_For_Partner"
	PipelineStagePartnerMatching    PipelineStage = "Partner_Matching"
	PipelineStagePartnerAssigned    PipelineStage = "Partner_Assigned"
	PipelineStageManualIntervention PipelineStage = "Manual_Intervention"
	PipelineStageCompleted          PipelineStage = "Completed"
	PipelineStageLost               PipelineStage = "Lost"
)

// Request DTOs
type CreateLeadRequest struct {
	FirstName     string       `json:"firstName" validate:"required,min=1,max=100"`
	LastName      string       `json:"lastName" validate:"required,min=1,max=100"`
	Phone         string       `json:"phone" validate:"required,min=5,max=20"`
	Email         string       `json:"email,omitempty" validate:"omitempty,email"`
	ConsumerRole  ConsumerRole `json:"consumerRole" validate:"required,oneof=Owner Tenant Landlord"`
	Street        string       `json:"street" validate:"required,min=1,max=200"`
	HouseNumber   string       `json:"houseNumber" validate:"required,min=1,max=20"`
	ZipCode       string       `json:"zipCode" validate:"required,min=1,max=20"`
	City          string       `json:"city" validate:"required,min=1,max=100"`
	Latitude      *float64     `json:"latitude,omitempty" validate:"omitempty,gte=-90,lte=90"`
	Longitude     *float64     `json:"longitude,omitempty" validate:"omitempty,gte=-180,lte=180"`
	ServiceType   ServiceType  `json:"serviceType" validate:"required,min=1,max=100"`
	AssigneeID    OptionalUUID `json:"assigneeId,omitempty" validate:"-"`
	ConsumerNote  string       `json:"consumerNote,omitempty" validate:"max=2000"`
	Source        string       `json:"source,omitempty" validate:"max=50"`
	GCLID         string       `json:"gclid,omitempty" validate:"max=255"`
	UTMSource     string       `json:"utmSource,omitempty" validate:"max=255"`
	UTMMedium     string       `json:"utmMedium,omitempty" validate:"max=255"`
	UTMCampaign   string       `json:"utmCampaign,omitempty" validate:"max=255"`
	UTMContent    string       `json:"utmContent,omitempty" validate:"max=255"`
	UTMTerm       string       `json:"utmTerm,omitempty" validate:"max=255"`
	AdLandingPage string       `json:"adLandingPage,omitempty" validate:"max=2048"`
	ReferrerURL   string       `json:"referrerUrl,omitempty" validate:"max=2048"`
}

type UpdateLeadRequest struct {
	FirstName    *string       `json:"firstName,omitempty" validate:"omitempty,min=1,max=100"`
	LastName     *string       `json:"lastName,omitempty" validate:"omitempty,min=1,max=100"`
	Phone        *string       `json:"phone,omitempty" validate:"omitempty,min=5,max=20"`
	Email        *string       `json:"email,omitempty" validate:"omitempty,email"`
	ConsumerRole *ConsumerRole `json:"consumerRole,omitempty" validate:"omitempty,oneof=Owner Tenant Landlord"`
	Street       *string       `json:"street,omitempty" validate:"omitempty,min=1,max=200"`
	HouseNumber  *string       `json:"houseNumber,omitempty" validate:"omitempty,min=1,max=20"`
	ZipCode      *string       `json:"zipCode,omitempty" validate:"omitempty,min=1,max=20"`
	City         *string       `json:"city,omitempty" validate:"omitempty,min=1,max=100"`
	Latitude     *float64      `json:"latitude,omitempty" validate:"omitempty,gte=-90,lte=90"`
	Longitude    *float64      `json:"longitude,omitempty" validate:"omitempty,gte=-180,lte=180"`
	AssigneeID   OptionalUUID  `json:"assigneeId,omitempty" validate:"-"`
}

type UpdateServiceStatusRequest struct {
	Status LeadStatus `json:"status" validate:"required,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
}

type AddServiceRequest struct {
	ServiceType        ServiceType `json:"serviceType" validate:"required,min=1,max=100"`
	CloseCurrentStatus bool        `json:"closeCurrentStatus"` // If true, auto-close current active service
	ConsumerNote       string      `json:"consumerNote,omitempty" validate:"max=2000"`
	Source             string      `json:"source,omitempty" validate:"max=50"`
}

type UpdateLeadStatusRequest struct {
	Status LeadStatus `json:"status" validate:"required,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
}

type AssignLeadRequest struct {
	AssigneeID *uuid.UUID `json:"assigneeId" validate:"omitempty"`
}

type BulkDeleteLeadsRequest struct {
	IDs []uuid.UUID `json:"ids" validate:"required,min=1,dive,required"`
}

type ListLeadsRequest struct {
	Status          *LeadStatus   `form:"status" validate:"omitempty,oneof=New Attempted_Contact Scheduled Surveyed Bad_Lead Needs_Rescheduling Closed"`
	ServiceType     *ServiceType  `form:"serviceType" validate:"omitempty,min=1,max=100"`
	Search          string        `form:"search" validate:"max=100"`
	FirstName       string        `form:"firstName" validate:"omitempty,max=100"`
	LastName        string        `form:"lastName" validate:"omitempty,max=100"`
	Phone           string        `form:"phone" validate:"omitempty,max=20"`
	Email           string        `form:"email" validate:"omitempty,max=200"`
	Role            *ConsumerRole `form:"role" validate:"omitempty,oneof=Owner Tenant Landlord"`
	Street          string        `form:"street" validate:"omitempty,max=200"`
	HouseNumber     string        `form:"houseNumber" validate:"omitempty,max=20"`
	ZipCode         string        `form:"zipCode" validate:"omitempty,max=20"`
	City            string        `form:"city" validate:"omitempty,max=100"`
	AssignedAgentID *uuid.UUID    `form:"assignedAgentId" validate:"omitempty"`
	CreatedAtFrom   string        `form:"createdAtFrom" validate:"omitempty"`
	CreatedAtTo     string        `form:"createdAtTo" validate:"omitempty"`
	Page            int           `form:"page" validate:"min=1"`
	PageSize        int           `form:"pageSize" validate:"min=1,max=100"`
	SortBy          string        `form:"sortBy" validate:"omitempty,oneof=createdAt firstName lastName phone email role street houseNumber zipCode city assignedAgentId"`
	SortOrder       string        `form:"sortOrder" validate:"omitempty,oneof=asc desc"`
}

type LeadHeatmapRequest struct {
	StartDate string `form:"startDate"`
	EndDate   string `form:"endDate"`
}

type ActionItemsRequest struct {
	Page     int `form:"page" validate:"min=1"`
	PageSize int `form:"pageSize" validate:"min=1,max=50"`
}

// Response DTOs
type ConsumerResponse struct {
	FirstName string       `json:"firstName"`
	LastName  string       `json:"lastName"`
	Phone     string       `json:"phone"`
	Email     *string      `json:"email,omitempty"`
	Role      ConsumerRole `json:"role"`
}

type AddressResponse struct {
	Street      string   `json:"street"`
	HouseNumber string   `json:"houseNumber"`
	ZipCode     string   `json:"zipCode"`
	City        string   `json:"city"`
	Latitude    *float64 `json:"latitude,omitempty"`
	Longitude   *float64 `json:"longitude,omitempty"`
}

type LeadServiceResponse struct {
	ID            uuid.UUID                `json:"id"`
	ServiceType   ServiceType              `json:"serviceType"`
	Status        LeadStatus               `json:"status"`
	PipelineStage PipelineStage            `json:"pipelineStage"`
	Preferences   *LeadPreferencesResponse `json:"preferences,omitempty"`
	ConsumerNote  *string                  `json:"consumerNote,omitempty"`
	CreatedAt     time.Time                `json:"createdAt"`
	UpdatedAt     time.Time                `json:"updatedAt"`
}

type LeadPreferencesResponse struct {
	Budget       *string `json:"budget,omitempty"`
	Timeframe    *string `json:"timeframe,omitempty"`
	Availability *string `json:"availability,omitempty"`
	ExtraNotes   *string `json:"extraNotes,omitempty"`
}

type EnergyLabelResponse struct {
	Energieklasse           string     `json:"energieklasse"`                     // Energy label class (A+++, A++, A+, A, B, C, D, E, F, G)
	EnergieIndex            *float64   `json:"energieIndex,omitempty"`            // Energy index value
	Bouwjaar                int        `json:"bouwjaar,omitempty"`                // Construction year
	GeldigTot               *time.Time `json:"geldigTot,omitempty"`               // Label validity end date
	Gebouwtype              string     `json:"gebouwtype,omitempty"`              // Building type
	Registratiedatum        *time.Time `json:"registratiedatum,omitempty"`        // When the label was registered
	PrimaireFossieleEnergie *float64   `json:"primaireFossieleEnergie,omitempty"` // Primary fossil energy use (kWh/m2jaar)
}

type LeadEnrichmentResponse struct {
	Source                    *string    `json:"source,omitempty"`
	Postcode6                 *string    `json:"postcode6,omitempty"`
	Postcode4                 *string    `json:"postcode4,omitempty"`
	Buurtcode                 *string    `json:"buurtcode,omitempty"`
	DataYear                  *int       `json:"dataYear,omitempty"` // Year of CBS statistics data (e.g. 2022, 2023, 2024)
	GemAardgasverbruik        *float64   `json:"gemAardgasverbruik,omitempty"`
	GemElektriciteitsverbruik *float64   `json:"gemElektriciteitsverbruik,omitempty"`
	HuishoudenGrootte         *float64   `json:"huishoudenGrootte,omitempty"`
	KoopwoningenPct           *float64   `json:"koopwoningenPct,omitempty"`
	BouwjaarVanaf2000Pct      *float64   `json:"bouwjaarVanaf2000Pct,omitempty"`
	WOZWaarde                 *float64   `json:"wozWaarde,omitempty"` // Average WOZ property value in thousands
	MediaanVermogenX1000      *float64   `json:"mediaanVermogenX1000,omitempty"`
	GemInkomen                *float64   `json:"gemInkomen,omitempty"` // Average income in thousands
	PctHoogInkomen            *float64   `json:"pctHoogInkomen,omitempty"`
	PctLaagInkomen            *float64   `json:"pctLaagInkomen,omitempty"`
	HuishoudensMetKinderenPct *float64   `json:"huishoudensMetKinderenPct,omitempty"`
	Stedelijkheid             *int       `json:"stedelijkheid,omitempty"` // 1=very urban to 5=rural
	Confidence                *float64   `json:"confidence,omitempty"`
	FetchedAt                 *time.Time `json:"fetchedAt,omitempty"`
}

type LeadScoreResponse struct {
	Score     *int            `json:"score,omitempty"`
	PreAI     *int            `json:"preAi,omitempty"`
	Factors   json.RawMessage `json:"factors,omitempty"`
	Version   *string         `json:"version,omitempty"`
	UpdatedAt *time.Time      `json:"updatedAt,omitempty"`
}

type AIAnalysisResponse struct {
	ID                      uuid.UUID `json:"id"`
	LeadID                  uuid.UUID `json:"leadId"`
	OrganizationID          uuid.UUID `json:"organizationId"`
	LeadServiceID           uuid.UUID `json:"leadServiceId"`
	UrgencyLevel            string    `json:"urgencyLevel"`
	UrgencyReason           *string   `json:"urgencyReason,omitempty"`
	LeadQuality             string    `json:"leadQuality"`
	RecommendedAction       string    `json:"recommendedAction"`
	MissingInformation      []string  `json:"missingInformation"`
	PreferredContactChannel string    `json:"preferredContactChannel"`
	SuggestedContactMessage string    `json:"suggestedContactMessage"`
	Summary                 string    `json:"summary"`
	CreatedAt               time.Time `json:"createdAt"`
}

func ToAIAnalysisResponse(analysis repository.AIAnalysis) AIAnalysisResponse {
	return AIAnalysisResponse{
		ID:                      analysis.ID,
		LeadID:                  analysis.LeadID,
		OrganizationID:          analysis.OrganizationID,
		LeadServiceID:           analysis.LeadServiceID,
		UrgencyLevel:            analysis.UrgencyLevel,
		UrgencyReason:           analysis.UrgencyReason,
		LeadQuality:             analysis.LeadQuality,
		RecommendedAction:       analysis.RecommendedAction,
		MissingInformation:      analysis.MissingInformation,
		PreferredContactChannel: analysis.PreferredContactChannel,
		SuggestedContactMessage: analysis.SuggestedContactMessage,
		Summary:                 analysis.Summary,
		CreatedAt:               analysis.CreatedAt,
	}
}

type LeadResponse struct {
	ID              uuid.UUID               `json:"id"`
	Consumer        ConsumerResponse        `json:"consumer"`
	Address         AddressResponse         `json:"address"`
	Services        []LeadServiceResponse   `json:"services"`
	CurrentService  *LeadServiceResponse    `json:"currentService,omitempty"`
	AggregateStatus *LeadStatus             `json:"aggregateStatus,omitempty"` // Derived from current service
	EnergyLabel     *EnergyLabelResponse    `json:"energyLabel,omitempty"`     // Energy label data from EP-Online
	LeadEnrichment  *LeadEnrichmentResponse `json:"leadEnrichment,omitempty"`
	LeadScore       *LeadScoreResponse      `json:"leadScore,omitempty"`
	AssignedAgentID *uuid.UUID              `json:"assignedAgentId,omitempty"`
	ViewedByID      *uuid.UUID              `json:"viewedById,omitempty"`
	ViewedAt        *time.Time              `json:"viewedAt,omitempty"`
	Source          *string                 `json:"source,omitempty"`
	CreatedAt       time.Time               `json:"createdAt"`
	UpdatedAt       time.Time               `json:"updatedAt"`
}

type LeadHeatmapPointResponse struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
}

type LeadHeatmapResponse struct {
	Points []LeadHeatmapPointResponse `json:"points"`
}

type ActionItemResponse struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	UrgencyReason *string   `json:"urgencyReason,omitempty"`
	CreatedAt     time.Time `json:"createdAt"`
	IsUrgent      bool      `json:"isUrgent"`
}

type ActionItemsResponse struct {
	Items    []ActionItemResponse `json:"items"`
	Total    int                  `json:"total"`
	Page     int                  `json:"page"`
	PageSize int                  `json:"pageSize"`
}

type LeadListResponse struct {
	Items      []LeadResponse `json:"items"`
	Total      int            `json:"total"`
	Page       int            `json:"page"`
	PageSize   int            `json:"pageSize"`
	TotalPages int            `json:"totalPages"`
}

type DuplicateCheckResponse struct {
	IsDuplicate  bool          `json:"isDuplicate"`
	ExistingLead *LeadResponse `json:"existingLead,omitempty"`
}

// ReturningCustomerResponse provides information about an existing lead for returning customer detection
type ReturningCustomerResponse struct {
	Found         bool           `json:"found"`
	LeadID        *uuid.UUID     `json:"leadId,omitempty"`
	FullName      string         `json:"fullName,omitempty"`
	TotalServices int            `json:"totalServices"`
	Services      []ServiceBrief `json:"services,omitempty"` // Brief summary of past services
}

// ServiceBrief provides a brief summary of a service for returning customer detection
type ServiceBrief struct {
	ServiceType ServiceType `json:"serviceType"`
	Status      LeadStatus  `json:"status"`
	CreatedAt   time.Time   `json:"createdAt"`
}

type BulkDeleteLeadsResponse struct {
	DeletedCount int `json:"deletedCount"`
}

// LeadMetricsResponse provides aggregated KPIs for the dashboard.
type LeadMetricsResponse struct {
	TotalLeads          int     `json:"totalLeads"`
	ProjectedValueCents int64   `json:"projectedValueCents"`
	DisqualifiedRate    float64 `json:"disqualifiedRate"`
	TouchpointsPerLead  float64 `json:"touchpointsPerLead"`
}

// TimelineItem represents an entry in the lead timeline feed.
type TimelineItem struct {
	ID        uuid.UUID      `json:"id"`
	ServiceID *uuid.UUID     `json:"serviceId,omitempty"`
	Type      string         `json:"type"` // 'ai', 'user', 'stage'
	Title     string         `json:"title"`
	Summary   string         `json:"summary"`
	Timestamp time.Time      `json:"timestamp"`
	Actor     string         `json:"actor"`
	Metadata  map[string]any `json:"metadata"`
}

// LogCallRequest is the request body for processing a post-call summary
type LogCallRequest struct {
	Summary string `json:"summary" validate:"required,min=1,max=5000"`
}

// ActivityFeedItem is a single entry in the dashboard activity feed (historical).
type ActivityFeedItem struct {
	ID              string            `json:"id"`
	Type            string            `json:"type"`
	Category        string            `json:"category"`
	Title           string            `json:"title"`
	Description     string            `json:"description,omitempty"`
	LeadName        string            `json:"leadName,omitempty"`
	Phone           string            `json:"phone,omitempty"`
	Email           string            `json:"email,omitempty"`
	LeadStatus      string            `json:"leadStatus,omitempty"`
	ServiceType     string            `json:"serviceType,omitempty"`
	LeadScore       *int              `json:"leadScore,omitempty"`
	Address         string            `json:"address,omitempty"`
	Latitude        *float64          `json:"latitude,omitempty"`
	Longitude       *float64          `json:"longitude,omitempty"`
	ScheduledAt     string            `json:"scheduledAt,omitempty"`
	Timestamp       string            `json:"timestamp"`
	Priority        int               `json:"priority,omitempty"`
	Link            []string          `json:"link,omitempty"`
	Sentiment       string            `json:"sentiment"`
	GroupCount      int               `json:"groupCount,omitempty"`
	ActorName       string            `json:"actorName,omitempty"`
	SuggestedAction string            `json:"suggestedAction,omitempty"`
	ActionLink      string            `json:"actionLink,omitempty"`
	Metadata        map[string]any    `json:"metadata,omitempty"`
	Reactions       []ReactionSummary `json:"reactions"`
	CommentCount    int               `json:"commentCount"`
}

// FeedSeparator marks a position in the feed list for visual grouping (e.g. day headers).
type FeedSeparator struct {
	Index int    `json:"index"`
	Label string `json:"label"`
}

// ActivityFeedResponse wraps the list returned by GET /leads/activity-feed.
type ActivityFeedResponse struct {
	Items      []ActivityFeedItem `json:"items"`
	Separators []FeedSeparator    `json:"separators,omitempty"`
}

// =====================================
// Feed Social DTOs
// =====================================

// ReactionSummary is a per-type aggregate shown on feed items.
type ReactionSummary struct {
	Type  string   `json:"type"` // thumbs-up | heart | party-popper | flame
	Count int      `json:"count"`
	Users []string `json:"users"` // emails of users who reacted
	Me    bool     `json:"me"`    // whether current user reacted
}

// ToggleReactionRequest is the body for POST /activity-feed/:eventId/reactions.
type ToggleReactionRequest struct {
	ReactionType string `json:"reactionType" validate:"required,oneof=thumbs-up heart party-popper flame"`
	EventSource  string `json:"eventSource" validate:"required"`
}

// ToggleReactionResponse is returned after toggling a reaction.
type ToggleReactionResponse struct {
	Active    bool              `json:"active"`
	Reactions []ReactionSummary `json:"reactions"`
}

// CommentItem represents a single feed comment.
type CommentItem struct {
	ID        string        `json:"id"`
	UserEmail string        `json:"userEmail"`
	Body      string        `json:"body"`
	Mentions  []MentionItem `json:"mentions"`
	CreatedAt string        `json:"createdAt"`
}

// MentionItem represents a @-mentioned user inside a comment.
type MentionItem struct {
	UserID string `json:"userId"`
	Email  string `json:"email"`
}

// CreateCommentRequest is the body for POST /activity-feed/:eventId/comments.
type CreateCommentRequest struct {
	Body        string   `json:"body" validate:"required,min=1,max=2000"`
	EventSource string   `json:"eventSource" validate:"required"`
	MentionIDs  []string `json:"mentionIds"`
}

// CommentListResponse wraps the comment thread for an event.
type CommentListResponse struct {
	Comments []CommentItem `json:"comments"`
}

// OrgMemberItem is a mentionable team member.
type OrgMemberItem struct {
	ID    string `json:"id"`
	Email string `json:"email"`
}

// OrgMembersResponse wraps the list of team members.
type OrgMembersResponse struct {
	Members []OrgMemberItem `json:"members"`
}

// LogCallResponse is the response for a processed call log
type LogCallResponse struct {
	NoteCreated            bool       `json:"noteCreated"`
	NoteBody               string     `json:"noteBody,omitempty"`
	AuthorEmail            string     `json:"authorEmail,omitempty"`
	CallOutcome            *string    `json:"callOutcome,omitempty"`
	StatusUpdated          *string    `json:"statusUpdated,omitempty"`
	PipelineStageUpdated   *string    `json:"pipelineStageUpdated,omitempty"`
	AppointmentBooked      *time.Time `json:"appointmentBooked,omitempty"`
	AppointmentRescheduled *time.Time `json:"appointmentRescheduled,omitempty"`
	AppointmentCancelled   bool       `json:"appointmentCancelled,omitempty"`
	Message                string     `json:"message"`
}
</file>

<file path="internal/events/event.go">
// Package events provides domain event definitions for decoupled,
// event-driven communication between modules.
// Infrastructure (Bus, Handler) is in platform/events.
package events

import (
	"time"

	"portal_final_backend/platform/events"

	"github.com/google/uuid"
)

// Re-export platform types for convenience
type (
	Event       = events.Event
	Bus         = events.Bus
	Handler     = events.Handler
	HandlerFunc = events.HandlerFunc
	BaseEvent   = events.BaseEvent
)

// Re-export platform functions
var NewBaseEvent = events.NewBaseEvent

// =============================================================================
// Auth Domain Events
// =============================================================================

// UserSignedUp is published when a new user successfully registers.
type UserSignedUp struct {
	BaseEvent
	UserID      uuid.UUID `json:"userId"`
	Email       string    `json:"email"`
	VerifyToken string    `json:"verifyToken"`
}

func (e UserSignedUp) EventName() string { return "auth.user.signed_up" }

// EmailVerificationRequested is published when a user needs to verify their email.
type EmailVerificationRequested struct {
	BaseEvent
	UserID      uuid.UUID `json:"userId"`
	Email       string    `json:"email"`
	VerifyToken string    `json:"verifyToken"`
}

func (e EmailVerificationRequested) EventName() string { return "auth.email.verification_requested" }

// PasswordResetRequested is published when a user requests a password reset.
type PasswordResetRequested struct {
	BaseEvent
	UserID     uuid.UUID `json:"userId"`
	Email      string    `json:"email"`
	ResetToken string    `json:"resetToken"`
}

func (e PasswordResetRequested) EventName() string { return "auth.password.reset_requested" }

// =============================================================================
// Leads Domain Events
// =============================================================================

// LeadCreated is published when a new lead is created.
type LeadCreated struct {
	BaseEvent
	LeadID          uuid.UUID  `json:"leadId"`
	LeadServiceID   uuid.UUID  `json:"leadServiceId"`
	TenantID        uuid.UUID  `json:"tenantId"`
	AssignedAgentID *uuid.UUID `json:"assignedAgentId,omitempty"`
	ServiceType     string     `json:"serviceType"`
	ConsumerName    string     `json:"consumerName"`
	ConsumerPhone   string     `json:"consumerPhone"`
	PublicToken     string     `json:"publicToken"`
}

func (e LeadCreated) EventName() string { return "RAC_leads.lead.created" }

// LeadAssigned is published when a lead is assigned to an agent.
type LeadAssigned struct {
	BaseEvent
	LeadID        uuid.UUID  `json:"leadId"`
	PreviousAgent *uuid.UUID `json:"previousAgent,omitempty"`
	NewAgent      *uuid.UUID `json:"newAgent,omitempty"`
	AssignedByID  uuid.UUID  `json:"assignedById"`
}

func (e LeadAssigned) EventName() string { return "RAC_leads.lead.assigned" }

// LeadServiceAdded is published when a new service is added to an existing lead.
type LeadServiceAdded struct {
	BaseEvent
	LeadID        uuid.UUID `json:"leadId"`
	LeadServiceID uuid.UUID `json:"leadServiceId"`
	TenantID      uuid.UUID `json:"tenantId"`
	ServiceType   string    `json:"serviceType"`
}

func (e LeadServiceAdded) EventName() string { return "leads.service.added" }

// LeadDataChanged is published when a user updates lead data such as notes or call logs.
type LeadDataChanged struct {
	BaseEvent
	LeadID        uuid.UUID `json:"leadId"`
	LeadServiceID uuid.UUID `json:"leadServiceId"`
	TenantID      uuid.UUID `json:"tenantId"`
	Source        string    `json:"source"` // "call_log", "note", "user_update"
}

func (e LeadDataChanged) EventName() string { return "leads.data.changed" }

// AttachmentUploaded is published when a lead service attachment is created.
type AttachmentUploaded struct {
	BaseEvent
	LeadID        uuid.UUID `json:"leadId"`
	LeadServiceID uuid.UUID `json:"leadServiceId"`
	TenantID      uuid.UUID `json:"tenantId"`
	AttachmentID  uuid.UUID `json:"attachmentId"`
	FileName      string    `json:"fileName"`
	FileKey       string    `json:"fileKey"`
	ContentType   string    `json:"contentType"`
	SizeBytes     int64     `json:"sizeBytes"`
}

func (e AttachmentUploaded) EventName() string { return "leads.attachment.uploaded" }

// PipelineStageChanged is published when the pipeline stage for a lead service changes.
type PipelineStageChanged struct {
	BaseEvent
	LeadID        uuid.UUID `json:"leadId"`
	LeadServiceID uuid.UUID `json:"leadServiceId"`
	TenantID      uuid.UUID `json:"tenantId"`
	OldStage      string    `json:"oldStage"`
	NewStage      string    `json:"newStage"`
}

func (e PipelineStageChanged) EventName() string { return "leads.pipeline.changed" }

// ManualInterventionRequired is published when a lead service requires manual review.
// This occurs when automated processing fails or identifies edge cases that need human attention.
type ManualInterventionRequired struct {
	BaseEvent
	LeadID        uuid.UUID `json:"leadId"`
	LeadServiceID uuid.UUID `json:"leadServiceId"`
	TenantID      uuid.UUID `json:"tenantId"`
	Reason        string    `json:"reason"` // "no_partners_found", "estimation_ambiguous", "special_requirements"
	Context       string    `json:"context,omitempty"`
}

func (e ManualInterventionRequired) EventName() string { return "leads.manual_intervention.required" }

// =============================================================================
// Webhook Domain Events
// =============================================================================

// WebhookLeadCreated is published when a lead is created via the webhook form capture.
type WebhookLeadCreated struct {
	BaseEvent
	LeadID       uuid.UUID `json:"leadId"`
	TenantID     uuid.UUID `json:"tenantId"`
	SourceDomain string    `json:"sourceDomain"`
	IsIncomplete bool      `json:"isIncomplete"`
}

func (e WebhookLeadCreated) EventName() string { return "webhook.lead.created" }

// =============================================================================
// Identity Domain Events
// =============================================================================

// OrganizationInviteCreated is published when an organization invite is created.
type OrganizationInviteCreated struct {
	BaseEvent
	OrganizationID   uuid.UUID `json:"organizationId"`
	OrganizationName string    `json:"organizationName"`
	Email            string    `json:"email"`
	InviteToken      string    `json:"inviteToken"`
}

func (e OrganizationInviteCreated) EventName() string { return "identity.invite.created" }

// OrganizationCreated is published when a new organization is created.
type OrganizationCreated struct {
	BaseEvent
	OrganizationID uuid.UUID `json:"organizationId"`
	CreatedBy      uuid.UUID `json:"createdBy"`
}

func (e OrganizationCreated) EventName() string { return "identity.organization.created" }

// =============================================================================
// Partners Domain Events
// =============================================================================

// PartnerInviteCreated is published when a partner invite is created.
type PartnerInviteCreated struct {
	BaseEvent
	OrganizationID   uuid.UUID  `json:"organizationId"`
	OrganizationName string     `json:"organizationName"`
	PartnerID        uuid.UUID  `json:"partnerId"`
	PartnerName      string     `json:"partnerName"`
	Email            string     `json:"email"`
	InviteToken      string     `json:"inviteToken"`
	LeadID           *uuid.UUID `json:"leadId,omitempty"`
	LeadServiceID    *uuid.UUID `json:"leadServiceId,omitempty"`
}

func (e PartnerInviteCreated) EventName() string { return "partners.invite.created" }

// =============================================================================
// Quotes Domain Events
// =============================================================================

// QuoteSent is published when an agent sends a quote proposal to a lead via magic link.
type QuoteSent struct {
	BaseEvent
	QuoteID          uuid.UUID  `json:"quoteId"`
	OrganizationID   uuid.UUID  `json:"organizationId"`
	LeadID           uuid.UUID  `json:"leadId"`
	LeadServiceID    *uuid.UUID `json:"leadServiceId,omitempty"`
	PublicToken      string     `json:"publicToken"`
	QuoteNumber      string     `json:"quoteNumber"`
	AgentID          uuid.UUID  `json:"agentId"`
	ConsumerEmail    string     `json:"consumerEmail"`
	ConsumerName     string     `json:"consumerName"`
	ConsumerPhone    string     `json:"consumerPhone"`
	OrganizationName string     `json:"organizationName"`
}

func (e QuoteSent) EventName() string { return "quotes.quote.sent" }

// QuoteViewed is published when a lead first opens the public proposal link.
type QuoteViewed struct {
	BaseEvent
	QuoteID        uuid.UUID `json:"quoteId"`
	OrganizationID uuid.UUID `json:"organizationId"`
	LeadID         uuid.UUID `json:"leadId"`
	ViewerIP       string    `json:"viewerIp"`
}

func (e QuoteViewed) EventName() string { return "quotes.quote.viewed" }

// QuoteUpdatedByCustomer is published when a lead toggles optional line items.
type QuoteUpdatedByCustomer struct {
	BaseEvent
	QuoteID         uuid.UUID `json:"quoteId"`
	OrganizationID  uuid.UUID `json:"organizationId"`
	ItemID          uuid.UUID `json:"itemId"`
	ItemDescription string    `json:"itemDescription"`
	IsSelected      bool      `json:"isSelected"`
	NewTotalCents   int64     `json:"newTotalCents"`
}

func (e QuoteUpdatedByCustomer) EventName() string { return "quotes.quote.updated_by_customer" }

// QuoteAnnotated is published when a customer or agent adds an annotation to a line item.
type QuoteAnnotated struct {
	BaseEvent
	QuoteID        uuid.UUID `json:"quoteId"`
	OrganizationID uuid.UUID `json:"organizationId"`
	ItemID         uuid.UUID `json:"itemId"`
	AuthorType     string    `json:"authorType"` // "customer" or "agent"
	AuthorID       string    `json:"authorId"`
	Text           string    `json:"text"`
}

func (e QuoteAnnotated) EventName() string { return "quotes.quote.annotated" }

// QuoteAccepted is published when a lead accepts and signs the quote.
type QuoteAccepted struct {
	BaseEvent
	QuoteID          uuid.UUID  `json:"quoteId"`
	OrganizationID   uuid.UUID  `json:"organizationId"`
	LeadID           uuid.UUID  `json:"leadId"`
	LeadServiceID    *uuid.UUID `json:"leadServiceId,omitempty"`
	SignatureName    string     `json:"signatureName"`
	TotalCents       int64      `json:"totalCents"`
	QuoteNumber      string     `json:"quoteNumber"`
	ConsumerEmail    string     `json:"consumerEmail"`
	ConsumerName     string     `json:"consumerName"`
	OrganizationName string     `json:"organizationName"`
	AgentEmail       string     `json:"agentEmail"`
	AgentName        string     `json:"agentName"`
}

func (e QuoteAccepted) EventName() string { return "quotes.quote.accepted" }

// QuoteRejected is published when a lead rejects the quote.
type QuoteRejected struct {
	BaseEvent
	QuoteID        uuid.UUID  `json:"quoteId"`
	OrganizationID uuid.UUID  `json:"organizationId"`
	LeadID         uuid.UUID  `json:"leadId"`
	LeadServiceID  *uuid.UUID `json:"leadServiceId,omitempty"`
	Reason         string     `json:"reason"`
}

func (e QuoteRejected) EventName() string { return "quotes.quote.rejected" }

// =============================================================================
// Partner Offer Domain Events
// =============================================================================

// PartnerOfferCreated is published when a dispatcher generates a job offer for a vakman.
type PartnerOfferCreated struct {
	BaseEvent
	OfferID          uuid.UUID `json:"offerId"`
	OrganizationID   uuid.UUID `json:"organizationId"`
	PartnerID        uuid.UUID `json:"partnerId"`
	LeadServiceID    uuid.UUID `json:"leadServiceId"`
	LeadID           uuid.UUID `json:"leadId"`
	VakmanPriceCents int64     `json:"vakmanPriceCents"`
	PublicToken      string    `json:"publicToken"`
	PartnerName      string    `json:"partnerName"`
	PartnerPhone     string    `json:"partnerPhone"`
}

func (e PartnerOfferCreated) EventName() string { return "partners.offer.created" }

// PartnerOfferAccepted is published when a vakman accepts the job offer.
type PartnerOfferAccepted struct {
	BaseEvent
	OfferID        uuid.UUID `json:"offerId"`
	OrganizationID uuid.UUID `json:"organizationId"`
	PartnerID      uuid.UUID `json:"partnerId"`
	LeadServiceID  uuid.UUID `json:"leadServiceId"`
	LeadID         uuid.UUID `json:"leadId"`
	PartnerName    string    `json:"partnerName"`
	PartnerEmail   string    `json:"partnerEmail"`
	PartnerPhone   string    `json:"partnerPhone"`
}

func (e PartnerOfferAccepted) EventName() string { return "partners.offer.accepted" }

// PartnerOfferRejected is published when a vakman declines the job offer.
type PartnerOfferRejected struct {
	BaseEvent
	OfferID        uuid.UUID `json:"offerId"`
	OrganizationID uuid.UUID `json:"organizationId"`
	PartnerID      uuid.UUID `json:"partnerId"`
	LeadServiceID  uuid.UUID `json:"leadServiceId"`
	LeadID         uuid.UUID `json:"leadId"`
	PartnerName    string    `json:"partnerName"`
	Reason         string    `json:"reason,omitempty"`
}

func (e PartnerOfferRejected) EventName() string { return "partners.offer.rejected" }

// PartnerOfferExpired is published when an offer expires without a response.
type PartnerOfferExpired struct {
	BaseEvent
	OfferID        uuid.UUID `json:"offerId"`
	OrganizationID uuid.UUID `json:"organizationId"`
	PartnerID      uuid.UUID `json:"partnerId"`
	LeadServiceID  uuid.UUID `json:"leadServiceId"`
	LeadID         uuid.UUID `json:"leadId"`
	PartnerName    string    `json:"partnerName"`
}

func (e PartnerOfferExpired) EventName() string { return "partners.offer.expired" }

// =============================================================================
// Appointments Domain Events
// =============================================================================

// AppointmentCreated is published when an appointment is scheduled.
type AppointmentCreated struct {
	BaseEvent
	AppointmentID  uuid.UUID  `json:"appointmentId"`
	OrganizationID uuid.UUID  `json:"organizationId"`
	LeadID         *uuid.UUID `json:"leadId,omitempty"`
	LeadServiceID  *uuid.UUID `json:"leadServiceId,omitempty"`
	UserID         uuid.UUID  `json:"userId"`
	Type           string     `json:"type"`
	Title          string     `json:"title"`
	StartTime      time.Time  `json:"startTime"`
	EndTime        time.Time  `json:"endTime"`
	ConsumerName   string     `json:"consumerName,omitempty"`
	ConsumerPhone  string     `json:"consumerPhone,omitempty"`
	Location       string     `json:"location,omitempty"`
}

func (e AppointmentCreated) EventName() string { return "appointments.created" }

// AppointmentReminderDue is published when a reminder should be sent.
type AppointmentReminderDue struct {
	BaseEvent
	AppointmentID  uuid.UUID  `json:"appointmentId"`
	OrganizationID uuid.UUID  `json:"organizationId"`
	LeadID         *uuid.UUID `json:"leadId,omitempty"`
	LeadServiceID  *uuid.UUID `json:"leadServiceId,omitempty"`
	UserID         uuid.UUID  `json:"userId"`
	Type           string     `json:"type"`
	Title          string     `json:"title"`
	StartTime      time.Time  `json:"startTime"`
	EndTime        time.Time  `json:"endTime"`
	ConsumerName   string     `json:"consumerName,omitempty"`
	ConsumerPhone  string     `json:"consumerPhone,omitempty"`
	Location       string     `json:"location,omitempty"`
}

func (e AppointmentReminderDue) EventName() string { return "appointments.reminder.due" }
</file>

<file path="internal/quotes/service/service.go">
package service

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/quotes/repository"
	"portal_final_backend/internal/quotes/transport"
	"portal_final_backend/platform/apperr"

	"github.com/google/uuid"
)

// Shared message constants to avoid duplicated string literals.
const (
	msgTotalFormat  = "Totaal: %.2f"
	msgLinkExpired  = "this quote link has expired"
	msgAlreadyFinal = "this quote has already been finalized"
	msgReadOnly     = "this preview link is read-only"
	msgInvalidField = "invalid "
)

// TimelineWriter is the narrow interface a quotes service needs to create lead timeline events.
// Implemented by an adapter in internal/adapters that wraps the leads repository.
type TimelineWriter interface {
	CreateTimelineEvent(ctx context.Context, params TimelineEventParams) error
}

// TimelineEventParams captures timeline event data without importing the leads domain.
type TimelineEventParams struct {
	LeadID         uuid.UUID
	ServiceID      *uuid.UUID
	OrganizationID uuid.UUID
	ActorType      string
	ActorName      string
	EventType      string
	Title          string
	Summary        *string
	Metadata       map[string]any
}

// QuoteContactData holds the consumer/organization/agent info needed for quote emails.
type QuoteContactData struct {
	ConsumerEmail    string
	ConsumerName     string
	ConsumerPhone    string
	OrganizationName string
	AgentEmail       string
	AgentName        string
}

// QuoteContactReader is a narrow interface the quotes service uses to look up lead and
// organization contact details for sending quote proposal emails.
// Implemented by an adapter in internal/adapters that wraps the leads + identity repositories.
type QuoteContactReader interface {
	GetQuoteContactData(ctx context.Context, leadID uuid.UUID, organizationID uuid.UUID) (QuoteContactData, error)
}

// OrgSettingsReader provides organization-level quote defaults (payment days, validity days).
type OrgSettingsReader interface {
	GetQuoteDefaults(ctx context.Context, organizationID uuid.UUID) (paymentDays int, validDays int, err error)
}

// QuotePromptGenerator is a narrow interface for generating quotes from a user prompt.
// Implemented by an adapter wrapping the leads module's QuoteGenerator agent.
type QuotePromptGenerator interface {
	GenerateFromPrompt(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, prompt string, existingQuoteID *uuid.UUID) (*GenerateQuoteResult, error)
}

// GenerateQuoteResult is the result of a prompt-based quote generation.
type GenerateQuoteResult struct {
	QuoteID     uuid.UUID
	QuoteNumber string
	ItemCount   int
}

// Service provides business logic for quotes
type Service struct {
	repo        *repository.Repository
	timeline    TimelineWriter       // optional  nil means no timeline integration
	eventBus    events.Bus           // optional  nil means no event publishing
	contacts    QuoteContactReader   // optional  nil means no email enrichment
	orgSettings OrgSettingsReader    // optional  nil means use hardcoded defaults
	promptGen   QuotePromptGenerator // optional  nil means prompt generation is disabled
}

// New creates a new quotes service
func New(repo *repository.Repository) *Service {
	return &Service{repo: repo}
}

// SetTimelineWriter injects the timeline writer (set after construction to break circular deps).
func (s *Service) SetTimelineWriter(tw TimelineWriter) {
	s.timeline = tw
}

// SetEventBus injects the event bus (set after construction to break circular deps).
func (s *Service) SetEventBus(bus events.Bus) {
	s.eventBus = bus
}

// SetQuoteContactReader injects the contact reader (set after construction to break circular deps).
func (s *Service) SetQuoteContactReader(cr QuoteContactReader) {
	s.contacts = cr
}

// SetOrgSettingsReader injects the org settings reader (set after construction to break circular deps).
func (s *Service) SetOrgSettingsReader(r OrgSettingsReader) {
	s.orgSettings = r
}

// SetQuotePromptGenerator injects the prompt-based quote generator.
func (s *Service) SetQuotePromptGenerator(g QuotePromptGenerator) {
	s.promptGen = g
}

// GetLatestNonDraftByLead returns the most recent non-draft quote for a lead.
func (s *Service) GetLatestNonDraftByLead(ctx context.Context, leadID uuid.UUID, orgID uuid.UUID) (*repository.Quote, error) {
	return s.repo.GetLatestNonDraftByLead(ctx, leadID, orgID)
}

// GenerateQuote generates a quote from a user prompt using the AI agent pipeline.
func (s *Service) GenerateQuote(ctx context.Context, tenantID uuid.UUID, leadID uuid.UUID, serviceID uuid.UUID, prompt string, existingQuoteID *uuid.UUID) (*GenerateQuoteResult, error) {
	if s.promptGen == nil {
		return nil, apperr.Internal("quote generation is not configured")
	}

	return s.promptGen.GenerateFromPrompt(ctx, leadID, serviceID, tenantID, prompt, existingQuoteID)
}

// Create creates a new quote with line items, computing totals server-side
func (s *Service) Create(ctx context.Context, tenantID uuid.UUID, actorID uuid.UUID, req transport.CreateQuoteRequest) (*transport.QuoteResponse, error) {
	// Generate the quote number atomically
	quoteNumber, err := s.repo.NextQuoteNumber(ctx, tenantID)
	if err != nil {
		return nil, fmt.Errorf("generate quote number: %w", err)
	}

	pricingMode := req.PricingMode
	if pricingMode == "" {
		pricingMode = "exclusive"
	}
	discountType := req.DiscountType
	if discountType == "" {
		discountType = "percentage"
	}

	// Server-side calculation
	calcReq := transport.QuoteCalculationRequest{
		Items:         req.Items,
		PricingMode:   pricingMode,
		DiscountType:  discountType,
		DiscountValue: req.DiscountValue,
	}
	calc := CalculateQuote(calcReq)

	now := time.Now()

	// Apply org default for validity if not provided
	validUntil := req.ValidUntil
	if validUntil == nil && s.orgSettings != nil {
		_, validDays, lookupErr := s.orgSettings.GetQuoteDefaults(ctx, tenantID)
		if lookupErr == nil && validDays > 0 {
			defaultExpiry := now.AddDate(0, 0, validDays)
			validUntil = &defaultExpiry
		}
	}

	quote := repository.Quote{
		ID:                  uuid.New(),
		OrganizationID:      tenantID,
		LeadID:              req.LeadID,
		LeadServiceID:       req.LeadServiceID,
		CreatedByID:         &actorID,
		QuoteNumber:         quoteNumber,
		Status:              string(transport.QuoteStatusDraft),
		PricingMode:         pricingMode,
		DiscountType:        discountType,
		DiscountValue:       req.DiscountValue,
		SubtotalCents:       calc.SubtotalCents,
		DiscountAmountCents: calc.DiscountAmountCents,
		TaxTotalCents:       calc.VatTotalCents,
		TotalCents:          calc.TotalCents,
		ValidUntil:          validUntil,
		Notes:               nilIfEmpty(req.Notes),
		FinancingDisclaimer: req.FinancingDisclaimer,
		CreatedAt:           now,
		UpdatedAt:           now,
	}

	items := make([]repository.QuoteItem, len(req.Items))
	for i, it := range req.Items {
		// New items: non-optional are always selected; optional items use request value
		selected := true
		if it.IsOptional {
			selected = it.IsSelected
		}
		items[i] = repository.QuoteItem{
			ID:               uuid.New(),
			QuoteID:          quote.ID,
			OrganizationID:   tenantID,
			Description:      it.Description,
			Quantity:         it.Quantity,
			QuantityNumeric:  parseQuantityNumber(it.Quantity),
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			IsSelected:       selected,
			SortOrder:        i,
			CatalogProductID: it.CatalogProductID,
			CreatedAt:        now,
		}
	}

	if err := s.repo.CreateWithItems(ctx, &quote, items); err != nil {
		return nil, err
	}

	// Save attachments and URLs
	if err := s.saveAttachments(ctx, quote.ID, tenantID, req.Attachments); err != nil {
		return nil, fmt.Errorf("save attachments: %w", err)
	}
	if err := s.saveURLs(ctx, quote.ID, tenantID, req.URLs); err != nil {
		return nil, fmt.Errorf("save urls: %w", err)
	}

	// Timeline event: "Quote OFF-2026-0001 created"
	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         quote.LeadID,
		ServiceID:      quote.LeadServiceID,
		OrganizationID: tenantID,
		ActorType:      "User",
		ActorName:      actorID.String(),
		EventType:      "quote_created",
		Title:          fmt.Sprintf("Offerte %s aangemaakt", quote.QuoteNumber),
		Summary:        toPtr(fmt.Sprintf(msgTotalFormat, float64(quote.TotalCents)/100)),
		Metadata: map[string]any{
			"quoteId": quote.ID,
			"status":  quote.Status,
		},
	})

	return s.buildResponse(&quote, items), nil
}

// DraftQuoteParams contains the data needed to create an AI-drafted quote.
// This is a service-level DTO, separate from transport.CreateQuoteRequest,
// because the AI agent does not go through the HTTP layer.
type DraftQuoteParams struct {
	QuoteID        *uuid.UUID // If set, update the existing quote instead of creating a new one
	LeadID         uuid.UUID
	LeadServiceID  uuid.UUID
	OrganizationID uuid.UUID
	CreatedByID    uuid.UUID
	Notes          string
	Items          []DraftQuoteItemParams
	Attachments    []DraftQuoteAttachmentParams
	URLs           []DraftQuoteURLParams
}

// DraftQuoteItemParams represents a single line item in an AI-drafted quote.
type DraftQuoteItemParams struct {
	Description      string
	Quantity         string
	UnitPriceCents   int64
	TaxRateBps       int
	IsOptional       bool
	CatalogProductID *uuid.UUID
}

// DraftQuoteAttachmentParams represents a catalog document to auto-attach to the quote.
type DraftQuoteAttachmentParams struct {
	Filename         string
	FileKey          string
	Source           string     // "catalog"
	CatalogProductID *uuid.UUID // originating product
}

// DraftQuoteURLParams represents a catalog URL to auto-attach to the quote.
type DraftQuoteURLParams struct {
	Label            string
	Href             string
	CatalogProductID *uuid.UUID // originating product
}

// DraftQuoteResult is the minimal return value after successfully drafting a quote.
type DraftQuoteResult struct {
	QuoteID     uuid.UUID
	QuoteNumber string
	ItemCount   int
}

// DraftQuote creates a new draft quote on behalf of the AI agent.
// If params.QuoteID is set, it updates the existing quote instead of creating a new one.
// It mirrors Create but uses the agent-level params, emits a "quote_drafted"
// timeline event with metadata enabling the frontend to show a "View Draft Quote" card.
func (s *Service) DraftQuote(ctx context.Context, params DraftQuoteParams) (*DraftQuoteResult, error) {
	if params.QuoteID != nil {
		return s.updateDraftQuote(ctx, params)
	}
	return s.createDraftQuote(ctx, params)
}

// createDraftQuote creates a brand-new draft quote.
func (s *Service) createDraftQuote(ctx context.Context, params DraftQuoteParams) (*DraftQuoteResult, error) {
	quoteNumber, err := s.repo.NextQuoteNumber(ctx, params.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("generate quote number: %w", err)
	}

	pricingMode := "exclusive"
	discountType := "percentage"
	calcItems := buildDraftCalcItems(params.Items)

	calc := CalculateQuote(transport.QuoteCalculationRequest{
		Items:       calcItems,
		PricingMode: pricingMode,
	})

	now := time.Now()
	validUntil := s.resolveValidUntil(ctx, params.OrganizationID, now)
	createdBy := nilIfZeroUUID(params.CreatedByID)
	serviceID := &params.LeadServiceID

	quote := repository.Quote{
		ID:                  uuid.New(),
		OrganizationID:      params.OrganizationID,
		LeadID:              params.LeadID,
		LeadServiceID:       serviceID,
		CreatedByID:         createdBy,
		QuoteNumber:         quoteNumber,
		Status:              string(transport.QuoteStatusDraft),
		PricingMode:         pricingMode,
		DiscountType:        discountType,
		DiscountValue:       0,
		SubtotalCents:       calc.SubtotalCents,
		DiscountAmountCents: calc.DiscountAmountCents,
		TaxTotalCents:       calc.VatTotalCents,
		TotalCents:          calc.TotalCents,
		ValidUntil:          validUntil,
		Notes:               nilIfEmpty(params.Notes),
		CreatedAt:           now,
		UpdatedAt:           now,
	}

	items, catalogCount := buildDraftRepoItems(quote.ID, params.OrganizationID, params.Items, now)

	if err := s.repo.CreateWithItems(ctx, &quote, items); err != nil {
		return nil, fmt.Errorf("draft quote: %w", err)
	}

	if err := s.saveDraftAssets(ctx, quote.ID, params); err != nil {
		return nil, err
	}

	s.emitDraftTimelineEvent(ctx, quote, params.OrganizationID, len(items), catalogCount)

	return &DraftQuoteResult{
		QuoteID:     quote.ID,
		QuoteNumber: quoteNumber,
		ItemCount:   len(items),
	}, nil
}

// updateDraftQuote replaces items, notes, and assets on an existing draft quote.
func (s *Service) updateDraftQuote(ctx context.Context, params DraftQuoteParams) (*DraftQuoteResult, error) {
	quoteID := *params.QuoteID

	quote, err := s.repo.GetByID(ctx, quoteID, params.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("update draft quote: load existing: %w", err)
	}

	// Recalculate totals from the new items.
	calcItems := buildDraftCalcItems(params.Items)
	calc := CalculateQuote(transport.QuoteCalculationRequest{
		Items:       calcItems,
		PricingMode: quote.PricingMode,
	})

	now := time.Now()
	quote.SubtotalCents = calc.SubtotalCents
	quote.DiscountAmountCents = calc.DiscountAmountCents
	quote.TaxTotalCents = calc.VatTotalCents
	quote.TotalCents = calc.TotalCents
	quote.Notes = nilIfEmpty(params.Notes)
	quote.UpdatedAt = now

	items, _ := buildDraftRepoItems(quoteID, params.OrganizationID, params.Items, now)

	if err := s.repo.UpdateWithItems(ctx, quote, items, true); err != nil {
		return nil, fmt.Errorf("update draft quote: %w", err)
	}

	if err := s.saveDraftAssets(ctx, quoteID, params); err != nil {
		return nil, err
	}

	return &DraftQuoteResult{
		QuoteID:     quoteID,
		QuoteNumber: quote.QuoteNumber,
		ItemCount:   len(items),
	}, nil
}

// buildDraftCalcItems converts DraftQuoteItemParams to transport items for calculation.
func buildDraftCalcItems(items []DraftQuoteItemParams) []transport.QuoteItemRequest {
	calcItems := make([]transport.QuoteItemRequest, len(items))
	for i, it := range items {
		calcItems[i] = transport.QuoteItemRequest{
			Description:      it.Description,
			Quantity:         it.Quantity,
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			IsSelected:       true,
			CatalogProductID: it.CatalogProductID,
		}
	}
	return calcItems
}

// buildDraftRepoItems creates repository QuoteItems and counts how many reference catalog products.
func buildDraftRepoItems(quoteID, orgID uuid.UUID, items []DraftQuoteItemParams, now time.Time) ([]repository.QuoteItem, int) {
	repoItems := make([]repository.QuoteItem, len(items))
	catalogCount := 0
	for i, it := range items {
		repoItems[i] = repository.QuoteItem{
			ID:               uuid.New(),
			QuoteID:          quoteID,
			OrganizationID:   orgID,
			Description:      it.Description,
			Quantity:         it.Quantity,
			QuantityNumeric:  parseQuantityNumber(it.Quantity),
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			IsSelected:       true,
			SortOrder:        i,
			CatalogProductID: it.CatalogProductID,
			CreatedAt:        now,
		}
		if it.CatalogProductID != nil {
			catalogCount++
		}
	}
	return repoItems, catalogCount
}

// resolveValidUntil returns the default expiry date based on org settings, or nil.
func (s *Service) resolveValidUntil(ctx context.Context, orgID uuid.UUID, now time.Time) *time.Time {
	if s.orgSettings == nil {
		return nil
	}
	_, validDays, err := s.orgSettings.GetQuoteDefaults(ctx, orgID)
	if err != nil || validDays <= 0 {
		return nil
	}
	expiry := now.AddDate(0, 0, validDays)
	return &expiry
}

// nilIfZeroUUID returns nil for uuid.Nil so the DB gets NULL instead of a zero UUID.
func nilIfZeroUUID(id uuid.UUID) *uuid.UUID {
	if id == uuid.Nil {
		return nil
	}
	return &id
}

// saveDraftAssets persists auto-collected catalog attachments and URLs for a draft quote.
func (s *Service) saveDraftAssets(ctx context.Context, quoteID uuid.UUID, params DraftQuoteParams) error {
	if len(params.Attachments) > 0 {
		attReqs := make([]transport.QuoteAttachmentRequest, len(params.Attachments))
		for i, att := range params.Attachments {
			attReqs[i] = transport.QuoteAttachmentRequest{
				Filename:         att.Filename,
				FileKey:          att.FileKey,
				Source:           att.Source,
				CatalogProductID: att.CatalogProductID,
				Enabled:          true,
				SortOrder:        i,
			}
		}
		if err := s.saveAttachments(ctx, quoteID, params.OrganizationID, attReqs); err != nil {
			return fmt.Errorf("draft quote save attachments: %w", err)
		}
	}
	if len(params.URLs) > 0 {
		urlReqs := make([]transport.QuoteURLRequest, len(params.URLs))
		for i, u := range params.URLs {
			urlReqs[i] = transport.QuoteURLRequest{
				Label:            u.Label,
				Href:             u.Href,
				CatalogProductID: u.CatalogProductID,
			}
		}
		if err := s.saveURLs(ctx, quoteID, params.OrganizationID, urlReqs); err != nil {
			return fmt.Errorf("draft quote save urls: %w", err)
		}
	}
	return nil
}

// emitDraftTimelineEvent records a "quote_drafted" timeline event.
func (s *Service) emitDraftTimelineEvent(ctx context.Context, quote repository.Quote, orgID uuid.UUID, itemCount, catalogCount int) {
	adHocCount := itemCount - catalogCount
	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         quote.LeadID,
		ServiceID:      quote.LeadServiceID,
		OrganizationID: orgID,
		ActorType:      "AI",
		ActorName:      "Estimation Agent",
		EventType:      "quote_drafted",
		Title:          fmt.Sprintf("Concept offerte %s opgesteld", quote.QuoteNumber),
		Summary:        toPtr(fmt.Sprintf("Totaal: %.2f (%d items, %d uit catalogus, %d geschat)", float64(quote.TotalCents)/100, itemCount, catalogCount, adHocCount)),
		Metadata: map[string]any{
			"quoteId":      quote.ID,
			"quoteNumber":  quote.QuoteNumber,
			"itemCount":    itemCount,
			"catalogItems": catalogCount,
			"adHocItems":   adHocCount,
			"status":       quote.Status,
		},
	})
}

// applyQuoteUpdates applies optional field updates from the request to the quote.
func applyQuoteUpdates(quote *repository.Quote, req transport.UpdateQuoteRequest) {
	if req.PricingMode != nil {
		quote.PricingMode = *req.PricingMode
	}
	if req.DiscountType != nil {
		quote.DiscountType = *req.DiscountType
	}
	if req.DiscountValue != nil {
		quote.DiscountValue = *req.DiscountValue
	}
	if req.ValidUntil != nil {
		quote.ValidUntil = req.ValidUntil
	}
	if req.Notes != nil {
		quote.Notes = req.Notes
	}
	if req.FinancingDisclaimer != nil {
		quote.FinancingDisclaimer = *req.FinancingDisclaimer
	}
}

// buildItemsFromRequest converts request items into repository QuoteItem models.
func buildItemsFromRequest(quoteID, tenantID uuid.UUID, items []transport.QuoteItemRequest) []repository.QuoteItem {
	now := time.Now()
	result := make([]repository.QuoteItem, len(items))
	for i, it := range items {
		selected := true
		if it.IsOptional {
			selected = it.IsSelected
		}
		result[i] = repository.QuoteItem{
			ID:               uuid.New(),
			QuoteID:          quoteID,
			OrganizationID:   tenantID,
			Description:      it.Description,
			Quantity:         it.Quantity,
			QuantityNumeric:  parseQuantityNumber(it.Quantity),
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			IsSelected:       selected,
			SortOrder:        i,
			CatalogProductID: it.CatalogProductID,
			CreatedAt:        now,
		}
	}
	return result
}

// toItemRequests converts repository QuoteItems to transport QuoteItemRequests.
func toItemRequests(items []repository.QuoteItem) []transport.QuoteItemRequest {
	reqs := make([]transport.QuoteItemRequest, len(items))
	for i, it := range items {
		reqs[i] = transport.QuoteItemRequest{
			Description:      it.Description,
			Quantity:         it.Quantity,
			UnitPriceCents:   it.UnitPriceCents,
			TaxRateBps:       it.TaxRateBps,
			IsOptional:       it.IsOptional,
			IsSelected:       it.IsSelected,
			CatalogProductID: it.CatalogProductID,
		}
	}
	return reqs
}

// Update updates an existing quote and recalculates totals
func (s *Service) Update(ctx context.Context, id uuid.UUID, tenantID uuid.UUID, req transport.UpdateQuoteRequest) (*transport.QuoteResponse, error) {
	quote, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	applyQuoteUpdates(quote, req)

	// Replace line items if provided, otherwise re-fetch existing
	var items []repository.QuoteItem
	if req.Items != nil {
		items = buildItemsFromRequest(quote.ID, tenantID, *req.Items)
	} else {
		items, err = s.repo.GetItemsByQuoteID(ctx, id, tenantID)
		if err != nil {
			return nil, err
		}
	}

	// Recalculate totals
	var itemReqs []transport.QuoteItemRequest
	if req.Items != nil {
		itemReqs = *req.Items
	} else {
		itemReqs = toItemRequests(items)
	}
	calc := CalculateQuote(transport.QuoteCalculationRequest{
		Items:         itemReqs,
		PricingMode:   quote.PricingMode,
		DiscountType:  quote.DiscountType,
		DiscountValue: quote.DiscountValue,
	})
	quote.SubtotalCents = calc.SubtotalCents
	quote.DiscountAmountCents = calc.DiscountAmountCents
	quote.TaxTotalCents = calc.VatTotalCents
	quote.TotalCents = calc.TotalCents
	quote.UpdatedAt = time.Now()

	if err := s.repo.UpdateWithItems(ctx, quote, items, req.Items != nil); err != nil {
		return nil, err
	}

	// Replace attachments / URLs if provided
	if req.Attachments != nil {
		if err := s.saveAttachments(ctx, quote.ID, tenantID, *req.Attachments); err != nil {
			return nil, fmt.Errorf("save attachments: %w", err)
		}
	}
	if req.URLs != nil {
		if err := s.saveURLs(ctx, quote.ID, tenantID, *req.URLs); err != nil {
			return nil, fmt.Errorf("save urls: %w", err)
		}
	}

	return s.buildResponse(quote, items), nil
}

// GetByID retrieves a quote with its line items
func (s *Service) GetByID(ctx context.Context, id uuid.UUID, tenantID uuid.UUID) (*transport.QuoteResponse, error) {
	quote, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	items, err := s.repo.GetItemsByQuoteID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	annotations, _ := s.repo.ListAnnotationsByQuoteID(ctx, id)

	return s.buildResponse(quote, items, annotations), nil
}

// List retrieves quotes with filtering and pagination
func (s *Service) List(ctx context.Context, tenantID uuid.UUID, req transport.ListQuotesRequest) (*transport.QuoteListResponse, error) {
	params := repository.ListParams{
		OrganizationID: tenantID,
		Status:         nilIfEmpty(req.Status),
		Search:         req.Search,
		SortBy:         req.SortBy,
		SortOrder:      req.SortOrder,
		Page:           max(req.Page, 1),
		PageSize:       clampPageSize(req.PageSize),
	}

	createdFrom, createdTo, err := parseDateRange(req.CreatedAtFrom, req.CreatedAtTo, "createdAtFrom", "createdAtTo")
	if err != nil {
		return nil, err
	}
	validFrom, validTo, err := parseDateRange(req.ValidUntilFrom, req.ValidUntilTo, "validUntilFrom", "validUntilTo")
	if err != nil {
		return nil, err
	}
	totalFrom, totalTo, err := parseInt64Range(req.TotalFrom, req.TotalTo, "totalFrom", "totalTo")
	if err != nil {
		return nil, err
	}

	params.CreatedAtFrom = createdFrom
	params.CreatedAtTo = createdTo
	params.ValidUntilFrom = validFrom
	params.ValidUntilTo = validTo
	params.TotalFrom = totalFrom
	params.TotalTo = totalTo

	if req.LeadID != "" {
		parsed, err := uuid.Parse(req.LeadID)
		if err != nil {
			return nil, apperr.BadRequest("invalid leadId format")
		}
		params.LeadID = &parsed
	}

	result, err := s.repo.List(ctx, params)
	if err != nil {
		return nil, err
	}

	items := make([]transport.QuoteResponse, len(result.Items))
	for i, q := range result.Items {
		qItems, _ := s.repo.GetItemsByQuoteID(ctx, q.ID, tenantID)
		items[i] = *s.buildResponse(&q, qItems)
	}

	return &transport.QuoteListResponse{
		Items:      items,
		Total:      result.Total,
		Page:       result.Page,
		PageSize:   result.PageSize,
		TotalPages: result.TotalPages,
	}, nil
}

// UpdateStatus changes the status of a quote
func (s *Service) UpdateStatus(ctx context.Context, id uuid.UUID, tenantID uuid.UUID, actorID uuid.UUID, status transport.QuoteStatus) (*transport.QuoteResponse, error) {
	if err := s.repo.UpdateStatus(ctx, id, tenantID, string(status)); err != nil {
		return nil, err
	}

	resp, err := s.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	// Timeline event: "Quote OFF-2026-0001 marked Sent"
	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         resp.LeadID,
		ServiceID:      resp.LeadServiceID,
		OrganizationID: tenantID,
		ActorType:      "User",
		ActorName:      actorID.String(),
		EventType:      "quote_status_changed",
		Title:          fmt.Sprintf("Offerte %s  %s", resp.QuoteNumber, string(status)),
		Summary:        toPtr(fmt.Sprintf(msgTotalFormat, float64(resp.TotalCents)/100)),
		Metadata: map[string]any{
			"quoteId": resp.ID,
			"status":  string(status),
		},
	})

	return resp, nil
}

// Delete removes a quote and its line items
func (s *Service) Delete(ctx context.Context, id uuid.UUID, tenantID uuid.UUID) error {
	return s.repo.Delete(ctx, id, tenantID)
}

// generatePublicToken creates a 32-byte cryptographically random hex token.
func generatePublicToken() (string, error) {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return "", fmt.Errorf("generate token: %w", err)
	}
	return hex.EncodeToString(b), nil
}

func tokenExpiresAt(q *repository.Quote, kind repository.TokenKind) *time.Time {
	if kind == repository.TokenKindPreview {
		return q.PreviewTokenExpAt
	}
	return q.PublicTokenExpAt
}

func isReadOnlyToken(kind repository.TokenKind) bool {
	return kind == repository.TokenKindPreview
}

func (s *Service) resolveToken(ctx context.Context, token string) (*repository.Quote, repository.TokenKind, error) {
	return s.repo.GetByToken(ctx, token)
}

// Send generates a public token for the quote and transitions it to "Sent" status.
func (s *Service) Send(ctx context.Context, id uuid.UUID, tenantID uuid.UUID, agentID uuid.UUID) (*transport.QuoteResponse, error) {
	quote, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	// Only draft quotes can be sent
	if quote.Status != string(transport.QuoteStatusDraft) {
		return nil, apperr.BadRequest("only draft quotes can be sent")
	}

	token, err := generatePublicToken()
	if err != nil {
		return nil, err
	}

	expiresAt := time.Now().Add(30 * 24 * time.Hour) // 30 days
	if quote.ValidUntil != nil && quote.ValidUntil.After(time.Now()) {
		expiresAt = *quote.ValidUntil
	}

	if err := s.repo.SetPublicToken(ctx, id, tenantID, token, expiresAt); err != nil {
		return nil, err
	}
	if err := s.repo.UpdateStatus(ctx, id, tenantID, string(transport.QuoteStatusSent)); err != nil {
		return nil, err
	}

	// Re-fetch after updates
	resp, err := s.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	// Emit event
	if s.eventBus != nil {
		evt := events.QuoteSent{
			BaseEvent:      events.NewBaseEvent(),
			QuoteID:        id,
			OrganizationID: tenantID,
			LeadID:         quote.LeadID,
			LeadServiceID:  quote.LeadServiceID,
			PublicToken:    token,
			QuoteNumber:    quote.QuoteNumber,
			AgentID:        agentID,
		}
		// Enrich event with contact data for email delivery
		if s.contacts != nil {
			contactData, err := s.contacts.GetQuoteContactData(ctx, quote.LeadID, tenantID)
			if err == nil {
				evt.ConsumerEmail = contactData.ConsumerEmail
				evt.ConsumerName = contactData.ConsumerName
				evt.ConsumerPhone = contactData.ConsumerPhone
				evt.OrganizationName = contactData.OrganizationName
			}
			// If lookup fails, we still publish the event (SSE still works) but email won't send
		}
		s.eventBus.Publish(ctx, evt)
	}

	// Timeline event
	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         quote.LeadID,
		ServiceID:      quote.LeadServiceID,
		OrganizationID: tenantID,
		ActorType:      "User",
		ActorName:      agentID.String(),
		EventType:      "quote_sent",
		Title:          fmt.Sprintf("Offerte %s verstuurd", quote.QuoteNumber),
		Summary:        toPtr(fmt.Sprintf(msgTotalFormat, float64(quote.TotalCents)/100)),
		Metadata: map[string]any{
			"quoteId": id,
			"status":  "Sent",
		},
	})

	return resp, nil
}

// GetPublicQuoteID resolves a public token to its quote UUID (for SSE subscription).
func (s *Service) GetPublicQuoteID(ctx context.Context, token string) (uuid.UUID, error) {
	quote, _, err := s.resolveToken(ctx, token)
	if err != nil {
		return uuid.Nil, err
	}
	return quote.ID, nil
}

// GetPDFFileKey returns the PDF file key for a quote (used for public PDF downloads).
func (s *Service) GetPDFFileKey(ctx context.Context, quoteID uuid.UUID) (string, error) {
	// GetByPublicToken isn't suitable here  use a direct query.
	// We need a method that gets by ID without org scoping.
	return s.repo.GetPDFFileKeyByQuoteID(ctx, quoteID)
}

// GetOrganizationID returns the organization ID for a quote (no org scoping).
func (s *Service) GetOrganizationID(ctx context.Context, quoteID uuid.UUID) (uuid.UUID, error) {
	return s.repo.GetOrganizationIDByQuoteID(ctx, quoteID)
}

// GetPublic retrieves a quote by its public token for unauthenticated lead access.
func (s *Service) GetPublic(ctx context.Context, token string) (*transport.PublicQuoteResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	readOnly := isReadOnlyToken(tokenKind)

	// Check expiry
	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}

	// Mark viewed if first time
	if !readOnly && quote.ViewedAt == nil {
		if err := s.repo.SetViewedAt(ctx, quote.ID); err != nil {
			return nil, err
		}
		now := time.Now()
		quote.ViewedAt = &now

		if s.eventBus != nil {
			s.eventBus.Publish(ctx, events.QuoteViewed{
				BaseEvent:      events.NewBaseEvent(),
				QuoteID:        quote.ID,
				OrganizationID: quote.OrganizationID,
				LeadID:         quote.LeadID,
			})
		}
	}

	items, err := s.repo.GetItemsByQuoteIDNoOrg(ctx, quote.ID)
	if err != nil {
		return nil, err
	}

	orgName, customerName := s.lookupContactNames(ctx, quote.LeadID, quote.OrganizationID)
	return s.buildPublicResponse(quote, items, orgName, customerName, readOnly)
}

// ToggleLineItem toggles the selection of an optional line item and recalculates totals.
func (s *Service) ToggleLineItem(ctx context.Context, token string, itemID uuid.UUID, req transport.ToggleItemRequest) (*transport.ToggleItemResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	if isReadOnlyToken(tokenKind) {
		return nil, apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}
	if quote.Status == string(transport.QuoteStatusAccepted) || quote.Status == string(transport.QuoteStatusRejected) {
		return nil, apperr.BadRequest(msgAlreadyFinal)
	}

	item, err := s.repo.GetItemByID(ctx, itemID, quote.ID)
	if err != nil {
		return nil, err
	}

	if !item.IsOptional {
		return nil, apperr.BadRequest("only optional items can be toggled")
	}

	if err := s.repo.UpdateItemSelection(ctx, itemID, quote.ID, req.IsSelected); err != nil {
		return nil, err
	}

	// Recalculate totals
	allItems, err := s.repo.GetItemsByQuoteIDNoOrg(ctx, quote.ID)
	if err != nil {
		return nil, err
	}

	itemReqs := make([]transport.QuoteItemRequest, len(allItems))
	for i, it := range allItems {
		selected := it.IsSelected
		if it.ID == itemID {
			selected = req.IsSelected
		}
		itemReqs[i] = transport.QuoteItemRequest{
			Description:    it.Description,
			Quantity:       it.Quantity,
			UnitPriceCents: it.UnitPriceCents,
			TaxRateBps:     it.TaxRateBps,
			IsOptional:     it.IsOptional,
			IsSelected:     selected,
		}
	}

	calc := CalculateQuote(transport.QuoteCalculationRequest{
		Items:         itemReqs,
		PricingMode:   quote.PricingMode,
		DiscountType:  quote.DiscountType,
		DiscountValue: quote.DiscountValue,
	})

	if err := s.repo.UpdateQuoteTotals(ctx, quote.ID, calc.SubtotalCents, calc.DiscountAmountCents, calc.VatTotalCents, calc.TotalCents); err != nil {
		return nil, err
	}

	if s.eventBus != nil {
		s.eventBus.Publish(ctx, events.QuoteUpdatedByCustomer{
			BaseEvent:       events.NewBaseEvent(),
			QuoteID:         quote.ID,
			OrganizationID:  quote.OrganizationID,
			ItemID:          itemID,
			ItemDescription: item.Description,
			IsSelected:      req.IsSelected,
			NewTotalCents:   calc.TotalCents,
		})
	}

	return &transport.ToggleItemResponse{
		SubtotalCents:       calc.SubtotalCents,
		DiscountAmountCents: calc.DiscountAmountCents,
		TaxTotalCents:       calc.VatTotalCents,
		TotalCents:          calc.TotalCents,
		VatBreakdown:        calc.VatBreakdown,
	}, nil
}

// AnnotateItem adds an annotation (question/comment) to a quote line item.
func (s *Service) AnnotateItem(ctx context.Context, token string, itemID uuid.UUID, authorType, authorID, text string) (*transport.AnnotationResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	if isReadOnlyToken(tokenKind) {
		return nil, apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}

	// Validate item belongs to quote
	if _, err := s.repo.GetItemByID(ctx, itemID, quote.ID); err != nil {
		return nil, err
	}

	var authorUUID *uuid.UUID
	if authorID != "" {
		parsed, parseErr := uuid.Parse(authorID)
		if parseErr == nil {
			authorUUID = &parsed
		}
	}

	annotation := repository.QuoteAnnotation{
		ID:             uuid.New(),
		QuoteItemID:    itemID,
		OrganizationID: quote.OrganizationID,
		AuthorType:     authorType,
		AuthorID:       authorUUID,
		Text:           text,
		IsResolved:     false,
		CreatedAt:      time.Now(),
	}

	if err := s.repo.CreateAnnotation(ctx, &annotation); err != nil {
		return nil, err
	}

	if s.eventBus != nil {
		s.eventBus.Publish(ctx, events.QuoteAnnotated{
			BaseEvent:      events.NewBaseEvent(),
			QuoteID:        quote.ID,
			OrganizationID: quote.OrganizationID,
			ItemID:         itemID,
			AuthorType:     authorType,
			AuthorID:       authorID,
			Text:           text,
		})
	}

	return &transport.AnnotationResponse{
		ID:         annotation.ID,
		ItemID:     annotation.QuoteItemID,
		AuthorType: annotation.AuthorType,
		AuthorID:   annotation.AuthorID,
		Text:       annotation.Text,
		IsResolved: annotation.IsResolved,
		CreatedAt:  annotation.CreatedAt,
	}, nil
}

// UpdateAnnotation updates an existing annotation's text (public flow).
func (s *Service) UpdateAnnotation(ctx context.Context, token string, itemID, annotationID uuid.UUID, authorType, text string) (*transport.AnnotationResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	if isReadOnlyToken(tokenKind) {
		return nil, apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}

	if _, err := s.repo.GetItemByID(ctx, itemID, quote.ID); err != nil {
		return nil, err
	}

	annotation, err := s.repo.UpdateAnnotationText(ctx, annotationID, itemID, authorType, text)
	if err != nil {
		return nil, err
	}

	return &transport.AnnotationResponse{
		ID:         annotation.ID,
		ItemID:     annotation.QuoteItemID,
		AuthorType: annotation.AuthorType,
		AuthorID:   annotation.AuthorID,
		Text:       annotation.Text,
		IsResolved: annotation.IsResolved,
		CreatedAt:  annotation.CreatedAt,
	}, nil
}

// DeleteAnnotation removes an existing annotation if it has no agent response.
func (s *Service) DeleteAnnotation(ctx context.Context, token string, itemID, annotationID uuid.UUID, authorType string) error {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return err
	}
	if isReadOnlyToken(tokenKind) {
		return apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return apperr.Gone(msgLinkExpired)
	}

	if _, err := s.repo.GetItemByID(ctx, itemID, quote.ID); err != nil {
		return err
	}

	annotations, err := s.repo.ListAnnotationsByQuoteID(ctx, quote.ID)
	if err != nil {
		return err
	}
	for _, ann := range annotations {
		if ann.QuoteItemID == itemID && ann.AuthorType == "agent" {
			return apperr.Forbidden("annotation cannot be deleted after agent response")
		}
	}

	return s.repo.DeleteAnnotation(ctx, annotationID, itemID, authorType)
}

// AgentAnnotateItem lets an authenticated agent add an annotation to a quote item.
func (s *Service) AgentAnnotateItem(ctx context.Context, quoteID, itemID, tenantID, agentID uuid.UUID, text string) (*transport.AnnotationResponse, error) {
	quote, err := s.repo.GetByID(ctx, quoteID, tenantID)
	if err != nil {
		return nil, err
	}

	if _, err := s.repo.GetItemByID(ctx, itemID, quote.ID); err != nil {
		return nil, err
	}

	agentPtr := &agentID
	annotation := repository.QuoteAnnotation{
		ID:             uuid.New(),
		QuoteItemID:    itemID,
		OrganizationID: tenantID,
		AuthorType:     "agent",
		AuthorID:       agentPtr,
		Text:           text,
		IsResolved:     false,
		CreatedAt:      time.Now(),
	}

	if err := s.repo.CreateAnnotation(ctx, &annotation); err != nil {
		return nil, err
	}

	if s.eventBus != nil {
		s.eventBus.Publish(ctx, events.QuoteAnnotated{
			BaseEvent:      events.NewBaseEvent(),
			QuoteID:        quoteID,
			OrganizationID: tenantID,
			ItemID:         itemID,
			AuthorType:     "agent",
			AuthorID:       agentID.String(),
			Text:           text,
		})
	}

	return &transport.AnnotationResponse{
		ID:         annotation.ID,
		ItemID:     annotation.QuoteItemID,
		AuthorType: annotation.AuthorType,
		AuthorID:   annotation.AuthorID,
		Text:       annotation.Text,
		IsResolved: annotation.IsResolved,
		CreatedAt:  annotation.CreatedAt,
	}, nil
}

// Accept processes a lead accepting the quote with their digital signature.
func (s *Service) Accept(ctx context.Context, token string, req transport.AcceptQuoteRequest, clientIP string) (*transport.PublicQuoteResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	if isReadOnlyToken(tokenKind) {
		return nil, apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}
	if quote.Status == string(transport.QuoteStatusAccepted) {
		return nil, apperr.BadRequest("this quote has already been accepted")
	}
	if quote.Status == string(transport.QuoteStatusRejected) {
		return nil, apperr.BadRequest("this quote has been rejected")
	}

	if err := s.repo.AcceptQuote(ctx, quote.ID, req.SignatureName, req.SignatureData, clientIP); err != nil {
		return nil, err
	}

	// Refresh
	quote, _, err = s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}

	items, err := s.repo.GetItemsByQuoteIDNoOrg(ctx, quote.ID)
	if err != nil {
		return nil, err
	}

	if s.eventBus != nil {
		evt := events.QuoteAccepted{
			BaseEvent:      events.NewBaseEvent(),
			QuoteID:        quote.ID,
			OrganizationID: quote.OrganizationID,
			LeadID:         quote.LeadID,
			LeadServiceID:  quote.LeadServiceID,
			SignatureName:  req.SignatureName,
			TotalCents:     quote.TotalCents,
			QuoteNumber:    quote.QuoteNumber,
		}
		// Enrich event with contact + agent data for email delivery and PDF
		if s.contacts != nil {
			contactData, lookupErr := s.contacts.GetQuoteContactData(ctx, quote.LeadID, quote.OrganizationID)
			if lookupErr == nil {
				evt.ConsumerEmail = contactData.ConsumerEmail
				evt.ConsumerName = contactData.ConsumerName
				evt.OrganizationName = contactData.OrganizationName
				evt.AgentEmail = contactData.AgentEmail
				evt.AgentName = contactData.AgentName
			}
		}
		s.eventBus.Publish(ctx, evt)
	}

	orgName, customerName := s.lookupContactNames(ctx, quote.LeadID, quote.OrganizationID)
	drafts := buildQuoteAcceptedDrafts(quote.QuoteNumber, orgName, customerName, req.SignatureName, quote.TotalCents)

	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         quote.LeadID,
		ServiceID:      quote.LeadServiceID,
		OrganizationID: quote.OrganizationID,
		ActorType:      "Lead",
		ActorName:      req.SignatureName,
		EventType:      "quote_accepted",
		Title:          fmt.Sprintf("Offerte %s geaccepteerd", quote.QuoteNumber),
		Summary:        toPtr(fmt.Sprintf("Ondertekend door %s  "+msgTotalFormat, req.SignatureName, float64(quote.TotalCents)/100)),
		Metadata: map[string]any{
			"quoteId":       quote.ID,
			"status":        "Accepted",
			"signatureName": req.SignatureName,
			"drafts":        drafts,
		},
	})
	return s.buildPublicResponse(quote, items, orgName, customerName, false)
}

// Reject processes a lead rejecting the quote.
func (s *Service) Reject(ctx context.Context, token string, req transport.RejectQuoteRequest) (*transport.PublicQuoteResponse, error) {
	quote, tokenKind, err := s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}
	if isReadOnlyToken(tokenKind) {
		return nil, apperr.Forbidden(msgReadOnly)
	}

	if expAt := tokenExpiresAt(quote, tokenKind); expAt != nil && expAt.Before(time.Now()) {
		return nil, apperr.Gone(msgLinkExpired)
	}
	if quote.Status == string(transport.QuoteStatusAccepted) || quote.Status == string(transport.QuoteStatusRejected) {
		return nil, apperr.BadRequest(msgAlreadyFinal)
	}

	reasonPtr := &req.Reason
	if req.Reason == "" {
		reasonPtr = nil
	}
	if err := s.repo.RejectQuote(ctx, quote.ID, reasonPtr); err != nil {
		return nil, err
	}

	quote, _, err = s.resolveToken(ctx, token)
	if err != nil {
		return nil, err
	}

	items, err := s.repo.GetItemsByQuoteIDNoOrg(ctx, quote.ID)
	if err != nil {
		return nil, err
	}

	if s.eventBus != nil {
		s.eventBus.Publish(ctx, events.QuoteRejected{
			BaseEvent:      events.NewBaseEvent(),
			QuoteID:        quote.ID,
			OrganizationID: quote.OrganizationID,
			LeadID:         quote.LeadID,
			LeadServiceID:  quote.LeadServiceID,
			Reason:         req.Reason,
		})
	}

	orgName, customerName := s.lookupContactNames(ctx, quote.LeadID, quote.OrganizationID)
	drafts := buildQuoteRejectedDrafts(quote.QuoteNumber, orgName, customerName, req.Reason)

	s.emitTimelineEvent(ctx, TimelineEventParams{
		LeadID:         quote.LeadID,
		ServiceID:      quote.LeadServiceID,
		OrganizationID: quote.OrganizationID,
		ActorType:      "Lead",
		ActorName:      "Klant",
		EventType:      "quote_rejected",
		Title:          fmt.Sprintf("Offerte %s afgewezen", quote.QuoteNumber),
		Summary:        nilIfEmpty(req.Reason),
		Metadata: map[string]any{
			"quoteId": quote.ID,
			"status":  "Rejected",
			"reason":  req.Reason,
			"drafts":  drafts,
		},
	})
	return s.buildPublicResponse(quote, items, orgName, customerName, false)
}

// buildPublicResponse converts a repository Quote + items into a public transport response.
func (s *Service) buildPublicResponse(q *repository.Quote, items []repository.QuoteItem, organizationName, customerName string, readOnly bool) (*transport.PublicQuoteResponse, error) {
	pricingMode := q.PricingMode
	if pricingMode == "" {
		pricingMode = "exclusive"
	}

	annotations, _ := s.repo.ListAnnotationsByQuoteID(context.Background(), q.ID)
	annotationsByItem := make(map[uuid.UUID][]transport.AnnotationResponse)
	for _, ann := range annotations {
		annotationsByItem[ann.QuoteItemID] = append(annotationsByItem[ann.QuoteItemID], transport.AnnotationResponse{
			ID:         ann.ID,
			ItemID:     ann.QuoteItemID,
			AuthorType: ann.AuthorType,
			AuthorID:   ann.AuthorID,
			Text:       ann.Text,
			IsResolved: ann.IsResolved,
			CreatedAt:  ann.CreatedAt,
		})
	}

	respItems := make([]transport.PublicQuoteItemResponse, len(items))
	for i, it := range items {
		qty := parseQuantityNumber(it.Quantity)
		unitPrice := float64(it.UnitPriceCents)
		taxRateBps := it.TaxRateBps

		netUnitPrice := unitPrice
		if pricingMode == "inclusive" && taxRateBps > 0 {
			netUnitPrice = unitPrice / (1.0 + float64(taxRateBps)/10000.0)
		}

		lineSubtotal := qty * netUnitPrice
		lineVat := lineSubtotal * (float64(taxRateBps) / 10000.0)

		respItems[i] = transport.PublicQuoteItemResponse{
			ID:                  it.ID,
			Description:         it.Description,
			Quantity:            it.Quantity,
			UnitPriceCents:      it.UnitPriceCents,
			TaxRateBps:          it.TaxRateBps,
			IsOptional:          it.IsOptional,
			IsSelected:          it.IsSelected,
			SortOrder:           it.SortOrder,
			TotalBeforeTaxCents: roundCents(lineSubtotal),
			TotalTaxCents:       roundCents(lineVat),
			LineTotalCents:      roundCents(lineSubtotal + lineVat),
			Annotations:         annotationsByItem[it.ID],
		}
		if respItems[i].Annotations == nil {
			respItems[i].Annotations = []transport.AnnotationResponse{}
		}
	}

	// Compute VAT breakdown
	itemReqs := make([]transport.QuoteItemRequest, len(items))
	for i, it := range items {
		itemReqs[i] = transport.QuoteItemRequest{
			Description:    it.Description,
			Quantity:       it.Quantity,
			UnitPriceCents: it.UnitPriceCents,
			TaxRateBps:     it.TaxRateBps,
			IsOptional:     it.IsOptional,
			IsSelected:     it.IsSelected,
		}
	}
	calc := CalculateQuote(transport.QuoteCalculationRequest{
		Items:         itemReqs,
		PricingMode:   q.PricingMode,
		DiscountType:  q.DiscountType,
		DiscountValue: q.DiscountValue,
	})

	return &transport.PublicQuoteResponse{
		ID:                  q.ID,
		QuoteNumber:         q.QuoteNumber,
		Status:              transport.QuoteStatus(q.Status),
		PricingMode:         q.PricingMode,
		OrganizationName:    organizationName,
		CustomerName:        customerName,
		DiscountType:        q.DiscountType,
		DiscountValue:       q.DiscountValue,
		SubtotalCents:       calc.SubtotalCents,
		DiscountAmountCents: calc.DiscountAmountCents,
		TaxTotalCents:       calc.VatTotalCents,
		TotalCents:          calc.TotalCents,
		VatBreakdown:        calc.VatBreakdown,
		ValidUntil:          q.ValidUntil,
		Notes:               q.Notes,
		Items:               respItems,
		Attachments:         s.loadAttachmentResponsesNoOrg(q.ID),
		URLs:                s.loadURLResponsesNoOrg(q.ID),
		AcceptedAt:          q.AcceptedAt,
		RejectedAt:          q.RejectedAt,
		FinancingDisclaimer: q.FinancingDisclaimer,
		IsReadOnly:          readOnly,
	}, nil
}

// GetPreviewLink returns (or creates) a read-only preview token for a quote.
func (s *Service) GetPreviewLink(ctx context.Context, id uuid.UUID, tenantID uuid.UUID) (*transport.QuotePreviewLinkResponse, error) {
	quote, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		return nil, err
	}

	if quote.Status == string(transport.QuoteStatusDraft) {
		return nil, apperr.BadRequest("preview link is not available for draft quotes")
	}

	now := time.Now()
	if quote.PreviewToken != nil && quote.PreviewTokenExpAt != nil && quote.PreviewTokenExpAt.After(now) {
		return &transport.QuotePreviewLinkResponse{
			Token:     *quote.PreviewToken,
			ExpiresAt: quote.PreviewTokenExpAt,
		}, nil
	}

	token, err := generatePublicToken()
	if err != nil {
		return nil, err
	}

	expiresAt := now.Add(30 * 24 * time.Hour)
	if quote.ValidUntil != nil && quote.ValidUntil.After(now) {
		expiresAt = *quote.ValidUntil
	}

	if err := s.repo.SetPreviewToken(ctx, id, tenantID, token, expiresAt); err != nil {
		return nil, err
	}

	return &transport.QuotePreviewLinkResponse{
		Token:     token,
		ExpiresAt: &expiresAt,
	}, nil
}

// buildResponse converts a repository Quote + items into a transport response
func (s *Service) buildResponse(q *repository.Quote, items []repository.QuoteItem, annotations ...[]repository.QuoteAnnotation) *transport.QuoteResponse {
	pricingMode := q.PricingMode
	if pricingMode == "" {
		pricingMode = "exclusive"
	}

	// Index annotations by item ID
	annotationsByItem := make(map[uuid.UUID][]transport.AnnotationResponse)
	if len(annotations) > 0 {
		for _, a := range annotations[0] {
			annotationsByItem[a.QuoteItemID] = append(annotationsByItem[a.QuoteItemID], transport.AnnotationResponse{
				ID:         a.ID,
				ItemID:     a.QuoteItemID,
				AuthorType: a.AuthorType,
				AuthorID:   a.AuthorID,
				Text:       a.Text,
				IsResolved: a.IsResolved,
				CreatedAt:  a.CreatedAt,
			})
		}
	}

	respItems := make([]transport.QuoteItemResponse, len(items))
	for i, it := range items {
		qty := parseQuantityNumber(it.Quantity)
		unitPrice := float64(it.UnitPriceCents)
		taxRateBps := it.TaxRateBps

		netUnitPrice := unitPrice
		if pricingMode == "inclusive" && taxRateBps > 0 {
			netUnitPrice = unitPrice / (1.0 + float64(taxRateBps)/10000.0)
		}

		lineSubtotal := qty * netUnitPrice
		lineVat := lineSubtotal * (float64(taxRateBps) / 10000.0)

		respItems[i] = transport.QuoteItemResponse{
			ID:                  it.ID,
			Description:         it.Description,
			Quantity:            it.Quantity,
			UnitPriceCents:      it.UnitPriceCents,
			TaxRateBps:          it.TaxRateBps,
			IsOptional:          it.IsOptional,
			IsSelected:          it.IsSelected,
			SortOrder:           it.SortOrder,
			CatalogProductID:    it.CatalogProductID,
			TotalBeforeTaxCents: roundCents(lineSubtotal),
			TotalTaxCents:       roundCents(lineVat),
			LineTotalCents:      roundCents(lineSubtotal + lineVat),
			Annotations:         annotationsByItem[it.ID],
		}
		if respItems[i].Annotations == nil {
			respItems[i].Annotations = []transport.AnnotationResponse{}
		}
	}

	return &transport.QuoteResponse{
		ID:                         q.ID,
		QuoteNumber:                q.QuoteNumber,
		LeadID:                     q.LeadID,
		LeadServiceID:              q.LeadServiceID,
		CreatedByID:                q.CreatedByID,
		CreatedByFirstName:         q.CreatedByFirstName,
		CreatedByLastName:          q.CreatedByLastName,
		CreatedByEmail:             q.CreatedByEmail,
		CustomerFirstName:          q.CustomerFirstName,
		CustomerLastName:           q.CustomerLastName,
		CustomerPhone:              q.CustomerPhone,
		CustomerEmail:              q.CustomerEmail,
		CustomerAddressStreet:      q.CustomerAddressStreet,
		CustomerAddressHouseNumber: q.CustomerAddressHouseNumber,
		CustomerAddressZipCode:     q.CustomerAddressZipCode,
		CustomerAddressCity:        q.CustomerAddressCity,
		Status:                     transport.QuoteStatus(q.Status),
		PricingMode:                q.PricingMode,
		DiscountType:               q.DiscountType,
		DiscountValue:              q.DiscountValue,
		SubtotalCents:              q.SubtotalCents,
		DiscountAmountCents:        q.DiscountAmountCents,
		TaxTotalCents:              q.TaxTotalCents,
		TotalCents:                 q.TotalCents,
		ValidUntil:                 q.ValidUntil,
		Notes:                      q.Notes,
		Items:                      respItems,
		Attachments:                s.loadAttachmentResponses(q.ID, q.OrganizationID),
		URLs:                       s.loadURLResponses(q.ID, q.OrganizationID),
		ViewedAt:                   q.ViewedAt,
		AcceptedAt:                 q.AcceptedAt,
		RejectedAt:                 q.RejectedAt,
		PDFFileKey:                 q.PDFFileKey,
		FinancingDisclaimer:        q.FinancingDisclaimer,
		CreatedAt:                  q.CreatedAt,
		UpdatedAt:                  q.UpdatedAt,
	}
}

//  Attachment & URL Helpers 

// GetAttachmentByID returns a single attachment by ID, verifying quote ownership.
func (s *Service) GetAttachmentByID(ctx context.Context, attachmentID, quoteID, tenantID uuid.UUID) (*repository.QuoteAttachment, error) {
	// Verify the quote belongs to this tenant
	if _, err := s.repo.GetByID(ctx, quoteID, tenantID); err != nil {
		return nil, err
	}
	return s.repo.GetAttachmentByID(ctx, attachmentID, quoteID, tenantID)
}

// saveAttachments persists a slice of attachment requests for a quote.
func (s *Service) saveAttachments(ctx context.Context, quoteID, orgID uuid.UUID, reqs []transport.QuoteAttachmentRequest) error {
	if len(reqs) == 0 {
		return nil
	}
	now := time.Now()
	models := make([]repository.QuoteAttachment, len(reqs))
	for i, r := range reqs {
		models[i] = repository.QuoteAttachment{
			ID:               uuid.New(),
			QuoteID:          quoteID,
			OrganizationID:   orgID,
			Filename:         r.Filename,
			FileKey:          r.FileKey,
			Source:           r.Source,
			CatalogProductID: r.CatalogProductID,
			Enabled:          r.Enabled,
			SortOrder:        r.SortOrder,
			CreatedAt:        now,
		}
	}
	return s.repo.ReplaceAttachments(ctx, quoteID, orgID, models)
}

// saveURLs persists a slice of URL requests for a quote.
func (s *Service) saveURLs(ctx context.Context, quoteID, orgID uuid.UUID, reqs []transport.QuoteURLRequest) error {
	if len(reqs) == 0 {
		return nil
	}
	now := time.Now()
	models := make([]repository.QuoteURL, len(reqs))
	for i, r := range reqs {
		models[i] = repository.QuoteURL{
			ID:               uuid.New(),
			QuoteID:          quoteID,
			OrganizationID:   orgID,
			Label:            r.Label,
			Href:             r.Href,
			Accepted:         false,
			CatalogProductID: r.CatalogProductID,
			CreatedAt:        now,
		}
	}
	return s.repo.ReplaceURLs(ctx, quoteID, orgID, models)
}

// loadAttachmentResponses loads attachments for a quote (org-scoped).
func (s *Service) loadAttachmentResponses(quoteID, orgID uuid.UUID) []transport.QuoteAttachmentResponse {
	attachments, _ := s.repo.GetAttachmentsByQuoteID(context.Background(), quoteID, orgID)
	resp := make([]transport.QuoteAttachmentResponse, len(attachments))
	for i, a := range attachments {
		resp[i] = toAttachmentResponse(a)
	}
	return resp
}

// loadURLResponses loads URLs for a quote (org-scoped).
func (s *Service) loadURLResponses(quoteID, orgID uuid.UUID) []transport.QuoteURLResponse {
	urls, _ := s.repo.GetURLsByQuoteID(context.Background(), quoteID, orgID)
	resp := make([]transport.QuoteURLResponse, len(urls))
	for i, u := range urls {
		resp[i] = toURLResponse(u)
	}
	return resp
}

// loadAttachmentResponsesNoOrg loads attachments without org scoping (public access / PDF).
func (s *Service) loadAttachmentResponsesNoOrg(quoteID uuid.UUID) []transport.QuoteAttachmentResponse {
	attachments, _ := s.repo.GetAttachmentsByQuoteIDNoOrg(context.Background(), quoteID)
	resp := make([]transport.QuoteAttachmentResponse, len(attachments))
	for i, a := range attachments {
		resp[i] = toAttachmentResponse(a)
	}
	return resp
}

// loadURLResponsesNoOrg loads URLs without org scoping (public access).
func (s *Service) loadURLResponsesNoOrg(quoteID uuid.UUID) []transport.QuoteURLResponse {
	urls, _ := s.repo.GetURLsByQuoteIDNoOrg(context.Background(), quoteID)
	resp := make([]transport.QuoteURLResponse, len(urls))
	for i, u := range urls {
		resp[i] = toURLResponse(u)
	}
	return resp
}

func toAttachmentResponse(a repository.QuoteAttachment) transport.QuoteAttachmentResponse {
	return transport.QuoteAttachmentResponse{
		ID:               a.ID,
		Filename:         a.Filename,
		FileKey:          a.FileKey,
		Source:           a.Source,
		CatalogProductID: a.CatalogProductID,
		Enabled:          a.Enabled,
		SortOrder:        a.SortOrder,
		CreatedAt:        a.CreatedAt,
	}
}

func toURLResponse(u repository.QuoteURL) transport.QuoteURLResponse {
	return transport.QuoteURLResponse{
		ID:               u.ID,
		Label:            u.Label,
		Href:             u.Href,
		Accepted:         u.Accepted,
		CatalogProductID: u.CatalogProductID,
		CreatedAt:        u.CreatedAt,
	}
}

// emitTimelineEvent fires a timeline event if a TimelineWriter is configured.
// Failures are logged but never block the main flow.
func (s *Service) emitTimelineEvent(ctx context.Context, params TimelineEventParams) {
	if s.timeline == nil {
		return
	}
	// Best-effort  do not fail the request if the timeline write fails
	_ = s.timeline.CreateTimelineEvent(ctx, params)
}

func toPtr(s string) *string { return &s }

// lookupContactNames returns the organization name and customer name for a quote.
// Returns empty strings if the contact reader is unavailable or lookup fails.
func (s *Service) lookupContactNames(ctx context.Context, leadID, orgID uuid.UUID) (orgName, customerName string) {
	if s.contacts == nil {
		return "", ""
	}
	data, err := s.contacts.GetQuoteContactData(ctx, leadID, orgID)
	if err != nil {
		return "", ""
	}
	return data.OrganizationName, data.ConsumerName
}

func clampPageSize(size int) int {
	if size < 1 || size > 100 {
		return 50
	}
	return size
}

func nilIfEmpty(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

func buildQuoteAcceptedDrafts(quoteNumber, orgName, customerName, signatureName string, totalCents int64) map[string]any {
	if strings.TrimSpace(customerName) == "" {
		customerName = "klant"
	}
	if strings.TrimSpace(orgName) == "" {
		orgName = "ons team"
	}
	subject := fmt.Sprintf("Bevestiging ontvangen - offerte %s", quoteNumber)
	body := fmt.Sprintf("Hallo %s,\n\nBedankt voor het accepteren van offerte %s. Wij verwerken uw akkoord en nemen snel contact met u op voor de volgende stappen.\n\nOndertekend door: %s\nTotaal: EUR %.2f\n\nMet vriendelijke groet,\n%s", customerName, quoteNumber, signatureName, float64(totalCents)/100, orgName)
	whatsApp := fmt.Sprintf("Hallo %s, bedankt voor het accepteren van offerte %s. Wij nemen snel contact met u op voor de volgende stappen.\n\nMet vriendelijke groet, %s", customerName, quoteNumber, orgName)

	return map[string]any{
		"emailSubject":    subject,
		"emailBody":       body,
		"whatsappMessage": whatsApp,
		"messageLanguage": "nl",
		"messageAudience": "customer",
		"messageCategory": "quote_accepted",
	}
}

func buildQuoteRejectedDrafts(quoteNumber, orgName, customerName, reason string) map[string]any {
	if strings.TrimSpace(customerName) == "" {
		customerName = "klant"
	}
	if strings.TrimSpace(orgName) == "" {
		orgName = "ons team"
	}
	cleanReason := strings.TrimSpace(reason)
	if cleanReason == "" {
		cleanReason = "Geen reden opgegeven"
	}
	subject := fmt.Sprintf("We hebben uw beslissing ontvangen - offerte %s", quoteNumber)
	body := fmt.Sprintf("Hallo %s,\n\nWij hebben uw beslissing over offerte %s ontvangen. Reden: %s.\n\nAls u vragen heeft of wilt overleggen, helpen wij graag.\n\nMet vriendelijke groet,\n%s", customerName, quoteNumber, cleanReason, orgName)
	whatsApp := fmt.Sprintf("Hallo %s, wij hebben uw beslissing over offerte %s ontvangen. Reden: %s. Als u vragen heeft, helpen wij graag.\n\nMet vriendelijke groet, %s", customerName, quoteNumber, cleanReason, orgName)

	return map[string]any{
		"emailSubject":    subject,
		"emailBody":       body,
		"whatsappMessage": whatsApp,
		"messageLanguage": "nl",
		"messageAudience": "customer",
		"messageCategory": "quote_rejected",
	}
}

func parseDateRange(from string, to string, fromField string, toField string) (*time.Time, *time.Time, error) {
	const dateLayout = "2006-01-02"

	trimmedFrom := strings.TrimSpace(from)
	trimmedTo := strings.TrimSpace(to)

	var start *time.Time
	var end *time.Time

	if trimmedFrom != "" {
		parsed, err := time.Parse(dateLayout, trimmedFrom)
		if err != nil {
			return nil, nil, apperr.Validation(msgInvalidField + fromField)
		}
		start = &parsed
	}

	if trimmedTo != "" {
		parsed, err := time.Parse(dateLayout, trimmedTo)
		if err != nil {
			return nil, nil, apperr.Validation(msgInvalidField + toField)
		}
		endExclusive := parsed.AddDate(0, 0, 1)
		end = &endExclusive
	}

	if start != nil && end != nil && start.After(*end) {
		return nil, nil, apperr.Validation(fromField + " must be before " + toField)
	}

	return start, end, nil
}

func parseInt64Range(from string, to string, fromField string, toField string) (*int64, *int64, error) {
	trimmedFrom := strings.TrimSpace(from)
	trimmedTo := strings.TrimSpace(to)

	var start *int64
	var end *int64

	if trimmedFrom != "" {
		parsed, err := strconv.ParseInt(trimmedFrom, 10, 64)
		if err != nil {
			return nil, nil, apperr.Validation(msgInvalidField + fromField)
		}
		start = &parsed
	}

	if trimmedTo != "" {
		parsed, err := strconv.ParseInt(trimmedTo, 10, 64)
		if err != nil {
			return nil, nil, apperr.Validation(msgInvalidField + toField)
		}
		end = &parsed
	}

	if start != nil && end != nil && *start > *end {
		return nil, nil, apperr.Validation(fromField + " must be <= " + toField)
	}

	return start, end, nil
}

// ListActivities returns the persisted activity log for a quote.
func (s *Service) ListActivities(ctx context.Context, quoteID, tenantID uuid.UUID) ([]transport.QuoteActivityResponse, error) {
	activities, err := s.repo.ListActivities(ctx, quoteID, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to list quote activities: %w", err)
	}

	out := make([]transport.QuoteActivityResponse, len(activities))
	for i, a := range activities {
		var meta map[string]interface{}
		if len(a.Metadata) > 0 {
			_ = json.Unmarshal(a.Metadata, &meta)
		}
		out[i] = transport.QuoteActivityResponse{
			ID:        a.ID,
			EventType: a.EventType,
			Message:   a.Message,
			Metadata:  meta,
			CreatedAt: a.CreatedAt,
		}
	}
	return out, nil
}
</file>

<file path="internal/leads/management/service.go">
// Package management handles lead CRUD operations.
// This is a vertically sliced feature package containing service logic
// for creating, reading, updating, and deleting RAC_leads.
package management

import (
	"context"
	"errors"
	"fmt"
	"math"
	"strconv"
	"strings"
	"time"

	"portal_final_backend/internal/auth/token"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/scoring"
	"portal_final_backend/internal/leads/transport"
	"portal_final_backend/internal/maps"
	"portal_final_backend/platform/apperr"
	"portal_final_backend/platform/phone"

	"github.com/google/uuid"
)

const (
	leadNotFoundMsg               = "lead not found"
	leadServiceNotFoundMsg        = "lead service not found"
	energyLabelRefreshInterval    = 30 * 24 * time.Hour
	leadEnrichmentRefreshInterval = 365 * 24 * time.Hour
)

// Repository defines the data access interface needed by the management service.
// This is a consumer-driven interface - only what management needs.
type Repository interface {
	repository.LeadReader
	repository.LeadWriter
	repository.LeadViewTracker
	repository.ActivityLogger
	repository.LeadServiceReader
	repository.LeadServiceWriter
	repository.MetricsReader
	repository.TimelineEventStore
	repository.ActivityFeedReader
	repository.FeedReactionStore
	repository.FeedCommentStore
	repository.OrgMemberReader
	UpdateEnergyLabel(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params repository.UpdateEnergyLabelParams) error
	UpdateLeadEnrichment(ctx context.Context, id uuid.UUID, organizationID uuid.UUID, params repository.UpdateLeadEnrichmentParams) error
}

// Service handles lead management operations (CRUD).
type Service struct {
	repo           Repository
	eventBus       events.Bus
	maps           *maps.Service
	energyEnricher ports.EnergyLabelEnricher
	leadEnricher   ports.LeadEnricher
	scorer         *scoring.Service
}

// New creates a new lead management service.
func New(repo Repository, eventBus events.Bus, mapsService *maps.Service) *Service {
	return &Service{repo: repo, eventBus: eventBus, maps: mapsService}
}

// SetEnergyLabelEnricher sets the energy label enricher for lead enrichment.
// This is called after module initialization to break circular dependencies.
func (s *Service) SetEnergyLabelEnricher(enricher ports.EnergyLabelEnricher) {
	s.energyEnricher = enricher
}

// SetLeadEnricher sets the lead enrichment provider.
func (s *Service) SetLeadEnricher(enricher ports.LeadEnricher) {
	s.leadEnricher = enricher
}

// SetLeadScorer sets the lead scoring service.
func (s *Service) SetLeadScorer(scorer *scoring.Service) {
	s.scorer = scorer
}

// Create creates a new lead.
func (s *Service) Create(ctx context.Context, req transport.CreateLeadRequest, tenantID uuid.UUID) (transport.LeadResponse, error) {
	req.Phone = phone.NormalizeE164(req.Phone)

	params := repository.CreateLeadParams{
		OrganizationID:     tenantID,
		ConsumerFirstName:  req.FirstName,
		ConsumerLastName:   req.LastName,
		ConsumerPhone:      req.Phone,
		ConsumerRole:       string(req.ConsumerRole),
		AddressStreet:      req.Street,
		AddressHouseNumber: req.HouseNumber,
		AddressZipCode:     req.ZipCode,
		AddressCity:        req.City,
		Latitude:           req.Latitude,
		Longitude:          req.Longitude,
		Source:             toPtr(req.Source),
		GCLID:              toPtr(req.GCLID),
		UTMSource:          toPtr(req.UTMSource),
		UTMMedium:          toPtr(req.UTMMedium),
		UTMCampaign:        toPtr(req.UTMCampaign),
		UTMContent:         toPtr(req.UTMContent),
		UTMTerm:            toPtr(req.UTMTerm),
		AdLandingPage:      toPtr(req.AdLandingPage),
		ReferrerURL:        toPtr(req.ReferrerURL),
	}

	if req.AssigneeID.Set {
		params.AssignedAgentID = req.AssigneeID.Value
	}

	if req.Email != "" {
		params.ConsumerEmail = &req.Email
	}

	lead, err := s.repo.Create(ctx, params)
	if err != nil {
		return transport.LeadResponse{}, err
	}

	// Create the initial service for the lead
	initialService, err := s.repo.CreateLeadService(ctx, repository.CreateLeadServiceParams{
		LeadID:         lead.ID,
		OrganizationID: tenantID,
		ServiceType:    string(req.ServiceType),
		ConsumerNote:   toPtr(req.ConsumerNote),
	})
	if err != nil {
		return transport.LeadResponse{}, err
	}

	publicToken, err := token.GenerateRandomToken(32)
	if err != nil {
		return transport.LeadResponse{}, err
	}
	publicTokenExpiresAt := time.Now().Add(30 * 24 * time.Hour)
	if err := s.repo.SetPublicToken(ctx, lead.ID, tenantID, publicToken, publicTokenExpiresAt); err != nil {
		return transport.LeadResponse{}, err
	}

	s.eventBus.Publish(ctx, events.LeadCreated{
		BaseEvent:       events.NewBaseEvent(),
		LeadID:          lead.ID,
		LeadServiceID:   initialService.ID,
		TenantID:        tenantID,
		AssignedAgentID: lead.AssignedAgentID,
		ServiceType:     string(req.ServiceType),
		ConsumerName:    strings.TrimSpace(lead.ConsumerFirstName + " " + lead.ConsumerLastName),
		ConsumerPhone:   lead.ConsumerPhone,
		PublicToken:     publicToken,
	})

	services, _ := s.repo.ListLeadServices(ctx, lead.ID, tenantID)
	resp := ToLeadResponseWithServices(lead, services)

	// Enrich with energy label data (fire and forget - don't fail lead creation)
	s.enrichWithEnergyLabel(ctx, tenantID, &lead, &resp)
	// Enrich with lead data (fire and forget - don't fail lead creation)
	s.enrichWithLeadData(ctx, tenantID, &lead, &resp)

	return resp, nil
}

// GetByID retrieves a lead by ID.
func (s *Service) GetByID(ctx context.Context, id uuid.UUID, tenantID uuid.UUID) (transport.LeadResponse, error) {
	lead, services, err := s.repo.GetByIDWithServices(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	resp := ToLeadResponseWithServices(lead, services)

	// Enrich with energy label data
	s.enrichWithEnergyLabel(ctx, tenantID, &lead, &resp)
	// Enrich with lead data
	s.enrichWithLeadData(ctx, tenantID, &lead, &resp)

	return resp, nil
}

// enrichWithEnergyLabel ensures the lead has up-to-date energy label data.
// This is a best-effort operation - failures do not block the request flow.
func (s *Service) enrichWithEnergyLabel(ctx context.Context, tenantID uuid.UUID, lead *repository.Lead, resp *transport.LeadResponse) {
	// Always apply whatever data we currently have stored
	resp.EnergyLabel = energyLabelFromLead(*lead)

	if s.energyEnricher == nil {
		return
	}
	if !shouldRefreshEnergyLabel(lead) {
		return
	}

	params := ports.EnrichLeadParams{
		Postcode:   lead.AddressZipCode,
		Huisnummer: lead.AddressHouseNumber,
	}

	data, err := s.energyEnricher.EnrichLead(ctx, params)
	if err != nil {
		return
	}

	fetchedAt := time.Now().UTC()
	ptrs := buildEnergyLabelPointers(data)
	updateParams := repository.UpdateEnergyLabelParams{
		Class:          ptrs.class,
		Index:          ptrs.index,
		Bouwjaar:       ptrs.bouwjaar,
		Gebouwtype:     ptrs.gebouwtype,
		ValidUntil:     ptrs.validUntil,
		RegisteredAt:   ptrs.registeredAt,
		PrimairFossiel: ptrs.primairFossiel,
		BAGObjectID:    ptrs.bagObjectID,
		FetchedAt:      fetchedAt,
	}

	if err := s.repo.UpdateEnergyLabel(ctx, lead.ID, tenantID, updateParams); err != nil {
		return
	}

	applyEnergyLabelUpdate(lead, updateParams)

	resp.EnergyLabel = energyLabelFromLead(*lead)
}

type energyLabelPointers struct {
	class          *string
	index          *float64
	bouwjaar       *int
	gebouwtype     *string
	validUntil     *time.Time
	registeredAt   *time.Time
	primairFossiel *float64
	bagObjectID    *string
}

func shouldRefreshEnergyLabel(lead *repository.Lead) bool {
	if lead.EnergyLabelFetchedAt == nil {
		return true
	}
	return time.Since(*lead.EnergyLabelFetchedAt) >= energyLabelRefreshInterval
}

func buildEnergyLabelPointers(data *ports.LeadEnergyData) energyLabelPointers {
	var ptrs energyLabelPointers
	if data == nil {
		return ptrs
	}

	if data.Energieklasse != "" {
		val := data.Energieklasse
		ptrs.class = &val
	}
	if data.EnergieIndex != nil {
		val := *data.EnergieIndex
		ptrs.index = &val
	}
	if data.Bouwjaar != 0 {
		val := data.Bouwjaar
		ptrs.bouwjaar = &val
	}
	if data.Gebouwtype != "" {
		val := data.Gebouwtype
		ptrs.gebouwtype = &val
	}
	if data.GeldigTot != nil {
		val := *data.GeldigTot
		ptrs.validUntil = &val
	}
	if data.Registratiedatum != nil {
		val := *data.Registratiedatum
		ptrs.registeredAt = &val
	}
	if data.PrimaireFossieleEnergie != nil {
		val := *data.PrimaireFossieleEnergie
		ptrs.primairFossiel = &val
	}
	if data.BAGVerblijfsobjectID != "" {
		val := data.BAGVerblijfsobjectID
		ptrs.bagObjectID = &val
	}

	return ptrs
}

func applyEnergyLabelUpdate(lead *repository.Lead, params repository.UpdateEnergyLabelParams) {
	lead.EnergyClass = params.Class
	lead.EnergyIndex = params.Index
	lead.EnergyBouwjaar = params.Bouwjaar
	lead.EnergyGebouwtype = params.Gebouwtype
	lead.EnergyLabelValidUntil = params.ValidUntil
	lead.EnergyLabelRegisteredAt = params.RegisteredAt
	lead.EnergyPrimairFossiel = params.PrimairFossiel
	lead.EnergyBAGVerblijfsobjectID = params.BAGObjectID
	fetchedAt := params.FetchedAt
	lead.EnergyLabelFetchedAt = &fetchedAt
}

// enrichWithLeadData ensures the lead has up-to-date enrichment and score data.
// This is a best-effort operation - failures do not block the request flow.
func (s *Service) enrichWithLeadData(ctx context.Context, tenantID uuid.UUID, lead *repository.Lead, resp *transport.LeadResponse) {
	resp.LeadEnrichment = leadEnrichmentFromLead(*lead)
	resp.LeadScore = leadScoreFromLead(*lead)

	if s.leadEnricher == nil {
		return
	}

	if lead.LeadEnrichmentFetchedAt != nil {
		if time.Since(*lead.LeadEnrichmentFetchedAt) < leadEnrichmentRefreshInterval {
			return
		}
	}

	data, err := s.leadEnricher.EnrichLead(ctx, lead.AddressZipCode)
	if err != nil || data == nil {
		return
	}

	fetchedAt := time.Now().UTC()

	var serviceID *uuid.UUID
	if resp.CurrentService != nil {
		serviceID = &resp.CurrentService.ID
	}

	var scoreResult *scoring.Result
	if s.scorer != nil {
		scoreResult, _ = s.scorer.Recalculate(ctx, lead.ID, serviceID, tenantID, false)
	}

	updateParams := repository.UpdateLeadEnrichmentParams{
		Source:                    toPtrString(data.Source),
		Postcode6:                 toPtrString(data.Postcode6),
		Postcode4:                 toPtrString(data.Postcode4),
		Buurtcode:                 toPtrString(data.Buurtcode),
		DataYear:                  data.DataYear,
		GemAardgasverbruik:        data.GemAardgasverbruik,
		GemElektriciteitsverbruik: data.GemElektriciteitsverbruik,
		HuishoudenGrootte:         data.HuishoudenGrootte,
		KoopwoningenPct:           data.KoopwoningenPct,
		BouwjaarVanaf2000Pct:      data.BouwjaarVanaf2000Pct,
		WOZWaarde:                 data.WOZWaarde,
		MediaanVermogenX1000:      data.MediaanVermogenX1000,
		GemInkomen:                data.GemInkomenHuishouden,
		PctHoogInkomen:            data.PctHoogInkomen,
		PctLaagInkomen:            data.PctLaagInkomen,
		HuishoudensMetKinderenPct: data.HuishoudensMetKinderenPct,
		Stedelijkheid:             data.Stedelijkheid,
		Confidence:                data.Confidence,
		FetchedAt:                 fetchedAt,
	}

	if scoreResult != nil {
		updateParams.Score = &scoreResult.Score
		updateParams.ScorePreAI = &scoreResult.ScorePreAI
		updateParams.ScoreFactors = scoreResult.FactorsJSON
		updateParams.ScoreVersion = toPtrString(scoreResult.Version)
		updateParams.ScoreUpdatedAt = &scoreResult.UpdatedAt
	}

	if err := s.repo.UpdateLeadEnrichment(ctx, lead.ID, tenantID, updateParams); err != nil {
		return
	}

	lead.LeadEnrichmentSource = updateParams.Source
	lead.LeadEnrichmentPostcode6 = updateParams.Postcode6
	lead.LeadEnrichmentPostcode4 = updateParams.Postcode4
	lead.LeadEnrichmentBuurtcode = updateParams.Buurtcode
	lead.LeadEnrichmentDataYear = updateParams.DataYear
	lead.LeadEnrichmentGemAardgasverbruik = updateParams.GemAardgasverbruik
	lead.LeadEnrichmentGemElektriciteitsverbruik = updateParams.GemElektriciteitsverbruik
	lead.LeadEnrichmentHuishoudenGrootte = updateParams.HuishoudenGrootte
	lead.LeadEnrichmentKoopwoningenPct = updateParams.KoopwoningenPct
	lead.LeadEnrichmentBouwjaarVanaf2000Pct = updateParams.BouwjaarVanaf2000Pct
	lead.LeadEnrichmentWOZWaarde = updateParams.WOZWaarde
	lead.LeadEnrichmentMediaanVermogenX1000 = updateParams.MediaanVermogenX1000
	lead.LeadEnrichmentGemInkomen = updateParams.GemInkomen
	lead.LeadEnrichmentPctHoogInkomen = updateParams.PctHoogInkomen
	lead.LeadEnrichmentPctLaagInkomen = updateParams.PctLaagInkomen
	lead.LeadEnrichmentHuishoudensMetKinderenPct = updateParams.HuishoudensMetKinderenPct
	lead.LeadEnrichmentStedelijkheid = updateParams.Stedelijkheid
	lead.LeadEnrichmentConfidence = updateParams.Confidence
	lead.LeadEnrichmentFetchedAt = &fetchedAt

	if scoreResult != nil {
		lead.LeadScore = updateParams.Score
		lead.LeadScorePreAI = updateParams.ScorePreAI
		lead.LeadScoreFactors = updateParams.ScoreFactors
		lead.LeadScoreVersion = updateParams.ScoreVersion
		lead.LeadScoreUpdatedAt = updateParams.ScoreUpdatedAt
	}

	resp.LeadEnrichment = leadEnrichmentFromLead(*lead)
	resp.LeadScore = leadScoreFromLead(*lead)
}

// Update updates a lead's information.
func (s *Service) Update(ctx context.Context, id uuid.UUID, req transport.UpdateLeadRequest, actorID uuid.UUID, tenantID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	params, current, err := s.prepareAssigneeUpdate(ctx, id, tenantID, req, actorID, actorRoles)
	if err != nil {
		return transport.LeadResponse{}, err
	}

	addressUpdateRequested, err := s.applyAddressGeocode(ctx, id, tenantID, req, &params, &current)
	if err != nil {
		return transport.LeadResponse{}, err
	}

	applyUpdateFields(&params, req, !addressUpdateRequested)

	lead, err := s.repo.Update(ctx, id, tenantID, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	if req.AssigneeID.Set && current != nil {
		if !equalUUIDPtrs(current.AssignedAgentID, req.AssigneeID.Value) {
			_ = s.repo.AddActivity(ctx, id, tenantID, actorID, "assigned", map[string]interface{}{
				"from": current.AssignedAgentID,
				"to":   req.AssigneeID.Value,
			})
		}
	}

	services, _ := s.repo.ListLeadServices(ctx, lead.ID, tenantID)
	return ToLeadResponseWithServices(lead, services), nil
}

// Delete soft-deletes a lead.
func (s *Service) Delete(ctx context.Context, id uuid.UUID, tenantID uuid.UUID) error {
	err := s.repo.Delete(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return apperr.NotFound(leadNotFoundMsg)
		}
		return err
	}
	return nil
}

// BulkDelete deletes multiple RAC_leads.
func (s *Service) BulkDelete(ctx context.Context, ids []uuid.UUID, tenantID uuid.UUID) (int, error) {
	deletedCount, err := s.repo.BulkDelete(ctx, ids, tenantID)
	if err != nil {
		return 0, err
	}
	if deletedCount == 0 {
		return 0, apperr.NotFound("no RAC_leads found to delete")
	}
	return deletedCount, nil
}

// List retrieves a paginated list of RAC_leads.
func (s *Service) List(ctx context.Context, req transport.ListLeadsRequest, tenantID uuid.UUID) (transport.LeadListResponse, error) {
	if req.Page < 1 {
		req.Page = 1
	}
	if req.PageSize < 1 {
		req.PageSize = 20
	}
	if req.PageSize > 100 {
		req.PageSize = 100
	}

	params, err := buildListParams(req)
	if err != nil {
		return transport.LeadListResponse{}, err
	}
	params.OrganizationID = tenantID

	leads, total, err := s.repo.List(ctx, params)
	if err != nil {
		return transport.LeadListResponse{}, err
	}

	items := make([]transport.LeadResponse, len(leads))
	for i, lead := range leads {
		services, _ := s.repo.ListLeadServices(ctx, lead.ID, tenantID)
		items[i] = ToLeadResponseWithServices(lead, services)
	}

	totalPages := (total + req.PageSize - 1) / req.PageSize

	return transport.LeadListResponse{
		Items:      items,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

func buildListParams(req transport.ListLeadsRequest) (repository.ListParams, error) {
	params := repository.ListParams{
		Search:    req.Search,
		Offset:    (req.Page - 1) * req.PageSize,
		Limit:     req.PageSize,
		SortBy:    req.SortBy,
		SortOrder: req.SortOrder,
	}

	if req.Status != nil {
		status := string(*req.Status)
		params.Status = &status
	}
	if req.ServiceType != nil {
		serviceType := string(*req.ServiceType)
		params.ServiceType = &serviceType
	}

	params.FirstName = optionalString(req.FirstName)
	params.LastName = optionalString(req.LastName)
	params.Phone = optionalString(req.Phone)
	params.Email = optionalString(req.Email)
	if req.Role != nil {
		role := string(*req.Role)
		params.Role = &role
	}
	params.Street = optionalString(req.Street)
	params.HouseNumber = optionalString(req.HouseNumber)
	params.ZipCode = optionalString(req.ZipCode)
	params.City = optionalString(req.City)
	params.AssignedAgentID = req.AssignedAgentID

	createdFrom, createdTo, err := parseDateRange(req.CreatedAtFrom, req.CreatedAtTo)
	if err != nil {
		return repository.ListParams{}, apperr.Validation(err.Error())
	}
	params.CreatedAtFrom = createdFrom
	params.CreatedAtTo = createdTo

	return params, nil
}

func optionalString(value string) *string {
	if strings.TrimSpace(value) == "" {
		return nil
	}
	trimmed := strings.TrimSpace(value)
	return &trimmed
}

func parseDateRange(from string, to string) (*time.Time, *time.Time, error) {
	const dateLayout = "2006-01-02"

	var start *time.Time
	var end *time.Time

	if from != "" {
		parsed, err := time.Parse(dateLayout, from)
		if err != nil {
			return nil, nil, err
		}
		start = &parsed
	}

	if to != "" {
		parsed, err := time.Parse(dateLayout, to)
		if err != nil {
			return nil, nil, err
		}
		endExclusive := parsed.AddDate(0, 0, 1)
		end = &endExclusive
	}

	if start != nil && end != nil && start.After(*end) {
		return nil, nil, errors.New("createdAtFrom must be before createdAtTo")
	}

	return start, end, nil
}

// CheckDuplicate checks if a lead with the given phone already exists.
func (s *Service) CheckDuplicate(ctx context.Context, phoneNumber string, tenantID uuid.UUID) (transport.DuplicateCheckResponse, error) {
	normalizedPhone := phone.NormalizeE164(phoneNumber)
	lead, err := s.repo.GetByPhone(ctx, normalizedPhone, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.DuplicateCheckResponse{IsDuplicate: false}, nil
		}
		return transport.DuplicateCheckResponse{}, err
	}

	resp := ToLeadResponse(lead)
	return transport.DuplicateCheckResponse{
		IsDuplicate:  true,
		ExistingLead: &resp,
	}, nil
}

// CheckReturningCustomer checks if a lead with the given phone or email already exists.
// This is used to detect returning customers when creating a new service request.
func (s *Service) CheckReturningCustomer(ctx context.Context, phoneNumber string, email string, tenantID uuid.UUID) (transport.ReturningCustomerResponse, error) {
	normalizedPhone := phone.NormalizeE164(phoneNumber)

	summary, services, err := s.repo.GetByPhoneOrEmail(ctx, normalizedPhone, email, tenantID)
	if err != nil {
		return transport.ReturningCustomerResponse{}, err
	}

	if summary == nil {
		return transport.ReturningCustomerResponse{Found: false}, nil
	}

	serviceBriefs := make([]transport.ServiceBrief, len(services))
	for i, svc := range services {
		serviceBriefs[i] = transport.ServiceBrief{
			ServiceType: transport.ServiceType(svc.ServiceType),
			Status:      transport.LeadStatus(svc.Status),
			CreatedAt:   svc.CreatedAt,
		}
	}

	return transport.ReturningCustomerResponse{
		Found:         true,
		LeadID:        &summary.ID,
		FullName:      summary.ConsumerName,
		TotalServices: summary.ServiceCount,
		Services:      serviceBriefs,
	}, nil
}

// Assign assigns or unassigns a lead to an agent.
func (s *Service) Assign(ctx context.Context, id uuid.UUID, assigneeID *uuid.UUID, actorID uuid.UUID, tenantID uuid.UUID, actorRoles []string) (transport.LeadResponse, error) {
	current, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	if !hasRole(actorRoles, "admin") {
		if current.AssignedAgentID == nil || *current.AssignedAgentID != actorID {
			return transport.LeadResponse{}, apperr.Forbidden("forbidden")
		}
	}

	params := repository.UpdateLeadParams{
		AssignedAgentID:    assigneeID,
		AssignedAgentIDSet: true,
	}
	updated, err := s.repo.Update(ctx, id, tenantID, params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	_ = s.repo.AddActivity(ctx, id, tenantID, actorID, "assigned", map[string]interface{}{
		"from": current.AssignedAgentID,
		"to":   assigneeID,
	})

	return ToLeadResponse(updated), nil
}

// AssignIfUnassigned assigns a lead to the agent if it is currently unassigned.
func (s *Service) AssignIfUnassigned(ctx context.Context, id uuid.UUID, agentID uuid.UUID, tenantID uuid.UUID) error {
	lead, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return apperr.NotFound(leadNotFoundMsg)
		}
		return err
	}

	if lead.AssignedAgentID != nil {
		return apperr.Forbidden("lead is already assigned")
	}

	params := repository.UpdateLeadParams{
		AssignedAgentID:    &agentID,
		AssignedAgentIDSet: true,
	}

	if _, err := s.repo.Update(ctx, id, tenantID, params); err != nil {
		return err
	}

	_ = s.repo.AddActivity(ctx, id, tenantID, agentID, "assigned", map[string]interface{}{
		"from": nil,
		"to":   agentID,
	})

	return nil
}

// SetViewedBy marks a lead as viewed by a user.
func (s *Service) SetViewedBy(ctx context.Context, id uuid.UUID, userID uuid.UUID, tenantID uuid.UUID) error {
	return s.repo.SetViewedBy(ctx, id, tenantID, userID)
}

// GetLeadServiceByID retrieves a lead service by its ID.
func (s *Service) GetLeadServiceByID(ctx context.Context, serviceID uuid.UUID, tenantID uuid.UUID) (repository.LeadService, error) {
	svc, err := s.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return repository.LeadService{}, apperr.NotFound(leadServiceNotFoundMsg)
		}
		return repository.LeadService{}, err
	}
	return svc, nil
}

// AddService adds a new service to an existing lead.
func (s *Service) AddService(ctx context.Context, leadID uuid.UUID, req transport.AddServiceRequest, tenantID uuid.UUID) (transport.LeadResponse, error) {
	lead, err := s.repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	if req.CloseCurrentStatus {
		if err := s.repo.CloseAllActiveServices(ctx, leadID, tenantID); err != nil {
			return transport.LeadResponse{}, err
		}
	}

	newService, err := s.repo.CreateLeadService(ctx, repository.CreateLeadServiceParams{
		LeadID:         leadID,
		OrganizationID: tenantID,
		ServiceType:    string(req.ServiceType),
		ConsumerNote:   toPtr(req.ConsumerNote),
		Source:         toPtr(req.Source),
	})
	if err != nil {
		return transport.LeadResponse{}, err
	}

	// Publish event so the gatekeeper agent triages the new service
	s.eventBus.Publish(ctx, events.LeadServiceAdded{
		BaseEvent:     events.NewBaseEvent(),
		LeadID:        leadID,
		LeadServiceID: newService.ID,
		TenantID:      tenantID,
		ServiceType:   string(req.ServiceType),
	})

	services, _ := s.repo.ListLeadServices(ctx, leadID, tenantID)
	return ToLeadResponseWithServices(lead, services), nil
}

// UpdateServiceStatus updates the status of a specific service.
func (s *Service) UpdateServiceStatus(ctx context.Context, leadID uuid.UUID, serviceID uuid.UUID, req transport.UpdateServiceStatusRequest, tenantID uuid.UUID) (transport.LeadResponse, error) {
	svc, err := s.repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadServiceNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}
	if svc.LeadID != leadID {
		return transport.LeadResponse{}, apperr.NotFound(leadServiceNotFoundMsg)
	}

	_, err = s.repo.UpdateServiceStatus(ctx, serviceID, tenantID, string(req.Status))
	if err != nil {
		return transport.LeadResponse{}, err
	}

	return s.GetByID(ctx, leadID, tenantID)
}

// UpdateStatus updates the status of the lead's current service.
func (s *Service) UpdateStatus(ctx context.Context, id uuid.UUID, req transport.UpdateLeadStatusRequest, tenantID uuid.UUID) (transport.LeadResponse, error) {
	service, err := s.repo.GetCurrentLeadService(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) || errors.Is(err, repository.ErrNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	if _, err := s.repo.UpdateServiceStatus(ctx, service.ID, tenantID, string(req.Status)); err != nil {
		if errors.Is(err, repository.ErrServiceNotFound) {
			return transport.LeadResponse{}, apperr.NotFound(leadNotFoundMsg)
		}
		return transport.LeadResponse{}, err
	}

	return s.GetByID(ctx, id, tenantID)
}

// GetMetrics returns aggregated KPI metrics for the dashboard.
func (s *Service) GetMetrics(ctx context.Context, tenantID uuid.UUID) (transport.LeadMetricsResponse, error) {
	metrics, err := s.repo.GetMetrics(ctx, tenantID)
	if err != nil {
		return transport.LeadMetricsResponse{}, err
	}

	var disqualifiedRate float64
	var touchpointsPerLead float64
	if metrics.TotalLeads > 0 {
		disqualifiedRate = float64(metrics.DisqualifiedLeads) / float64(metrics.TotalLeads)
		touchpointsPerLead = float64(metrics.Touchpoints) / float64(metrics.TotalLeads)
	}

	return transport.LeadMetricsResponse{
		TotalLeads:          metrics.TotalLeads,
		ProjectedValueCents: metrics.ProjectedValueCents,
		DisqualifiedRate:    roundToOneDecimal(disqualifiedRate * 100),
		TouchpointsPerLead:  roundToOneDecimal(touchpointsPerLead),
	}, nil
}

// GetHeatmap returns geocoded lead points for the dashboard heatmap.
func (s *Service) GetHeatmap(ctx context.Context, startDate *time.Time, endDate *time.Time, tenantID uuid.UUID) (transport.LeadHeatmapResponse, error) {
	var endExclusive *time.Time
	if endDate != nil {
		end := endDate.AddDate(0, 0, 1)
		endExclusive = &end
	}

	points, err := s.repo.ListHeatmapPoints(ctx, tenantID, startDate, endExclusive)
	if err != nil {
		return transport.LeadHeatmapResponse{}, err
	}

	resp := transport.LeadHeatmapResponse{Points: make([]transport.LeadHeatmapPointResponse, 0, len(points))}
	for _, point := range points {
		resp.Points = append(resp.Points, transport.LeadHeatmapPointResponse{
			Latitude:  point.Latitude,
			Longitude: point.Longitude,
		})
	}

	return resp, nil
}

// GetActionItems returns urgent or recent RAC_leads for the dashboard widget.
func (s *Service) GetActionItems(ctx context.Context, page int, pageSize int, newLeadDays int, tenantID uuid.UUID) (transport.ActionItemsResponse, error) {
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 5
	}
	if pageSize > 50 {
		pageSize = 50
	}

	offset := (page - 1) * pageSize
	result, err := s.repo.ListActionItems(ctx, tenantID, newLeadDays, pageSize, offset)
	if err != nil {
		return transport.ActionItemsResponse{}, err
	}

	items := make([]transport.ActionItemResponse, 0, len(result.Items))
	for _, item := range result.Items {
		name := strings.TrimSpace(item.FirstName + " " + item.LastName)
		isUrgent := item.UrgencyLevel != nil && *item.UrgencyLevel == "High"
		items = append(items, transport.ActionItemResponse{
			ID:            item.ID,
			Name:          name,
			UrgencyReason: item.UrgencyReason,
			CreatedAt:     item.CreatedAt,
			IsUrgent:      isUrgent,
		})
	}

	return transport.ActionItemsResponse{
		Items:    items,
		Total:    result.Total,
		Page:     page,
		PageSize: pageSize,
	}, nil
}

// GetTimeline returns the lead timeline events in reverse chronological order.
// When serviceID is provided, only events for that service (plus unscoped events) are returned.
func (s *Service) GetTimeline(ctx context.Context, leadID uuid.UUID, tenantID uuid.UUID, serviceID *uuid.UUID) ([]transport.TimelineItem, error) {
	if _, err := s.repo.GetByID(ctx, leadID, tenantID); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, apperr.NotFound(leadNotFoundMsg)
		}
		return nil, err
	}

	var events []repository.TimelineEvent
	var err error
	if serviceID != nil {
		events, err = s.repo.ListTimelineEventsByService(ctx, leadID, *serviceID, tenantID)
	} else {
		events, err = s.repo.ListTimelineEvents(ctx, leadID, tenantID)
	}
	if err != nil {
		return nil, err
	}

	items := make([]transport.TimelineItem, len(events))
	for i, event := range events {
		timelineType := "user"
		if event.EventType == "stage_change" {
			timelineType = "stage"
		} else if event.ActorType == "AI" {
			timelineType = "ai"
		}

		items[i] = transport.TimelineItem{
			ID:        event.ID,
			ServiceID: event.ServiceID,
			Type:      timelineType,
			Title:     event.Title,
			Summary:   summaryValue(event.Summary),
			Timestamp: event.CreatedAt,
			Actor:     event.ActorName,
			Metadata:  event.Metadata,
		}
	}

	return items, nil
}

func summaryValue(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}

func roundToOneDecimal(value float64) float64 {
	return math.Round(value*10) / 10
}

func (s *Service) prepareAssigneeUpdate(ctx context.Context, id uuid.UUID, tenantID uuid.UUID, req transport.UpdateLeadRequest, actorID uuid.UUID, actorRoles []string) (repository.UpdateLeadParams, *repository.Lead, error) {
	params := repository.UpdateLeadParams{}
	if !req.AssigneeID.Set {
		return params, nil, nil
	}

	lead, err := s.repo.GetByID(ctx, id, tenantID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return repository.UpdateLeadParams{}, nil, apperr.NotFound(leadNotFoundMsg)
		}
		return repository.UpdateLeadParams{}, nil, err
	}

	if !hasRole(actorRoles, "admin") {
		if lead.AssignedAgentID == nil || *lead.AssignedAgentID != actorID {
			return repository.UpdateLeadParams{}, nil, apperr.Forbidden("forbidden")
		}
	}

	params.AssignedAgentID = req.AssigneeID.Value
	params.AssignedAgentIDSet = true
	return params, &lead, nil
}

func applyUpdateFields(params *repository.UpdateLeadParams, req transport.UpdateLeadRequest, applyCoords bool) {
	if req.FirstName != nil {
		params.ConsumerFirstName = req.FirstName
	}
	if req.LastName != nil {
		params.ConsumerLastName = req.LastName
	}
	if req.Phone != nil {
		normalized := phone.NormalizeE164(*req.Phone)
		params.ConsumerPhone = &normalized
	}
	if req.Email != nil {
		params.ConsumerEmail = req.Email
	}
	if applyCoords {
		if req.Latitude != nil {
			params.Latitude = req.Latitude
		}
		if req.Longitude != nil {
			params.Longitude = req.Longitude
		}
	}
	if req.ConsumerRole != nil {
		role := string(*req.ConsumerRole)
		params.ConsumerRole = &role
	}
	if req.Street != nil {
		params.AddressStreet = req.Street
	}
	if req.HouseNumber != nil {
		params.AddressHouseNumber = req.HouseNumber
	}
	if req.ZipCode != nil {
		params.AddressZipCode = req.ZipCode
	}
	if req.City != nil {
		params.AddressCity = req.City
	}
}

func (s *Service) applyAddressGeocode(ctx context.Context, id uuid.UUID, tenantID uuid.UUID, req transport.UpdateLeadRequest, params *repository.UpdateLeadParams, current **repository.Lead) (bool, error) {
	if !hasAddressUpdate(req) {
		return false, nil
	}

	if *current == nil {
		lead, err := s.repo.GetByID(ctx, id, tenantID)
		if err != nil {
			if errors.Is(err, repository.ErrNotFound) {
				return true, apperr.NotFound(leadNotFoundMsg)
			}
			return true, err
		}
		*current = &lead
	}

	updatedAddress, changed := buildUpdatedAddress(**current, req)
	if changed {
		if lat, lon, ok := s.geocodeAddress(ctx, updatedAddress); ok {
			params.Latitude = &lat
			params.Longitude = &lon
		}
	}

	return true, nil
}

type addressUpdate struct {
	street      string
	houseNumber string
	zipCode     string
	city        string
}

func hasAddressUpdate(req transport.UpdateLeadRequest) bool {
	return req.Street != nil || req.HouseNumber != nil || req.ZipCode != nil || req.City != nil
}

func buildUpdatedAddress(current repository.Lead, req transport.UpdateLeadRequest) (addressUpdate, bool) {
	updated := addressUpdate{
		street:      current.AddressStreet,
		houseNumber: current.AddressHouseNumber,
		zipCode:     current.AddressZipCode,
		city:        current.AddressCity,
	}

	changed := false
	if req.Street != nil {
		updated.street = strings.TrimSpace(*req.Street)
		changed = changed || updated.street != current.AddressStreet
	}
	if req.HouseNumber != nil {
		updated.houseNumber = strings.TrimSpace(*req.HouseNumber)
		changed = changed || updated.houseNumber != current.AddressHouseNumber
	}
	if req.ZipCode != nil {
		updated.zipCode = strings.TrimSpace(*req.ZipCode)
		changed = changed || updated.zipCode != current.AddressZipCode
	}
	if req.City != nil {
		updated.city = strings.TrimSpace(*req.City)
		changed = changed || updated.city != current.AddressCity
	}

	return updated, changed
}

func (s *Service) geocodeAddress(ctx context.Context, address addressUpdate) (float64, float64, bool) {
	if s.maps == nil {
		return 0, 0, false
	}

	if address.street == "" || address.city == "" {
		return 0, 0, false
	}

	query := formatGeocodeQuery(address)
	suggestions, err := s.maps.SearchAddress(ctx, query)
	if err != nil || len(suggestions) == 0 {
		return 0, 0, false
	}

	lat, err := strconv.ParseFloat(suggestions[0].Lat, 64)
	if err != nil {
		return 0, 0, false
	}
	lon, err := strconv.ParseFloat(suggestions[0].Lon, 64)
	if err != nil {
		return 0, 0, false
	}

	return lat, lon, true
}

func formatGeocodeQuery(address addressUpdate) string {
	streetPart := strings.TrimSpace(strings.Join([]string{address.street, address.houseNumber}, " "))
	cityPart := strings.TrimSpace(strings.Join([]string{address.zipCode, address.city}, " "))
	query := strings.TrimSpace(fmt.Sprintf("%s, %s", streetPart, cityPart))
	return strings.Trim(query, ", ")
}

func hasRole(roles []string, target string) bool {
	for _, role := range roles {
		if role == target {
			return true
		}
	}
	return false
}

func equalUUIDPtrs(a *uuid.UUID, b *uuid.UUID) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

func toPtr(value string) *string {
	if value == "" {
		return nil
	}
	return &value
}

func toPtrString(value string) *string {
	return toPtr(value)
}

// GetActivityFeed returns the most recent org-wide activity for the dashboard feed card.
func (s *Service) GetActivityFeed(ctx context.Context, tenantID, userID uuid.UUID, page int, limit int) (transport.ActivityFeedResponse, error) {
	page, limit, offset := normalizePagination(page, limit)

	entries, err := s.repo.ListRecentActivity(ctx, tenantID, limit, offset)
	if err != nil {
		return transport.ActivityFeedResponse{}, err
	}

	if page == 1 {
		entries, err = s.mergeUpcomingAppointments(ctx, tenantID, entries)
		if err != nil {
			return transport.ActivityFeedResponse{}, err
		}
	}

	items := buildFeedItems(entries)
	if err := s.enrichFeedItems(ctx, tenantID, userID, items); err != nil {
		return transport.ActivityFeedResponse{}, err
	}

	return transport.ActivityFeedResponse{Items: items}, nil
}

func normalizePagination(page, limit int) (int, int, int) {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 20
	}
	if limit > 50 {
		limit = 50
	}

	offset := (page - 1) * limit
	return page, limit, offset
}

func buildFeedItems(entries []repository.ActivityFeedEntry) []transport.ActivityFeedItem {
	items := make([]transport.ActivityFeedItem, 0, len(entries))
	for _, e := range entries {
		items = append(items, mapEntryToFeedItem(e))
	}
	return items
}

func (s *Service) enrichFeedItems(ctx context.Context, tenantID, userID uuid.UUID, items []transport.ActivityFeedItem) error {
	if len(items) == 0 {
		return nil
	}

	eventIDs := make([]string, len(items))
	for i, it := range items {
		eventIDs[i] = it.ID
	}

	reactions, err := s.repo.ListReactionsByEvents(ctx, eventIDs, tenantID)
	if err != nil {
		return err
	}

	commentCounts, err := s.repo.ListCommentCountsByEvents(ctx, eventIDs, tenantID)
	if err != nil {
		return err
	}

	reactionsByEvent := map[string][]repository.FeedReaction{}
	for _, r := range reactions {
		reactionsByEvent[r.EventID] = append(reactionsByEvent[r.EventID], r)
	}

	for i := range items {
		items[i].Reactions = buildReactionSummary(reactionsByEvent[items[i].ID], userID)
		if cnt, ok := commentCounts[items[i].ID]; ok {
			items[i].CommentCount = cnt
		}
	}

	return nil
}

// mergeUpcomingAppointments prepends upcoming appointments to the feed entries (page 1 only).
func (s *Service) mergeUpcomingAppointments(ctx context.Context, tenantID uuid.UUID, entries []repository.ActivityFeedEntry) ([]repository.ActivityFeedEntry, error) {
	upcoming, err := s.repo.ListUpcomingAppointments(ctx, tenantID, 5)
	if err != nil {
		return nil, err
	}
	if len(upcoming) == 0 {
		return entries, nil
	}

	existing := make(map[uuid.UUID]struct{}, len(entries))
	for _, entry := range entries {
		existing[entry.EntityID] = struct{}{}
	}

	filtered := make([]repository.ActivityFeedEntry, 0, len(upcoming))
	for _, entry := range upcoming {
		if _, seen := existing[entry.EntityID]; seen {
			continue
		}
		filtered = append(filtered, entry)
	}

	if len(filtered) > 0 {
		return append(filtered, entries...), nil
	}
	return entries, nil
}

// mapEntryToFeedItem converts a repository entry into a transport feed item.
func mapEntryToFeedItem(e repository.ActivityFeedEntry) transport.ActivityFeedItem {
	item := transport.ActivityFeedItem{
		ID:          e.ID.String(),
		Type:        e.EventType,
		Category:    e.Category,
		Title:       mapActivityTitle(e.Category, e.EventType, e.Title, e.ScheduledAt),
		Description: e.Description,
		Timestamp:   e.CreatedAt.Format(time.RFC3339),
	}

	populateFeedItemFields(&item, &e)
	assignFeedItemLink(&item, &e)
	enrichFeedItem(&item, &e)

	return item
}

// populateFeedItemFields sets optional fields from the entry onto the feed item.
func populateFeedItemFields(item *transport.ActivityFeedItem, e *repository.ActivityFeedEntry) {
	if e.LeadName != "" {
		item.LeadName = e.LeadName
	}
	if e.Phone != "" {
		item.Phone = e.Phone
	}
	if e.Email != "" {
		item.Email = e.Email
	}
	if e.LeadStatus != "" {
		item.LeadStatus = e.LeadStatus
	}
	if e.ServiceType != "" {
		item.ServiceType = e.ServiceType
	}
	if e.LeadScore != nil {
		item.LeadScore = e.LeadScore
	}
	if e.Address != "" {
		item.Address = e.Address
	}
	if e.Latitude != nil {
		item.Latitude = e.Latitude
	}
	if e.Longitude != nil {
		item.Longitude = e.Longitude
	}
	if e.ScheduledAt != nil {
		item.ScheduledAt = e.ScheduledAt.Format(time.RFC3339)
	}
	if e.Priority > 0 {
		item.Priority = e.Priority
	}
}

// assignFeedItemLink builds the navigation link for the feed item based on category.
func assignFeedItemLink(item *transport.ActivityFeedItem, e *repository.ActivityFeedEntry) {
	switch e.Category {
	case "leads":
		item.Link = []string{"leads", e.EntityID.String()}
	case "quotes":
		item.Link = []string{"offertes", e.EntityID.String()}
	case "appointments":
		item.Link = []string{"appointments"}
	case "ai":
		item.Link = []string{"leads", e.EntityID.String()}
	}
}

// mapActivityTitle translates raw event types into human-readable Dutch titles.
func mapActivityTitle(category, eventType, rawTitle string, scheduledAt *time.Time) string {
	switch eventType {
	// Lead events
	case "lead_created":
		return "Nieuwe lead aangemaakt"
	case "lead_updated":
		return "Lead bijgewerkt"
	case "status_change":
		switch category {
		case "quotes":
			return "Offerte status gewijzigd"
		case "appointments":
			return "Afspraak status gewijzigd"
		default:
			return "Lead bijgewerkt"
		}
	case "lead_assigned":
		return "Lead toegewezen"
	case "lead_viewed":
		return "Lead bekeken"
	case "note_added":
		return "Notitie toegevoegd"
	case "call_logged":
		return "Gesprek gelogd"
	// AI events
	case "analysis_complete":
		return "Gatekeeper analyse voltooid"
	case "photo_analysis_complete", "photo_analysis_completed":
		return "Foto-analyse voltooid"
	// Partner events
	case "partner_offer_accepted":
		return "Partner offerte geaccepteerd"
	case "partner_offer_rejected":
		return "Partner offerte afgewezen"
	// Pipeline / triage events
	case "manual_intervention":
		return "Handmatige interventie vereist"
	case "gatekeeper_rejected":
		return "Gatekeeper heeft lead afgewezen"
	case "lead_lost":
		return "Lead verloren"
	// Quote events (rawTitle already contains the human-readable message)
	case "quote_sent", "quote_viewed", "quote_accepted", "quote_rejected",
		"quote_item_toggled", "quote_annotated":
		if rawTitle != "" {
			return rawTitle
		}
		return "Offerte activiteit"
	// Appointment events
	case "appointment_created":
		if rawTitle != "" {
			return "Nieuwe afspraak: " + rawTitle
		}
		return "Nieuwe afspraak"
	case "appointment_updated":
		if rawTitle != "" {
			return "Afspraak bijgewerkt: " + rawTitle
		}
		return "Afspraak bijgewerkt"
	case "appointment_upcoming":
		return formatUpcomingTitle(scheduledAt, rawTitle)
	default:
		if rawTitle != "" {
			return rawTitle
		}
		// Use category for a friendlier fallback than the raw eventType
		switch category {
		case "leads":
			return "Lead activiteit"
		case "quotes":
			return "Offerte activiteit"
		case "appointments":
			return "Afspraak activiteit"
		default:
			return eventType
		}
	}
}

func formatUpcomingTitle(scheduledAt *time.Time, fallback string) string {
	if scheduledAt == nil {
		if fallback != "" {
			return "Afspraak binnenkort: " + fallback
		}
		return "Afspraak binnenkort"
	}

	start := *scheduledAt
	until := time.Until(start)
	minutes := int(math.Round(until.Minutes()))
	if minutes <= 60 {
		return appendTitle("Afspraak begint zo", fallback)
	}
	if minutes <= 180 {
		hours := int(math.Round(float64(minutes) / 60.0))
		return appendTitle("Afspraak over "+strconv.Itoa(hours)+" uur", fallback)
	}

	datePart := start.Format("02 Jan")
	timePart := start.Format("15:04")
	if minutes <= 24*60 {
		return appendTitle("Afspraak vandaag om "+timePart, fallback)
	}
	if minutes <= 48*60 {
		return appendTitle("Afspraak morgen om "+timePart, fallback)
	}
	return appendTitle("Afspraak op "+datePart+" om "+timePart, fallback)
}

func appendTitle(label string, fallback string) string {
	if fallback == "" {
		return label
	}
	return label + ": " + fallback
}
</file>

<file path="internal/notification/module.go">
// Package notification provides event handlers for sending notifications
// (emails, SMS, push, etc.) in response to domain events.
// This module subscribes to events and inverts the dependency: domain modules
// no longer need to know about email providers or templates.
package notification

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"portal_final_backend/internal/email"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/identity/repository"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/internal/whatsapp"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/phone"

	"github.com/google/uuid"
)

// QuoteAcceptanceProcessor handles the post-acceptance side effects:
// PDF generation, upload to storage, and persisting the file key.
type QuoteAcceptanceProcessor interface {
	// GenerateAndStorePDF builds the quote PDF, uploads it to storage,
	// and persists the file key. Returns the file key, the raw PDF bytes, or an error.
	GenerateAndStorePDF(ctx context.Context, quoteID, organizationID uuid.UUID, orgName, customerName, signatureName string) (fileKey string, pdfBytes []byte, err error)
}

// QuoteActivityWriter persists activity log entries for quotes.
type QuoteActivityWriter interface {
	CreateActivity(ctx context.Context, quoteID, orgID uuid.UUID, eventType, message string, metadata map[string]interface{}) error
}

// PartnerOfferTimelineWriter writes partner-offer events into the leads timeline.
type PartnerOfferTimelineWriter interface {
	WriteOfferEvent(ctx context.Context, leadID uuid.UUID, serviceID *uuid.UUID, orgID uuid.UUID, actorType, actorName, eventType, title string, summary *string, metadata map[string]any) error
}

// WhatsAppSender sends WhatsApp messages.
type WhatsAppSender interface {
	SendMessage(ctx context.Context, deviceID string, phoneNumber string, message string) error
}

// OrganizationSettingsReader provides org-level settings for notifications.
type OrganizationSettingsReader interface {
	GetOrganizationSettings(ctx context.Context, organizationID uuid.UUID) (repository.OrganizationSettings, error)
}

// LeadTimelineEventParams describes a lead timeline event payload.
type LeadTimelineEventParams struct {
	LeadID    uuid.UUID
	ServiceID *uuid.UUID
	OrgID     uuid.UUID
	ActorType string
	ActorName string
	EventType string
	Title     string
	Summary   *string
	Metadata  map[string]any
}

// LeadTimelineWriter persists lead timeline events.
type LeadTimelineWriter interface {
	CreateTimelineEvent(ctx context.Context, params LeadTimelineEventParams) error
}

// Module handles all notification-related event subscriptions.
type Module struct {
	sender         email.Sender
	cfg            config.NotificationConfig
	log            *logger.Logger
	sse            *sse.Service
	pdfProc        QuoteAcceptanceProcessor
	actWriter      QuoteActivityWriter
	offerTimeline  PartnerOfferTimelineWriter
	whatsapp       WhatsAppSender
	leadTimeline   LeadTimelineWriter
	settingsReader OrganizationSettingsReader
}

// New creates a new notification module.
func New(sender email.Sender, cfg config.NotificationConfig, log *logger.Logger) *Module {
	return &Module{
		sender: sender,
		cfg:    cfg,
		log:    log,
	}
}

// SetSSE injects the SSE service so quote events can be pushed to agents.
func (m *Module) SetSSE(s *sse.Service) { m.sse = s }

// SetQuoteAcceptanceProcessor injects the processor for PDF generation on quote acceptance.
func (m *Module) SetQuoteAcceptanceProcessor(p QuoteAcceptanceProcessor) { m.pdfProc = p }

// SetQuoteActivityWriter injects the writer for persisting quote activity log entries.
func (m *Module) SetQuoteActivityWriter(w QuoteActivityWriter) { m.actWriter = w }

// SetOfferTimelineWriter injects the writer for persisting partner-offer timeline events.
func (m *Module) SetOfferTimelineWriter(w PartnerOfferTimelineWriter) {
	m.offerTimeline = w
}

// SetWhatsAppSender injects the WhatsApp sender.
func (m *Module) SetWhatsAppSender(sender WhatsAppSender) { m.whatsapp = sender }

// SetOrganizationSettingsReader injects org settings reader for WhatsApp device resolution.
func (m *Module) SetOrganizationSettingsReader(reader OrganizationSettingsReader) {
	m.settingsReader = reader
}

// SetLeadTimelineWriter injects the lead timeline writer.
func (m *Module) SetLeadTimelineWriter(writer LeadTimelineWriter) { m.leadTimeline = writer }

// RegisterHandlers subscribes to all relevant domain events on the event bus.
func (m *Module) RegisterHandlers(bus *events.InMemoryBus) {
	// Auth domain events
	bus.Subscribe(events.UserSignedUp{}.EventName(), m)
	bus.Subscribe(events.EmailVerificationRequested{}.EventName(), m)
	bus.Subscribe(events.PasswordResetRequested{}.EventName(), m)

	// Identity domain events
	bus.Subscribe(events.OrganizationInviteCreated{}.EventName(), m)
	// Partners domain events
	bus.Subscribe(events.PartnerInviteCreated{}.EventName(), m)
	bus.Subscribe(events.PartnerOfferCreated{}.EventName(), m)
	bus.Subscribe(events.PartnerOfferAccepted{}.EventName(), m)
	bus.Subscribe(events.PartnerOfferRejected{}.EventName(), m)
	bus.Subscribe(events.PartnerOfferExpired{}.EventName(), m)

	// Lead events
	bus.Subscribe(events.LeadCreated{}.EventName(), m)
	bus.Subscribe(events.LeadDataChanged{}.EventName(), m)
	bus.Subscribe(events.PipelineStageChanged{}.EventName(), m)

	// Quote domain events
	bus.Subscribe(events.QuoteSent{}.EventName(), m)
	bus.Subscribe(events.QuoteViewed{}.EventName(), m)
	bus.Subscribe(events.QuoteUpdatedByCustomer{}.EventName(), m)
	bus.Subscribe(events.QuoteAnnotated{}.EventName(), m)
	bus.Subscribe(events.QuoteAccepted{}.EventName(), m)
	bus.Subscribe(events.QuoteRejected{}.EventName(), m)

	// Appointment domain events
	bus.Subscribe(events.AppointmentCreated{}.EventName(), m)
	bus.Subscribe(events.AppointmentReminderDue{}.EventName(), m)

	m.log.Info("notification module registered event handlers")
}

// Handle routes events to the appropriate handler method.
func (m *Module) Handle(ctx context.Context, event events.Event) error {
	switch e := event.(type) {
	case events.UserSignedUp:
		return m.handleUserSignedUp(ctx, e)
	case events.EmailVerificationRequested:
		return m.handleEmailVerificationRequested(ctx, e)
	case events.PasswordResetRequested:
		return m.handlePasswordResetRequested(ctx, e)
	case events.OrganizationInviteCreated:
		return m.handleOrganizationInviteCreated(ctx, e)
	case events.PartnerInviteCreated:
		return m.handlePartnerInviteCreated(ctx, e)
	case events.PartnerOfferCreated:
		return m.handlePartnerOfferCreated(ctx, e)
	case events.PartnerOfferAccepted:
		return m.handlePartnerOfferAccepted(ctx, e)
	case events.PartnerOfferRejected:
		return m.handlePartnerOfferRejected(ctx, e)
	case events.PartnerOfferExpired:
		return m.handlePartnerOfferExpired(ctx, e)
	case events.LeadCreated:
		return m.handleLeadCreated(ctx, e)
	case events.LeadDataChanged:
		return m.handleLeadDataChanged(ctx, e)
	case events.PipelineStageChanged:
		return m.handlePipelineStageChanged(ctx, e)
	// Quote events
	case events.QuoteSent:
		return m.handleQuoteSent(ctx, e)
	case events.QuoteViewed:
		return m.handleQuoteViewed(ctx, e)
	case events.QuoteUpdatedByCustomer:
		return m.handleQuoteUpdatedByCustomer(ctx, e)
	case events.QuoteAnnotated:
		return m.handleQuoteAnnotated(ctx, e)
	case events.QuoteAccepted:
		return m.handleQuoteAccepted(ctx, e)
	case events.QuoteRejected:
		return m.handleQuoteRejected(ctx, e)
	case events.AppointmentCreated:
		return m.handleAppointmentCreated(ctx, e)
	case events.AppointmentReminderDue:
		return m.handleAppointmentReminderDue(ctx, e)
	default:
		m.log.Warn("unhandled event type", "event", event.EventName())
		return nil
	}
}

func (m *Module) handleUserSignedUp(ctx context.Context, e events.UserSignedUp) error {
	verifyURL := m.buildURL("/verify-email", e.VerifyToken)
	if err := m.sender.SendVerificationEmail(ctx, e.Email, verifyURL); err != nil {
		m.log.Error("failed to send verification email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("verification email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handleEmailVerificationRequested(ctx context.Context, e events.EmailVerificationRequested) error {
	verifyURL := m.buildURL("/verify-email", e.VerifyToken)
	if err := m.sender.SendVerificationEmail(ctx, e.Email, verifyURL); err != nil {
		m.log.Error("failed to send verification email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("verification email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handlePasswordResetRequested(ctx context.Context, e events.PasswordResetRequested) error {
	resetURL := m.buildURL("/reset-password", e.ResetToken)
	if err := m.sender.SendPasswordResetEmail(ctx, e.Email, resetURL); err != nil {
		m.log.Error("failed to send password reset email",
			"userId", e.UserID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("password reset email sent", "userId", e.UserID, "email", e.Email)
	return nil
}

func (m *Module) handleOrganizationInviteCreated(ctx context.Context, e events.OrganizationInviteCreated) error {
	inviteURL := m.buildURL("/sign-up", e.InviteToken)
	if err := m.sender.SendOrganizationInviteEmail(ctx, e.Email, e.OrganizationName, inviteURL); err != nil {
		m.log.Error("failed to send organization invite email",
			"organizationId", e.OrganizationID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("organization invite email sent", "organizationId", e.OrganizationID, "email", e.Email)
	return nil
}

func (m *Module) handlePartnerInviteCreated(ctx context.Context, e events.PartnerInviteCreated) error {
	inviteURL := m.buildURL("/partner-invite", e.InviteToken)
	if err := m.sender.SendPartnerInviteEmail(ctx, e.Email, e.OrganizationName, e.PartnerName, inviteURL); err != nil {
		m.log.Error("failed to send partner invite email",
			"organizationId", e.OrganizationID,
			"partnerId", e.PartnerID,
			"email", e.Email,
			"error", err,
		)
		return err
	}
	m.log.Info("partner invite email sent", "organizationId", e.OrganizationID, "partnerId", e.PartnerID, "email", e.Email)
	return nil
}

func (m *Module) handlePartnerOfferCreated(ctx context.Context, e events.PartnerOfferCreated) error {
	// Build the public acceptance URL for the vakman.
	acceptURL := m.buildURL("/partner-offer", e.PublicToken)

	// Build WhatsApp draft URL
	priceFormatted := fmt.Sprintf("%.2f", float64(e.VakmanPriceCents)/100)
	whatsappMsg := fmt.Sprintf(
		partnerOfferCreatedTemplate,
		e.PartnerName, priceFormatted, acceptURL,
	)
	cleanPhone := strings.Map(func(r rune) rune {
		if r >= '0' && r <= '9' {
			return r
		}
		return -1
	}, e.PartnerPhone)
	whatsappURL := fmt.Sprintf("https://wa.me/%s?text=%s", cleanPhone, urlEncode(whatsappMsg))

	m.log.Info("partner offer created  acceptance URL generated",
		"offerId", e.OfferID,
		"organizationId", e.OrganizationID,
		"partnerId", e.PartnerID,
		"leadServiceId", e.LeadServiceID,
		"vakmanPriceCents", e.VakmanPriceCents,
		"acceptanceUrl", acceptURL,
	)

	// Write timeline event on the lead with WhatsApp draft
	if m.offerTimeline != nil {
		serviceID := e.LeadServiceID
		summary := fmt.Sprintf("Aanbod van %s naar %s verstuurd", priceFormatted, e.PartnerName)
		drafts := buildPartnerOfferCreatedDrafts(e.PartnerName, priceFormatted, acceptURL)
		if err := m.offerTimeline.WriteOfferEvent(ctx,
			e.LeadID, &serviceID, e.OrganizationID,
			"System", "Offer Dispatch",
			"partner_offer_created",
			"Werkaanbod verstuurd naar vakman",
			&summary,
			map[string]any{
				"offerId":          e.OfferID.String(),
				"partnerId":        e.PartnerID.String(),
				"partnerName":      e.PartnerName,
				"vakmanPriceCents": e.VakmanPriceCents,
				"publicToken":      e.PublicToken,
				"acceptanceUrl":    acceptURL,
				"whatsappUrl":      whatsappURL,
				"drafts":           drafts,
			},
		); err != nil {
			m.log.Error("failed to write partner offer timeline event",
				"offerId", e.OfferID,
				"error", err,
			)
		}
	}

	return nil
}

func (m *Module) buildURL(path string, tokenValue string) string {
	base := strings.TrimRight(m.cfg.GetAppBaseURL(), "/")
	return base + path + "?token=" + tokenValue
}

//  Partner offer event handlers 

const partnerOfferNotificationEmail = "info@salestainable.nl"
const partnerOfferCreatedTemplate = "Hallo %s,\n\nEr is een nieuw werkaanbod voor u beschikbaar ter waarde van %s.\n\nBekijk het aanbod en geef uw beschikbaarheid door via onderstaande link:\n%s\n\nMet vriendelijke groet"

func (m *Module) handlePartnerOfferAccepted(ctx context.Context, e events.PartnerOfferAccepted) error {
	m.log.Info("partner offer accepted",
		"offerId", e.OfferID,
		"partnerId", e.PartnerID,
		"partnerName", e.PartnerName,
		"leadId", e.LeadID,
	)

	// 1. Write timeline event on the lead
	if m.offerTimeline != nil {
		serviceID := e.LeadServiceID
		summary := fmt.Sprintf("%s heeft het werkaanbod geaccepteerd en beschikbaarheid doorgegeven", e.PartnerName)
		if err := m.offerTimeline.WriteOfferEvent(ctx,
			e.LeadID, &serviceID, e.OrganizationID,
			"Partner", e.PartnerName,
			"partner_offer_accepted",
			"Werkaanbod geaccepteerd",
			&summary,
			map[string]any{
				"offerId":     e.OfferID.String(),
				"partnerId":   e.PartnerID.String(),
				"partnerName": e.PartnerName,
			},
		); err != nil {
			m.log.Error("failed to write partner offer accepted timeline event",
				"offerId", e.OfferID,
				"error", err,
			)
		}
	}

	// 2. Send notification email to info@salestainable.nl
	if err := m.sender.SendPartnerOfferAcceptedEmail(ctx, partnerOfferNotificationEmail, e.PartnerName, e.OfferID.String()); err != nil {
		m.log.Error("failed to send partner offer accepted email",
			"offerId", e.OfferID,
			"error", err,
		)
		// Non-fatal: continue to send confirmation to vakman
	}
	m.log.Info("partner offer accepted email sent",
		"offerId", e.OfferID,
		"toEmail", partnerOfferNotificationEmail,
	)

	// 3. Send confirmation email to the vakman
	if e.PartnerEmail != "" {
		if err := m.sender.SendPartnerOfferAcceptedConfirmationEmail(ctx, e.PartnerEmail, e.PartnerName); err != nil {
			m.log.Error("failed to send partner offer accepted confirmation to vakman",
				"offerId", e.OfferID,
				"partnerEmail", e.PartnerEmail,
				"error", err,
			)
		} else {
			m.log.Info("partner offer accepted confirmation sent to vakman",
				"offerId", e.OfferID,
				"partnerEmail", e.PartnerEmail,
			)
		}
	}

	if e.PartnerPhone != "" {
		msg := fmt.Sprintf(
			"Bedankt %s! \n\nU heeft de klus geaccepteerd (Offer ID: %s). We hebben de klant genformeerd.\n\nWe sturen u zo snel mogelijk de definitieve details voor de inspectie.",
			e.PartnerName,
			e.OfferID.String()[:8],
		)
		m.sendWhatsAppBestEffort(whatsAppBestEffortParams{
			Ctx:         ctx,
			OrgID:       e.OrganizationID,
			LeadID:      &e.LeadID,
			ServiceID:   &e.LeadServiceID,
			PhoneNumber: e.PartnerPhone,
			Message:     msg,
			Category:    "partner_offer_accepted",
			Audience:    "partner",
			Summary:     fmt.Sprintf("WhatsApp bevestiging verstuurd naar %s", e.PartnerName),
			ActorType:   "System",
			ActorName:   "Portal",
		})
	}

	return nil
}

func (m *Module) handlePartnerOfferRejected(ctx context.Context, e events.PartnerOfferRejected) error {
	m.log.Info("partner offer rejected",
		"offerId", e.OfferID,
		"partnerId", e.PartnerID,
		"partnerName", e.PartnerName,
		"reason", e.Reason,
	)

	// 1. Write timeline event on the lead
	if m.offerTimeline != nil {
		serviceID := e.LeadServiceID
		summary := fmt.Sprintf("%s heeft het werkaanbod afgewezen", e.PartnerName)
		if e.Reason != "" {
			summary += fmt.Sprintf("  reden: %s", e.Reason)
		}
		drafts := buildPartnerOfferRejectedDrafts(e.PartnerName, e.Reason)
		if err := m.offerTimeline.WriteOfferEvent(ctx,
			e.LeadID, &serviceID, e.OrganizationID,
			"Partner", e.PartnerName,
			"partner_offer_rejected",
			"Werkaanbod afgewezen",
			&summary,
			map[string]any{
				"offerId":     e.OfferID.String(),
				"partnerId":   e.PartnerID.String(),
				"partnerName": e.PartnerName,
				"reason":      e.Reason,
				"drafts":      drafts,
			},
		); err != nil {
			m.log.Error("failed to write partner offer rejected timeline event",
				"offerId", e.OfferID,
				"error", err,
			)
		}
	}

	// 2. Send notification email to info@salestainable.nl
	if err := m.sender.SendPartnerOfferRejectedEmail(ctx, partnerOfferNotificationEmail, e.PartnerName, e.OfferID.String(), e.Reason); err != nil {
		m.log.Error("failed to send partner offer rejected email",
			"offerId", e.OfferID,
			"error", err,
		)
		return err
	}
	m.log.Info("partner offer rejected email sent",
		"offerId", e.OfferID,
		"toEmail", partnerOfferNotificationEmail,
	)

	return nil
}

func (m *Module) handlePartnerOfferExpired(ctx context.Context, e events.PartnerOfferExpired) error {
	m.log.Info("partner offer expired",
		"offerId", e.OfferID,
		"partnerId", e.PartnerID,
		"partnerName", e.PartnerName,
	)

	// Write timeline event on the lead
	if m.offerTimeline != nil {
		serviceID := e.LeadServiceID
		summary := fmt.Sprintf("Werkaanbod naar %s is verlopen zonder reactie", e.PartnerName)
		drafts := buildPartnerOfferExpiredDrafts(e.PartnerName)
		if err := m.offerTimeline.WriteOfferEvent(ctx,
			e.LeadID, &serviceID, e.OrganizationID,
			"System", "Offer Expiry",
			"partner_offer_expired",
			"Werkaanbod verlopen",
			&summary,
			map[string]any{
				"offerId":     e.OfferID.String(),
				"partnerId":   e.PartnerID.String(),
				"partnerName": e.PartnerName,
				"drafts":      drafts,
			},
		); err != nil {
			m.log.Error("failed to write partner offer expired timeline event",
				"offerId", e.OfferID,
				"error", err,
			)
		}
	}

	return nil
}

func (m *Module) handleLeadCreated(ctx context.Context, e events.LeadCreated) error {
	_ = ctx
	m.log.Info("processing lead created notification", "leadId", e.LeadID)

	if e.ConsumerPhone == "" {
		return nil
	}

	consumerName := strings.TrimSpace(e.ConsumerName)
	if consumerName == "" {
		consumerName = "daar"
	}

	trackLink := ""
	if e.PublicToken != "" {
		base := strings.TrimRight(m.cfg.GetAppBaseURL(), "/")
		trackLink = fmt.Sprintf("%s/track/%s", base, e.PublicToken)
	}

	message := ""
	if trackLink == "" {
		message = fmt.Sprintf(
			"Beste %s,\n\n"+
				"Bedankt voor je aanvraag! \n\n"+
				"We hebben alles ontvangen en gaan het nu rustig doornemen. "+
				"Vandaag nemen we contact met je op om het verder te bespreken.",
			consumerName,
		)
	} else {
		message = fmt.Sprintf(
			"Beste %s,\n\n"+
				"Bedankt voor je aanvraag! \n\n"+
				"Volg de status of voeg details toe via jouw persoonlijke pagina:\n%s\n\n"+
				"We nemen vandaag contact met je op.",
			consumerName,
			trackLink,
		)
	}

	go func() {
		bg := context.Background()
		svcID := e.LeadServiceID
		metadata := buildWhatsAppSentMetadata("lead_welcome", "lead", e.ConsumerPhone, message)
		metadata["preferredContactChannel"] = "WhatsApp"
		metadata["suggestedContactMessage"] = message
		m.sendWhatsAppBestEffort(whatsAppBestEffortParams{
			Ctx:         bg,
			OrgID:       e.TenantID,
			LeadID:      &e.LeadID,
			ServiceID:   &svcID,
			PhoneNumber: e.ConsumerPhone,
			Message:     message,
			Category:    "lead_welcome",
			Audience:    "lead",
			Summary:     fmt.Sprintf("WhatsApp welkomstbericht verstuurd naar %s", consumerName),
			ActorType:   "System",
			ActorName:   "Portal",
			Metadata:    metadata,
		})
	}()

	return nil
}

func (m *Module) handleLeadDataChanged(_ context.Context, e events.LeadDataChanged) error {
	if m.sse == nil {
		return nil
	}

	var eventType sse.EventType
	var message string

	switch e.Source {
	case "customer_preferences":
		eventType = sse.EventLeadPreferencesUpdated
		message = "Klant heeft voorkeuren bijgewerkt"
	case "customer_portal_update":
		eventType = sse.EventLeadInfoAdded
		message = "Klant heeft extra info toegevoegd"
	case "customer_portal_upload":
		eventType = sse.EventLeadAttachmentUploaded
		message = "Klant heeft bestanden geupload"
	case "customer_portal_delete":
		eventType = sse.EventLeadAttachmentDeleted
		message = "Klant heeft een bestand verwijderd"
	case "appointment_request":
		eventType = sse.EventLeadAppointmentRequested
		message = "Klant heeft een inspectie aangevraagd"
	default:
		return nil
	}

	m.sse.PublishToOrganization(e.TenantID, sse.Event{
		Type:      eventType,
		LeadID:    e.LeadID,
		ServiceID: e.LeadServiceID,
		Message:   message,
		Data: map[string]interface{}{
			"source": e.Source,
		},
	})

	return nil
}

func (m *Module) handlePipelineStageChanged(_ context.Context, e events.PipelineStageChanged) error {
	if m.sse == nil {
		return nil
	}

	m.sse.PublishToLead(e.LeadID, sse.Event{
		Type:      sse.EventLeadStatusChanged,
		LeadID:    e.LeadID,
		ServiceID: e.LeadServiceID,
		Data: map[string]interface{}{
			"oldStage": e.OldStage,
			"newStage": e.NewStage,
		},
	})

	return nil
}

//  Quote event handlers 

func (m *Module) handleQuoteSent(ctx context.Context, e events.QuoteSent) error {
	// Send the quote proposal email to the consumer
	if e.ConsumerEmail != "" {
		proposalURL := strings.TrimRight(m.cfg.GetAppBaseURL(), "/") + "/quote/" + e.PublicToken
		if err := m.sender.SendQuoteProposalEmail(ctx, e.ConsumerEmail, e.ConsumerName, e.OrganizationName, e.QuoteNumber, proposalURL); err != nil {
			m.log.Error("failed to send quote proposal email",
				"quoteId", e.QuoteID,
				"email", e.ConsumerEmail,
				"error", err,
			)
			return err
		}
		m.log.Info("quote proposal email sent",
			"quoteId", e.QuoteID,
			"email", e.ConsumerEmail,
			"quoteNumber", e.QuoteNumber,
		)
	} else {
		m.log.Warn("quote sent but no consumer email available, skipping email",
			"quoteId", e.QuoteID,
			"leadId", e.LeadID,
		)
	}

	// Push SSE event so the agent dashboard updates
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteSent, e.QuoteID, map[string]interface{}{
		"quoteNumber": e.QuoteNumber,
		"status":      "Sent",
	})

	if m.sse != nil {
		evt := sse.Event{
			Type:   sse.EventQuoteSent,
			LeadID: e.LeadID,
			Data: map[string]interface{}{
				"quoteId":     e.QuoteID,
				"quoteNumber": e.QuoteNumber,
				"status":      "Sent",
			},
		}
		if e.LeadServiceID != nil {
			evt.ServiceID = *e.LeadServiceID
		}
		m.sse.PublishToLead(e.LeadID, evt)
	}

	// Persist activity
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_sent",
		"Offerte verstuurd naar "+e.ConsumerName,
		map[string]interface{}{"quoteNumber": e.QuoteNumber, "consumerEmail": e.ConsumerEmail})

	if e.ConsumerPhone != "" {
		proposalURL := strings.TrimRight(m.cfg.GetAppBaseURL(), "/") + "/quote/" + e.PublicToken
		name := strings.TrimSpace(e.ConsumerName)
		if name == "" {
			name = "klant"
		}

		msg := fmt.Sprintf(
			"Hi %s,\n\nUw offerte %s van %s is klaar! \n\nBekijk en accordeer hem direct via deze link:\n%s\n\nMet vriendelijke groet,\n%s",
			name,
			e.QuoteNumber,
			e.OrganizationName,
			proposalURL,
			e.OrganizationName,
		)

		m.sendWhatsAppBestEffort(whatsAppBestEffortParams{
			Ctx:         ctx,
			OrgID:       e.OrganizationID,
			LeadID:      &e.LeadID,
			ServiceID:   e.LeadServiceID,
			PhoneNumber: e.ConsumerPhone,
			Message:     msg,
			Category:    "quote_sent",
			Audience:    "lead",
			Summary:     fmt.Sprintf("WhatsApp offerte verstuurd naar %s", name),
			ActorType:   "System",
			ActorName:   "Portal",
		})
	}

	m.log.Info("quote sent event processed", "quoteId", e.QuoteID)
	return nil
}

func (m *Module) handleAppointmentCreated(ctx context.Context, e events.AppointmentCreated) error {
	if e.Type != "lead_visit" || e.ConsumerPhone == "" {
		return nil
	}

	name := strings.TrimSpace(e.ConsumerName)
	if name == "" {
		name = "klant"
	}

	dateStr := e.StartTime.Format("02-01-2006")
	timeStr := e.StartTime.Format("15:04")

	msg := fmt.Sprintf(
		"Hi %s,\n\nUw afspraak is bevestigd! \n\nDatum: %s\nTijd: %s\n\nOnze adviseur komt bij u langs voor de opname. Tot dan!",
		name,
		dateStr,
		timeStr,
	)

	m.sendWhatsAppBestEffort(whatsAppBestEffortParams{
		Ctx:         ctx,
		OrgID:       e.OrganizationID,
		LeadID:      e.LeadID,
		ServiceID:   e.LeadServiceID,
		PhoneNumber: e.ConsumerPhone,
		Message:     msg,
		Category:    "appointment_created",
		Audience:    "lead",
		Summary:     fmt.Sprintf("WhatsApp afspraakbevestiging verstuurd naar %s", name),
		ActorType:   "System",
		ActorName:   "Portal",
	})
	return nil
}

func (m *Module) handleAppointmentReminderDue(ctx context.Context, e events.AppointmentReminderDue) error {
	if e.Type != "lead_visit" || e.ConsumerPhone == "" {
		return nil
	}

	name := strings.TrimSpace(e.ConsumerName)
	if name == "" {
		name = "klant"
	}

	dateStr := e.StartTime.Format("02-01-2006")
	timeStr := e.StartTime.Format("15:04")

	msg := fmt.Sprintf(
		"Herinnering, %s! \n\nMorgen staat uw afspraak gepland.\n\nDatum: %s\nTijd: %s\n\nTot morgen!",
		name,
		dateStr,
		timeStr,
	)

	m.sendWhatsAppBestEffort(whatsAppBestEffortParams{
		Ctx:         ctx,
		OrgID:       e.OrganizationID,
		LeadID:      e.LeadID,
		ServiceID:   e.LeadServiceID,
		PhoneNumber: e.ConsumerPhone,
		Message:     msg,
		Category:    "appointment_reminder",
		Audience:    "lead",
		Summary:     fmt.Sprintf("WhatsApp afspraakherinnering verstuurd naar %s", name),
		ActorType:   "System",
		ActorName:   "Portal",
	})
	return nil
}

func (m *Module) handleQuoteViewed(ctx context.Context, e events.QuoteViewed) error {
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteViewed, e.QuoteID, map[string]interface{}{
		"viewerIp": e.ViewerIP,
	})
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_viewed",
		"Klant heeft de offerte geopend",
		map[string]interface{}{"viewerIp": e.ViewerIP})
	m.log.Info("quote viewed event processed", "quoteId", e.QuoteID)
	return nil
}

func (m *Module) handleQuoteUpdatedByCustomer(ctx context.Context, e events.QuoteUpdatedByCustomer) error {
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteItemToggled, e.QuoteID, map[string]interface{}{
		"itemId":          e.ItemID,
		"itemDescription": e.ItemDescription,
		"isSelected":      e.IsSelected,
		"newTotalCents":   e.NewTotalCents,
	})
	action := "uitgeschakeld"
	if e.IsSelected {
		action = "ingeschakeld"
	}
	desc := e.ItemDescription
	if desc == "" {
		desc = "een item"
	}
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_item_toggled",
		"Klant heeft '"+truncate(desc, 60)+"' "+action,
		map[string]interface{}{"itemId": e.ItemID.String(), "itemDescription": e.ItemDescription, "isSelected": e.IsSelected, "newTotalCents": e.NewTotalCents})
	m.log.Info("quote item toggled event processed", "quoteId", e.QuoteID, "itemId", e.ItemID)
	return nil
}

func (m *Module) handleQuoteAnnotated(ctx context.Context, e events.QuoteAnnotated) error {
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteAnnotated, e.QuoteID, map[string]interface{}{
		"itemId":     e.ItemID,
		"authorType": e.AuthorType,
		"text":       e.Text,
	})
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_annotated",
		"Nieuwe vraag: \""+truncate(e.Text, 80)+"\"",
		map[string]interface{}{"itemId": e.ItemID.String(), "authorType": e.AuthorType, "text": e.Text})
	m.log.Info("quote annotated event processed", "quoteId", e.QuoteID, "itemId", e.ItemID)
	return nil
}

func (m *Module) handleQuoteAccepted(ctx context.Context, e events.QuoteAccepted) error {
	pdfBytes := m.generateAcceptancePDF(ctx, e)
	m.sendAcceptanceThankYouEmail(ctx, e, pdfBytes)
	m.sendAcceptanceAgentEmail(ctx, e)
	m.publishQuoteAcceptedSSE(e)
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_accepted",
		"Offerte geaccepteerd door "+e.SignatureName,
		map[string]interface{}{"signatureName": e.SignatureName, "totalCents": e.TotalCents, "consumerName": e.ConsumerName})

	m.log.Info("quote accepted event processed", "quoteId", e.QuoteID)
	return nil
}

func (m *Module) generateAcceptancePDF(ctx context.Context, e events.QuoteAccepted) []byte {
	if m.pdfProc == nil {
		return nil
	}

	fileKey, generatedPDF, err := m.pdfProc.GenerateAndStorePDF(ctx, e.QuoteID, e.OrganizationID, e.OrganizationName, e.ConsumerName, e.SignatureName)
	if err != nil {
		m.log.Error("failed to generate/store acceptance PDF",
			"quoteId", e.QuoteID,
			"error", err,
		)
		return nil
	}

	m.log.Info("acceptance PDF generated and stored",
		"quoteId", e.QuoteID,
		"fileKey", fileKey,
	)

	return generatedPDF
}

func (m *Module) sendAcceptanceThankYouEmail(ctx context.Context, e events.QuoteAccepted, pdfBytes []byte) {
	if e.ConsumerEmail == "" {
		return
	}

	var attachments []email.Attachment
	if len(pdfBytes) > 0 {
		attachments = append(attachments, email.Attachment{
			Content:  pdfBytes,
			FileName: "offerte-" + e.QuoteNumber + ".pdf",
			MIMEType: "application/pdf",
		})
	}

	if err := m.sender.SendQuoteAcceptedThankYouEmail(ctx, e.ConsumerEmail, e.ConsumerName, e.OrganizationName, e.QuoteNumber, attachments...); err != nil {
		m.log.Error("failed to send acceptance thank-you email to customer",
			"quoteId", e.QuoteID,
			"email", e.ConsumerEmail,
			"error", err,
		)
		return
	}

	m.log.Info("acceptance thank-you email sent to customer",
		"quoteId", e.QuoteID,
		"email", e.ConsumerEmail,
	)
}

func (m *Module) sendAcceptanceAgentEmail(ctx context.Context, e events.QuoteAccepted) {
	if e.AgentEmail == "" {
		return
	}

	if err := m.sender.SendQuoteAcceptedEmail(ctx, e.AgentEmail, e.AgentName, e.QuoteNumber, e.ConsumerName, e.TotalCents); err != nil {
		m.log.Error("failed to send acceptance notification email to agent",
			"quoteId", e.QuoteID,
			"email", e.AgentEmail,
			"error", err,
		)
		return
	}

	m.log.Info("acceptance notification email sent to agent",
		"quoteId", e.QuoteID,
		"email", e.AgentEmail,
	)
}

func (m *Module) publishQuoteAcceptedSSE(e events.QuoteAccepted) {
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteAccepted, e.QuoteID, map[string]interface{}{
		"signatureName": e.SignatureName,
		"totalCents":    e.TotalCents,
	})

	if m.sse == nil {
		return
	}

	evt := sse.Event{
		Type:   sse.EventQuoteAccepted,
		LeadID: e.LeadID,
		Data: map[string]interface{}{
			"quoteId":   e.QuoteID,
			"status":    "Accepted",
			"signature": e.SignatureName,
		},
	}
	if e.LeadServiceID != nil {
		evt.ServiceID = *e.LeadServiceID
	}
	m.sse.PublishToLead(e.LeadID, evt)
}

func (m *Module) handleQuoteRejected(ctx context.Context, e events.QuoteRejected) error {
	m.pushQuoteSSE(e.OrganizationID, sse.EventQuoteRejected, e.QuoteID, map[string]interface{}{
		"reason": e.Reason,
	})

	if m.sse != nil {
		evt := sse.Event{
			Type:   sse.EventQuoteRejected,
			LeadID: e.LeadID,
			Data: map[string]interface{}{
				"quoteId": e.QuoteID,
				"status":  "Rejected",
				"reason":  e.Reason,
			},
		}
		if e.LeadServiceID != nil {
			evt.ServiceID = *e.LeadServiceID
		}
		m.sse.PublishToLead(e.LeadID, evt)
	}
	m.logQuoteActivity(ctx, e.QuoteID, e.OrganizationID, "quote_rejected",
		"Offerte afgewezen door klant",
		map[string]interface{}{"reason": e.Reason})
	m.log.Info("quote rejected event processed", "quoteId", e.QuoteID)
	return nil
}

// pushQuoteSSE broadcasts a quote event to all connected agents in the org via SSE.
func (m *Module) pushQuoteSSE(orgID uuid.UUID, eventType sse.EventType, quoteID uuid.UUID, data interface{}) {
	if m.sse == nil {
		return
	}
	m.sse.PublishQuoteEvent(orgID, eventType, quoteID, data)
}

// logQuoteActivity persists an activity record for a quote. Failures are logged but non-fatal.
func (m *Module) logQuoteActivity(ctx context.Context, quoteID, orgID uuid.UUID, eventType, message string, metadata map[string]interface{}) {
	if m.actWriter == nil {
		return
	}
	if err := m.actWriter.CreateActivity(ctx, quoteID, orgID, eventType, message, metadata); err != nil {
		m.log.Error("failed to persist quote activity",
			"quoteId", quoteID,
			"eventType", eventType,
			"error", err,
		)
	}
}

// truncate shortens a string to max characters, appending "" when truncated.
func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max] + "..."
}

// urlEncode percent-encodes a string for use in a URL query parameter.
func urlEncode(s string) string {
	var b strings.Builder
	for _, c := range []byte(s) {
		if (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '-' || c == '_' || c == '.' || c == '~' {
			b.WriteByte(c)
		} else {
			fmt.Fprintf(&b, "%%%02X", c)
		}
	}
	return b.String()
}

func buildPartnerOfferCreatedDrafts(partnerName, priceFormatted, acceptURL string) map[string]any {
	emailSubject := "Nieuw werkaanbod beschikbaar"
	emailBody := fmt.Sprintf(partnerOfferCreatedTemplate, partnerName, priceFormatted, acceptURL)
	whatsAppMessage := fmt.Sprintf(partnerOfferCreatedTemplate, partnerName, priceFormatted, acceptURL)

	return map[string]any{
		"emailSubject":    emailSubject,
		"emailBody":       emailBody,
		"whatsappMessage": whatsAppMessage,
		"messageLanguage": "nl",
		"messageAudience": "partner",
		"messageCategory": "partner_offer_created",
		"status":          "draft",
	}
}

func buildPartnerOfferRejectedDrafts(partnerName, reason string) map[string]any {
	cleanReason := strings.TrimSpace(reason)
	if cleanReason == "" {
		cleanReason = "Geen reden opgegeven"
	}

	emailSubject := "Werkaanbod afgewezen"
	emailBody := fmt.Sprintf("Hallo %s,\n\nWij hebben uw afwijzing ontvangen. Reden: %s.\n\nAls u toch beschikbaar bent of aanvullende vragen heeft, laat het ons weten.\n\nMet vriendelijke groet", partnerName, cleanReason)
	whatsAppMessage := fmt.Sprintf("Hallo %s,\n\nWij hebben uw afwijzing ontvangen. Reden: %s.\n\nAls u toch beschikbaar bent of aanvullende vragen heeft, laat het ons weten.", partnerName, cleanReason)

	return map[string]any{
		"emailSubject":    emailSubject,
		"emailBody":       emailBody,
		"whatsappMessage": whatsAppMessage,
		"messageLanguage": "nl",
		"messageAudience": "partner",
		"messageCategory": "partner_offer_rejected",
		"status":          "draft",
	}
}

func buildPartnerOfferExpiredDrafts(partnerName string) map[string]any {
	emailSubject := "Werkaanbod verlopen"
	emailBody := fmt.Sprintf("Hallo %s,\n\nHet werkaanbod is verlopen zonder reactie. Als u alsnog beschikbaar bent, laat het ons weten.\n\nMet vriendelijke groet", partnerName)
	whatsAppMessage := fmt.Sprintf("Hallo %s,\n\nHet werkaanbod is verlopen zonder reactie. Als u alsnog beschikbaar bent, laat het ons weten.", partnerName)

	return map[string]any{
		"emailSubject":    emailSubject,
		"emailBody":       emailBody,
		"whatsappMessage": whatsAppMessage,
		"messageLanguage": "nl",
		"messageAudience": "partner",
		"messageCategory": "partner_offer_expired",
		"status":          "draft",
	}
}

type whatsAppBestEffortParams struct {
	Ctx         context.Context
	OrgID       uuid.UUID
	LeadID      *uuid.UUID
	ServiceID   *uuid.UUID
	PhoneNumber string
	Message     string
	Category    string
	Audience    string
	Summary     string
	ActorType   string
	ActorName   string
	Metadata    map[string]any
}

func (m *Module) sendWhatsAppBestEffort(params whatsAppBestEffortParams) {
	if m.whatsapp == nil || params.PhoneNumber == "" {
		return
	}

	deviceID := m.resolveWhatsAppDeviceID(params.Ctx, params.OrgID)
	err := m.whatsapp.SendMessage(params.Ctx, deviceID, params.PhoneNumber, params.Message)
	if err != nil {
		if errors.Is(err, whatsapp.ErrNoDevice) {
			m.log.Debug("whatsapp skipped: no device configured", "orgId", params.OrgID)
			return
		}

		m.log.Warn("failed to send whatsapp", "error", err, "orgId", params.OrgID)
		if params.LeadID != nil {
			m.writeWhatsAppFailureEvent(params.Ctx, *params.LeadID, params.ServiceID, params.OrgID, err.Error())
		}
		return
	}

	if params.LeadID == nil {
		return
	}

	metadata := params.Metadata
	if metadata == nil {
		metadata = buildWhatsAppSentMetadata(params.Category, params.Audience, params.PhoneNumber, params.Message)
	}

	m.writeWhatsAppSentEventWithMetadata(whatsAppSentEventWithMetadataParams{
		Ctx:       params.Ctx,
		LeadID:    *params.LeadID,
		ServiceID: params.ServiceID,
		OrgID:     params.OrgID,
		ActorType: params.ActorType,
		ActorName: params.ActorName,
		Summary:   params.Summary,
		Metadata:  metadata,
	})
}

func (m *Module) resolveWhatsAppDeviceID(ctx context.Context, orgID uuid.UUID) string {
	if m.settingsReader == nil {
		return ""
	}

	settings, err := m.settingsReader.GetOrganizationSettings(ctx, orgID)
	if err != nil {
		m.log.Warn("failed to fetch org settings for whatsapp", "error", err, "orgId", orgID)
		return ""
	}
	if settings.WhatsAppDeviceID == nil {
		return ""
	}
	return *settings.WhatsAppDeviceID
}

func (m *Module) writeWhatsAppFailureEvent(ctx context.Context, leadID uuid.UUID, serviceID *uuid.UUID, orgID uuid.UUID, errorMsg string) {
	if m.leadTimeline == nil {
		return
	}

	friendlyError := "Verzenden mislukt"
	msgLower := strings.ToLower(errorMsg)
	if strings.Contains(msgLower, "disconnected") || strings.Contains(msgLower, "not connected") {
		friendlyError = "Telefoon niet verbonden"
	}

	summary := fmt.Sprintf("WhatsApp niet verstuurd: %s", friendlyError)
	_ = m.leadTimeline.CreateTimelineEvent(ctx, LeadTimelineEventParams{
		LeadID:    leadID,
		ServiceID: serviceID,
		OrgID:     orgID,
		ActorType: "System",
		ActorName: "WhatsApp",
		EventType: "whatsapp_failed",
		Title:     "WhatsApp fout",
		Summary:   &summary,
		Metadata: map[string]any{
			"raw_error": errorMsg,
		},
	})
}

func buildWhatsAppSentMetadata(category, audience, phoneNumber, message string) map[string]any {
	return map[string]any{
		"status":          "sent",
		"messageCategory": category,
		"messageAudience": audience,
		"messageLanguage": "nl",
		"phoneNumber":     phone.NormalizeE164(phoneNumber),
		"messageContent":  message,
		"sentAt":          time.Now().UTC().Format(time.RFC3339),
	}
}

type whatsAppSentEventWithMetadataParams struct {
	Ctx       context.Context
	LeadID    uuid.UUID
	ServiceID *uuid.UUID
	OrgID     uuid.UUID
	ActorType string
	ActorName string
	Summary   string
	Metadata  map[string]any
}

func (m *Module) writeWhatsAppSentEventWithMetadata(params whatsAppSentEventWithMetadataParams) {
	if m.leadTimeline == nil {
		return
	}

	if err := m.leadTimeline.CreateTimelineEvent(params.Ctx, LeadTimelineEventParams{
		LeadID:    params.LeadID,
		ServiceID: params.ServiceID,
		OrgID:     params.OrgID,
		ActorType: params.ActorType,
		ActorName: params.ActorName,
		EventType: "whatsapp_sent",
		Title:     "WhatsApp verstuurd",
		Summary:   &params.Summary,
		Metadata:  params.Metadata,
	}); err != nil {
		m.log.Error("failed to write whatsapp timeline event", "error", err, "leadId", params.LeadID)
	}
}
</file>

<file path="internal/leads/module.go">
// Package leads provides the lead management bounded context module.
// This file defines the module that encapsulates all leads setup and route registration.
package leads

import (
	"context"
	"time"

	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/events"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/leads/agent"
	"portal_final_backend/internal/leads/domain"
	"portal_final_backend/internal/leads/handler"
	"portal_final_backend/internal/leads/management"
	"portal_final_backend/internal/leads/notes"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/scoring"
	"portal_final_backend/internal/maps"
	"portal_final_backend/internal/notification/sse"
	"portal_final_backend/platform/ai/embeddings"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/httpkit"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/qdrant"
	"portal_final_backend/platform/validator"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Module is the RAC_leads bounded context module implementing http.Module.
type Module struct {
	handler               *handler.Handler
	attachmentsHandler    *handler.AttachmentsHandler
	photoAnalysisHandler  *handler.PhotoAnalysisHandler
	publicHandler         *handler.PublicHandler
	management            *management.Service
	notes                 *notes.Service
	gatekeeper            *agent.Gatekeeper
	estimator             *agent.Estimator
	dispatcher            *agent.Dispatcher
	orchestrator          *Orchestrator
	photoAnalyzer         *agent.PhotoAnalyzer
	callLogger            *agent.CallLogger
	quoteGenerator        *agent.QuoteGenerator
	offerSummaryGenerator *agent.OfferSummaryGenerator
	sse                   *sse.Service
	repo                  repository.LeadsRepository
	storage               storage.StorageService
	attachmentsBucket     string
	log                   *logger.Logger
	scorer                *scoring.Service
}

// NewModule creates and initializes the RAC_leads module with all its dependencies.
func NewModule(pool *pgxpool.Pool, eventBus events.Bus, storageSvc storage.StorageService, val *validator.Validator, cfg *config.Config, log *logger.Logger) (*Module, error) {
	// Create shared repository
	repo := repository.New(pool)

	// Score service for lead scoring
	scorer := scoring.New(repo, log)

	photoAnalyzer, callLogger, gatekeeper, estimator, dispatcher, quoteGenerator, offerSummaryGenerator, err := buildAgents(cfg, repo, storageSvc, scorer, eventBus)
	if err != nil {
		return nil, err
	}

	// SSE service for real-time notifications
	sseService := sse.New()

	// Subscribe to LeadCreated and LeadServiceAdded events to kick off gatekeeper triage
	subscribeLeadCreated(eventBus, repo, gatekeeper, log)
	subscribeLeadServiceAdded(eventBus, repo, gatekeeper, log)

	// Create focused services (vertical slices)
	mapsSvc := maps.NewService(log)
	mgmtSvc := management.New(repo, eventBus, mapsSvc)
	mgmtSvc.SetLeadScorer(scorer)
	notesSvc := notes.New(repo)

	// Create orchestrator and event listeners
	orchestrator := NewOrchestrator(gatekeeper, estimator, dispatcher, repo, eventBus, sseService, log)
	subscribeOrchestrator(eventBus, orchestrator)

	// Create handlers
	h, attachmentsHandler, photoAnalysisHandler := buildHandlers(buildHandlersDeps{
		MgmtSvc:       mgmtSvc,
		NotesSvc:      notesSvc,
		Gatekeeper:    gatekeeper,
		CallLogger:    callLogger,
		SSEService:    sseService,
		EventBus:      eventBus,
		Repo:          repo,
		StorageSvc:    storageSvc,
		Config:        cfg,
		Validator:     val,
		PhotoAnalyzer: photoAnalyzer,
	})

	photoBatcher := newPhotoAnalysisBatcher(photoAnalysisHandler, 60*time.Second, log)
	subscribeAttachmentUploaded(eventBus, repo, photoBatcher, log)
	publicHandler := handler.NewPublicHandler(repo, eventBus, sseService, storageSvc, cfg.GetMinioBucketLeadServiceAttachments(), val)

	return &Module{
		handler:               h,
		attachmentsHandler:    attachmentsHandler,
		photoAnalysisHandler:  photoAnalysisHandler,
		publicHandler:         publicHandler,
		management:            mgmtSvc,
		notes:                 notesSvc,
		gatekeeper:            gatekeeper,
		estimator:             estimator,
		dispatcher:            dispatcher,
		orchestrator:          orchestrator,
		photoAnalyzer:         photoAnalyzer,
		callLogger:            callLogger,
		quoteGenerator:        quoteGenerator,
		offerSummaryGenerator: offerSummaryGenerator,
		sse:                   sseService,
		repo:                  repo,
		storage:               storageSvc,
		attachmentsBucket:     cfg.GetMinioBucketLeadServiceAttachments(),
		log:                   log,
		scorer:                scorer,
	}, nil
}

func buildAgents(cfg *config.Config, repo repository.LeadsRepository, storageSvc storage.StorageService, scorer *scoring.Service, eventBus events.Bus) (*agent.PhotoAnalyzer, *agent.CallLogger, *agent.Gatekeeper, *agent.Estimator, *agent.Dispatcher, *agent.QuoteGenerator, *agent.OfferSummaryGenerator, error) {
	_ = storageSvc
	_ = scorer
	photoAnalyzer, err := agent.NewPhotoAnalyzer(cfg.MoonshotAPIKey, repo)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	callLogger, err := agent.NewCallLogger(cfg.MoonshotAPIKey, repo, nil, eventBus)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	gatekeeper, err := agent.NewGatekeeper(cfg.MoonshotAPIKey, repo, eventBus)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	// Create embedding and qdrant clients if configured
	var embeddingClient *embeddings.Client
	var qdrantClient *qdrant.Client
	var catalogQdrantClient *qdrant.Client

	if cfg.IsEmbeddingEnabled() {
		embeddingClient = embeddings.NewClient(embeddings.Config{
			BaseURL: cfg.GetEmbeddingAPIURL(),
			APIKey:  cfg.GetEmbeddingAPIKey(),
		})
	}

	if cfg.IsQdrantEnabled() {
		qdrantClient = qdrant.NewClient(qdrant.Config{
			BaseURL:    cfg.GetQdrantURL(),
			APIKey:     cfg.GetQdrantAPIKey(),
			Collection: cfg.GetQdrantCollection(),
		})
	}

	if cfg.GetQdrantURL() != "" && cfg.GetCatalogEmbeddingCollection() != "" {
		catalogQdrantClient = qdrant.NewClient(qdrant.Config{
			BaseURL:    cfg.GetQdrantURL(),
			APIKey:     cfg.GetQdrantAPIKey(),
			Collection: cfg.GetCatalogEmbeddingCollection(),
		})
	}

	estimator, err := agent.NewEstimator(agent.EstimatorConfig{
		APIKey:              cfg.MoonshotAPIKey,
		Repo:                repo,
		EventBus:            eventBus,
		EmbeddingClient:     embeddingClient,
		QdrantClient:        qdrantClient,
		CatalogQdrantClient: catalogQdrantClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	dispatcher, err := agent.NewDispatcher(cfg.MoonshotAPIKey, repo, eventBus)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	quoteGenerator, err := agent.NewQuoteGenerator(agent.QuoteGeneratorConfig{
		APIKey:              cfg.MoonshotAPIKey,
		Repo:                repo,
		EventBus:            eventBus,
		EmbeddingClient:     embeddingClient,
		QdrantClient:        qdrantClient,
		CatalogQdrantClient: catalogQdrantClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	offerSummaryGenerator, err := agent.NewOfferSummaryGenerator(cfg.MoonshotAPIKey)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	return photoAnalyzer, callLogger, gatekeeper, estimator, dispatcher, quoteGenerator, offerSummaryGenerator, nil
}

// OfferSummaryGenerator exposes the AI summary generator for partner offers.
func (m *Module) OfferSummaryGenerator() ports.OfferSummaryGenerator {
	return m.offerSummaryGenerator
}

func subscribeLeadCreated(eventBus events.Bus, repo repository.LeadsRepository, gatekeeper *agent.Gatekeeper, log *logger.Logger) {
	eventBus.Subscribe(events.LeadCreated{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.LeadCreated)
		if !ok {
			return nil
		}

		go func() {
			bg := context.Background()

			// Terminal check: verify the service is not already in a terminal state
			service, err := repo.GetLeadServiceByID(bg, e.LeadServiceID, e.TenantID)
			if err != nil {
				log.Error("gatekeeper: failed to load service", "error", err, "leadId", e.LeadID, "serviceId", e.LeadServiceID)
				return
			}
			if domain.IsTerminal(service.Status, service.PipelineStage) {
				log.Info("gatekeeper: skipping terminal service on lead created", "leadId", e.LeadID, "serviceId", e.LeadServiceID)
				return
			}

			if err := gatekeeper.Run(bg, e.LeadID, e.LeadServiceID, e.TenantID); err != nil {
				log.Error("gatekeeper run failed", "error", err, "leadId", e.LeadID)
			}
		}()

		return nil
	}))
}

func subscribeLeadServiceAdded(eventBus events.Bus, repo repository.LeadsRepository, gatekeeper *agent.Gatekeeper, log *logger.Logger) {
	eventBus.Subscribe(events.LeadServiceAdded{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.LeadServiceAdded)
		if !ok {
			return nil
		}

		go func() {
			bg := context.Background()

			// Terminal check: verify the service is not already in a terminal state
			service, err := repo.GetLeadServiceByID(bg, e.LeadServiceID, e.TenantID)
			if err != nil {
				log.Error("gatekeeper: failed to load service", "error", err, "leadId", e.LeadID, "serviceId", e.LeadServiceID)
				return
			}
			if domain.IsTerminal(service.Status, service.PipelineStage) {
				log.Info("gatekeeper: skipping terminal service on service added", "leadId", e.LeadID, "serviceId", e.LeadServiceID)
				return
			}

			if err := gatekeeper.Run(bg, e.LeadID, e.LeadServiceID, e.TenantID); err != nil {
				log.Error("gatekeeper run failed for new service", "error", err, "leadId", e.LeadID, "serviceId", e.LeadServiceID)
			}
		}()

		return nil
	}))
}

func subscribeOrchestrator(eventBus events.Bus, orchestrator *Orchestrator) {
	eventBus.Subscribe(events.LeadDataChanged{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.LeadDataChanged)
		if !ok {
			return nil
		}
		orchestrator.OnDataChange(ctx, e)
		return nil
	}))

	eventBus.Subscribe(events.QuoteAccepted{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.QuoteAccepted)
		if !ok {
			return nil
		}
		orchestrator.OnQuoteAccepted(ctx, e)
		return nil
	}))

	eventBus.Subscribe(events.PartnerOfferRejected{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.PartnerOfferRejected)
		if !ok {
			return nil
		}
		orchestrator.OnPartnerOfferRejected(ctx, e)
		return nil
	}))

	eventBus.Subscribe(events.PartnerOfferAccepted{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.PartnerOfferAccepted)
		if !ok {
			return nil
		}
		orchestrator.OnPartnerOfferAccepted(ctx, e)
		return nil
	}))

	eventBus.Subscribe(events.PartnerOfferExpired{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.PartnerOfferExpired)
		if !ok {
			return nil
		}
		orchestrator.OnPartnerOfferExpired(ctx, e)
		return nil
	}))

	eventBus.Subscribe(events.PipelineStageChanged{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.PipelineStageChanged)
		if !ok {
			return nil
		}
		orchestrator.OnStageChange(ctx, e)
		return nil
	}))
}

func subscribeAttachmentUploaded(eventBus events.Bus, repo repository.LeadsRepository, batcher *photoAnalysisBatcher, log *logger.Logger) {
	eventBus.Subscribe(events.AttachmentUploaded{}.EventName(), events.HandlerFunc(func(ctx context.Context, event events.Event) error {
		e, ok := event.(events.AttachmentUploaded)
		if !ok {
			return nil
		}

		// 1. Persist attachment record to database
		_, err := repo.CreateAttachment(ctx, repository.CreateAttachmentParams{
			LeadServiceID:  e.LeadServiceID,
			OrganizationID: e.TenantID,
			FileKey:        e.FileKey,
			FileName:       e.FileName,
			ContentType:    e.ContentType,
			SizeBytes:      e.SizeBytes,
			UploadedBy:     nil, // webhook uploads are system/anonymous
		})
		if err != nil {
			log.Error("failed to persist attachment record", "error", err, "leadServiceId", e.LeadServiceID)
			// Don't return error - continue with photo analysis
		}

		// 2. Trigger photo analysis for images
		if !isImageContentType(e.ContentType) {
			return nil
		}
		if batcher == nil {
			log.Warn("photo analysis batcher not configured")
			return nil
		}

		// Terminal check: don't analyze photos for terminal services
		service, err := repo.GetLeadServiceByID(ctx, e.LeadServiceID, e.TenantID)
		if err != nil {
			log.Error("photo batcher: failed to load service", "error", err, "serviceId", e.LeadServiceID)
			return nil
		}
		if domain.IsTerminal(service.Status, service.PipelineStage) {
			log.Info("photo batcher: skipping terminal service", "serviceId", e.LeadServiceID)
			return nil
		}

		batcher.OnImageUploaded(e.LeadID, e.LeadServiceID, e.TenantID)
		return nil
	}))
}

type buildHandlersDeps struct {
	MgmtSvc       *management.Service
	NotesSvc      *notes.Service
	Gatekeeper    *agent.Gatekeeper
	CallLogger    *agent.CallLogger
	SSEService    *sse.Service
	EventBus      events.Bus
	Repo          repository.LeadsRepository
	StorageSvc    storage.StorageService
	Config        *config.Config
	Validator     *validator.Validator
	PhotoAnalyzer *agent.PhotoAnalyzer
}

func buildHandlers(deps buildHandlersDeps) (*handler.Handler, *handler.AttachmentsHandler, *handler.PhotoAnalysisHandler) {
	notesHandler := handler.NewNotesHandler(deps.NotesSvc, deps.Repo, deps.EventBus, deps.Validator)
	attachmentsHandler := handler.NewAttachmentsHandler(deps.Repo, deps.EventBus, deps.StorageSvc, deps.Config.GetMinioBucketLeadServiceAttachments(), deps.Validator)
	photoAnalysisHandler := handler.NewPhotoAnalysisHandler(deps.PhotoAnalyzer, deps.Repo, deps.StorageSvc, deps.Config.GetMinioBucketLeadServiceAttachments(), deps.SSEService, deps.Validator)
	h := handler.New(handler.HandlerDeps{
		Mgmt:         deps.MgmtSvc,
		NotesHandler: notesHandler,
		Gatekeeper:   deps.Gatekeeper,
		CallLogger:   deps.CallLogger,
		SSE:          deps.SSEService,
		EventBus:     deps.EventBus,
		Repo:         deps.Repo,
		Validator:    deps.Validator,
	})

	return h, attachmentsHandler, photoAnalysisHandler
}

// Name returns the module identifier.
func (m *Module) Name() string {
	return "RAC_leads"
}

// ManagementService returns the lead management service for external use.
func (m *Module) ManagementService() *management.Service {
	return m.management
}

// NotesService returns the lead notes service for external use.
func (m *Module) NotesService() *notes.Service {
	return m.notes
}

// CallLogger returns the call logger agent for external use.
func (m *Module) CallLogger() *agent.CallLogger {
	return m.callLogger
}

// PhotoAnalyzer returns the photo analyzer agent for external use.
func (m *Module) PhotoAnalyzer() *agent.PhotoAnalyzer {
	return m.photoAnalyzer
}

// SSE returns the SSE service for external use.
func (m *Module) SSE() *sse.Service {
	return m.sse
}

// Repository returns the RAC_leads repository for external use.
func (m *Module) Repository() repository.LeadsRepository {
	return m.repo
}

// SetAppointmentBooker sets the appointment booker on the CallLogger.
// This is called after module initialization to break circular dependencies.
func (m *Module) SetAppointmentBooker(booker ports.AppointmentBooker) {
	m.callLogger.SetAppointmentBooker(booker)
}

// SetPublicViewers injects quote and appointment viewers for the public portal.
func (m *Module) SetPublicViewers(quoteViewer ports.QuotePublicViewer, apptViewer ports.AppointmentPublicViewer, slotViewer ports.AppointmentSlotProvider) {
	if m.publicHandler == nil {
		return
	}
	m.publicHandler.SetPublicViewers(quoteViewer, apptViewer, slotViewer)
}

// SetPublicOrgViewer injects organization contact info for the public portal.
func (m *Module) SetPublicOrgViewer(orgViewer ports.OrganizationPublicViewer) {
	if m.publicHandler == nil {
		return
	}
	m.publicHandler.SetPublicOrgViewer(orgViewer)
}

// SetEnergyLabelEnricher sets the energy label enricher on the management service.
// This is called after module initialization to break circular dependencies.
func (m *Module) SetEnergyLabelEnricher(enricher ports.EnergyLabelEnricher) {
	m.management.SetEnergyLabelEnricher(enricher)
}

// SetLeadEnricher sets the lead enrichment provider.
func (m *Module) SetLeadEnricher(enricher ports.LeadEnricher) {
	m.management.SetLeadEnricher(enricher)
}

// SetLeadScorer sets the scoring service for lead updates.
func (m *Module) SetLeadScorer(scorer *scoring.Service) {
	m.management.SetLeadScorer(scorer)
	m.scorer = scorer
}

// SetCatalogReader sets the catalog reader on the Estimator agent.
// This is called after module initialization to break circular dependencies.
func (m *Module) SetCatalogReader(cr ports.CatalogReader) {
	m.estimator.SetCatalogReader(cr)
	m.quoteGenerator.SetCatalogReader(cr)
}

// SetQuoteDrafter sets the quote drafter on the Estimator agent.
// This is called after module initialization to break circular dependencies.
func (m *Module) SetQuoteDrafter(qd ports.QuoteDrafter) {
	m.estimator.SetQuoteDrafter(qd)
	m.quoteGenerator.SetQuoteDrafter(qd)
}

// SetPartnerOfferCreator sets the partner offer creator on the Dispatcher agent.
// This is called after module initialization to break circular dependencies.
func (m *Module) SetPartnerOfferCreator(poc ports.PartnerOfferCreator) {
	m.dispatcher.SetOfferCreator(poc)
}

// GenerateQuoteFromPrompt runs the QuoteGenerator agent with a user prompt.
func (m *Module) GenerateQuoteFromPrompt(ctx context.Context, leadID, serviceID, tenantID uuid.UUID, prompt string, existingQuoteID *uuid.UUID) (*agent.GenerateResult, error) {
	return m.quoteGenerator.Generate(ctx, leadID, serviceID, tenantID, prompt, existingQuoteID)
}

// RegisterRoutes mounts RAC_leads routes on the provided router context.
func (m *Module) RegisterRoutes(ctx *apphttp.RouterContext) {
	// All RAC_leads routes require authentication
	leadsGroup := ctx.Protected.Group("/leads")
	m.handler.RegisterRoutes(leadsGroup)

	// Attachment routes: /RAC_leads/:id/services/:serviceId/attachments
	attachmentsGroup := leadsGroup.Group("/:id/services/:serviceId/attachments")
	m.attachmentsHandler.RegisterRoutes(attachmentsGroup)

	// Photo analysis routes: /RAC_leads/:id/services/:serviceId/...
	photoAnalysisGroup := leadsGroup.Group("/:id/services/:serviceId")
	m.photoAnalysisHandler.RegisterRoutes(photoAnalysisGroup)

	// SSE endpoint for real-time notifications (user-specific)
	ctx.Protected.GET("/events", m.sseHandler())

	// Public lead portal routes (no auth middleware)
	publicGroup := ctx.V1.Group("/public/leads")
	m.publicHandler.RegisterRoutes(publicGroup)
}

// sseHandler returns the SSE handler with user ID extraction
func (m *Module) sseHandler() func(c *gin.Context) {
	return m.sse.Handler(
		func(c *gin.Context) (uuid.UUID, bool) {
			id := httpkit.GetIdentity(c)
			if !id.IsAuthenticated() {
				return uuid.UUID{}, false
			}
			return id.UserID(), true
		},
		func(c *gin.Context) (uuid.UUID, bool) {
			id := httpkit.GetIdentity(c)
			if !id.IsAuthenticated() {
				return uuid.UUID{}, false
			}
			tenantID := id.TenantID()
			if tenantID == nil {
				return uuid.UUID{}, false
			}
			return *tenantID, true
		},
	)
}

// Compile-time check that Module implements http.Module
var _ apphttp.Module = (*Module)(nil)
</file>

<file path="cmd/api/main.go">
package main

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"portal_final_backend/internal/adapters"
	"portal_final_backend/internal/adapters/storage"
	"portal_final_backend/internal/appointments"
	"portal_final_backend/internal/auth"
	"portal_final_backend/internal/catalog"
	"portal_final_backend/internal/email"
	"portal_final_backend/internal/energylabel"
	"portal_final_backend/internal/events"
	"portal_final_backend/internal/exports"
	apphttp "portal_final_backend/internal/http"
	"portal_final_backend/internal/http/router"
	"portal_final_backend/internal/identity"
	"portal_final_backend/internal/leadenrichment"
	"portal_final_backend/internal/leads"
	"portal_final_backend/internal/maps"
	"portal_final_backend/internal/notification"
	"portal_final_backend/internal/partners"
	"portal_final_backend/internal/pdf"
	"portal_final_backend/internal/quotes"
	"portal_final_backend/internal/scheduler"
	"portal_final_backend/internal/services"
	"portal_final_backend/internal/webhook"
	"portal_final_backend/internal/whatsapp"
	"portal_final_backend/platform/config"
	"portal_final_backend/platform/db"
	"portal_final_backend/platform/logger"
	"portal_final_backend/platform/validator"

	"github.com/jackc/pgx/v5/pgxpool"
)

const storageBucketEnsureErrPrefix = "failed to ensure storage bucket exists: "
const storageBucketEnsureErrMsg = "failed to ensure storage bucket exists"

// ensureBucket wraps the retry logic for verifying a MinIO bucket exists.
func ensureBucket(ctx context.Context, log *logger.Logger, storageSvc storage.StorageService, name, bucket string) {
	if err := withRetry(ctx, log, "ensure "+name+" bucket", 5, 2*time.Second, func() error {
		return storageSvc.EnsureBucketExists(ctx, bucket)
	}); err != nil {
		log.Error(storageBucketEnsureErrMsg, "error", err, "bucket", bucket)
		panic(storageBucketEnsureErrPrefix + err.Error())
	}
}

func main() {
	cfg, err := config.Load()
	if err != nil {
		panic("failed to load config: " + err.Error())
	}

	// Initialize structured logger
	log := logger.New(cfg.Env)
	log.Info("starting server", "env", cfg.Env, "addr", cfg.HTTPAddr)

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	// ========================================================================
	// Infrastructure Layer
	// ========================================================================

	if err := withRetry(ctx, log, "database migrations", 5, 2*time.Second, func() error {
		return db.RunMigrations(ctx, cfg, "migrations")
	}); err != nil {
		log.Error("failed to run database migrations", "error", err)
		panic("failed to run database migrations: " + err.Error())
	}
	log.Info("database migrations complete")

	var pool *pgxpool.Pool
	if err := withRetry(ctx, log, "database connection", 5, 2*time.Second, func() error {
		p, err := db.NewPool(ctx, cfg)
		if err != nil {
			return err
		}
		pool = p
		return nil
	}); err != nil {
		log.Error("failed to connect to database", "error", err)
		panic("failed to connect to database: " + err.Error())
	}
	defer pool.Close()
	log.Info("database connection established")

	// Event bus for decoupled communication between modules
	eventBus := events.NewInMemoryBus(log)

	reminderScheduler, closeScheduler := initReminderScheduler(cfg, log)
	if closeScheduler != nil {
		defer closeScheduler()
	}

	sender, err := email.NewSender(cfg)
	if err != nil {
		log.Error("failed to initialize email sender", "error", err)
		panic("failed to initialize email sender: " + err.Error())
	}

	// Shared validator instance for dependency injection
	val := validator.New()

	// Storage service for file uploads (MinIO)
	storageSvc, err := storage.NewMinIOService(cfg)
	if err != nil {
		log.Error("failed to initialize storage service", "error", err)
		panic("failed to initialize storage service: " + err.Error())
	}
	ensureBucket(ctx, log, storageSvc, "lead-service-attachments", cfg.GetMinioBucketLeadServiceAttachments())
	ensureBucket(ctx, log, storageSvc, "catalog-assets", cfg.GetMinioBucketCatalogAssets())
	ensureBucket(ctx, log, storageSvc, "partner-logos", cfg.GetMinioBucketPartnerLogos())
	ensureBucket(ctx, log, storageSvc, "organization-logos", cfg.GetMinioBucketOrganizationLogos())
	ensureBucket(ctx, log, storageSvc, "quote-pdfs", cfg.GetMinioBucketQuotePDFs())
	ensureBucket(ctx, log, storageSvc, "quote-attachments", cfg.GetMinioBucketQuoteAttachments())
	log.Info(
		"storage service initialized",
		"leadAttachmentsBucket", cfg.GetMinioBucketLeadServiceAttachments(),
		"catalogAssetsBucket", cfg.GetMinioBucketCatalogAssets(),
		"partnerLogosBucket", cfg.GetMinioBucketPartnerLogos(),
		"organizationLogosBucket", cfg.GetMinioBucketOrganizationLogos(),
		"quotePDFsBucket", cfg.GetMinioBucketQuotePDFs(),
		"quoteAttachmentsBucket", cfg.GetMinioBucketQuoteAttachments(),
	)

	// Gotenberg PDF generator
	if cfg.IsGotenbergEnabled() {
		pdf.Init(cfg.GetGotenbergURL(), cfg.GetGotenbergUsername(), cfg.GetGotenbergPassword())
		log.Info("gotenberg PDF generator initialized", "url", cfg.GetGotenbergURL())
	}

	// ========================================================================
	// Domain Modules (Composition Root)
	// ========================================================================

	// Notification module subscribes to domain events (not HTTP-facing)
	notificationModule := notification.New(sender, cfg, log)
	notificationModule.RegisterHandlers(eventBus)
	whatsappClient := whatsapp.NewClient(cfg, log)
	notificationModule.SetWhatsAppSender(whatsappClient)

	// Initialize domain modules
	identityModule := identity.NewModule(pool, eventBus, storageSvc, cfg.GetMinioBucketOrganizationLogos(), val, whatsappClient)
	notificationModule.SetOrganizationSettingsReader(identityModule.Service())
	authModule := auth.NewModule(pool, identityModule.Service(), cfg, eventBus, log, val)
	leadsModule, err := leads.NewModule(pool, eventBus, storageSvc, val, cfg, log)
	if err != nil {
		log.Error("failed to initialize leads module", "error", err)
		panic("failed to initialize leads module: " + err.Error())
	}

	// Share SSE service with notification module so quote events reach agents
	notificationModule.SetSSE(leadsModule.SSE())
	leadAssigner := adapters.NewAppointmentsLeadAssigner(leadsModule.ManagementService())
	appointmentsModule := appointments.NewModule(pool, val, leadAssigner, sender, eventBus, reminderScheduler)
	appointmentsModule.SetSSE(leadsModule.SSE())

	// Set appointment booker on leads module (breaks circular dependency)
	appointmentBooker := adapters.NewAppointmentsAdapter(appointmentsModule.Service)
	leadsModule.SetAppointmentBooker(appointmentBooker)

	// Energy label module for lead enrichment
	energyLabelModule := energylabel.NewModule(cfg, log)
	if energyLabelModule.IsEnabled() {
		energyLabelEnricher := adapters.NewEnergyLabelAdapter(energyLabelModule.Service())
		leadsModule.SetEnergyLabelEnricher(energyLabelEnricher)
	}

	// Lead enrichment module for PDOK/CBS signals
	leadEnrichmentModule := leadenrichment.NewModule(log)
	leadEnricher := adapters.NewLeadEnrichmentAdapter(leadEnrichmentModule.Service())
	leadsModule.SetLeadEnricher(leadEnricher)

	mapsModule := maps.NewModule(log)
	servicesModule := services.NewModule(pool, val, log)
	servicesModule.RegisterHandlers(eventBus)
	catalogModule := catalog.NewModule(pool, storageSvc, cfg.GetMinioBucketCatalogAssets(), val, cfg, log)
	catalogModule.RegisterHandlers(eventBus)
	partnersModule := partners.NewModule(pool, eventBus, storageSvc, cfg.GetMinioBucketPartnerLogos(), val)
	quotesModule := quotes.NewModule(pool, eventBus, val)

	// Wire public viewers for lead portal (quotes + appointments)
	quotePublicViewer := adapters.NewQuotePublicAdapter(quotesModule.Service())
	appointmentPublicViewer := adapters.NewAppointmentPublicAdapter(appointmentsModule.Service)
	appointmentSlotViewer := adapters.NewAppointmentSlotAdapter(appointmentsModule.Service)
	leadsModule.SetPublicViewers(quotePublicViewer, appointmentPublicViewer, appointmentSlotViewer)

	orgPublicViewer := adapters.NewOrganizationPublicAdapter(identityModule.Service())
	leadsModule.SetPublicOrgViewer(orgPublicViewer)

	offerAdapter := adapters.NewPartnerOfferAdapter(partnersModule.Service())
	leadsModule.SetPartnerOfferCreator(offerAdapter)

	offerSummaryAdapter := adapters.NewOfferSummaryGeneratorAdapter(leadsModule.OfferSummaryGenerator())
	partnersModule.Service().SetOfferSummaryGenerator(offerSummaryAdapter)

	// Share SSE service with quotes module so public viewers get real-time updates
	quotesModule.SetSSE(leadsModule.SSE())

	// Inject storage for PDF download endpoints
	quotesModule.SetStorageForPDF(storageSvc, cfg.GetMinioBucketQuotePDFs())

	// Inject bucket for manual quote attachment uploads
	quotesModule.SetAttachmentBucket(cfg.GetMinioBucketQuoteAttachments())

	// Inject catalog bucket for attachment preview (catalog-sourced docs)
	quotesModule.SetCatalogBucket(cfg.GetMinioBucketCatalogAssets())

	// Wire timeline integration: quotes  leads timeline
	quotesTimeline := adapters.NewQuotesTimelineWriter(leadsModule.Repository())
	quotesModule.Service().SetTimelineWriter(quotesTimeline)

	// Wire contact reader: quotes  leads + identity + auth (for email enrichment)
	quotesContacts := adapters.NewQuotesContactReader(leadsModule.Repository(), identityModule.Service(), authModule.Repository())
	quotesModule.Service().SetQuoteContactReader(quotesContacts)

	// Wire org settings reader: quotes  identity settings (for quote defaults)
	orgSettingsAdapter := adapters.NewOrgSettingsAdapter(identityModule.Service())
	quotesModule.Service().SetOrgSettingsReader(orgSettingsAdapter)

	// Wire quote acceptance processor: PDF generation + upload + emails
	quotePDFProcessor := adapters.NewQuoteAcceptanceProcessor(quotesModule.Repository(), identityModule.Service(), quotesContacts, storageSvc, cfg, identityModule.Service())
	notificationModule.SetQuoteAcceptanceProcessor(quotePDFProcessor)
	quotesModule.SetPDFGenerator(quotePDFProcessor)

	// Wire quote activity writer so notification handlers persist activity history
	quoteActivityWriter := adapters.NewQuoteActivityWriter(quotesModule.Repository())
	notificationModule.SetQuoteActivityWriter(quoteActivityWriter)

	// Wire partner-offer timeline writer so offer events create lead timeline entries
	offerTimelineWriter := adapters.NewPartnerOffersTimelineWriter(leadsModule.Repository())
	notificationModule.SetOfferTimelineWriter(offerTimelineWriter)

	// Wire lead timeline writer for generic lead events (e.g., WhatsApp sent)
	leadTimelineWriter := adapters.NewLeadTimelineWriter(leadsModule.Repository())
	notificationModule.SetLeadTimelineWriter(leadTimelineWriter)

	// Anti-Corruption Layer: Create adapter for cross-domain communication
	// This ensures leads module only depends on its own AgentProvider interface
	_ = adapters.NewAuthAgentProvider(authModule.Service())

	// Wire catalog reader: leads  catalog (for hydrating product search results)
	catalogReader := adapters.NewCatalogProductReader(catalogModule.Repository())
	leadsModule.SetCatalogReader(catalogReader)

	// Wire quote drafter: leads  quotes (for AI-drafted quotes)
	quotesDrafter := adapters.NewQuotesDraftWriter(quotesModule.Service())
	leadsModule.SetQuoteDrafter(quotesDrafter)

	// Wire prompt-based quote generator: quotes  leads (for /quotes/generate endpoint)
	quoteGenAdapter := adapters.NewQuoteGeneratorAdapter(leadsModule)
	quotesModule.Service().SetQuotePromptGenerator(quoteGenAdapter)

	// Webhook module for external form capture
	webhookModule := webhook.NewModule(pool, leadsModule.ManagementService(), storageSvc, cfg.GetMinioBucketLeadServiceAttachments(), eventBus, val, log)

	// Exports module for Google Ads conversions
	exportsModule := exports.NewModule(pool, val)

	// ========================================================================
	// HTTP Layer
	// ========================================================================

	app := &apphttp.App{
		Config:   cfg,
		Logger:   log,
		Health:   db.NewPoolAdapter(pool),
		EventBus: eventBus,
		Modules: []apphttp.Module{
			authModule,
			identityModule,
			leadsModule,
			mapsModule,
			servicesModule,
			catalogModule,
			appointmentsModule,
			partnersModule,
			quotesModule,
			webhookModule,
			exportsModule,
		},
	}

	engine := router.New(app)

	srvErr := make(chan error, 1)
	go func() {
		log.Info("server listening", "addr", cfg.HTTPAddr)
		srvErr <- engine.Run(cfg.HTTPAddr)
	}()

	select {
	case <-ctx.Done():
		log.Info("shutdown signal received, gracefully shutting down")
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		_ = shutdownCtx
	case err := <-srvErr:
		if err != nil {
			log.Error("server error", "error", err)
			panic("server error: " + err.Error())
		}
	}
}

func initReminderScheduler(cfg config.SchedulerConfig, log *logger.Logger) (scheduler.ReminderScheduler, func()) {
	if cfg.GetRedisURL() == "" {
		log.Warn("REDIS_URL not configured; appointment reminders disabled")
		return nil, nil
	}

	reminderClient, err := scheduler.NewClient(cfg)
	if err != nil {
		log.Error("failed to initialize reminder scheduler client", "error", err)
		return nil, nil
	}

	return reminderClient, func() {
		_ = reminderClient.Close()
	}
}

func withRetry(ctx context.Context, log *logger.Logger, name string, attempts int, baseDelay time.Duration, fn func() error) error {
	if attempts < 1 {
		return fmt.Errorf("%s: invalid retry attempts", name)
	}

	var lastErr error
	for attempt := 1; attempt <= attempts; attempt++ {
		if ctx.Err() != nil {
			return ctx.Err()
		}
		if err := fn(); err == nil {
			return nil
		} else {
			lastErr = err
			log.Warn("retryable operation failed", "operation", name, "attempt", attempt, "error", err)
		}

		if attempt < attempts {
			delay := time.Duration(attempt*attempt) * baseDelay
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(delay):
			}
		}
	}

	return errors.New(name + ": " + lastErr.Error())
}
</file>

<file path="internal/leads/agent/tools.go">
package agent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"math"
	"sort"
	"strings"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/adk/tool"
	"google.golang.org/adk/tool/functiontool"

	"portal_final_backend/internal/events"
	"portal_final_backend/internal/leads/domain"
	"portal_final_backend/internal/leads/ports"
	"portal_final_backend/internal/leads/repository"
	"portal_final_backend/internal/leads/scoring"
	"portal_final_backend/platform/ai/embeddings"
	"portal_final_backend/platform/phone"
	"portal_final_backend/platform/qdrant"
)

const (
	invalidLeadIDMessage        = "Invalid lead ID"
	invalidLeadServiceIDMessage = "Invalid lead service ID"
	missingTenantContextMessage = "Missing tenant context"
	missingLeadContextMessage   = "Missing lead context"
	missingLeadContextError     = "missing lead context"
	leadNotFoundMessage         = "Lead not found"
	leadServiceNotFoundMessage  = "Lead service not found"
	invalidFieldFormat          = "invalid %s"
)

// normalizeUrgencyLevel converts various urgency level formats to the required values: High, Medium, Low
func normalizeUrgencyLevel(level string) (string, error) {
	normalized := strings.ToLower(strings.TrimSpace(level))

	switch normalized {
	case "high", "hoog", "urgent", "spoed", "spoedeisend", "critical":
		return "High", nil
	case "medium", "mid", "moderate", "matig", "gemiddeld", "normal":
		return "Medium", nil
	case "low", "laag", "non-urgent", "niet-urgent", "minor":
		return "Low", nil
	default:
		// If unrecognized, default to Medium but log it
		log.Printf("Unrecognized urgency level '%s', defaulting to Medium", level)
		return "Medium", nil
	}
}

// normalizeLeadQuality converts various lead quality formats to the required values: Junk, Low, Potential, High, Urgent
func normalizeLeadQuality(quality string) string {
	normalized := strings.ToLower(strings.TrimSpace(quality))

	switch normalized {
	case "junk", "spam", "rommel", "onzin", "fake":
		return "Junk"
	case "low", "laag":
		return "Low"
	case "potential", "potentieel", "medium", "gemiddeld", "moderate", "mid":
		return "Potential"
	case "high", "hoog", "good", "goed":
		return "High"
	case "urgent", "spoed", "critical", "kritiek":
		return "Urgent"
	default:
		log.Printf("Unrecognized lead quality '%s', defaulting to Potential", quality)
		return "Potential"
	}
}

// normalizeRecommendedAction converts various action formats to valid values: Reject, RequestInfo, ScheduleSurvey, CallImmediately
func normalizeRecommendedAction(action string) string {
	normalized := strings.ToLower(strings.TrimSpace(action))

	// Check for exact matches first
	switch normalized {
	case "reject", "afwijzen", "weigeren":
		return "Reject"
	case "requestinfo", "request_info", "request info":
		return "RequestInfo"
	case "schedulesurvey", "schedule_survey", "schedule survey", "survey", "opname", "inmeten":
		return "ScheduleSurvey"
	case "callimmediately", "call_immediately", "call immediately", "call", "bellen":
		return "CallImmediately"
	}

	// Check for partial matches (LLM often sends descriptive text)
	if strings.Contains(normalized, "reject") || strings.Contains(normalized, "spam") || strings.Contains(normalized, "junk") {
		return "Reject"
	}
	if strings.Contains(normalized, "call") || strings.Contains(normalized, "bel") || strings.Contains(normalized, "phone") {
		return "CallImmediately"
	}
	if strings.Contains(normalized, "survey") || strings.Contains(normalized, "opname") || strings.Contains(normalized, "inmeten") || strings.Contains(normalized, "schedule") {
		return "ScheduleSurvey"
	}
	// Default: anything about info, contact, nurture, clarification  RequestInfo
	if strings.Contains(normalized, "info") || strings.Contains(normalized, "contact") ||
		strings.Contains(normalized, "nurtur") || strings.Contains(normalized, "clarif") ||
		strings.Contains(normalized, "request") || strings.Contains(normalized, "more") ||
		strings.Contains(normalized, "review") {
		return "RequestInfo"
	}

	log.Printf("Unrecognized recommended action '%s', defaulting to RequestInfo", action)
	return "RequestInfo"
}

func normalizeConsumerRole(role string) (string, error) {
	normalized := strings.ToLower(strings.TrimSpace(role))
	switch normalized {
	case "owner":
		return "Owner", nil
	case "tenant":
		return "Tenant", nil
	case "landlord":
		return "Landlord", nil
	default:
		return "", fmt.Errorf("invalid consumer role")
	}
}

// ToolDependencies contains the dependencies needed by tools
type ToolDependencies struct {
	Repo                 repository.LeadsRepository
	Scorer               *scoring.Service
	EventBus             events.Bus
	EmbeddingClient      *embeddings.Client
	QdrantClient         *qdrant.Client
	CatalogQdrantClient  *qdrant.Client
	CatalogReader        ports.CatalogReader // optional: hydrate search results from DB
	QuoteDrafter         ports.QuoteDrafter  // optional: draft quotes from agent
	OfferCreator         ports.PartnerOfferCreator
	mu                   sync.RWMutex
	tenantID             *uuid.UUID
	leadID               *uuid.UUID
	serviceID            *uuid.UUID
	actorType            string
	actorName            string
	existingQuoteID      *uuid.UUID              // If set, DraftQuote updates this quote instead of creating new
	lastAnalysisMetadata map[string]any          // Populated by SaveAnalysis for use in stage_change events
	saveAnalysisCalled   bool                    // Track if SaveAnalysis was called
	saveEstimationCalled bool                    // Track if SaveEstimation was called
	stageUpdateCalled    bool                    // Track if UpdatePipelineStage was called
	lastStageUpdated     string                  // Track last pipeline stage written
	draftQuoteCalled     bool                    // Track if DraftQuote was called
	offerCreated         bool                    // Track if CreatePartnerOffer was called
	lastDraftResult      *ports.DraftQuoteResult // Captured by handleDraftQuote for generate endpoint
}

func (d *ToolDependencies) SetTenantID(tenantID uuid.UUID) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.tenantID = &tenantID
}

func (d *ToolDependencies) GetTenantID() (*uuid.UUID, bool) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	if d.tenantID == nil {
		return nil, false
	}
	return d.tenantID, true
}

func (d *ToolDependencies) SetLeadContext(leadID, serviceID uuid.UUID) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.leadID = &leadID
	d.serviceID = &serviceID
}

func (d *ToolDependencies) GetLeadContext() (uuid.UUID, uuid.UUID, bool) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	if d.leadID == nil || d.serviceID == nil {
		return uuid.UUID{}, uuid.UUID{}, false
	}
	return *d.leadID, *d.serviceID, true
}

func (d *ToolDependencies) SetActor(actorType, actorName string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.actorType = actorType
	d.actorName = actorName
}

func (d *ToolDependencies) GetActor() (string, string) {
	d.mu.RLock()
	defer d.mu.RUnlock()
	if d.actorType == "" {
		return "AI", "Agent"
	}
	return d.actorType, d.actorName
}

// SetLastAnalysisMetadata stores the analysis metadata for inclusion in subsequent events
func (d *ToolDependencies) SetLastAnalysisMetadata(metadata map[string]any) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.lastAnalysisMetadata = metadata
}

// GetLastAnalysisMetadata retrieves the analysis metadata saved by SaveAnalysis
func (d *ToolDependencies) GetLastAnalysisMetadata() map[string]any {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.lastAnalysisMetadata
}

// MarkSaveAnalysisCalled marks that SaveAnalysis tool was called
func (d *ToolDependencies) MarkSaveAnalysisCalled() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.saveAnalysisCalled = true
	log.Printf("ToolDependencies: MarkSaveAnalysisCalled() - set to true")
}

// MarkSaveEstimationCalled marks that SaveEstimation tool was called.
func (d *ToolDependencies) MarkSaveEstimationCalled() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.saveEstimationCalled = true
}

// MarkStageUpdateCalled marks that UpdatePipelineStage tool was called
func (d *ToolDependencies) MarkStageUpdateCalled(stage string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.stageUpdateCalled = true
	d.lastStageUpdated = stage
}

// MarkDraftQuoteCalled marks that DraftQuote tool was called.
func (d *ToolDependencies) MarkDraftQuoteCalled() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.draftQuoteCalled = true
}

// MarkOfferCreated marks that CreatePartnerOffer tool was called.
func (d *ToolDependencies) MarkOfferCreated() {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.offerCreated = true
}

// WasSaveAnalysisCalled returns whether SaveAnalysis was called
func (d *ToolDependencies) WasSaveAnalysisCalled() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.saveAnalysisCalled
}

// WasSaveEstimationCalled returns whether SaveEstimation was called.
func (d *ToolDependencies) WasSaveEstimationCalled() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.saveEstimationCalled
}

// WasStageUpdateCalled returns whether UpdatePipelineStage was called
func (d *ToolDependencies) WasStageUpdateCalled() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.stageUpdateCalled
}

// LastStageUpdated returns the last stage recorded by UpdatePipelineStage.
func (d *ToolDependencies) LastStageUpdated() string {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.lastStageUpdated
}

// WasDraftQuoteCalled returns whether DraftQuote was called.
func (d *ToolDependencies) WasDraftQuoteCalled() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.draftQuoteCalled
}

// WasOfferCreated returns whether CreatePartnerOffer was called.
func (d *ToolDependencies) WasOfferCreated() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.offerCreated
}

// SetExistingQuoteID sets the existing quote ID for update-instead-of-create behavior.
func (d *ToolDependencies) SetExistingQuoteID(id *uuid.UUID) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.existingQuoteID = id
}

// GetExistingQuoteID returns the existing quote ID if set.
func (d *ToolDependencies) GetExistingQuoteID() *uuid.UUID {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.existingQuoteID
}

// ResetToolCallTracking resets the tool call tracking flags
func (d *ToolDependencies) ResetToolCallTracking() {
	d.mu.Lock()
	defer d.mu.Unlock()
	log.Printf("ToolDependencies: ResetToolCallTracking() - resetting flags (was saveAnalysisCalled=%v)", d.saveAnalysisCalled)
	d.saveAnalysisCalled = false
	d.saveEstimationCalled = false
	d.stageUpdateCalled = false
	d.lastStageUpdated = ""
	d.draftQuoteCalled = false
	d.offerCreated = false
	d.lastAnalysisMetadata = nil
	d.lastDraftResult = nil
	d.existingQuoteID = nil
}

// SetLastDraftResult stores the last DraftQuoteResult for retrieval by callers.
func (d *ToolDependencies) SetLastDraftResult(result *ports.DraftQuoteResult) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.lastDraftResult = result
}

// GetLastDraftResult returns the last DraftQuoteResult (set by handleDraftQuote).
func (d *ToolDependencies) GetLastDraftResult() *ports.DraftQuoteResult {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.lastDraftResult
}

// IsProductSearchEnabled returns true if both embedding and Qdrant clients are configured.
func (d *ToolDependencies) IsProductSearchEnabled() bool {
	return d.EmbeddingClient != nil && (d.CatalogQdrantClient != nil || d.QdrantClient != nil)
}

func parseUUID(value string, invalidMessage string) (uuid.UUID, error) {
	parsed, err := uuid.Parse(value)
	if err != nil {
		return uuid.UUID{}, errors.New(invalidMessage)
	}
	return parsed, nil
}

func getTenantID(deps *ToolDependencies) (uuid.UUID, error) {
	tenantID, ok := deps.GetTenantID()
	if !ok {
		return uuid.UUID{}, fmt.Errorf("missing tenant context")
	}
	return *tenantID, nil
}

func getLeadContext(deps *ToolDependencies) (uuid.UUID, uuid.UUID, error) {
	leadID, serviceID, ok := deps.GetLeadContext()
	if !ok {
		return uuid.UUID{}, uuid.UUID{}, errors.New(missingLeadContextError)
	}
	return leadID, serviceID, nil
}

func normalizeContactChannel(channel string) (string, error) {
	clean := strings.TrimSpace(channel)
	normalized := strings.ToLower(clean)

	// WhatsApp variations
	if strings.Contains(normalized, "whatsapp") || normalized == "wa" {
		return "WhatsApp", nil
	}

	// Email variations
	if strings.Contains(normalized, "email") || strings.Contains(normalized, "e-mail") || normalized == "mail" {
		return "Email", nil
	}

	// Phone/call variations - map to WhatsApp since it's our phone-based channel
	if strings.Contains(normalized, "phone") || strings.Contains(normalized, "telefoon") ||
		strings.Contains(normalized, "call") || strings.Contains(normalized, "bel") ||
		normalized == "tel" || normalized == "sms" {
		return "WhatsApp", nil
	}

	// If unrecognized, default to Email and log
	log.Printf("Unrecognized contact channel '%s', defaulting to Email", channel)
	return "Email", nil
}

func resolvePreferredChannel(inputChannel string, lead repository.Lead) (string, error) {
	_, err := normalizeContactChannel(inputChannel)
	if err != nil {
		return "", err
	}
	if strings.TrimSpace(lead.ConsumerPhone) != "" {
		return "WhatsApp", nil
	}
	return "Email", nil
}

func parseLeadServiceID(value string) (uuid.UUID, error) {
	if strings.TrimSpace(value) == "" {
		return uuid.UUID{}, fmt.Errorf("missing lead service ID")
	}
	return parseUUID(value, invalidLeadServiceIDMessage)
}

func handleSaveAnalysis(ctx tool.Context, deps *ToolDependencies, input SaveAnalysisInput) (SaveAnalysisOutput, error) {
	log.Printf("handleSaveAnalysis: CALLED with leadID=%s serviceID=%s urgency=%s action=%s",
		input.LeadID, input.LeadServiceID, input.UrgencyLevel, input.RecommendedAction)

	leadID, err := parseUUID(input.LeadID, invalidLeadIDMessage)
	if err != nil {
		log.Printf("handleSaveAnalysis: FAILED - invalid leadID: %s", input.LeadID)
		return SaveAnalysisOutput{Success: false, Message: invalidLeadIDMessage}, err
	}

	tenantID, err := getTenantID(deps)
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: missingTenantContextMessage}, err
	}

	leadServiceID, err := parseLeadServiceID(input.LeadServiceID)
	if err != nil {
		message := err.Error()
		if err.Error() == invalidLeadServiceIDMessage {
			message = invalidLeadServiceIDMessage
		}
		return SaveAnalysisOutput{Success: false, Message: message}, err
	}

	// Terminal check: refuse to save analysis for terminal services
	svc, err := deps.Repo.GetLeadServiceByID(ctx, leadServiceID, tenantID)
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: leadServiceNotFoundMessage}, err
	}
	if domain.IsTerminal(svc.Status, svc.PipelineStage) {
		log.Printf("handleSaveAnalysis: REJECTED - service %s is in terminal state (status=%s, stage=%s)", leadServiceID, svc.Status, svc.PipelineStage)
		return SaveAnalysisOutput{Success: false, Message: "Cannot save analysis for a service in terminal state"}, fmt.Errorf("service %s is terminal", leadServiceID)
	}

	urgencyLevel, err := normalizeUrgencyLevel(input.UrgencyLevel)
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: err.Error()}, err
	}

	var urgencyReason *string
	if input.UrgencyReason != "" {
		urgencyReason = &input.UrgencyReason
	}

	lead, err := deps.Repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: leadNotFoundMessage}, err
	}

	channel, err := resolvePreferredChannel(input.PreferredContactChannel, lead)
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: "Invalid preferred contact channel"}, err
	}

	// Normalize lead quality to valid enum value
	leadQuality := normalizeLeadQuality(input.LeadQuality)

	// Normalize recommended action to valid enum value
	recommendedAction := normalizeRecommendedAction(input.RecommendedAction)
	log.Printf("handleSaveAnalysis: normalized recommendedAction '%s' -> '%s'", input.RecommendedAction, recommendedAction)

	_, err = deps.Repo.CreateAIAnalysis(context.Background(), repository.CreateAIAnalysisParams{
		LeadID:                  leadID,
		OrganizationID:          tenantID,
		LeadServiceID:           leadServiceID,
		UrgencyLevel:            urgencyLevel,
		UrgencyReason:           urgencyReason,
		LeadQuality:             leadQuality,
		RecommendedAction:       recommendedAction,
		MissingInformation:      input.MissingInformation,
		PreferredContactChannel: channel,
		SuggestedContactMessage: input.SuggestedContactMessage,
		Summary:                 input.Summary,
	})
	if err != nil {
		return SaveAnalysisOutput{Success: false, Message: err.Error()}, err
	}

	actorType, actorName := deps.GetActor()

	// Create comprehensive analysis timeline event for frontend rendering
	analysisSummary := input.Summary
	if analysisSummary == "" {
		analysisSummary = fmt.Sprintf("AI analyse voltooid: %s urgentie, aanbevolen actie: %s", urgencyLevel, recommendedAction)
	}
	analysisMetadata := map[string]any{
		"urgencyLevel":      urgencyLevel,
		"recommendedAction": recommendedAction,
		"leadQuality":       leadQuality,
	}
	if input.SuggestedContactMessage != "" {
		analysisMetadata["suggestedContactMessage"] = input.SuggestedContactMessage
		analysisMetadata["preferredContactChannel"] = string(channel)
	}
	if len(input.MissingInformation) > 0 {
		analysisMetadata["missingInformation"] = input.MissingInformation
	}
	_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &leadServiceID,
		OrganizationID: tenantID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      "ai",
		Title:          "Gatekeeper analyse voltooid",
		Summary:        &analysisSummary,
		Metadata:       analysisMetadata,
	})

	// Store analysis metadata for use in stage_change events
	deps.SetLastAnalysisMetadata(analysisMetadata)
	log.Printf("SaveAnalysis: stored analysis metadata for lead=%s service=%s channel=%s action=%s",
		leadID, leadServiceID, channel, recommendedAction)

	recalculateAndRecordScore(ctx, deps, leadID, leadServiceID, tenantID, actorType, actorName)

	log.Printf(
		"gatekeeper SaveAnalysis: leadId=%s serviceId=%s urgency=%s quality=%s action=%s missing=%d",
		leadID,
		leadServiceID,
		urgencyLevel,
		leadQuality,
		recommendedAction,
		len(input.MissingInformation),
	)

	deps.MarkSaveAnalysisCalled()
	return SaveAnalysisOutput{Success: true, Message: "Analysis saved successfully"}, nil
}

func recalculateAndRecordScore(ctx tool.Context, deps *ToolDependencies, leadID, leadServiceID, tenantID uuid.UUID, actorType, actorName string) {
	if deps.Scorer == nil {
		return
	}
	scoreResult, scoreErr := deps.Scorer.Recalculate(ctx, leadID, &leadServiceID, tenantID, true)
	if scoreErr != nil {
		return
	}
	_ = deps.Repo.UpdateLeadScore(ctx, leadID, tenantID, repository.UpdateLeadScoreParams{
		Score:          &scoreResult.Score,
		ScorePreAI:     &scoreResult.ScorePreAI,
		ScoreFactors:   scoreResult.FactorsJSON,
		ScoreVersion:   &scoreResult.Version,
		ScoreUpdatedAt: scoreResult.UpdatedAt,
	})

	summary := buildLeadScoreSummary(scoreResult)
	_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &leadServiceID,
		OrganizationID: tenantID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      "analysis",
		Title:          "Leadscore bijgewerkt",
		Summary:        &summary,
		Metadata: map[string]any{
			"leadScore":        scoreResult.Score,
			"leadScorePreAI":   scoreResult.ScorePreAI,
			"leadScoreVersion": scoreResult.Version,
		},
	})
}

func buildLeadScoreSummary(result *scoring.Result) string {
	return fmt.Sprintf("Leadscore %d (pre-AI %d)", result.Score, result.ScorePreAI)
}

func handleUpdateLeadServiceType(ctx tool.Context, deps *ToolDependencies, input UpdateLeadServiceTypeInput) (UpdateLeadServiceTypeOutput, error) {
	leadID, err := parseUUID(input.LeadID, invalidLeadIDMessage)
	if err != nil {
		return UpdateLeadServiceTypeOutput{Success: false, Message: invalidLeadIDMessage}, err
	}
	leadServiceID, err := parseUUID(input.LeadServiceID, invalidLeadServiceIDMessage)
	if err != nil {
		return UpdateLeadServiceTypeOutput{Success: false, Message: invalidLeadServiceIDMessage}, err
	}
	serviceType := strings.TrimSpace(input.ServiceType)
	if serviceType == "" {
		return UpdateLeadServiceTypeOutput{Success: false, Message: "Missing service type"}, fmt.Errorf("missing service type")
	}

	tenantID, err := getTenantID(deps)
	if err != nil {
		return UpdateLeadServiceTypeOutput{Success: false, Message: missingTenantContextMessage}, err
	}

	leadService, err := deps.Repo.GetLeadServiceByID(ctx, leadServiceID, tenantID)
	if err != nil {
		return UpdateLeadServiceTypeOutput{Success: false, Message: leadServiceNotFoundMessage}, err
	}
	if leadService.LeadID != leadID {
		return UpdateLeadServiceTypeOutput{Success: false, Message: "Lead service does not belong to lead"}, fmt.Errorf("lead service mismatch")
	}

	_, err = deps.Repo.UpdateLeadServiceType(ctx, leadServiceID, tenantID, serviceType)
	if err != nil {
		if errors.Is(err, repository.ErrServiceTypeNotFound) {
			return UpdateLeadServiceTypeOutput{Success: false, Message: "Service type not found or inactive"}, nil
		}
		return UpdateLeadServiceTypeOutput{Success: false, Message: "Failed to update service type"}, err
	}

	actorType, actorName := deps.GetActor()
	reasonText := strings.TrimSpace(input.Reason)
	if reasonText == "" {
		reasonText = "Diensttype aangepast"
	}
	_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      &leadServiceID,
		OrganizationID: tenantID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      "service_type_change",
		Title:          "Diensttype bijgewerkt",
		Summary:        &reasonText,
		Metadata: map[string]any{
			"oldServiceType": leadService.ServiceType,
			"newServiceType": serviceType,
			"reason":         input.Reason,
		},
	})

	log.Printf(
		"gatekeeper UpdateLeadServiceType: leadId=%s serviceId=%s from=%s to=%s",
		leadID,
		leadServiceID,
		leadService.ServiceType,
		serviceType,
	)

	return UpdateLeadServiceTypeOutput{Success: true, Message: "Service type updated"}, nil
}

// leadDetailsBuilder encapsulates field update logic for handleUpdateLeadDetails
type leadDetailsBuilder struct {
	params        repository.UpdateLeadParams
	updatedFields []string
}

func newLeadDetailsBuilder() *leadDetailsBuilder {
	return &leadDetailsBuilder{
		params:        repository.UpdateLeadParams{},
		updatedFields: make([]string, 0, 10),
	}
}

func (b *leadDetailsBuilder) setStringField(input *string, current string, fieldName string, setter func(*string)) error {
	if input == nil {
		return nil
	}
	value := strings.TrimSpace(*input)
	if value == "" {
		return fmt.Errorf(invalidFieldFormat, fieldName)
	}
	setter(&value)
	if value != current {
		b.updatedFields = append(b.updatedFields, fieldName)
	}
	return nil
}

func (b *leadDetailsBuilder) setOptionalStringField(input *string, current *string, fieldName string, setter func(*string)) error {
	if input == nil {
		return nil
	}
	value := strings.TrimSpace(*input)
	if value == "" {
		return fmt.Errorf(invalidFieldFormat, fieldName)
	}
	setter(&value)
	if current == nil || *current != value {
		b.updatedFields = append(b.updatedFields, fieldName)
	}
	return nil
}

func (b *leadDetailsBuilder) setPhoneField(input *string, current string) error {
	if input == nil {
		return nil
	}
	value := phone.NormalizeE164(strings.TrimSpace(*input))
	if value == "" {
		return fmt.Errorf("invalid phone")
	}
	b.params.ConsumerPhone = &value
	if value != current {
		b.updatedFields = append(b.updatedFields, "phone")
	}
	return nil
}

func (b *leadDetailsBuilder) setConsumerRole(input *string, current string) error {
	if input == nil {
		return nil
	}
	role, err := normalizeConsumerRole(*input)
	if err != nil {
		return fmt.Errorf("invalid consumer role")
	}
	b.params.ConsumerRole = &role
	if role != current {
		b.updatedFields = append(b.updatedFields, "consumerRole")
	}
	return nil
}

func (b *leadDetailsBuilder) setCoordinate(input *float64, current *float64, fieldName string, min, max float64, setter func(*float64)) error {
	if input == nil {
		return nil
	}
	if *input < min || *input > max {
		return fmt.Errorf(invalidFieldFormat, fieldName)
	}
	setter(input)
	if current == nil || *current != *input {
		b.updatedFields = append(b.updatedFields, fieldName)
	}
	return nil
}

func (b *leadDetailsBuilder) buildFromInput(input UpdateLeadDetailsInput, current repository.Lead) error {
	if err := b.setStringField(input.FirstName, current.ConsumerFirstName, "firstName", func(v *string) { b.params.ConsumerFirstName = v }); err != nil {
		return err
	}
	if err := b.setStringField(input.LastName, current.ConsumerLastName, "lastName", func(v *string) { b.params.ConsumerLastName = v }); err != nil {
		return err
	}
	if err := b.setPhoneField(input.Phone, current.ConsumerPhone); err != nil {
		return err
	}
	if err := b.setOptionalStringField(input.Email, current.ConsumerEmail, "email", func(v *string) { b.params.ConsumerEmail = v }); err != nil {
		return err
	}
	if err := b.setConsumerRole(input.ConsumerRole, current.ConsumerRole); err != nil {
		return err
	}
	if err := b.setStringField(input.Street, current.AddressStreet, "street", func(v *string) { b.params.AddressStreet = v }); err != nil {
		return err
	}
	if err := b.setStringField(input.HouseNumber, current.AddressHouseNumber, "houseNumber", func(v *string) { b.params.AddressHouseNumber = v }); err != nil {
		return err
	}
	if err := b.setStringField(input.ZipCode, current.AddressZipCode, "zipCode", func(v *string) { b.params.AddressZipCode = v }); err != nil {
		return err
	}
	if err := b.setStringField(input.City, current.AddressCity, "city", func(v *string) { b.params.AddressCity = v }); err != nil {
		return err
	}
	if err := b.setCoordinate(input.Latitude, current.Latitude, "latitude", -90, 90, func(v *float64) { b.params.Latitude = v }); err != nil {
		return err
	}
	if err := b.setCoordinate(input.Longitude, current.Longitude, "longitude", -180, 180, func(v *float64) { b.params.Longitude = v }); err != nil {
		return err
	}
	return nil
}

func handleUpdateLeadDetails(ctx tool.Context, deps *ToolDependencies, input UpdateLeadDetailsInput) (UpdateLeadDetailsOutput, error) {
	leadID, err := parseUUID(input.LeadID, invalidLeadIDMessage)
	if err != nil {
		return UpdateLeadDetailsOutput{Success: false, Message: invalidLeadIDMessage}, err
	}

	tenantID, err := getTenantID(deps)
	if err != nil {
		return UpdateLeadDetailsOutput{Success: false, Message: missingTenantContextMessage}, err
	}

	current, err := deps.Repo.GetByID(ctx, leadID, tenantID)
	if err != nil {
		return UpdateLeadDetailsOutput{Success: false, Message: leadNotFoundMessage}, err
	}

	builder := newLeadDetailsBuilder()
	if err := builder.buildFromInput(input, current); err != nil {
		return UpdateLeadDetailsOutput{Success: false, Message: err.Error()}, err
	}

	if len(builder.updatedFields) == 0 {
		return UpdateLeadDetailsOutput{Success: true, Message: "No updates required"}, nil
	}

	_, err = deps.Repo.Update(ctx, leadID, tenantID, builder.params)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return UpdateLeadDetailsOutput{Success: false, Message: leadNotFoundMessage}, err
		}
		return UpdateLeadDetailsOutput{Success: false, Message: "Failed to update lead"}, err
	}

	recordLeadDetailsUpdate(ctx, deps, leadID, tenantID, builder.updatedFields, input.Reason, input.Confidence)
	return UpdateLeadDetailsOutput{Success: true, Message: "Lead updated", UpdatedFields: builder.updatedFields}, nil
}

func recordLeadDetailsUpdate(ctx tool.Context, deps *ToolDependencies, leadID, tenantID uuid.UUID, updatedFields []string, reason string, confidence *float64) {
	actorType, actorName := deps.GetActor()
	reasonText := strings.TrimSpace(reason)
	if reasonText == "" {
		reasonText = "Leadgegevens bijgewerkt"
	}
	metadata := map[string]any{
		"updatedFields": updatedFields,
	}
	if confidence != nil {
		metadata["confidence"] = *confidence
	}

	var serviceID *uuid.UUID
	if _, svcID, ok := deps.GetLeadContext(); ok {
		serviceID = &svcID
	}

	_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         leadID,
		ServiceID:      serviceID,
		OrganizationID: tenantID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      "lead_update",
		Title:          "Leadgegevens bijgewerkt",
		Summary:        &reasonText,
		Metadata:       metadata,
	})

	log.Printf("gatekeeper UpdateLeadDetails: leadId=%s fields=%v reason=%s", leadID, updatedFields, reasonText)
}

// createSaveAnalysisTool creates the SaveAnalysis tool
func createSaveAnalysisTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "SaveAnalysis",
		Description: "Saves the gatekeeper triage analysis to the database. Call this ONCE after completing your full analysis. Include urgency, lead quality, recommended action, missing information, preferred contact channel, message, and summary.",
	}, func(ctx tool.Context, input SaveAnalysisInput) (SaveAnalysisOutput, error) {
		return handleSaveAnalysis(ctx, deps, input)
	})
}

// createUpdateLeadServiceTypeTool creates the UpdateLeadServiceType tool
func createUpdateLeadServiceTypeTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "UpdateLeadServiceType",
		Description: "Updates the service type for a lead service when there is a confident mismatch. The service type must match an active service type name or slug.",
	}, func(ctx tool.Context, input UpdateLeadServiceTypeInput) (UpdateLeadServiceTypeOutput, error) {
		return handleUpdateLeadServiceType(ctx, deps, input)
	})
}

func createUpdateLeadDetailsTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "UpdateLeadDetails",
		Description: "Updates lead contact or address details when you are highly confident the current data is wrong.",
	}, func(ctx tool.Context, input UpdateLeadDetailsInput) (UpdateLeadDetailsOutput, error) {
		return handleUpdateLeadDetails(ctx, deps, input)
	})
}

var validPipelineStages = map[string]bool{
	"Triage":              true,
	"Nurturing":           true,
	"Ready_For_Estimator": true,
	"Quote_Sent":          true,
	"Ready_For_Partner":   true,
	"Partner_Matching":    true,
	"Partner_Assigned":    true,
	"Manual_Intervention": true,
	"Completed":           true,
	"Lost":                true,
}

func handleUpdatePipelineStage(ctx tool.Context, deps *ToolDependencies, input UpdatePipelineStageInput) (UpdatePipelineStageOutput, error) {
	if !validPipelineStages[input.Stage] {
		return UpdatePipelineStageOutput{Success: false, Message: "Invalid pipeline stage"}, fmt.Errorf("invalid pipeline stage: %s", input.Stage)
	}

	tenantID, err := getTenantID(deps)
	if err != nil {
		return UpdatePipelineStageOutput{Success: false, Message: missingTenantContextMessage}, err
	}

	leadID, serviceID, err := getLeadContext(deps)
	if err != nil {
		return UpdatePipelineStageOutput{Success: false, Message: missingLeadContextMessage}, err
	}

	_, actorName := deps.GetActor()
	if actorName == "Dispatcher" && input.Stage == "Partner_Matching" && !deps.WasOfferCreated() {
		return UpdatePipelineStageOutput{Success: false, Message: "CreatePartnerOffer must be called before Partner_Matching"}, fmt.Errorf("offer not created")
	}

	svc, err := deps.Repo.GetLeadServiceByID(ctx, serviceID, tenantID)
	if err != nil {
		return UpdatePipelineStageOutput{Success: false, Message: leadServiceNotFoundMessage}, err
	}
	oldStage := svc.PipelineStage

	// Terminal check: refuse to update pipeline stage for terminal services
	if domain.IsTerminal(svc.Status, svc.PipelineStage) {
		log.Printf("handleUpdatePipelineStage: REJECTED - service %s is in terminal state (status=%s, stage=%s)", serviceID, svc.Status, svc.PipelineStage)
		return UpdatePipelineStageOutput{Success: false, Message: "Cannot update pipeline stage for a service in terminal state"}, fmt.Errorf("service %s is terminal", serviceID)
	}

	// Validate state combination
	if reason := domain.ValidateStateCombination(svc.Status, input.Stage); reason != "" {
		log.Printf("handleUpdatePipelineStage: invalid state combination: status=%s, newStage=%s - %s", svc.Status, input.Stage, reason)
		return UpdatePipelineStageOutput{Success: false, Message: reason}, fmt.Errorf("invalid state combination: %s", reason)
	}

	_, err = deps.Repo.UpdatePipelineStage(ctx, serviceID, tenantID, input.Stage)
	if err != nil {
		return UpdatePipelineStageOutput{Success: false, Message: "Failed to update pipeline stage"}, err
	}

	recordPipelineStageChange(ctx, deps, stageChangeParams{
		leadID:    leadID,
		serviceID: serviceID,
		tenantID:  tenantID,
		oldStage:  oldStage,
		newStage:  input.Stage,
		reason:    input.Reason,
	})
	deps.MarkStageUpdateCalled(input.Stage)
	return UpdatePipelineStageOutput{Success: true, Message: "Pipeline stage updated"}, nil
}

// stageChangeParams groups parameters for recording a pipeline stage change.
type stageChangeParams struct {
	leadID    uuid.UUID
	serviceID uuid.UUID
	tenantID  uuid.UUID
	oldStage  string
	newStage  string
	reason    string
}

func recordPipelineStageChange(ctx tool.Context, deps *ToolDependencies, p stageChangeParams) {
	actorType, actorName := deps.GetActor()
	reasonText := strings.TrimSpace(p.reason)
	var summary *string
	if reasonText != "" {
		summary = &reasonText
	}

	stageMetadata := map[string]any{
		"oldStage": p.oldStage,
		"newStage": p.newStage,
	}
	if analysisMeta := deps.GetLastAnalysisMetadata(); analysisMeta != nil {
		stageMetadata["analysis"] = analysisMeta
	}

	_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
		LeadID:         p.leadID,
		ServiceID:      &p.serviceID,
		OrganizationID: p.tenantID,
		ActorType:      actorType,
		ActorName:      actorName,
		EventType:      "stage_change",
		Title:          "Fase bijgewerkt",
		Summary:        summary,
		Metadata:       stageMetadata,
	})

	if deps.EventBus != nil {
		deps.EventBus.Publish(ctx, events.PipelineStageChanged{
			BaseEvent:     events.NewBaseEvent(),
			LeadID:        p.leadID,
			LeadServiceID: p.serviceID,
			TenantID:      p.tenantID,
			OldStage:      p.oldStage,
			NewStage:      p.newStage,
		})
	}

	logReason := reasonText
	if logReason == "" {
		logReason = "(no reason provided)"
	}
	log.Printf("gatekeeper UpdatePipelineStage: leadId=%s serviceId=%s from=%s to=%s reason=%s",
		p.leadID, p.serviceID, p.oldStage, p.newStage, logReason)
}

func createUpdatePipelineStageTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "UpdatePipelineStage",
		Description: "Updates the pipeline stage for the lead service and records a timeline event.",
	}, func(ctx tool.Context, input UpdatePipelineStageInput) (UpdatePipelineStageOutput, error) {
		return handleUpdatePipelineStage(ctx, deps, input)
	})
}

func createFindMatchingPartnersTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "FindMatchingPartners",
		Description: "Finds partner matches by service type and distance radius. Allows excluding specific partner IDs.",
	}, func(ctx tool.Context, input FindMatchingPartnersInput) (FindMatchingPartnersOutput, error) {
		tenantID, err := getTenantID(deps)
		if err != nil {
			return FindMatchingPartnersOutput{Matches: nil}, err
		}

		excludeUUIDs := make([]uuid.UUID, 0, len(input.ExcludePartnerIDs))
		for _, idStr := range input.ExcludePartnerIDs {
			if uid, err := uuid.Parse(idStr); err == nil {
				excludeUUIDs = append(excludeUUIDs, uid)
			}
		}

		leadID, serviceID, err := getLeadContext(deps)
		if err != nil {
			return FindMatchingPartnersOutput{Matches: nil}, err
		}

		matches, err := deps.Repo.FindMatchingPartners(ctx, tenantID, input.ServiceType, input.ZipCode, input.RadiusKm, excludeUUIDs)
		if err != nil {
			return FindMatchingPartnersOutput{Matches: nil}, err
		}

		actorType, actorName := deps.GetActor()
		summary := fmt.Sprintf("Found %d partner(s)", len(matches))
		_, _ = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
			LeadID:         leadID,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      actorType,
			ActorName:      actorName,
			EventType:      "partner_search",
			Title:          "Partnerzoekactie",
			Summary:        &summary,
			Metadata: map[string]any{
				"serviceType": input.ServiceType,
				"zipCode":     input.ZipCode,
				"radiusKm":    input.RadiusKm,
				"excludedIds": excludeUUIDs,
				"matches":     matches,
			},
		})

		output := make([]PartnerMatch, 0, len(matches))
		for _, match := range matches {
			output = append(output, PartnerMatch{
				PartnerID:    match.ID.String(),
				BusinessName: match.BusinessName,
				Email:        match.Email,
				DistanceKm:   match.DistanceKm,
			})
		}

		return FindMatchingPartnersOutput{Matches: output}, nil
	})
}

func resolveOfferContext(deps *ToolDependencies, partnerIDRaw string, expirationHours int) (uuid.UUID, uuid.UUID, uuid.UUID, int, string, error) {
	tenantID, err := getTenantID(deps)
	if err != nil {
		return uuid.UUID{}, uuid.UUID{}, uuid.UUID{}, 0, missingTenantContextMessage, err
	}

	_, serviceID, err := getLeadContext(deps)
	if err != nil {
		return uuid.UUID{}, uuid.UUID{}, uuid.UUID{}, 0, missingLeadContextMessage, err
	}

	partnerID, err := uuid.Parse(partnerIDRaw)
	if err != nil {
		return uuid.UUID{}, uuid.UUID{}, uuid.UUID{}, 0, "Invalid partner ID", err
	}

	hours := expirationHours
	if hours <= 0 {
		hours = 48
	}
	if hours > 168 {
		hours = 168
	}

	return tenantID, serviceID, partnerID, hours, "", nil
}

func resolveOfferPricing(ctx tool.Context, deps *ToolDependencies, serviceID, tenantID uuid.UUID) (string, int64, error) {
	totalCents, err := deps.Repo.GetLatestQuoteTotal(ctx, serviceID, tenantID)
	if err != nil {
		return "", 0, err
	}

	pricingSource := "quote"
	if totalCents <= 0 {
		pricingSource = "estimate"
	}

	return pricingSource, totalCents, nil
}

func createCreatePartnerOfferTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "CreatePartnerOffer",
		Description: "Creates a formal job offer for a specific partner. This generates the unique link they use to accept the job.",
	}, func(ctx tool.Context, input CreatePartnerOfferInput) (CreatePartnerOfferOutput, error) {
		if deps.OfferCreator == nil {
			return CreatePartnerOfferOutput{Success: false, Message: "Offer creation not configured"}, fmt.Errorf("offer creator not configured")
		}

		tenantID, serviceID, partnerID, hours, contextMessage, err := resolveOfferContext(deps, input.PartnerID, input.ExpirationHours)
		if err != nil {
			return CreatePartnerOfferOutput{Success: false, Message: contextMessage}, err
		}

		pricingSource, totalCents, err := resolveOfferPricing(ctx, deps, serviceID, tenantID)
		if err != nil {
			return CreatePartnerOfferOutput{Success: false, Message: "Quote not found for service"}, err
		}

		summary := truncateRunes(strings.TrimSpace(input.JobSummaryShort), 200)
		result, err := deps.OfferCreator.CreateOffer(ctx, tenantID, ports.CreateOfferParams{
			PartnerID:          partnerID,
			LeadServiceID:      serviceID,
			PricingSource:      pricingSource,
			CustomerPriceCents: totalCents,
			ExpiresInHours:     hours,
			JobSummaryShort:    summary,
		})
		if err != nil {
			return CreatePartnerOfferOutput{Success: false, Message: err.Error()}, err
		}

		deps.MarkOfferCreated()

		return CreatePartnerOfferOutput{
			Success:     true,
			Message:     "Offer created",
			OfferID:     result.OfferID.String(),
			PublicToken: result.PublicToken,
		}, nil
	})
}

func createSaveEstimationTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "SaveEstimation",
		Description: "Saves estimation metadata (scope and price range) to the lead timeline.",
	}, func(ctx tool.Context, input SaveEstimationInput) (SaveEstimationOutput, error) {
		tenantID, err := getTenantID(deps)
		if err != nil {
			return SaveEstimationOutput{Success: false, Message: missingTenantContextMessage}, err
		}

		leadID, serviceID, err := getLeadContext(deps)
		if err != nil {
			return SaveEstimationOutput{Success: false, Message: missingLeadContextMessage}, err
		}

		actorType, actorName := deps.GetActor()
		summary := strings.TrimSpace(input.Summary)
		var summaryPtr *string
		if summary != "" {
			summaryPtr = &summary
		}

		_, err = deps.Repo.CreateTimelineEvent(ctx, repository.CreateTimelineEventParams{
			LeadID:         leadID,
			ServiceID:      &serviceID,
			OrganizationID: tenantID,
			ActorType:      actorType,
			ActorName:      actorName,
			EventType:      "analysis",
			Title:          "Schatting opgeslagen",
			Summary:        summaryPtr,
			Metadata: map[string]any{
				"scope":      input.Scope,
				"priceRange": input.PriceRange,
				"notes":      input.Notes,
			},
		})
		if err != nil {
			return SaveEstimationOutput{Success: false, Message: "Failed to save estimation"}, err
		}

		deps.MarkSaveEstimationCalled()

		return SaveEstimationOutput{Success: true, Message: "Estimation saved"}, nil
	})
}

// handleCalculator evaluates a single arithmetic operation deterministically.
// The LLM MUST call this for ANY math instead of doing it in its head.
func handleCalculator(_ tool.Context, input CalculatorInput) (CalculatorOutput, error) {
	var result float64
	var expr string

	switch strings.ToLower(strings.TrimSpace(input.Operation)) {
	case "add":
		result = input.A + input.B
		expr = fmt.Sprintf("%g + %g = %g", input.A, input.B, result)
	case "subtract":
		result = input.A - input.B
		expr = fmt.Sprintf("%g - %g = %g", input.A, input.B, result)
	case "multiply":
		result = input.A * input.B
		expr = fmt.Sprintf("%g  %g = %g", input.A, input.B, result)
	case "divide":
		if input.B == 0 {
			return CalculatorOutput{}, fmt.Errorf("division by zero")
		}
		result = input.A / input.B
		expr = fmt.Sprintf("%g  %g = %g", input.A, input.B, result)
	case "ceil_divide":
		if input.B == 0 {
			return CalculatorOutput{}, fmt.Errorf("division by zero")
		}
		result = math.Ceil(input.A / input.B)
		expr = fmt.Sprintf("%g  %g = %g", input.A, input.B, result)
	case "ceil":
		result = math.Ceil(input.A)
		expr = fmt.Sprintf("%g = %g", input.A, result)
	case "floor":
		result = math.Floor(input.A)
		expr = fmt.Sprintf("%g = %g", input.A, result)
	case "round":
		places := int(input.B)
		if places < 0 {
			places = 0
		}
		if places > 10 {
			places = 10
		}
		factor := math.Pow(10, float64(places))
		result = math.Round(input.A*factor) / factor
		expr = fmt.Sprintf("round(%g, %d) = %g", input.A, places, result)
	case "percentage":
		result = input.A * input.B / 100
		expr = fmt.Sprintf("%g  %g%% = %g", input.A, input.B, result)
	default:
		return CalculatorOutput{}, fmt.Errorf("unknown operation %q; use add, subtract, multiply, divide, ceil_divide, ceil, floor, round, percentage", input.Operation)
	}

	return CalculatorOutput{Result: result, Expression: expr}, nil
}

func createCalculatorTool() (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name: "Calculator",
		Description: `Performs exact arithmetic. You MUST use this for ANY calculation  never do math yourself.
Supported operations:
  "add"          a + b
  "subtract"     a - b
  "multiply"     a  b
  "divide"       a  b
  "ceil_divide"  a  b  (divide then round UP  use for quantity-needed calculations)
  "ceil"         a      (round a up to nearest integer)
  "floor"        a      (round a down to nearest integer)
  "round"        round a to b decimal places
  "percentage"   a  b / 100  (e.g., tax amount)
Examples:
  Window area 2m  1.5m: Calculator(operation="multiply", a=2, b=1.5)  3
  Sheets needed: 4 m  2.5 m/sheet, round up: Calculator(operation="ceil_divide", a=4, b=2.5)  2
  Price total: Calculator(operation="multiply", a=15.99, b=3)  47.97`,
	}, handleCalculator)
}

func createCalculateEstimateTool() (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name:        "CalculateEstimate",
		Description: "Calculates material subtotal, labor subtotal range, and total range from structured inputs.",
	}, func(ctx tool.Context, input CalculateEstimateInput) (CalculateEstimateOutput, error) {
		_ = ctx
		materialSubtotal := 0.0
		for _, item := range input.MaterialItems {
			if item.UnitPrice <= 0 || item.Quantity <= 0 {
				continue
			}
			materialSubtotal += item.UnitPrice * item.Quantity
		}

		laborLow := clampNonNegative(input.LaborHoursLow) * clampNonNegative(input.HourlyRateLow)
		laborHigh := clampNonNegative(input.LaborHoursHigh) * clampNonNegative(input.HourlyRateHigh)
		if laborHigh < laborLow {
			laborLow, laborHigh = laborHigh, laborLow
		}

		extra := clampNonNegative(input.ExtraCosts)

		return CalculateEstimateOutput{
			MaterialSubtotal:  round2(materialSubtotal),
			LaborSubtotalLow:  round2(laborLow),
			LaborSubtotalHigh: round2(laborHigh),
			TotalLow:          round2(materialSubtotal + laborLow + extra),
			TotalHigh:         round2(materialSubtotal + laborHigh + extra),
			AppliedExtraCosts: round2(extra),
		}, nil
	})
}

func round2(value float64) float64 {
	return math.Round(value*100) / 100
}

func clampNonNegative(value float64) float64 {
	if value < 0 {
		return 0
	}
	return value
}

// defaultSearchScoreThreshold is the minimum cosine similarity score for
// BGE-M3 embeddings. Results below this are irrelevant noise.
const defaultSearchScoreThreshold = 0.35

// noMatchMessage builds the "no relevant products" message for a query.
func noMatchMessage(query string) string {
	return fmt.Sprintf("No relevant products found for query '%s'. Try different search terms (synonyms, broader/narrower terms, Dutch and English). If no match exists, you may add an ad-hoc item.", query)
}

// resolveSearchParams extracts and normalises the search parameters from input.
func resolveSearchParams(input SearchProductMaterialsInput) (query string, limit int, useCatalog bool, scoreThreshold float64, err error) {
	query = strings.TrimSpace(input.Query)
	if query == "" {
		return "", 0, false, 0, fmt.Errorf("empty query")
	}
	limit = normalizeLimit(input.Limit, 5, 20)
	useCatalog = true
	if input.UseCatalog != nil {
		useCatalog = *input.UseCatalog
	}
	scoreThreshold = defaultSearchScoreThreshold
	if input.MinScore != nil && *input.MinScore > 0 && *input.MinScore < 1 {
		scoreThreshold = *input.MinScore
	}
	return query, limit, useCatalog, scoreThreshold, nil
}

// searchCatalogCollection searches the catalog Qdrant collection and hydrates results.
// Returns nil products (not an error) when nothing relevant is found or the search fails.
func searchCatalogCollection(ctx tool.Context, deps *ToolDependencies, vector []float32, limit int, scoreThreshold float64, query string) []ProductResult {
	results, err := deps.CatalogQdrantClient.SearchWithThreshold(ctx, vector, limit, scoreThreshold)
	if err != nil {
		log.Printf("SearchProductMaterials: catalog search failed: %v", err)
		return nil
	}
	products := convertSearchResults(results)
	if len(products) == 0 {
		log.Printf("SearchProductMaterials: catalog query=%q found 0 products above threshold %.2f, falling back", query, scoreThreshold)
		return nil
	}
	products = hydrateProductResults(ctx, deps, products)
	log.Printf("SearchProductMaterials: catalog query=%q found %d products (threshold=%.2f, scores: %s)",
		query, len(products), scoreThreshold, formatScores(products))
	return products
}

func handleSearchProductMaterials(ctx tool.Context, deps *ToolDependencies, input SearchProductMaterialsInput) (SearchProductMaterialsOutput, error) {
	if !deps.IsProductSearchEnabled() {
		return SearchProductMaterialsOutput{Products: nil, Message: "Product search is not configured"}, nil
	}

	query, limit, useCatalog, scoreThreshold, err := resolveSearchParams(input)
	if err != nil {
		return SearchProductMaterialsOutput{Products: nil, Message: "Query cannot be empty"}, err
	}

	vector, err := deps.EmbeddingClient.Embed(ctx, query)
	if err != nil {
		log.Printf("SearchProductMaterials: embedding failed: %v", err)
		return SearchProductMaterialsOutput{Products: nil, Message: "Failed to generate embedding for query"}, err
	}

	// Try catalog collection first.
	if useCatalog && deps.CatalogQdrantClient != nil {
		if products := searchCatalogCollection(ctx, deps, vector, limit, scoreThreshold, query); len(products) > 0 {
			return SearchProductMaterialsOutput{
				Products: products,
				Message:  fmt.Sprintf("Found %d matching products from catalog (min relevance %.0f%%)", len(products), scoreThreshold*100),
			}, nil
		}
	}

	// Fallback to general collection.
	if deps.QdrantClient == nil {
		return SearchProductMaterialsOutput{Products: nil, Message: noMatchMessage(query)}, nil
	}

	results, err := deps.QdrantClient.SearchWithThreshold(ctx, vector, limit, scoreThreshold)
	if err != nil {
		log.Printf("SearchProductMaterials: fallback search failed: %v", err)
		return SearchProductMaterialsOutput{Products: nil, Message: "Failed to search product catalog"}, err
	}

	products := convertSearchResults(results)
	if len(products) == 0 {
		log.Printf("SearchProductMaterials: fallback query=%q found 0 products above threshold %.2f", query, scoreThreshold)
		return SearchProductMaterialsOutput{Products: nil, Message: noMatchMessage(query)}, nil
	}

	// Fallback results are scraped reference data  strip IDs so the AI
	// treats them as ad-hoc line items (no catalogProductId, no auto-attachments).
	stripProductIDs(products)

	log.Printf("SearchProductMaterials: fallback query=%q found %d reference products (threshold=%.2f, scores: %s)",
		query, len(products), scoreThreshold, formatScores(products))

	return SearchProductMaterialsOutput{
		Products: products,
		Message:  fmt.Sprintf("Found %d reference products (not from your catalog  use as ad-hoc line items without catalogProductId, min relevance %.0f%%)", len(products), scoreThreshold*100),
	}, nil
}

// stripProductIDs clears the ID field on all products so the AI treats
// them as ad-hoc items (no catalogProductId on the draft quote).
// Also sets a default VAT rate of 21% for fallback products that lack one.
func stripProductIDs(products []ProductResult) {
	for i := range products {
		products[i].ID = ""
		if products[i].VatRateBps == 0 {
			products[i].VatRateBps = 2100 // 21% BTW default
		}
	}
}

// formatScores returns a compact summary of product scores for logging.
func formatScores(products []ProductResult) string {
	if len(products) == 0 {
		return "[]"
	}
	parts := make([]string, 0, len(products))
	for _, p := range products {
		parts = append(parts, fmt.Sprintf("%.3f", p.Score))
	}
	return strings.Join(parts, ", ")
}

func normalizeLimit(limit, defaultVal, maxVal int) int {
	if limit <= 0 {
		return defaultVal
	}
	if limit > maxVal {
		return maxVal
	}
	return limit
}

func truncateRunes(value string, max int) string {
	if max <= 0 || value == "" {
		return ""
	}
	if len(value) <= max {
		return value
	}
	runes := []rune(value)
	if len(runes) <= max {
		return value
	}
	return string(runes[:max])
}

func convertSearchResults(results []qdrant.SearchResult) []ProductResult {
	products := make([]ProductResult, 0, len(results))
	for _, r := range results {
		product := extractProductFromPayload(r.Payload, r.Score)
		if product.Name != "" {
			products = append(products, product)
		}
	}

	// Prefer lower-priced items; treat missing/zero price as lowest priority.
	sort.SliceStable(products, func(i, j int) bool {
		pi := products[i].PriceEuros
		pj := products[j].PriceEuros
		iMissing := pi <= 0
		jMissing := pj <= 0
		if iMissing != jMissing {
			return !iMissing
		}
		if pi == pj {
			return products[i].Score > products[j].Score
		}
		return pi < pj
	})
	return products
}

func extractProductFromPayload(payload map[string]any, score float64) ProductResult {
	product := ProductResult{Score: score}
	product.ID = payloadStr(payload, "id")
	product.Name = payloadStr(payload, "name")
	product.Description = payloadStr(payload, "description")
	product.Type = resolveProductType(payload)
	product.PriceEuros = payloadFloat(payload, "price")
	product.Unit = resolveUnit(payload)
	product.LaborTime = strings.TrimSpace(payloadStr(payload, "labor_time_text"))
	product.Category = payloadStr(payload, "category")
	product.SourceURL = payloadStr(payload, "source_url")

	if product.PriceEuros <= 0 {
		product.PriceEuros = payloadFloat(payload, "unit_price")
	}

	applyBrandPrefix(&product, payloadStr(payload, "brand"))
	extractSpecsMaterial(&product, payload)

	product.PriceCents = eurosToCents(product.PriceEuros)
	return product
}

// payloadStr safely extracts a string value from the payload map.
func payloadStr(payload map[string]any, key string) string {
	v, _ := payload[key].(string)
	return v
}

// payloadFloat safely extracts a float64 value from the payload map.
func payloadFloat(payload map[string]any, key string) float64 {
	v, _ := payload[key].(float64)
	return v
}

// resolveUnit determines the unit label from the payload, preferring
// unit_label > unit > parsed from price_raw.
func resolveUnit(payload map[string]any) string {
	if u := payloadStr(payload, "unit_label"); u != "" {
		return u
	}
	if u := payloadStr(payload, "unit"); u != "" {
		return u
	}
	return parseUnitFromPriceRaw(payload)
}

// resolveProductType returns the product type from the payload.
// Catalog products have a "type" field (service, digital_service, product, material).
// Fallback/scraped products default to "material".
func resolveProductType(payload map[string]any) string {
	if t := payloadStr(payload, "type"); t != "" {
		return t
	}
	return "material"
}

// applyBrandPrefix prepends the brand to the product description if present.
func applyBrandPrefix(product *ProductResult, brand string) {
	if brand == "" {
		return
	}
	if product.Description != "" {
		product.Description = brand + "  " + product.Description
	} else {
		product.Description = brand
	}
}

// parseUnitFromPriceRaw extracts a unit string from the scraped price_raw field.
// e.g. "1,21/m1"  "per m1", "3,50/stuk"  "per stuk".
func parseUnitFromPriceRaw(payload map[string]any) string {
	raw, ok := payload["price_raw"].(string)
	if !ok || raw == "" {
		return ""
	}
	idx := strings.LastIndex(raw, "/")
	if idx < 0 || idx >= len(raw)-1 {
		return ""
	}
	unit := strings.TrimSpace(raw[idx+1:])
	if unit == "" {
		return ""
	}
	return "per " + unit
}

// extractSpecsMaterial reads specs.raw.Materiaal from the payload and populates
// the product's Materials slice if it's empty.
func extractSpecsMaterial(product *ProductResult, payload map[string]any) {
	if len(product.Materials) > 0 {
		return
	}
	specs, ok := payload["specs"].(map[string]any)
	if !ok {
		return
	}
	raw, ok := specs["raw"].(map[string]any)
	if !ok {
		return
	}
	if mat, ok := raw["Materiaal"].(string); ok && mat != "" {
		product.Materials = []string{mat}
	}
}

// eurosToCents converts a euro amount to integer cents, rounding to nearest.
func eurosToCents(euros float64) int64 {
	return int64(math.Round(euros * 100))
}

// hydrateProductResults enriches vector-search ProductResults with DB-accurate
// pricing, VAT rates, and materials via the CatalogReader port. Products whose
// IDs cannot be resolved are returned unchanged.
func hydrateProductResults(ctx context.Context, deps *ToolDependencies, products []ProductResult) []ProductResult {
	if deps.CatalogReader == nil {
		return products
	}
	tenantID, ok := deps.GetTenantID()
	if !ok || tenantID == nil {
		return products
	}

	ids := collectProductUUIDs(products)
	if len(ids) == 0 {
		return products
	}

	details, err := deps.CatalogReader.GetProductDetails(ctx, *tenantID, ids)
	if err != nil {
		log.Printf("hydrateProductResults: catalog reader failed: %v", err)
		return products
	}

	return applyProductDetails(products, details)
}

// collectProductUUIDs extracts unique, parseable UUIDs from product results.
func collectProductUUIDs(products []ProductResult) []uuid.UUID {
	seen := make(map[string]struct{}, len(products))
	ids := make([]uuid.UUID, 0, len(products))
	for _, p := range products {
		if p.ID == "" {
			continue
		}
		if _, dup := seen[p.ID]; dup {
			continue
		}
		uid, err := uuid.Parse(p.ID)
		if err != nil {
			continue
		}
		seen[p.ID] = struct{}{}
		ids = append(ids, uid)
	}
	return ids
}

// applyProductDetails merges DB-accurate catalog details back into product results.
func applyProductDetails(products []ProductResult, details []ports.CatalogProductDetails) []ProductResult {
	detailMap := make(map[string]ports.CatalogProductDetails, len(details))
	for _, d := range details {
		detailMap[d.ID.String()] = d
	}

	for i, p := range products {
		d, ok := detailMap[p.ID]
		if !ok {
			continue
		}
		products[i].PriceEuros = float64(d.UnitPriceCents) / 100
		products[i].PriceCents = d.UnitPriceCents
		products[i].VatRateBps = d.VatRateBps
		products[i].Materials = d.Materials
		mergeOptionalString(&products[i].Unit, d.UnitLabel)
		mergeOptionalString(&products[i].LaborTime, d.LaborTimeText)
		mergeOptionalString(&products[i].Description, d.Description)
	}
	return products
}

// mergeOptionalString overwrites dst when src is non-empty.
func mergeOptionalString(dst *string, src string) {
	if src != "" {
		*dst = src
	}
}

func createSearchProductMaterialsTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name: "SearchProductMaterials",
		Description: `Searches the product catalog for materials and their prices via semantic (vector) search.
The query is embedded into a vector, so use descriptive, varied language for best recall.
Only products with a relevance score >= 35% are returned. If no results are returned, it means the
catalog does not contain a matching product  try a different query or add an ad-hoc item.

Tips for effective queries:
- Use generic product category names (e.g. "scharnier deur" instead of just "RVS scharnieren").
- Include synonyms and alternative terms (e.g. "deurhanger deurbeslag scharnier").
- Mix Dutch and English terms if the catalog may contain either.
- Search for broader categories first, then refine with specific queries.
- Call this tool multiple times with different queries to cover all needed materials.

Each result includes a "score" field (0-1) indicating match quality.
Products with score > 0.6 are strong matches. Products with score 0.35-0.6 are partial matches  verify relevance.

Result fields:
- name: product name
- description: product description (may include brand)
- type: product type  "service" or "digital_service" means price INCLUDES labor; "product" or "material" means price is material only.
- priceEuros: price in euros (e.g. 7.93 = EUR 7.93). Use for CalculateEstimate unitPrice.
- priceCents: price in euro-cents (e.g. 793). Use this directly as unitPriceCents in DraftQuote.
- unit: how the product is sold (e.g. "per m1", "per stuk", "per m2"). Use to compute correct quantities.
- vatRateBps: VAT rate in basis points (2100 = 21%). Defaults to 2100 for reference products.
- materials: included materials (e.g. ["Verzinkt staal"])
- category: product category path (reference products only)
- sourceUrl: reference URL (reference products only)
- laborTime: estimated labor time text (if available)
- score: similarity score (0-1)
- id: catalog product UUID (only for catalog items  use as catalogProductId in DraftQuote)`,
	}, func(ctx tool.Context, input SearchProductMaterialsInput) (SearchProductMaterialsOutput, error) {
		return handleSearchProductMaterials(ctx, deps, input)
	})
}

// handleDraftQuote creates a draft quote via the QuoteDrafter port.
func handleDraftQuote(ctx tool.Context, deps *ToolDependencies, input DraftQuoteInput) (DraftQuoteOutput, error) {
	if deps.QuoteDrafter == nil {
		return DraftQuoteOutput{Success: false, Message: "Quote drafting is not configured"}, nil
	}

	tenantID, ok := deps.GetTenantID()
	if !ok || tenantID == nil {
		return DraftQuoteOutput{Success: false, Message: "Organization context not available"}, fmt.Errorf("missing tenant context")
	}

	leadID, serviceID, ok := deps.GetLeadContext()
	if !ok {
		return DraftQuoteOutput{Success: false, Message: "Lead context not available"}, errors.New(missingLeadContextError)
	}

	if len(input.Items) == 0 {
		return DraftQuoteOutput{Success: false, Message: "At least one item is required"}, fmt.Errorf("empty items")
	}

	portItems := convertDraftItems(input.Items)
	portAttachments, portURLs := collectCatalogAssetsForDraft(ctx, deps, tenantID, portItems)

	result, err := deps.QuoteDrafter.DraftQuote(ctx, ports.DraftQuoteParams{
		QuoteID:        deps.GetExistingQuoteID(),
		LeadID:         leadID,
		LeadServiceID:  serviceID,
		OrganizationID: *tenantID,
		CreatedByID:    uuid.Nil,
		Notes:          input.Notes,
		Items:          portItems,
		Attachments:    portAttachments,
		URLs:           portURLs,
	})
	if err != nil {
		log.Printf("DraftQuote: failed: %v", err)
		return DraftQuoteOutput{Success: false, Message: fmt.Sprintf("Failed to draft quote: %v", err)}, err
	}

	log.Printf("DraftQuote: created %s with %d items for lead %s", result.QuoteNumber, result.ItemCount, leadID)
	deps.SetLastDraftResult(result)
	deps.MarkDraftQuoteCalled()

	return DraftQuoteOutput{
		Success:     true,
		Message:     fmt.Sprintf("Draft quote %s created with %d items", result.QuoteNumber, result.ItemCount),
		QuoteID:     result.QuoteID.String(),
		QuoteNumber: result.QuoteNumber,
		ItemCount:   result.ItemCount,
	}, nil
}

// convertDraftItems converts tool-level DraftQuoteItems to port-level items.
func convertDraftItems(items []DraftQuoteItem) []ports.DraftQuoteItem {
	portItems := make([]ports.DraftQuoteItem, len(items))
	for i, it := range items {
		portItems[i] = ports.DraftQuoteItem{
			Description:    it.Description,
			Quantity:       it.Quantity,
			UnitPriceCents: it.UnitPriceCents,
			TaxRateBps:     it.TaxRateBps,
			IsOptional:     it.IsOptional,
		}
		if it.CatalogProductID != nil && *it.CatalogProductID != "" {
			uid, err := uuid.Parse(*it.CatalogProductID)
			if err == nil {
				portItems[i].CatalogProductID = &uid
			}
		}
	}
	return portItems
}

// collectCatalogAssetsForDraft auto-collects catalog product attachments and URLs.
func collectCatalogAssetsForDraft(ctx context.Context, deps *ToolDependencies, tenantID *uuid.UUID, items []ports.DraftQuoteItem) ([]ports.DraftQuoteAttachment, []ports.DraftQuoteURL) {
	if deps.CatalogReader == nil {
		return nil, nil
	}
	catalogIDs := collectCatalogProductIDs(items)
	if len(catalogIDs) == 0 {
		return nil, nil
	}
	details, err := deps.CatalogReader.GetProductDetails(ctx, *tenantID, catalogIDs)
	if err != nil {
		log.Printf("DraftQuote: catalog details fetch failed (non-fatal): %v", err)
		return nil, nil
	}
	return collectCatalogAssets(details)
}

func createDraftQuoteTool(deps *ToolDependencies) (tool.Tool, error) {
	return functiontool.New(functiontool.Config{
		Name: "DraftQuote",
		Description: `Creates a draft quote for the current lead based on estimation results.
Use this AFTER searching the catalog and calculating estimates.
For each item, provide description, quantity, unitPriceCents (in euro-cents), taxRateBps.
IMPORTANT: Set unitPriceCents to the product's "priceCents" value from SearchProductMaterials (already in cents).
If the item came from SearchProductMaterials, include its catalogProductId.
Ad-hoc items (not found in catalog) should omit catalogProductId.`,
	}, func(ctx tool.Context, input DraftQuoteInput) (DraftQuoteOutput, error) {
		return handleDraftQuote(ctx, deps, input)
	})
}

// collectCatalogProductIDs extracts unique, non-nil catalog product UUIDs from draft items.
func collectCatalogProductIDs(items []ports.DraftQuoteItem) []uuid.UUID {
	seen := make(map[uuid.UUID]struct{}, len(items))
	ids := make([]uuid.UUID, 0, len(items))
	for _, it := range items {
		if it.CatalogProductID == nil {
			continue
		}
		if _, dup := seen[*it.CatalogProductID]; dup {
			continue
		}
		seen[*it.CatalogProductID] = struct{}{}
		ids = append(ids, *it.CatalogProductID)
	}
	return ids
}

// collectCatalogAssets de-duplicates document attachments and URLs across all
// catalog product details and returns them as port-level types.
func collectCatalogAssets(details []ports.CatalogProductDetails) ([]ports.DraftQuoteAttachment, []ports.DraftQuoteURL) {
	seenFileKeys := make(map[string]struct{})
	seenHrefs := make(map[string]struct{})

	var attachments []ports.DraftQuoteAttachment
	var urls []ports.DraftQuoteURL

	for _, d := range details {
		pid := d.ID
		for _, doc := range d.Documents {
			if _, dup := seenFileKeys[doc.FileKey]; dup {
				continue
			}
			seenFileKeys[doc.FileKey] = struct{}{}
			attachments = append(attachments, ports.DraftQuoteAttachment{
				Filename:         doc.Filename,
				FileKey:          doc.FileKey,
				Source:           "catalog",
				CatalogProductID: &pid,
			})
		}
		for _, u := range d.URLs {
			if _, dup := seenHrefs[u.Href]; dup {
				continue
			}
			seenHrefs[u.Href] = struct{}{}
			urls = append(urls, ports.DraftQuoteURL{
				Label:            u.Label,
				Href:             u.Href,
				CatalogProductID: &pid,
			})
		}
	}

	return attachments, urls
}
</file>

</files>
